/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */


"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var ts;
(function (ts) {
    // WARNING: The script `configurePrerelease.ts` uses a regexp to parse out these values.
    // If changing the text in this section, be sure to test `configurePrerelease` too.
    ts.versionMajorMinor = "4.8";
    // The following is baselined as a literal template type without intervention
    /** The version of the TypeScript compiler release */
    // eslint-disable-next-line @typescript-eslint/no-inferrable-types
    ts.version = "4.8.3";
    /* @internal */
    var Comparison;
    (function (Comparison) {
        Comparison[Comparison["LessThan"] = -1] = "LessThan";
        Comparison[Comparison["EqualTo"] = 0] = "EqualTo";
        Comparison[Comparison["GreaterThan"] = 1] = "GreaterThan";
    })(Comparison = ts.Comparison || (ts.Comparison = {}));
    /* @internal */
    var NativeCollections;
    (function (NativeCollections) {
        var globals = typeof globalThis !== "undefined" ? globalThis :
            typeof global !== "undefined" ? global :
                typeof self !== "undefined" ? self :
                    undefined;
        /**
         * Returns the native Map implementation if it is available and compatible (i.e. supports iteration).
         */
        function tryGetNativeMap() {
            // Internet Explorer's Map doesn't support iteration, so don't use it.
            var gMap = globals === null || globals === void 0 ? void 0 : globals.Map;
            // eslint-disable-next-line no-in-operator
            return typeof gMap !== "undefined" && "entries" in gMap.prototype && new gMap([[0, 0]]).size === 1 ? gMap : undefined;
        }
        NativeCollections.tryGetNativeMap = tryGetNativeMap;
        /**
         * Returns the native Set implementation if it is available and compatible (i.e. supports iteration).
         */
        function tryGetNativeSet() {
            // Internet Explorer's Set doesn't support iteration, so don't use it.
            var gSet = globals === null || globals === void 0 ? void 0 : globals.Set;
            // eslint-disable-next-line no-in-operator
            return typeof gSet !== "undefined" && "entries" in gSet.prototype && new gSet([0]).size === 1 ? gSet : undefined;
        }
        NativeCollections.tryGetNativeSet = tryGetNativeSet;
    })(NativeCollections || (NativeCollections = {}));
    /* @internal */
    ts.Map = getCollectionImplementation("Map", "tryGetNativeMap", "createMapShim");
    /* @internal */
    ts.Set = getCollectionImplementation("Set", "tryGetNativeSet", "createSetShim");
    /* @internal */
    function getCollectionImplementation(name, nativeFactory, shimFactory) {
        var _a;
        // NOTE: ts.ShimCollections will be defined for typescriptServices.js but not for tsc.js, so we must test for it.
        var constructor = (_a = NativeCollections[nativeFactory]()) !== null && _a !== void 0 ? _a : ts.ShimCollections === null || ts.ShimCollections === void 0 ? void 0 : ts.ShimCollections[shimFactory](ts.getIterator);
        if (constructor)
            return constructor;
        throw new Error("TypeScript requires an environment that provides a compatible native ".concat(name, " implementation."));
    }
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    function getIterator(iterable) {
        if (iterable) {
            if (isArray(iterable))
                return arrayIterator(iterable);
            if (iterable instanceof ts.Map)
                return iterable.entries();
            if (iterable instanceof ts.Set)
                return iterable.values();
            throw new Error("Iteration not supported.");
        }
    }
    ts.getIterator = getIterator;
    ts.emptyArray = [];
    ts.emptyMap = new ts.Map();
    ts.emptySet = new ts.Set();
    function length(array) {
        return array ? array.length : 0;
    }
    ts.length = length;
    /**
     * Iterates through 'array' by index and performs the callback on each element of array until the callback
     * returns a truthy value, then returns that value.
     * If no such value is found, the callback is applied to each element of array and undefined is returned.
     */
    function forEach(array, callback) {
        if (array) {
            for (var i = 0; i < array.length; i++) {
                var result = callback(array[i], i);
                if (result) {
                    return result;
                }
            }
        }
        return undefined;
    }
    ts.forEach = forEach;
    /**
     * Like `forEach`, but iterates in reverse order.
     */
    function forEachRight(array, callback) {
        if (array) {
            for (var i = array.length - 1; i >= 0; i--) {
                var result = callback(array[i], i);
                if (result) {
                    return result;
                }
            }
        }
        return undefined;
    }
    ts.forEachRight = forEachRight;
    /** Like `forEach`, but suitable for use with numbers and strings (which may be falsy). */
    function firstDefined(array, callback) {
        if (array === undefined) {
            return undefined;
        }
        for (var i = 0; i < array.length; i++) {
            var result = callback(array[i], i);
            if (result !== undefined) {
                return result;
            }
        }
        return undefined;
    }
    ts.firstDefined = firstDefined;
    function firstDefinedIterator(iter, callback) {
        while (true) {
            var iterResult = iter.next();
            if (iterResult.done) {
                return undefined;
            }
            var result = callback(iterResult.value);
            if (result !== undefined) {
                return result;
            }
        }
    }
    ts.firstDefinedIterator = firstDefinedIterator;
    function reduceLeftIterator(iterator, f, initial) {
        var result = initial;
        if (iterator) {
            for (var step = iterator.next(), pos = 0; !step.done; step = iterator.next(), pos++) {
                result = f(result, step.value, pos);
            }
        }
        return result;
    }
    ts.reduceLeftIterator = reduceLeftIterator;
    function zipWith(arrayA, arrayB, callback) {
        var result = [];
        ts.Debug.assertEqual(arrayA.length, arrayB.length);
        for (var i = 0; i < arrayA.length; i++) {
            result.push(callback(arrayA[i], arrayB[i], i));
        }
        return result;
    }
    ts.zipWith = zipWith;
    function zipToIterator(arrayA, arrayB) {
        ts.Debug.assertEqual(arrayA.length, arrayB.length);
        var i = 0;
        return {
            next: function () {
                if (i === arrayA.length) {
                    return { value: undefined, done: true };
                }
                i++;
                return { value: [arrayA[i - 1], arrayB[i - 1]], done: false };
            }
        };
    }
    ts.zipToIterator = zipToIterator;
    function zipToMap(keys, values) {
        ts.Debug.assert(keys.length === values.length);
        var map = new ts.Map();
        for (var i = 0; i < keys.length; ++i) {
            map.set(keys[i], values[i]);
        }
        return map;
    }
    ts.zipToMap = zipToMap;
    /**
     * Creates a new array with `element` interspersed in between each element of `input`
     * if there is more than 1 value in `input`. Otherwise, returns the existing array.
     */
    function intersperse(input, element) {
        if (input.length <= 1) {
            return input;
        }
        var result = [];
        for (var i = 0, n = input.length; i < n; i++) {
            if (i)
                result.push(element);
            result.push(input[i]);
        }
        return result;
    }
    ts.intersperse = intersperse;
    /**
     * Iterates through `array` by index and performs the callback on each element of array until the callback
     * returns a falsey value, then returns false.
     * If no such value is found, the callback is applied to each element of array and `true` is returned.
     */
    function every(array, callback) {
        if (array) {
            for (var i = 0; i < array.length; i++) {
                if (!callback(array[i], i)) {
                    return false;
                }
            }
        }
        return true;
    }
    ts.every = every;
    function find(array, predicate, startIndex) {
        if (array === undefined)
            return undefined;
        for (var i = startIndex !== null && startIndex !== void 0 ? startIndex : 0; i < array.length; i++) {
            var value = array[i];
            if (predicate(value, i)) {
                return value;
            }
        }
        return undefined;
    }
    ts.find = find;
    function findLast(array, predicate, startIndex) {
        if (array === undefined)
            return undefined;
        for (var i = startIndex !== null && startIndex !== void 0 ? startIndex : array.length - 1; i >= 0; i--) {
            var value = array[i];
            if (predicate(value, i)) {
                return value;
            }
        }
        return undefined;
    }
    ts.findLast = findLast;
    /** Works like Array.prototype.findIndex, returning `-1` if no element satisfying the predicate is found. */
    function findIndex(array, predicate, startIndex) {
        if (array === undefined)
            return -1;
        for (var i = startIndex !== null && startIndex !== void 0 ? startIndex : 0; i < array.length; i++) {
            if (predicate(array[i], i)) {
                return i;
            }
        }
        return -1;
    }
    ts.findIndex = findIndex;
    function findLastIndex(array, predicate, startIndex) {
        if (array === undefined)
            return -1;
        for (var i = startIndex !== null && startIndex !== void 0 ? startIndex : array.length - 1; i >= 0; i--) {
            if (predicate(array[i], i)) {
                return i;
            }
        }
        return -1;
    }
    ts.findLastIndex = findLastIndex;
    /**
     * Returns the first truthy result of `callback`, or else fails.
     * This is like `forEach`, but never returns undefined.
     */
    function findMap(array, callback) {
        for (var i = 0; i < array.length; i++) {
            var result = callback(array[i], i);
            if (result) {
                return result;
            }
        }
        return ts.Debug.fail();
    }
    ts.findMap = findMap;
    function contains(array, value, equalityComparer) {
        if (equalityComparer === void 0) { equalityComparer = equateValues; }
        if (array) {
            for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {
                var v = array_1[_i];
                if (equalityComparer(v, value)) {
                    return true;
                }
            }
        }
        return false;
    }
    ts.contains = contains;
    function arraysEqual(a, b, equalityComparer) {
        if (equalityComparer === void 0) { equalityComparer = equateValues; }
        return a.length === b.length && a.every(function (x, i) { return equalityComparer(x, b[i]); });
    }
    ts.arraysEqual = arraysEqual;
    function indexOfAnyCharCode(text, charCodes, start) {
        for (var i = start || 0; i < text.length; i++) {
            if (contains(charCodes, text.charCodeAt(i))) {
                return i;
            }
        }
        return -1;
    }
    ts.indexOfAnyCharCode = indexOfAnyCharCode;
    function countWhere(array, predicate) {
        var count = 0;
        if (array) {
            for (var i = 0; i < array.length; i++) {
                var v = array[i];
                if (predicate(v, i)) {
                    count++;
                }
            }
        }
        return count;
    }
    ts.countWhere = countWhere;
    function filter(array, f) {
        if (array) {
            var len = array.length;
            var i = 0;
            while (i < len && f(array[i]))
                i++;
            if (i < len) {
                var result = array.slice(0, i);
                i++;
                while (i < len) {
                    var item = array[i];
                    if (f(item)) {
                        result.push(item);
                    }
                    i++;
                }
                return result;
            }
        }
        return array;
    }
    ts.filter = filter;
    function filterMutate(array, f) {
        var outIndex = 0;
        for (var i = 0; i < array.length; i++) {
            if (f(array[i], i, array)) {
                array[outIndex] = array[i];
                outIndex++;
            }
        }
        array.length = outIndex;
    }
    ts.filterMutate = filterMutate;
    function clear(array) {
        array.length = 0;
    }
    ts.clear = clear;
    function map(array, f) {
        var result;
        if (array) {
            result = [];
            for (var i = 0; i < array.length; i++) {
                result.push(f(array[i], i));
            }
        }
        return result;
    }
    ts.map = map;
    function mapIterator(iter, mapFn) {
        return {
            next: function () {
                var iterRes = iter.next();
                return iterRes.done ? iterRes : { value: mapFn(iterRes.value), done: false };
            }
        };
    }
    ts.mapIterator = mapIterator;
    function sameMap(array, f) {
        if (array) {
            for (var i = 0; i < array.length; i++) {
                var item = array[i];
                var mapped = f(item, i);
                if (item !== mapped) {
                    var result = array.slice(0, i);
                    result.push(mapped);
                    for (i++; i < array.length; i++) {
                        result.push(f(array[i], i));
                    }
                    return result;
                }
            }
        }
        return array;
    }
    ts.sameMap = sameMap;
    /**
     * Flattens an array containing a mix of array or non-array elements.
     *
     * @param array The array to flatten.
     */
    function flatten(array) {
        var result = [];
        for (var _i = 0, array_2 = array; _i < array_2.length; _i++) {
            var v = array_2[_i];
            if (v) {
                if (isArray(v)) {
                    addRange(result, v);
                }
                else {
                    result.push(v);
                }
            }
        }
        return result;
    }
    ts.flatten = flatten;
    /**
     * Maps an array. If the mapped value is an array, it is spread into the result.
     *
     * @param array The array to map.
     * @param mapfn The callback used to map the result into one or more values.
     */
    function flatMap(array, mapfn) {
        var result;
        if (array) {
            for (var i = 0; i < array.length; i++) {
                var v = mapfn(array[i], i);
                if (v) {
                    if (isArray(v)) {
                        result = addRange(result, v);
                    }
                    else {
                        result = append(result, v);
                    }
                }
            }
        }
        return result || ts.emptyArray;
    }
    ts.flatMap = flatMap;
    function flatMapToMutable(array, mapfn) {
        var result = [];
        if (array) {
            for (var i = 0; i < array.length; i++) {
                var v = mapfn(array[i], i);
                if (v) {
                    if (isArray(v)) {
                        addRange(result, v);
                    }
                    else {
                        result.push(v);
                    }
                }
            }
        }
        return result;
    }
    ts.flatMapToMutable = flatMapToMutable;
    function flatMapIterator(iter, mapfn) {
        var first = iter.next();
        if (first.done) {
            return ts.emptyIterator;
        }
        var currentIter = getIterator(first.value);
        return {
            next: function () {
                while (true) {
                    var currentRes = currentIter.next();
                    if (!currentRes.done) {
                        return currentRes;
                    }
                    var iterRes = iter.next();
                    if (iterRes.done) {
                        return iterRes;
                    }
                    currentIter = getIterator(iterRes.value);
                }
            },
        };
        function getIterator(x) {
            var res = mapfn(x);
            return res === undefined ? ts.emptyIterator : isArray(res) ? arrayIterator(res) : res;
        }
    }
    ts.flatMapIterator = flatMapIterator;
    function sameFlatMap(array, mapfn) {
        var result;
        if (array) {
            for (var i = 0; i < array.length; i++) {
                var item = array[i];
                var mapped = mapfn(item, i);
                if (result || item !== mapped || isArray(mapped)) {
                    if (!result) {
                        result = array.slice(0, i);
                    }
                    if (isArray(mapped)) {
                        addRange(result, mapped);
                    }
                    else {
                        result.push(mapped);
                    }
                }
            }
        }
        return result || array;
    }
    ts.sameFlatMap = sameFlatMap;
    function mapAllOrFail(array, mapFn) {
        var result = [];
        for (var i = 0; i < array.length; i++) {
            var mapped = mapFn(array[i], i);
            if (mapped === undefined) {
                return undefined;
            }
            result.push(mapped);
        }
        return result;
    }
    ts.mapAllOrFail = mapAllOrFail;
    function mapDefined(array, mapFn) {
        var result = [];
        if (array) {
            for (var i = 0; i < array.length; i++) {
                var mapped = mapFn(array[i], i);
                if (mapped !== undefined) {
                    result.push(mapped);
                }
            }
        }
        return result;
    }
    ts.mapDefined = mapDefined;
    function mapDefinedIterator(iter, mapFn) {
        return {
            next: function () {
                while (true) {
                    var res = iter.next();
                    if (res.done) {
                        return res;
                    }
                    var value = mapFn(res.value);
                    if (value !== undefined) {
                        return { value: value, done: false };
                    }
                }
            }
        };
    }
    ts.mapDefinedIterator = mapDefinedIterator;
    function mapDefinedEntries(map, f) {
        if (!map) {
            return undefined;
        }
        var result = new ts.Map();
        map.forEach(function (value, key) {
            var entry = f(key, value);
            if (entry !== undefined) {
                var newKey = entry[0], newValue = entry[1];
                if (newKey !== undefined && newValue !== undefined) {
                    result.set(newKey, newValue);
                }
            }
        });
        return result;
    }
    ts.mapDefinedEntries = mapDefinedEntries;
    function mapDefinedValues(set, f) {
        if (set) {
            var result_1 = new ts.Set();
            set.forEach(function (value) {
                var newValue = f(value);
                if (newValue !== undefined) {
                    result_1.add(newValue);
                }
            });
            return result_1;
        }
    }
    ts.mapDefinedValues = mapDefinedValues;
    function getOrUpdate(map, key, callback) {
        if (map.has(key)) {
            return map.get(key);
        }
        var value = callback();
        map.set(key, value);
        return value;
    }
    ts.getOrUpdate = getOrUpdate;
    function tryAddToSet(set, value) {
        if (!set.has(value)) {
            set.add(value);
            return true;
        }
        return false;
    }
    ts.tryAddToSet = tryAddToSet;
    ts.emptyIterator = { next: function () { return ({ value: undefined, done: true }); } };
    function singleIterator(value) {
        var done = false;
        return {
            next: function () {
                var wasDone = done;
                done = true;
                return wasDone ? { value: undefined, done: true } : { value: value, done: false };
            }
        };
    }
    ts.singleIterator = singleIterator;
    function spanMap(array, keyfn, mapfn) {
        var result;
        if (array) {
            result = [];
            var len = array.length;
            var previousKey = void 0;
            var key = void 0;
            var start = 0;
            var pos = 0;
            while (start < len) {
                while (pos < len) {
                    var value = array[pos];
                    key = keyfn(value, pos);
                    if (pos === 0) {
                        previousKey = key;
                    }
                    else if (key !== previousKey) {
                        break;
                    }
                    pos++;
                }
                if (start < pos) {
                    var v = mapfn(array.slice(start, pos), previousKey, start, pos);
                    if (v) {
                        result.push(v);
                    }
                    start = pos;
                }
                previousKey = key;
                pos++;
            }
        }
        return result;
    }
    ts.spanMap = spanMap;
    function mapEntries(map, f) {
        if (!map) {
            return undefined;
        }
        var result = new ts.Map();
        map.forEach(function (value, key) {
            var _a = f(key, value), newKey = _a[0], newValue = _a[1];
            result.set(newKey, newValue);
        });
        return result;
    }
    ts.mapEntries = mapEntries;
    function some(array, predicate) {
        if (array) {
            if (predicate) {
                for (var _i = 0, array_3 = array; _i < array_3.length; _i++) {
                    var v = array_3[_i];
                    if (predicate(v)) {
                        return true;
                    }
                }
            }
            else {
                return array.length > 0;
            }
        }
        return false;
    }
    ts.some = some;
    /** Calls the callback with (start, afterEnd) index pairs for each range where 'pred' is true. */
    function getRangesWhere(arr, pred, cb) {
        var start;
        for (var i = 0; i < arr.length; i++) {
            if (pred(arr[i])) {
                start = start === undefined ? i : start;
            }
            else {
                if (start !== undefined) {
                    cb(start, i);
                    start = undefined;
                }
            }
        }
        if (start !== undefined)
            cb(start, arr.length);
    }
    ts.getRangesWhere = getRangesWhere;
    function concatenate(array1, array2) {
        if (!some(array2))
            return array1;
        if (!some(array1))
            return array2;
        return __spreadArray(__spreadArray([], array1, true), array2, true);
    }
    ts.concatenate = concatenate;
    function selectIndex(_, i) {
        return i;
    }
    function indicesOf(array) {
        return array.map(selectIndex);
    }
    ts.indicesOf = indicesOf;
    function deduplicateRelational(array, equalityComparer, comparer) {
        // Perform a stable sort of the array. This ensures the first entry in a list of
        // duplicates remains the first entry in the result.
        var indices = indicesOf(array);
        stableSortIndices(array, indices, comparer);
        var last = array[indices[0]];
        var deduplicated = [indices[0]];
        for (var i = 1; i < indices.length; i++) {
            var index = indices[i];
            var item = array[index];
            if (!equalityComparer(last, item)) {
                deduplicated.push(index);
                last = item;
            }
        }
        // restore original order
        deduplicated.sort();
        return deduplicated.map(function (i) { return array[i]; });
    }
    function deduplicateEquality(array, equalityComparer) {
        var result = [];
        for (var _i = 0, array_4 = array; _i < array_4.length; _i++) {
            var item = array_4[_i];
            pushIfUnique(result, item, equalityComparer);
        }
        return result;
    }
    /**
     * Deduplicates an unsorted array.
     * @param equalityComparer An `EqualityComparer` used to determine if two values are duplicates.
     * @param comparer An optional `Comparer` used to sort entries before comparison, though the
     * result will remain in the original order in `array`.
     */
    function deduplicate(array, equalityComparer, comparer) {
        return array.length === 0 ? [] :
            array.length === 1 ? array.slice() :
                comparer ? deduplicateRelational(array, equalityComparer, comparer) :
                    deduplicateEquality(array, equalityComparer);
    }
    ts.deduplicate = deduplicate;
    /**
     * Deduplicates an array that has already been sorted.
     */
    function deduplicateSorted(array, comparer) {
        if (array.length === 0)
            return ts.emptyArray;
        var last = array[0];
        var deduplicated = [last];
        for (var i = 1; i < array.length; i++) {
            var next = array[i];
            switch (comparer(next, last)) {
                // equality comparison
                case true:
                // relational comparison
                // falls through
                case 0 /* Comparison.EqualTo */:
                    continue;
                case -1 /* Comparison.LessThan */:
                    // If `array` is sorted, `next` should **never** be less than `last`.
                    return ts.Debug.fail("Array is unsorted.");
            }
            deduplicated.push(last = next);
        }
        return deduplicated;
    }
    function createSortedArray() {
        return []; // TODO: GH#19873
    }
    ts.createSortedArray = createSortedArray;
    function insertSorted(array, insert, compare, allowDuplicates) {
        if (array.length === 0) {
            array.push(insert);
            return;
        }
        var insertIndex = binarySearch(array, insert, identity, compare);
        if (insertIndex < 0) {
            array.splice(~insertIndex, 0, insert);
        }
        else if (allowDuplicates) {
            array.splice(insertIndex, 0, insert);
        }
    }
    ts.insertSorted = insertSorted;
    function sortAndDeduplicate(array, comparer, equalityComparer) {
        return deduplicateSorted(sort(array, comparer), equalityComparer || comparer || compareStringsCaseSensitive);
    }
    ts.sortAndDeduplicate = sortAndDeduplicate;
    function arrayIsSorted(array, comparer) {
        if (array.length < 2)
            return true;
        var prevElement = array[0];
        for (var _i = 0, _a = array.slice(1); _i < _a.length; _i++) {
            var element = _a[_i];
            if (comparer(prevElement, element) === 1 /* Comparison.GreaterThan */) {
                return false;
            }
            prevElement = element;
        }
        return true;
    }
    ts.arrayIsSorted = arrayIsSorted;
    function arrayIsEqualTo(array1, array2, equalityComparer) {
        if (equalityComparer === void 0) { equalityComparer = equateValues; }
        if (!array1 || !array2) {
            return array1 === array2;
        }
        if (array1.length !== array2.length) {
            return false;
        }
        for (var i = 0; i < array1.length; i++) {
            if (!equalityComparer(array1[i], array2[i], i)) {
                return false;
            }
        }
        return true;
    }
    ts.arrayIsEqualTo = arrayIsEqualTo;
    function compact(array) {
        var result;
        if (array) {
            for (var i = 0; i < array.length; i++) {
                var v = array[i];
                if (result || !v) {
                    if (!result) {
                        result = array.slice(0, i);
                    }
                    if (v) {
                        result.push(v);
                    }
                }
            }
        }
        return result || array;
    }
    ts.compact = compact;
    /**
     * Gets the relative complement of `arrayA` with respect to `arrayB`, returning the elements that
     * are not present in `arrayA` but are present in `arrayB`. Assumes both arrays are sorted
     * based on the provided comparer.
     */
    function relativeComplement(arrayA, arrayB, comparer) {
        if (!arrayB || !arrayA || arrayB.length === 0 || arrayA.length === 0)
            return arrayB;
        var result = [];
        loopB: for (var offsetA = 0, offsetB = 0; offsetB < arrayB.length; offsetB++) {
            if (offsetB > 0) {
                // Ensure `arrayB` is properly sorted.
                ts.Debug.assertGreaterThanOrEqual(comparer(arrayB[offsetB], arrayB[offsetB - 1]), 0 /* Comparison.EqualTo */);
            }
            loopA: for (var startA = offsetA; offsetA < arrayA.length; offsetA++) {
                if (offsetA > startA) {
                    // Ensure `arrayA` is properly sorted. We only need to perform this check if
                    // `offsetA` has changed since we entered the loop.
                    ts.Debug.assertGreaterThanOrEqual(comparer(arrayA[offsetA], arrayA[offsetA - 1]), 0 /* Comparison.EqualTo */);
                }
                switch (comparer(arrayB[offsetB], arrayA[offsetA])) {
                    case -1 /* Comparison.LessThan */:
                        // If B is less than A, B does not exist in arrayA. Add B to the result and
                        // move to the next element in arrayB without changing the current position
                        // in arrayA.
                        result.push(arrayB[offsetB]);
                        continue loopB;
                    case 0 /* Comparison.EqualTo */:
                        // If B is equal to A, B exists in arrayA. Move to the next element in
                        // arrayB without adding B to the result or changing the current position
                        // in arrayA.
                        continue loopB;
                    case 1 /* Comparison.GreaterThan */:
                        // If B is greater than A, we need to keep looking for B in arrayA. Move to
                        // the next element in arrayA and recheck.
                        continue loopA;
                }
            }
        }
        return result;
    }
    ts.relativeComplement = relativeComplement;
    function sum(array, prop) {
        var result = 0;
        for (var _i = 0, array_5 = array; _i < array_5.length; _i++) {
            var v = array_5[_i];
            result += v[prop];
        }
        return result;
    }
    ts.sum = sum;
    function append(to, value) {
        if (value === undefined)
            return to;
        if (to === undefined)
            return [value];
        to.push(value);
        return to;
    }
    ts.append = append;
    function combine(xs, ys) {
        if (xs === undefined)
            return ys;
        if (ys === undefined)
            return xs;
        if (isArray(xs))
            return isArray(ys) ? concatenate(xs, ys) : append(xs, ys);
        if (isArray(ys))
            return append(ys, xs);
        return [xs, ys];
    }
    ts.combine = combine;
    /**
     * Gets the actual offset into an array for a relative offset. Negative offsets indicate a
     * position offset from the end of the array.
     */
    function toOffset(array, offset) {
        return offset < 0 ? array.length + offset : offset;
    }
    function addRange(to, from, start, end) {
        if (from === undefined || from.length === 0)
            return to;
        if (to === undefined)
            return from.slice(start, end);
        start = start === undefined ? 0 : toOffset(from, start);
        end = end === undefined ? from.length : toOffset(from, end);
        for (var i = start; i < end && i < from.length; i++) {
            if (from[i] !== undefined) {
                to.push(from[i]);
            }
        }
        return to;
    }
    ts.addRange = addRange;
    /**
     * @return Whether the value was added.
     */
    function pushIfUnique(array, toAdd, equalityComparer) {
        if (contains(array, toAdd, equalityComparer)) {
            return false;
        }
        else {
            array.push(toAdd);
            return true;
        }
    }
    ts.pushIfUnique = pushIfUnique;
    /**
     * Unlike `pushIfUnique`, this can take `undefined` as an input, and returns a new array.
     */
    function appendIfUnique(array, toAdd, equalityComparer) {
        if (array) {
            pushIfUnique(array, toAdd, equalityComparer);
            return array;
        }
        else {
            return [toAdd];
        }
    }
    ts.appendIfUnique = appendIfUnique;
    function stableSortIndices(array, indices, comparer) {
        // sort indices by value then position
        indices.sort(function (x, y) { return comparer(array[x], array[y]) || compareValues(x, y); });
    }
    /**
     * Returns a new sorted array.
     */
    function sort(array, comparer) {
        return (array.length === 0 ? array : array.slice().sort(comparer));
    }
    ts.sort = sort;
    function arrayIterator(array) {
        var i = 0;
        return { next: function () {
                if (i === array.length) {
                    return { value: undefined, done: true };
                }
                else {
                    i++;
                    return { value: array[i - 1], done: false };
                }
            } };
    }
    ts.arrayIterator = arrayIterator;
    function arrayReverseIterator(array) {
        var i = array.length;
        return {
            next: function () {
                if (i === 0) {
                    return { value: undefined, done: true };
                }
                else {
                    i--;
                    return { value: array[i], done: false };
                }
            }
        };
    }
    ts.arrayReverseIterator = arrayReverseIterator;
    /**
     * Stable sort of an array. Elements equal to each other maintain their relative position in the array.
     */
    function stableSort(array, comparer) {
        var indices = indicesOf(array);
        stableSortIndices(array, indices, comparer);
        return indices.map(function (i) { return array[i]; });
    }
    ts.stableSort = stableSort;
    function rangeEquals(array1, array2, pos, end) {
        while (pos < end) {
            if (array1[pos] !== array2[pos]) {
                return false;
            }
            pos++;
        }
        return true;
    }
    ts.rangeEquals = rangeEquals;
    /**
     * Returns the element at a specific offset in an array if non-empty, `undefined` otherwise.
     * A negative offset indicates the element should be retrieved from the end of the array.
     */
    function elementAt(array, offset) {
        if (array) {
            offset = toOffset(array, offset);
            if (offset < array.length) {
                return array[offset];
            }
        }
        return undefined;
    }
    ts.elementAt = elementAt;
    /**
     * Returns the first element of an array if non-empty, `undefined` otherwise.
     */
    function firstOrUndefined(array) {
        return array === undefined || array.length === 0 ? undefined : array[0];
    }
    ts.firstOrUndefined = firstOrUndefined;
    function first(array) {
        ts.Debug.assert(array.length !== 0);
        return array[0];
    }
    ts.first = first;
    /**
     * Returns the last element of an array if non-empty, `undefined` otherwise.
     */
    function lastOrUndefined(array) {
        return array === undefined || array.length === 0 ? undefined : array[array.length - 1];
    }
    ts.lastOrUndefined = lastOrUndefined;
    function last(array) {
        ts.Debug.assert(array.length !== 0);
        return array[array.length - 1];
    }
    ts.last = last;
    /**
     * Returns the only element of an array if it contains only one element, `undefined` otherwise.
     */
    function singleOrUndefined(array) {
        return array && array.length === 1
            ? array[0]
            : undefined;
    }
    ts.singleOrUndefined = singleOrUndefined;
    function singleOrMany(array) {
        return array && array.length === 1
            ? array[0]
            : array;
    }
    ts.singleOrMany = singleOrMany;
    function replaceElement(array, index, value) {
        var result = array.slice(0);
        result[index] = value;
        return result;
    }
    ts.replaceElement = replaceElement;
    /**
     * Performs a binary search, finding the index at which `value` occurs in `array`.
     * If no such index is found, returns the 2's-complement of first index at which
     * `array[index]` exceeds `value`.
     * @param array A sorted array whose first element must be no larger than number
     * @param value The value to be searched for in the array.
     * @param keySelector A callback used to select the search key from `value` and each element of
     * `array`.
     * @param keyComparer A callback used to compare two keys in a sorted array.
     * @param offset An offset into `array` at which to start the search.
     */
    function binarySearch(array, value, keySelector, keyComparer, offset) {
        return binarySearchKey(array, keySelector(value), keySelector, keyComparer, offset);
    }
    ts.binarySearch = binarySearch;
    /**
     * Performs a binary search, finding the index at which an object with `key` occurs in `array`.
     * If no such index is found, returns the 2's-complement of first index at which
     * `array[index]` exceeds `key`.
     * @param array A sorted array whose first element must be no larger than number
     * @param key The key to be searched for in the array.
     * @param keySelector A callback used to select the search key from each element of `array`.
     * @param keyComparer A callback used to compare two keys in a sorted array.
     * @param offset An offset into `array` at which to start the search.
     */
    function binarySearchKey(array, key, keySelector, keyComparer, offset) {
        if (!some(array)) {
            return -1;
        }
        var low = offset || 0;
        var high = array.length - 1;
        while (low <= high) {
            var middle = low + ((high - low) >> 1);
            var midKey = keySelector(array[middle], middle);
            switch (keyComparer(midKey, key)) {
                case -1 /* Comparison.LessThan */:
                    low = middle + 1;
                    break;
                case 0 /* Comparison.EqualTo */:
                    return middle;
                case 1 /* Comparison.GreaterThan */:
                    high = middle - 1;
                    break;
            }
        }
        return ~low;
    }
    ts.binarySearchKey = binarySearchKey;
    function reduceLeft(array, f, initial, start, count) {
        if (array && array.length > 0) {
            var size = array.length;
            if (size > 0) {
                var pos = start === undefined || start < 0 ? 0 : start;
                var end = count === undefined || pos + count > size - 1 ? size - 1 : pos + count;
                var result = void 0;
                if (arguments.length <= 2) {
                    result = array[pos];
                    pos++;
                }
                else {
                    result = initial;
                }
                while (pos <= end) {
                    result = f(result, array[pos], pos);
                    pos++;
                }
                return result;
            }
        }
        return initial;
    }
    ts.reduceLeft = reduceLeft;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    /**
     * Indicates whether a map-like contains an own property with the specified key.
     *
     * @param map A map-like.
     * @param key A property key.
     */
    function hasProperty(map, key) {
        return hasOwnProperty.call(map, key);
    }
    ts.hasProperty = hasProperty;
    /**
     * Gets the value of an owned property in a map-like.
     *
     * @param map A map-like.
     * @param key A property key.
     */
    function getProperty(map, key) {
        return hasOwnProperty.call(map, key) ? map[key] : undefined;
    }
    ts.getProperty = getProperty;
    /**
     * Gets the owned, enumerable property keys of a map-like.
     */
    function getOwnKeys(map) {
        var keys = [];
        for (var key in map) {
            if (hasOwnProperty.call(map, key)) {
                keys.push(key);
            }
        }
        return keys;
    }
    ts.getOwnKeys = getOwnKeys;
    function getAllKeys(obj) {
        var result = [];
        do {
            var names = Object.getOwnPropertyNames(obj);
            for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {
                var name = names_1[_i];
                pushIfUnique(result, name);
            }
        } while (obj = Object.getPrototypeOf(obj));
        return result;
    }
    ts.getAllKeys = getAllKeys;
    function getOwnValues(collection) {
        var values = [];
        for (var key in collection) {
            if (hasOwnProperty.call(collection, key)) {
                values.push(collection[key]);
            }
        }
        return values;
    }
    ts.getOwnValues = getOwnValues;
    var _entries = Object.entries || (function (obj) {
        var keys = getOwnKeys(obj);
        var result = Array(keys.length);
        for (var i = 0; i < keys.length; i++) {
            result[i] = [keys[i], obj[keys[i]]];
        }
        return result;
    });
    function getEntries(obj) {
        return obj ? _entries(obj) : [];
    }
    ts.getEntries = getEntries;
    function arrayOf(count, f) {
        var result = new Array(count);
        for (var i = 0; i < count; i++) {
            result[i] = f(i);
        }
        return result;
    }
    ts.arrayOf = arrayOf;
    function arrayFrom(iterator, map) {
        var result = [];
        for (var iterResult = iterator.next(); !iterResult.done; iterResult = iterator.next()) {
            result.push(map ? map(iterResult.value) : iterResult.value);
        }
        return result;
    }
    ts.arrayFrom = arrayFrom;
    function assign(t) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
            var arg = args_1[_a];
            if (arg === undefined)
                continue;
            for (var p in arg) {
                if (hasProperty(arg, p)) {
                    t[p] = arg[p];
                }
            }
        }
        return t;
    }
    ts.assign = assign;
    /**
     * Performs a shallow equality comparison of the contents of two map-likes.
     *
     * @param left A map-like whose properties should be compared.
     * @param right A map-like whose properties should be compared.
     */
    function equalOwnProperties(left, right, equalityComparer) {
        if (equalityComparer === void 0) { equalityComparer = equateValues; }
        if (left === right)
            return true;
        if (!left || !right)
            return false;
        for (var key in left) {
            if (hasOwnProperty.call(left, key)) {
                if (!hasOwnProperty.call(right, key))
                    return false;
                if (!equalityComparer(left[key], right[key]))
                    return false;
            }
        }
        for (var key in right) {
            if (hasOwnProperty.call(right, key)) {
                if (!hasOwnProperty.call(left, key))
                    return false;
            }
        }
        return true;
    }
    ts.equalOwnProperties = equalOwnProperties;
    function arrayToMap(array, makeKey, makeValue) {
        if (makeValue === void 0) { makeValue = identity; }
        var result = new ts.Map();
        for (var _i = 0, array_6 = array; _i < array_6.length; _i++) {
            var value = array_6[_i];
            var key = makeKey(value);
            if (key !== undefined)
                result.set(key, makeValue(value));
        }
        return result;
    }
    ts.arrayToMap = arrayToMap;
    function arrayToNumericMap(array, makeKey, makeValue) {
        if (makeValue === void 0) { makeValue = identity; }
        var result = [];
        for (var _i = 0, array_7 = array; _i < array_7.length; _i++) {
            var value = array_7[_i];
            result[makeKey(value)] = makeValue(value);
        }
        return result;
    }
    ts.arrayToNumericMap = arrayToNumericMap;
    function arrayToMultiMap(values, makeKey, makeValue) {
        if (makeValue === void 0) { makeValue = identity; }
        var result = createMultiMap();
        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
            var value = values_1[_i];
            result.add(makeKey(value), makeValue(value));
        }
        return result;
    }
    ts.arrayToMultiMap = arrayToMultiMap;
    function group(values, getGroupId, resultSelector) {
        if (resultSelector === void 0) { resultSelector = identity; }
        return arrayFrom(arrayToMultiMap(values, getGroupId).values(), resultSelector);
    }
    ts.group = group;
    function clone(object) {
        var result = {};
        for (var id in object) {
            if (hasOwnProperty.call(object, id)) {
                result[id] = object[id];
            }
        }
        return result;
    }
    ts.clone = clone;
    /**
     * Creates a new object by adding the own properties of `second`, then the own properties of `first`.
     *
     * NOTE: This means that if a property exists in both `first` and `second`, the property in `first` will be chosen.
     */
    function extend(first, second) {
        var result = {};
        for (var id in second) {
            if (hasOwnProperty.call(second, id)) {
                result[id] = second[id];
            }
        }
        for (var id in first) {
            if (hasOwnProperty.call(first, id)) {
                result[id] = first[id];
            }
        }
        return result;
    }
    ts.extend = extend;
    function copyProperties(first, second) {
        for (var id in second) {
            if (hasOwnProperty.call(second, id)) {
                first[id] = second[id];
            }
        }
    }
    ts.copyProperties = copyProperties;
    function maybeBind(obj, fn) {
        return fn ? fn.bind(obj) : undefined;
    }
    ts.maybeBind = maybeBind;
    function createMultiMap() {
        var map = new ts.Map();
        map.add = multiMapAdd;
        map.remove = multiMapRemove;
        return map;
    }
    ts.createMultiMap = createMultiMap;
    function multiMapAdd(key, value) {
        var values = this.get(key);
        if (values) {
            values.push(value);
        }
        else {
            this.set(key, values = [value]);
        }
        return values;
    }
    function multiMapRemove(key, value) {
        var values = this.get(key);
        if (values) {
            unorderedRemoveItem(values, value);
            if (!values.length) {
                this.delete(key);
            }
        }
    }
    function createUnderscoreEscapedMultiMap() {
        return createMultiMap();
    }
    ts.createUnderscoreEscapedMultiMap = createUnderscoreEscapedMultiMap;
    function createQueue(items) {
        var elements = (items === null || items === void 0 ? void 0 : items.slice()) || [];
        var headIndex = 0;
        function isEmpty() {
            return headIndex === elements.length;
        }
        function enqueue() {
            var items = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                items[_i] = arguments[_i];
            }
            elements.push.apply(elements, items);
        }
        function dequeue() {
            if (isEmpty()) {
                throw new Error("Queue is empty");
            }
            var result = elements[headIndex];
            elements[headIndex] = undefined; // Don't keep referencing dequeued item
            headIndex++;
            // If more than half of the queue is empty, copy the remaining elements to the
            // front and shrink the array (unless we'd be saving fewer than 100 slots)
            if (headIndex > 100 && headIndex > (elements.length >> 1)) {
                var newLength = elements.length - headIndex;
                elements.copyWithin(/*target*/ 0, /*start*/ headIndex);
                elements.length = newLength;
                headIndex = 0;
            }
            return result;
        }
        return {
            enqueue: enqueue,
            dequeue: dequeue,
            isEmpty: isEmpty,
        };
    }
    ts.createQueue = createQueue;
    /**
     * Creates a Set with custom equality and hash code functionality.  This is useful when you
     * want to use something looser than object identity - e.g. "has the same span".
     *
     * If `equals(a, b)`, it must be the case that `getHashCode(a) === getHashCode(b)`.
     * The converse is not required.
     *
     * To facilitate a perf optimization (lazy allocation of bucket arrays), `TElement` is
     * assumed not to be an array type.
     */
    function createSet(getHashCode, equals) {
        var multiMap = new ts.Map();
        var size = 0;
        function getElementIterator() {
            var valueIt = multiMap.values();
            var arrayIt;
            return {
                next: function () {
                    while (true) {
                        if (arrayIt) {
                            var n = arrayIt.next();
                            if (!n.done) {
                                return { value: n.value };
                            }
                            arrayIt = undefined;
                        }
                        else {
                            var n = valueIt.next();
                            if (n.done) {
                                return { value: undefined, done: true };
                            }
                            if (!isArray(n.value)) {
                                return { value: n.value };
                            }
                            arrayIt = arrayIterator(n.value);
                        }
                    }
                }
            };
        }
        var set = {
            has: function (element) {
                var hash = getHashCode(element);
                if (!multiMap.has(hash))
                    return false;
                var candidates = multiMap.get(hash);
                if (!isArray(candidates))
                    return equals(candidates, element);
                for (var _i = 0, candidates_1 = candidates; _i < candidates_1.length; _i++) {
                    var candidate = candidates_1[_i];
                    if (equals(candidate, element)) {
                        return true;
                    }
                }
                return false;
            },
            add: function (element) {
                var hash = getHashCode(element);
                if (multiMap.has(hash)) {
                    var values = multiMap.get(hash);
                    if (isArray(values)) {
                        if (!contains(values, element, equals)) {
                            values.push(element);
                            size++;
                        }
                    }
                    else {
                        var value = values;
                        if (!equals(value, element)) {
                            multiMap.set(hash, [value, element]);
                            size++;
                        }
                    }
                }
                else {
                    multiMap.set(hash, element);
                    size++;
                }
                return this;
            },
            delete: function (element) {
                var hash = getHashCode(element);
                if (!multiMap.has(hash))
                    return false;
                var candidates = multiMap.get(hash);
                if (isArray(candidates)) {
                    for (var i = 0; i < candidates.length; i++) {
                        if (equals(candidates[i], element)) {
                            if (candidates.length === 1) {
                                multiMap.delete(hash);
                            }
                            else if (candidates.length === 2) {
                                multiMap.set(hash, candidates[1 - i]);
                            }
                            else {
                                unorderedRemoveItemAt(candidates, i);
                            }
                            size--;
                            return true;
                        }
                    }
                }
                else {
                    var candidate = candidates;
                    if (equals(candidate, element)) {
                        multiMap.delete(hash);
                        size--;
                        return true;
                    }
                }
                return false;
            },
            clear: function () {
                multiMap.clear();
                size = 0;
            },
            get size() {
                return size;
            },
            forEach: function (action) {
                for (var _i = 0, _a = arrayFrom(multiMap.values()); _i < _a.length; _i++) {
                    var elements = _a[_i];
                    if (isArray(elements)) {
                        for (var _b = 0, elements_1 = elements; _b < elements_1.length; _b++) {
                            var element = elements_1[_b];
                            action(element, element);
                        }
                    }
                    else {
                        var element = elements;
                        action(element, element);
                    }
                }
            },
            keys: function () {
                return getElementIterator();
            },
            values: function () {
                return getElementIterator();
            },
            entries: function () {
                var it = getElementIterator();
                return {
                    next: function () {
                        var n = it.next();
                        return n.done ? n : { value: [n.value, n.value] };
                    }
                };
            },
        };
        return set;
    }
    ts.createSet = createSet;
    /**
     * Tests whether a value is an array.
     */
    function isArray(value) {
        return Array.isArray ? Array.isArray(value) : value instanceof Array;
    }
    ts.isArray = isArray;
    function toArray(value) {
        return isArray(value) ? value : [value];
    }
    ts.toArray = toArray;
    /**
     * Tests whether a value is string
     */
    function isString(text) {
        return typeof text === "string";
    }
    ts.isString = isString;
    function isNumber(x) {
        return typeof x === "number";
    }
    ts.isNumber = isNumber;
    function tryCast(value, test) {
        return value !== undefined && test(value) ? value : undefined;
    }
    ts.tryCast = tryCast;
    function cast(value, test) {
        if (value !== undefined && test(value))
            return value;
        return ts.Debug.fail("Invalid cast. The supplied value ".concat(value, " did not pass the test '").concat(ts.Debug.getFunctionName(test), "'."));
    }
    ts.cast = cast;
    /** Does nothing. */
    function noop(_) { }
    ts.noop = noop;
    ts.noopPush = {
        push: noop,
        length: 0
    };
    /** Do nothing and return false */
    function returnFalse() {
        return false;
    }
    ts.returnFalse = returnFalse;
    /** Do nothing and return true */
    function returnTrue() {
        return true;
    }
    ts.returnTrue = returnTrue;
    /** Do nothing and return undefined */
    function returnUndefined() {
        return undefined;
    }
    ts.returnUndefined = returnUndefined;
    /** Returns its argument. */
    function identity(x) {
        return x;
    }
    ts.identity = identity;
    /** Returns lower case string */
    function toLowerCase(x) {
        return x.toLowerCase();
    }
    ts.toLowerCase = toLowerCase;
    // We convert the file names to lower case as key for file name on case insensitive file system
    // While doing so we need to handle special characters (eg \u0130) to ensure that we dont convert
    // it to lower case, fileName with its lowercase form can exist along side it.
    // Handle special characters and make those case sensitive instead
    //
    // |-#--|-Unicode--|-Char code-|-Desc-------------------------------------------------------------------|
    // | 1. | i        | 105       | Ascii i                                                                |
    // | 2. | I        | 73        | Ascii I                                                                |
    // |-------- Special characters ------------------------------------------------------------------------|
    // | 3. | \u0130   | 304       | Upper case I with dot above                                            |
    // | 4. | i,\u0307 | 105,775   | i, followed by 775: Lower case of (3rd item)                           |
    // | 5. | I,\u0307 | 73,775    | I, followed by 775: Upper case of (4th item), lower case is (4th item) |
    // | 6. | \u0131   | 305       | Lower case i without dot, upper case is I (2nd item)                   |
    // | 7. | \u00DF   | 223       | Lower case sharp s                                                     |
    //
    // Because item 3 is special where in its lowercase character has its own
    // upper case form we cant convert its case.
    // Rest special characters are either already in lower case format or
    // they have corresponding upper case character so they dont need special handling
    //
    // But to avoid having to do string building for most common cases, also ignore
    // a-z, 0-9, \u0131, \u00DF, \, /, ., : and space
    var fileNameLowerCaseRegExp = /[^\u0130\u0131\u00DFa-z0-9\\/:\-_\. ]+/g;
    /**
     * Case insensitive file systems have descripencies in how they handle some characters (eg. turkish Upper case I with dot on top - \u0130)
     * This function is used in places where we want to make file name as a key on these systems
     * It is possible on mac to be able to refer to file name with I with dot on top as a fileName with its lower case form
     * But on windows we cannot. Windows can have fileName with I with dot on top next to its lower case and they can not each be referred with the lowercase forms
     * Technically we would want this function to be platform sepcific as well but
     * our api has till now only taken caseSensitive as the only input and just for some characters we dont want to update API and ensure all customers use those api
     * We could use upper case and we would still need to deal with the descripencies but
     * we want to continue using lower case since in most cases filenames are lowercasewe and wont need any case changes and avoid having to store another string for the key
     * So for this function purpose, we go ahead and assume character I with dot on top it as case sensitive since its very unlikely to use lower case form of that special character
     */
    function toFileNameLowerCase(x) {
        return fileNameLowerCaseRegExp.test(x) ?
            x.replace(fileNameLowerCaseRegExp, toLowerCase) :
            x;
    }
    ts.toFileNameLowerCase = toFileNameLowerCase;
    /** Throws an error because a function is not implemented. */
    function notImplemented() {
        throw new Error("Not implemented");
    }
    ts.notImplemented = notImplemented;
    function memoize(callback) {
        var value;
        return function () {
            if (callback) {
                value = callback();
                callback = undefined;
            }
            return value;
        };
    }
    ts.memoize = memoize;
    /** A version of `memoize` that supports a single primitive argument */
    function memoizeOne(callback) {
        var map = new ts.Map();
        return function (arg) {
            var key = "".concat(typeof arg, ":").concat(arg);
            var value = map.get(key);
            if (value === undefined && !map.has(key)) {
                value = callback(arg);
                map.set(key, value);
            }
            return value;
        };
    }
    ts.memoizeOne = memoizeOne;
    function compose(a, b, c, d, e) {
        if (!!e) {
            var args_2 = [];
            for (var i = 0; i < arguments.length; i++) {
                args_2[i] = arguments[i];
            }
            return function (t) { return reduceLeft(args_2, function (u, f) { return f(u); }, t); };
        }
        else if (d) {
            return function (t) { return d(c(b(a(t)))); };
        }
        else if (c) {
            return function (t) { return c(b(a(t))); };
        }
        else if (b) {
            return function (t) { return b(a(t)); };
        }
        else if (a) {
            return function (t) { return a(t); };
        }
        else {
            return function (t) { return t; };
        }
    }
    ts.compose = compose;
    var AssertionLevel;
    (function (AssertionLevel) {
        AssertionLevel[AssertionLevel["None"] = 0] = "None";
        AssertionLevel[AssertionLevel["Normal"] = 1] = "Normal";
        AssertionLevel[AssertionLevel["Aggressive"] = 2] = "Aggressive";
        AssertionLevel[AssertionLevel["VeryAggressive"] = 3] = "VeryAggressive";
    })(AssertionLevel = ts.AssertionLevel || (ts.AssertionLevel = {}));
    function equateValues(a, b) {
        return a === b;
    }
    ts.equateValues = equateValues;
    /**
     * Compare the equality of two strings using a case-sensitive ordinal comparison.
     *
     * Case-sensitive comparisons compare both strings one code-point at a time using the integer
     * value of each code-point after applying `toUpperCase` to each string. We always map both
     * strings to their upper-case form as some unicode characters do not properly round-trip to
     * lowercase (such as `` (German sharp capital s)).
     */
    function equateStringsCaseInsensitive(a, b) {
        return a === b
            || a !== undefined
                && b !== undefined
                && a.toUpperCase() === b.toUpperCase();
    }
    ts.equateStringsCaseInsensitive = equateStringsCaseInsensitive;
    /**
     * Compare the equality of two strings using a case-sensitive ordinal comparison.
     *
     * Case-sensitive comparisons compare both strings one code-point at a time using the
     * integer value of each code-point.
     */
    function equateStringsCaseSensitive(a, b) {
        return equateValues(a, b);
    }
    ts.equateStringsCaseSensitive = equateStringsCaseSensitive;
    function compareComparableValues(a, b) {
        return a === b ? 0 /* Comparison.EqualTo */ :
            a === undefined ? -1 /* Comparison.LessThan */ :
                b === undefined ? 1 /* Comparison.GreaterThan */ :
                    a < b ? -1 /* Comparison.LessThan */ :
                        1 /* Comparison.GreaterThan */;
    }
    /**
     * Compare two numeric values for their order relative to each other.
     * To compare strings, use any of the `compareStrings` functions.
     */
    function compareValues(a, b) {
        return compareComparableValues(a, b);
    }
    ts.compareValues = compareValues;
    /**
     * Compare two TextSpans, first by `start`, then by `length`.
     */
    function compareTextSpans(a, b) {
        return compareValues(a === null || a === void 0 ? void 0 : a.start, b === null || b === void 0 ? void 0 : b.start) || compareValues(a === null || a === void 0 ? void 0 : a.length, b === null || b === void 0 ? void 0 : b.length);
    }
    ts.compareTextSpans = compareTextSpans;
    function min(a, b, compare) {
        return compare(a, b) === -1 /* Comparison.LessThan */ ? a : b;
    }
    ts.min = min;
    /**
     * Compare two strings using a case-insensitive ordinal comparison.
     *
     * Ordinal comparisons are based on the difference between the unicode code points of both
     * strings. Characters with multiple unicode representations are considered unequal. Ordinal
     * comparisons provide predictable ordering, but place "a" after "B".
     *
     * Case-insensitive comparisons compare both strings one code-point at a time using the integer
     * value of each code-point after applying `toUpperCase` to each string. We always map both
     * strings to their upper-case form as some unicode characters do not properly round-trip to
     * lowercase (such as `` (German sharp capital s)).
     */
    function compareStringsCaseInsensitive(a, b) {
        if (a === b)
            return 0 /* Comparison.EqualTo */;
        if (a === undefined)
            return -1 /* Comparison.LessThan */;
        if (b === undefined)
            return 1 /* Comparison.GreaterThan */;
        a = a.toUpperCase();
        b = b.toUpperCase();
        return a < b ? -1 /* Comparison.LessThan */ : a > b ? 1 /* Comparison.GreaterThan */ : 0 /* Comparison.EqualTo */;
    }
    ts.compareStringsCaseInsensitive = compareStringsCaseInsensitive;
    /**
     * Compare two strings using a case-sensitive ordinal comparison.
     *
     * Ordinal comparisons are based on the difference between the unicode code points of both
     * strings. Characters with multiple unicode representations are considered unequal. Ordinal
     * comparisons provide predictable ordering, but place "a" after "B".
     *
     * Case-sensitive comparisons compare both strings one code-point at a time using the integer
     * value of each code-point.
     */
    function compareStringsCaseSensitive(a, b) {
        return compareComparableValues(a, b);
    }
    ts.compareStringsCaseSensitive = compareStringsCaseSensitive;
    function getStringComparer(ignoreCase) {
        return ignoreCase ? compareStringsCaseInsensitive : compareStringsCaseSensitive;
    }
    ts.getStringComparer = getStringComparer;
    /**
     * Creates a string comparer for use with string collation in the UI.
     */
    var createUIStringComparer = (function () {
        var defaultComparer;
        var enUSComparer;
        var stringComparerFactory = getStringComparerFactory();
        return createStringComparer;
        function compareWithCallback(a, b, comparer) {
            if (a === b)
                return 0 /* Comparison.EqualTo */;
            if (a === undefined)
                return -1 /* Comparison.LessThan */;
            if (b === undefined)
                return 1 /* Comparison.GreaterThan */;
            var value = comparer(a, b);
            return value < 0 ? -1 /* Comparison.LessThan */ : value > 0 ? 1 /* Comparison.GreaterThan */ : 0 /* Comparison.EqualTo */;
        }
        function createIntlCollatorStringComparer(locale) {
            // Intl.Collator.prototype.compare is bound to the collator. See NOTE in
            // http://www.ecma-international.org/ecma-402/2.0/#sec-Intl.Collator.prototype.compare
            var comparer = new Intl.Collator(locale, { usage: "sort", sensitivity: "variant" }).compare;
            return function (a, b) { return compareWithCallback(a, b, comparer); };
        }
        function createLocaleCompareStringComparer(locale) {
            // if the locale is not the default locale (`undefined`), use the fallback comparer.
            if (locale !== undefined)
                return createFallbackStringComparer();
            return function (a, b) { return compareWithCallback(a, b, compareStrings); };
            function compareStrings(a, b) {
                return a.localeCompare(b);
            }
        }
        function createFallbackStringComparer() {
            // An ordinal comparison puts "A" after "b", but for the UI we want "A" before "b".
            // We first sort case insensitively.  So "Aaa" will come before "baa".
            // Then we sort case sensitively, so "aaa" will come before "Aaa".
            //
            // For case insensitive comparisons we always map both strings to their
            // upper-case form as some unicode characters do not properly round-trip to
            // lowercase (such as `` (German sharp capital s)).
            return function (a, b) { return compareWithCallback(a, b, compareDictionaryOrder); };
            function compareDictionaryOrder(a, b) {
                return compareStrings(a.toUpperCase(), b.toUpperCase()) || compareStrings(a, b);
            }
            function compareStrings(a, b) {
                return a < b ? -1 /* Comparison.LessThan */ : a > b ? 1 /* Comparison.GreaterThan */ : 0 /* Comparison.EqualTo */;
            }
        }
        function getStringComparerFactory() {
            // If the host supports Intl, we use it for comparisons using the default locale.
            if (typeof Intl === "object" && typeof Intl.Collator === "function") {
                return createIntlCollatorStringComparer;
            }
            // If the host does not support Intl, we fall back to localeCompare.
            // localeCompare in Node v0.10 is just an ordinal comparison, so don't use it.
            if (typeof String.prototype.localeCompare === "function" &&
                typeof String.prototype.toLocaleUpperCase === "function" &&
                "a".localeCompare("B") < 0) {
                return createLocaleCompareStringComparer;
            }
            // Otherwise, fall back to ordinal comparison:
            return createFallbackStringComparer;
        }
        function createStringComparer(locale) {
            // Hold onto common string comparers. This avoids constantly reallocating comparers during
            // tests.
            if (locale === undefined) {
                return defaultComparer || (defaultComparer = stringComparerFactory(locale));
            }
            else if (locale === "en-US") {
                return enUSComparer || (enUSComparer = stringComparerFactory(locale));
            }
            else {
                return stringComparerFactory(locale);
            }
        }
    })();
    var uiComparerCaseSensitive;
    var uiLocale;
    function getUILocale() {
        return uiLocale;
    }
    ts.getUILocale = getUILocale;
    function setUILocale(value) {
        if (uiLocale !== value) {
            uiLocale = value;
            uiComparerCaseSensitive = undefined;
        }
    }
    ts.setUILocale = setUILocale;
    /**
     * Compare two strings in a using the case-sensitive sort behavior of the UI locale.
     *
     * Ordering is not predictable between different host locales, but is best for displaying
     * ordered data for UI presentation. Characters with multiple unicode representations may
     * be considered equal.
     *
     * Case-sensitive comparisons compare strings that differ in base characters, or
     * accents/diacritic marks, or case as unequal.
     */
    function compareStringsCaseSensitiveUI(a, b) {
        var comparer = uiComparerCaseSensitive || (uiComparerCaseSensitive = createUIStringComparer(uiLocale));
        return comparer(a, b);
    }
    ts.compareStringsCaseSensitiveUI = compareStringsCaseSensitiveUI;
    function compareProperties(a, b, key, comparer) {
        return a === b ? 0 /* Comparison.EqualTo */ :
            a === undefined ? -1 /* Comparison.LessThan */ :
                b === undefined ? 1 /* Comparison.GreaterThan */ :
                    comparer(a[key], b[key]);
    }
    ts.compareProperties = compareProperties;
    /** True is greater than false. */
    function compareBooleans(a, b) {
        return compareValues(a ? 1 : 0, b ? 1 : 0);
    }
    ts.compareBooleans = compareBooleans;
    /**
     * Given a name and a list of names that are *not* equal to the name, return a spelling suggestion if there is one that is close enough.
     * Names less than length 3 only check for case-insensitive equality.
     *
     * find the candidate with the smallest Levenshtein distance,
     *    except for candidates:
     *      * With no name
     *      * Whose length differs from the target name by more than 0.34 of the length of the name.
     *      * Whose levenshtein distance is more than 0.4 of the length of the name
     *        (0.4 allows 1 substitution/transposition for every 5 characters,
     *         and 1 insertion/deletion at 3 characters)
     */
    function getSpellingSuggestion(name, candidates, getName) {
        var maximumLengthDifference = Math.max(2, Math.floor(name.length * 0.34));
        var bestDistance = Math.floor(name.length * 0.4) + 1; // If the best result is worse than this, don't bother.
        var bestCandidate;
        for (var _i = 0, candidates_2 = candidates; _i < candidates_2.length; _i++) {
            var candidate = candidates_2[_i];
            var candidateName = getName(candidate);
            if (candidateName !== undefined && Math.abs(candidateName.length - name.length) <= maximumLengthDifference) {
                if (candidateName === name) {
                    continue;
                }
                // Only consider candidates less than 3 characters long when they differ by case.
                // Otherwise, don't bother, since a user would usually notice differences of a 2-character name.
                if (candidateName.length < 3 && candidateName.toLowerCase() !== name.toLowerCase()) {
                    continue;
                }
                var distance = levenshteinWithMax(name, candidateName, bestDistance - 0.1);
                if (distance === undefined) {
                    continue;
                }
                ts.Debug.assert(distance < bestDistance); // Else `levenshteinWithMax` should return undefined
                bestDistance = distance;
                bestCandidate = candidate;
            }
        }
        return bestCandidate;
    }
    ts.getSpellingSuggestion = getSpellingSuggestion;
    function levenshteinWithMax(s1, s2, max) {
        var previous = new Array(s2.length + 1);
        var current = new Array(s2.length + 1);
        /** Represents any value > max. We don't care about the particular value. */
        var big = max + 0.01;
        for (var i = 0; i <= s2.length; i++) {
            previous[i] = i;
        }
        for (var i = 1; i <= s1.length; i++) {
            var c1 = s1.charCodeAt(i - 1);
            var minJ = Math.ceil(i > max ? i - max : 1);
            var maxJ = Math.floor(s2.length > max + i ? max + i : s2.length);
            current[0] = i;
            /** Smallest value of the matrix in the ith column. */
            var colMin = i;
            for (var j = 1; j < minJ; j++) {
                current[j] = big;
            }
            for (var j = minJ; j <= maxJ; j++) {
                // case difference should be significantly cheaper than other differences
                var substitutionDistance = s1[i - 1].toLowerCase() === s2[j - 1].toLowerCase()
                    ? (previous[j - 1] + 0.1)
                    : (previous[j - 1] + 2);
                var dist = c1 === s2.charCodeAt(j - 1)
                    ? previous[j - 1]
                    : Math.min(/*delete*/ previous[j] + 1, /*insert*/ current[j - 1] + 1, /*substitute*/ substitutionDistance);
                current[j] = dist;
                colMin = Math.min(colMin, dist);
            }
            for (var j = maxJ + 1; j <= s2.length; j++) {
                current[j] = big;
            }
            if (colMin > max) {
                // Give up -- everything in this column is > max and it can't get better in future columns.
                return undefined;
            }
            var temp = previous;
            previous = current;
            current = temp;
        }
        var res = previous[s2.length];
        return res > max ? undefined : res;
    }
    function endsWith(str, suffix) {
        var expectedPos = str.length - suffix.length;
        return expectedPos >= 0 && str.indexOf(suffix, expectedPos) === expectedPos;
    }
    ts.endsWith = endsWith;
    function removeSuffix(str, suffix) {
        return endsWith(str, suffix) ? str.slice(0, str.length - suffix.length) : str;
    }
    ts.removeSuffix = removeSuffix;
    function tryRemoveSuffix(str, suffix) {
        return endsWith(str, suffix) ? str.slice(0, str.length - suffix.length) : undefined;
    }
    ts.tryRemoveSuffix = tryRemoveSuffix;
    function stringContains(str, substring) {
        return str.indexOf(substring) !== -1;
    }
    ts.stringContains = stringContains;
    /**
     * Takes a string like "jquery-min.4.2.3" and returns "jquery"
     */
    function removeMinAndVersionNumbers(fileName) {
        // We used to use the regex /[.-]((min)|(\d+(\.\d+)*))$/ and would just .replace it twice.
        // Unfortunately, that regex has O(n^2) performance because v8 doesn't match from the end of the string.
        // Instead, we now essentially scan the filename (backwards) ourselves.
        var end = fileName.length;
        for (var pos = end - 1; pos > 0; pos--) {
            var ch = fileName.charCodeAt(pos);
            if (ch >= 48 /* CharacterCodes._0 */ && ch <= 57 /* CharacterCodes._9 */) {
                // Match a \d+ segment
                do {
                    --pos;
                    ch = fileName.charCodeAt(pos);
                } while (pos > 0 && ch >= 48 /* CharacterCodes._0 */ && ch <= 57 /* CharacterCodes._9 */);
            }
            else if (pos > 4 && (ch === 110 /* CharacterCodes.n */ || ch === 78 /* CharacterCodes.N */)) {
                // Looking for "min" or "min"
                // Already matched the 'n'
                --pos;
                ch = fileName.charCodeAt(pos);
                if (ch !== 105 /* CharacterCodes.i */ && ch !== 73 /* CharacterCodes.I */) {
                    break;
                }
                --pos;
                ch = fileName.charCodeAt(pos);
                if (ch !== 109 /* CharacterCodes.m */ && ch !== 77 /* CharacterCodes.M */) {
                    break;
                }
                --pos;
                ch = fileName.charCodeAt(pos);
            }
            else {
                // This character is not part of either suffix pattern
                break;
            }
            if (ch !== 45 /* CharacterCodes.minus */ && ch !== 46 /* CharacterCodes.dot */) {
                break;
            }
            end = pos;
        }
        // end might be fileName.length, in which case this should internally no-op
        return end === fileName.length ? fileName : fileName.slice(0, end);
    }
    ts.removeMinAndVersionNumbers = removeMinAndVersionNumbers;
    /** Remove an item from an array, moving everything to its right one space left. */
    function orderedRemoveItem(array, item) {
        for (var i = 0; i < array.length; i++) {
            if (array[i] === item) {
                orderedRemoveItemAt(array, i);
                return true;
            }
        }
        return false;
    }
    ts.orderedRemoveItem = orderedRemoveItem;
    /** Remove an item by index from an array, moving everything to its right one space left. */
    function orderedRemoveItemAt(array, index) {
        // This seems to be faster than either `array.splice(i, 1)` or `array.copyWithin(i, i+ 1)`.
        for (var i = index; i < array.length - 1; i++) {
            array[i] = array[i + 1];
        }
        array.pop();
    }
    ts.orderedRemoveItemAt = orderedRemoveItemAt;
    function unorderedRemoveItemAt(array, index) {
        // Fill in the "hole" left at `index`.
        array[index] = array[array.length - 1];
        array.pop();
    }
    ts.unorderedRemoveItemAt = unorderedRemoveItemAt;
    /** Remove the *first* occurrence of `item` from the array. */
    function unorderedRemoveItem(array, item) {
        return unorderedRemoveFirstItemWhere(array, function (element) { return element === item; });
    }
    ts.unorderedRemoveItem = unorderedRemoveItem;
    /** Remove the *first* element satisfying `predicate`. */
    function unorderedRemoveFirstItemWhere(array, predicate) {
        for (var i = 0; i < array.length; i++) {
            if (predicate(array[i])) {
                unorderedRemoveItemAt(array, i);
                return true;
            }
        }
        return false;
    }
    function createGetCanonicalFileName(useCaseSensitiveFileNames) {
        return useCaseSensitiveFileNames ? identity : toFileNameLowerCase;
    }
    ts.createGetCanonicalFileName = createGetCanonicalFileName;
    function patternText(_a) {
        var prefix = _a.prefix, suffix = _a.suffix;
        return "".concat(prefix, "*").concat(suffix);
    }
    ts.patternText = patternText;
    /**
     * Given that candidate matches pattern, returns the text matching the '*'.
     * E.g.: matchedText(tryParsePattern("foo*baz"), "foobarbaz") === "bar"
     */
    function matchedText(pattern, candidate) {
        ts.Debug.assert(isPatternMatch(pattern, candidate));
        return candidate.substring(pattern.prefix.length, candidate.length - pattern.suffix.length);
    }
    ts.matchedText = matchedText;
    /** Return the object corresponding to the best pattern to match `candidate`. */
    function findBestPatternMatch(values, getPattern, candidate) {
        var matchedValue;
        // use length of prefix as betterness criteria
        var longestMatchPrefixLength = -1;
        for (var _i = 0, values_2 = values; _i < values_2.length; _i++) {
            var v = values_2[_i];
            var pattern = getPattern(v);
            if (isPatternMatch(pattern, candidate) && pattern.prefix.length > longestMatchPrefixLength) {
                longestMatchPrefixLength = pattern.prefix.length;
                matchedValue = v;
            }
        }
        return matchedValue;
    }
    ts.findBestPatternMatch = findBestPatternMatch;
    function startsWith(str, prefix) {
        return str.lastIndexOf(prefix, 0) === 0;
    }
    ts.startsWith = startsWith;
    function removePrefix(str, prefix) {
        return startsWith(str, prefix) ? str.substr(prefix.length) : str;
    }
    ts.removePrefix = removePrefix;
    function tryRemovePrefix(str, prefix, getCanonicalFileName) {
        if (getCanonicalFileName === void 0) { getCanonicalFileName = identity; }
        return startsWith(getCanonicalFileName(str), getCanonicalFileName(prefix)) ? str.substring(prefix.length) : undefined;
    }
    ts.tryRemovePrefix = tryRemovePrefix;
    function isPatternMatch(_a, candidate) {
        var prefix = _a.prefix, suffix = _a.suffix;
        return candidate.length >= prefix.length + suffix.length &&
            startsWith(candidate, prefix) &&
            endsWith(candidate, suffix);
    }
    ts.isPatternMatch = isPatternMatch;
    function and(f, g) {
        return function (arg) { return f(arg) && g(arg); };
    }
    ts.and = and;
    function or() {
        var fs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            fs[_i] = arguments[_i];
        }
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var lastResult;
            for (var _a = 0, fs_1 = fs; _a < fs_1.length; _a++) {
                var f = fs_1[_a];
                lastResult = f.apply(void 0, args);
                if (lastResult) {
                    return lastResult;
                }
            }
            return lastResult;
        };
    }
    ts.or = or;
    function not(fn) {
        return function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return !fn.apply(void 0, args);
        };
    }
    ts.not = not;
    function assertType(_) { }
    ts.assertType = assertType;
    function singleElementArray(t) {
        return t === undefined ? undefined : [t];
    }
    ts.singleElementArray = singleElementArray;
    function enumerateInsertsAndDeletes(newItems, oldItems, comparer, inserted, deleted, unchanged) {
        unchanged = unchanged || noop;
        var newIndex = 0;
        var oldIndex = 0;
        var newLen = newItems.length;
        var oldLen = oldItems.length;
        var hasChanges = false;
        while (newIndex < newLen && oldIndex < oldLen) {
            var newItem = newItems[newIndex];
            var oldItem = oldItems[oldIndex];
            var compareResult = comparer(newItem, oldItem);
            if (compareResult === -1 /* Comparison.LessThan */) {
                inserted(newItem);
                newIndex++;
                hasChanges = true;
            }
            else if (compareResult === 1 /* Comparison.GreaterThan */) {
                deleted(oldItem);
                oldIndex++;
                hasChanges = true;
            }
            else {
                unchanged(oldItem, newItem);
                newIndex++;
                oldIndex++;
            }
        }
        while (newIndex < newLen) {
            inserted(newItems[newIndex++]);
            hasChanges = true;
        }
        while (oldIndex < oldLen) {
            deleted(oldItems[oldIndex++]);
            hasChanges = true;
        }
        return hasChanges;
    }
    ts.enumerateInsertsAndDeletes = enumerateInsertsAndDeletes;
    function fill(length, cb) {
        var result = Array(length);
        for (var i = 0; i < length; i++) {
            result[i] = cb(i);
        }
        return result;
    }
    ts.fill = fill;
    function cartesianProduct(arrays) {
        var result = [];
        cartesianProductWorker(arrays, result, /*outer*/ undefined, 0);
        return result;
    }
    ts.cartesianProduct = cartesianProduct;
    function cartesianProductWorker(arrays, result, outer, index) {
        for (var _i = 0, _a = arrays[index]; _i < _a.length; _i++) {
            var element = _a[_i];
            var inner = void 0;
            if (outer) {
                inner = outer.slice();
                inner.push(element);
            }
            else {
                inner = [element];
            }
            if (index === arrays.length - 1) {
                result.push(inner);
            }
            else {
                cartesianProductWorker(arrays, result, inner, index + 1);
            }
        }
    }
    /**
     * Returns string left-padded with spaces or zeros until it reaches the given length.
     *
     * @param s String to pad.
     * @param length Final padded length. If less than or equal to 's.length', returns 's' unchanged.
     * @param padString Character to use as padding (default " ").
     */
    function padLeft(s, length, padString) {
        if (padString === void 0) { padString = " "; }
        return length <= s.length ? s : padString.repeat(length - s.length) + s;
    }
    ts.padLeft = padLeft;
    /**
     * Returns string right-padded with spaces until it reaches the given length.
     *
     * @param s String to pad.
     * @param length Final padded length. If less than or equal to 's.length', returns 's' unchanged.
     * @param padString Character to use as padding (default " ").
     */
    function padRight(s, length, padString) {
        if (padString === void 0) { padString = " "; }
        return length <= s.length ? s : s + padString.repeat(length - s.length);
    }
    ts.padRight = padRight;
    function takeWhile(array, predicate) {
        var len = array.length;
        var index = 0;
        while (index < len && predicate(array[index])) {
            index++;
        }
        return array.slice(0, index);
    }
    ts.takeWhile = takeWhile;
    /**
     * Removes the leading and trailing white space and line terminator characters from a string.
     */
    ts.trimString = !!String.prototype.trim ? (function (s) { return s.trim(); }) : function (s) { return ts.trimStringEnd(ts.trimStringStart(s)); };
    /**
     * Returns a copy with trailing whitespace removed.
     */
    ts.trimStringEnd = !!String.prototype.trimEnd ? (function (s) { return s.trimEnd(); }) : trimEndImpl;
    /**
     * Returns a copy with leading whitespace removed.
     */
    ts.trimStringStart = !!String.prototype.trimStart ? (function (s) { return s.trimStart(); }) : function (s) { return s.replace(/^\s+/g, ""); };
    /**
     * https://jsbench.me/gjkoxld4au/1
     * The simple regex for this, /\s+$/g is O(n^2) in v8.
     * The native .trimEnd method is by far best, but since that's technically ES2019,
     * we provide a (still much faster than the simple regex) fallback.
     */
    function trimEndImpl(s) {
        var end = s.length - 1;
        while (end >= 0) {
            if (!ts.isWhiteSpaceLike(s.charCodeAt(end)))
                break;
            end--;
        }
        return s.slice(0, end + 1);
    }
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var LogLevel;
    (function (LogLevel) {
        LogLevel[LogLevel["Off"] = 0] = "Off";
        LogLevel[LogLevel["Error"] = 1] = "Error";
        LogLevel[LogLevel["Warning"] = 2] = "Warning";
        LogLevel[LogLevel["Info"] = 3] = "Info";
        LogLevel[LogLevel["Verbose"] = 4] = "Verbose";
    })(LogLevel = ts.LogLevel || (ts.LogLevel = {}));
    var Debug;
    (function (Debug) {
        var typeScriptVersion;
        /* eslint-disable prefer-const */
        var currentAssertionLevel = 0 /* AssertionLevel.None */;
        Debug.currentLogLevel = LogLevel.Warning;
        Debug.isDebugging = false;
        Debug.enableDeprecationWarnings = true;
        function getTypeScriptVersion() {
            return typeScriptVersion !== null && typeScriptVersion !== void 0 ? typeScriptVersion : (typeScriptVersion = new ts.Version(ts.version));
        }
        Debug.getTypeScriptVersion = getTypeScriptVersion;
        function shouldLog(level) {
            return Debug.currentLogLevel <= level;
        }
        Debug.shouldLog = shouldLog;
        function logMessage(level, s) {
            if (Debug.loggingHost && shouldLog(level)) {
                Debug.loggingHost.log(level, s);
            }
        }
        function log(s) {
            logMessage(LogLevel.Info, s);
        }
        Debug.log = log;
        (function (log_1) {
            function error(s) {
                logMessage(LogLevel.Error, s);
            }
            log_1.error = error;
            function warn(s) {
                logMessage(LogLevel.Warning, s);
            }
            log_1.warn = warn;
            function log(s) {
                logMessage(LogLevel.Info, s);
            }
            log_1.log = log;
            function trace(s) {
                logMessage(LogLevel.Verbose, s);
            }
            log_1.trace = trace;
        })(log = Debug.log || (Debug.log = {}));
        var assertionCache = {};
        function getAssertionLevel() {
            return currentAssertionLevel;
        }
        Debug.getAssertionLevel = getAssertionLevel;
        function setAssertionLevel(level) {
            var prevAssertionLevel = currentAssertionLevel;
            currentAssertionLevel = level;
            if (level > prevAssertionLevel) {
                // restore assertion functions for the current assertion level (see `shouldAssertFunction`).
                for (var _i = 0, _a = ts.getOwnKeys(assertionCache); _i < _a.length; _i++) {
                    var key = _a[_i];
                    var cachedFunc = assertionCache[key];
                    if (cachedFunc !== undefined && Debug[key] !== cachedFunc.assertion && level >= cachedFunc.level) {
                        Debug[key] = cachedFunc;
                        assertionCache[key] = undefined;
                    }
                }
            }
        }
        Debug.setAssertionLevel = setAssertionLevel;
        function shouldAssert(level) {
            return currentAssertionLevel >= level;
        }
        Debug.shouldAssert = shouldAssert;
        /**
         * Tests whether an assertion function should be executed. If it shouldn't, it is cached and replaced with `ts.noop`.
         * Replaced assertion functions are restored when `Debug.setAssertionLevel` is set to a high enough level.
         * @param level The minimum assertion level required.
         * @param name The name of the current assertion function.
         */
        function shouldAssertFunction(level, name) {
            if (!shouldAssert(level)) {
                assertionCache[name] = { level: level, assertion: Debug[name] };
                Debug[name] = ts.noop;
                return false;
            }
            return true;
        }
        function fail(message, stackCrawlMark) {
            debugger;
            var e = new Error(message ? "Debug Failure. ".concat(message) : "Debug Failure.");
            if (Error.captureStackTrace) {
                Error.captureStackTrace(e, stackCrawlMark || fail);
            }
            throw e;
        }
        Debug.fail = fail;
        function failBadSyntaxKind(node, message, stackCrawlMark) {
            return fail("".concat(message || "Unexpected node.", "\r\nNode ").concat(formatSyntaxKind(node.kind), " was unexpected."), stackCrawlMark || failBadSyntaxKind);
        }
        Debug.failBadSyntaxKind = failBadSyntaxKind;
        function assert(expression, message, verboseDebugInfo, stackCrawlMark) {
            if (!expression) {
                message = message ? "False expression: ".concat(message) : "False expression.";
                if (verboseDebugInfo) {
                    message += "\r\nVerbose Debug Information: " + (typeof verboseDebugInfo === "string" ? verboseDebugInfo : verboseDebugInfo());
                }
                fail(message, stackCrawlMark || assert);
            }
        }
        Debug.assert = assert;
        function assertEqual(a, b, msg, msg2, stackCrawlMark) {
            if (a !== b) {
                var message = msg ? msg2 ? "".concat(msg, " ").concat(msg2) : msg : "";
                fail("Expected ".concat(a, " === ").concat(b, ". ").concat(message), stackCrawlMark || assertEqual);
            }
        }
        Debug.assertEqual = assertEqual;
        function assertLessThan(a, b, msg, stackCrawlMark) {
            if (a >= b) {
                fail("Expected ".concat(a, " < ").concat(b, ". ").concat(msg || ""), stackCrawlMark || assertLessThan);
            }
        }
        Debug.assertLessThan = assertLessThan;
        function assertLessThanOrEqual(a, b, stackCrawlMark) {
            if (a > b) {
                fail("Expected ".concat(a, " <= ").concat(b), stackCrawlMark || assertLessThanOrEqual);
            }
        }
        Debug.assertLessThanOrEqual = assertLessThanOrEqual;
        function assertGreaterThanOrEqual(a, b, stackCrawlMark) {
            if (a < b) {
                fail("Expected ".concat(a, " >= ").concat(b), stackCrawlMark || assertGreaterThanOrEqual);
            }
        }
        Debug.assertGreaterThanOrEqual = assertGreaterThanOrEqual;
        function assertIsDefined(value, message, stackCrawlMark) {
            // eslint-disable-next-line no-null/no-null
            if (value === undefined || value === null) {
                fail(message, stackCrawlMark || assertIsDefined);
            }
        }
        Debug.assertIsDefined = assertIsDefined;
        function checkDefined(value, message, stackCrawlMark) {
            assertIsDefined(value, message, stackCrawlMark || checkDefined);
            return value;
        }
        Debug.checkDefined = checkDefined;
        function assertEachIsDefined(value, message, stackCrawlMark) {
            for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
                var v = value_1[_i];
                assertIsDefined(v, message, stackCrawlMark || assertEachIsDefined);
            }
        }
        Debug.assertEachIsDefined = assertEachIsDefined;
        function checkEachDefined(value, message, stackCrawlMark) {
            assertEachIsDefined(value, message, stackCrawlMark || checkEachDefined);
            return value;
        }
        Debug.checkEachDefined = checkEachDefined;
        function assertNever(member, message, stackCrawlMark) {
            if (message === void 0) { message = "Illegal value:"; }
            var detail = typeof member === "object" && ts.hasProperty(member, "kind") && ts.hasProperty(member, "pos") ? "SyntaxKind: " + formatSyntaxKind(member.kind) : JSON.stringify(member);
            return fail("".concat(message, " ").concat(detail), stackCrawlMark || assertNever);
        }
        Debug.assertNever = assertNever;
        function assertEachNode(nodes, test, message, stackCrawlMark) {
            if (shouldAssertFunction(1 /* AssertionLevel.Normal */, "assertEachNode")) {
                assert(test === undefined || ts.every(nodes, test), message || "Unexpected node.", function () { return "Node array did not pass test '".concat(getFunctionName(test), "'."); }, stackCrawlMark || assertEachNode);
            }
        }
        Debug.assertEachNode = assertEachNode;
        function assertNode(node, test, message, stackCrawlMark) {
            if (shouldAssertFunction(1 /* AssertionLevel.Normal */, "assertNode")) {
                assert(node !== undefined && (test === undefined || test(node)), message || "Unexpected node.", function () { return "Node ".concat(formatSyntaxKind(node === null || node === void 0 ? void 0 : node.kind), " did not pass test '").concat(getFunctionName(test), "'."); }, stackCrawlMark || assertNode);
            }
        }
        Debug.assertNode = assertNode;
        function assertNotNode(node, test, message, stackCrawlMark) {
            if (shouldAssertFunction(1 /* AssertionLevel.Normal */, "assertNotNode")) {
                assert(node === undefined || test === undefined || !test(node), message || "Unexpected node.", function () { return "Node ".concat(formatSyntaxKind(node.kind), " should not have passed test '").concat(getFunctionName(test), "'."); }, stackCrawlMark || assertNotNode);
            }
        }
        Debug.assertNotNode = assertNotNode;
        function assertOptionalNode(node, test, message, stackCrawlMark) {
            if (shouldAssertFunction(1 /* AssertionLevel.Normal */, "assertOptionalNode")) {
                assert(test === undefined || node === undefined || test(node), message || "Unexpected node.", function () { return "Node ".concat(formatSyntaxKind(node === null || node === void 0 ? void 0 : node.kind), " did not pass test '").concat(getFunctionName(test), "'."); }, stackCrawlMark || assertOptionalNode);
            }
        }
        Debug.assertOptionalNode = assertOptionalNode;
        function assertOptionalToken(node, kind, message, stackCrawlMark) {
            if (shouldAssertFunction(1 /* AssertionLevel.Normal */, "assertOptionalToken")) {
                assert(kind === undefined || node === undefined || node.kind === kind, message || "Unexpected node.", function () { return "Node ".concat(formatSyntaxKind(node === null || node === void 0 ? void 0 : node.kind), " was not a '").concat(formatSyntaxKind(kind), "' token."); }, stackCrawlMark || assertOptionalToken);
            }
        }
        Debug.assertOptionalToken = assertOptionalToken;
        function assertMissingNode(node, message, stackCrawlMark) {
            if (shouldAssertFunction(1 /* AssertionLevel.Normal */, "assertMissingNode")) {
                assert(node === undefined, message || "Unexpected node.", function () { return "Node ".concat(formatSyntaxKind(node.kind), " was unexpected'."); }, stackCrawlMark || assertMissingNode);
            }
        }
        Debug.assertMissingNode = assertMissingNode;
        function type(_value) { }
        Debug.type = type;
        function getFunctionName(func) {
            if (typeof func !== "function") {
                return "";
            }
            else if (func.hasOwnProperty("name")) {
                return func.name;
            }
            else {
                var text = Function.prototype.toString.call(func);
                var match = /^function\s+([\w\$]+)\s*\(/.exec(text);
                return match ? match[1] : "";
            }
        }
        Debug.getFunctionName = getFunctionName;
        function formatSymbol(symbol) {
            return "{ name: ".concat(ts.unescapeLeadingUnderscores(symbol.escapedName), "; flags: ").concat(formatSymbolFlags(symbol.flags), "; declarations: ").concat(ts.map(symbol.declarations, function (node) { return formatSyntaxKind(node.kind); }), " }");
        }
        Debug.formatSymbol = formatSymbol;
        /**
         * Formats an enum value as a string for debugging and debug assertions.
         */
        function formatEnum(value, enumObject, isFlags) {
            if (value === void 0) { value = 0; }
            var members = getEnumMembers(enumObject);
            if (value === 0) {
                return members.length > 0 && members[0][0] === 0 ? members[0][1] : "0";
            }
            if (isFlags) {
                var result = [];
                var remainingFlags = value;
                for (var _i = 0, members_1 = members; _i < members_1.length; _i++) {
                    var _a = members_1[_i], enumValue = _a[0], enumName = _a[1];
                    if (enumValue > value) {
                        break;
                    }
                    if (enumValue !== 0 && enumValue & value) {
                        result.push(enumName);
                        remainingFlags &= ~enumValue;
                    }
                }
                if (remainingFlags === 0) {
                    return result.join("|");
                }
            }
            else {
                for (var _b = 0, members_2 = members; _b < members_2.length; _b++) {
                    var _c = members_2[_b], enumValue = _c[0], enumName = _c[1];
                    if (enumValue === value) {
                        return enumName;
                    }
                }
            }
            return value.toString();
        }
        Debug.formatEnum = formatEnum;
        var enumMemberCache = new ts.Map();
        function getEnumMembers(enumObject) {
            // Assuming enum objects do not change at runtime, we can cache the enum members list
            // to reuse later. This saves us from reconstructing this each and every time we call
            // a formatting function (which can be expensive for large enums like SyntaxKind).
            var existing = enumMemberCache.get(enumObject);
            if (existing) {
                return existing;
            }
            var result = [];
            for (var name in enumObject) {
                var value = enumObject[name];
                if (typeof value === "number") {
                    result.push([value, name]);
                }
            }
            var sorted = ts.stableSort(result, function (x, y) { return ts.compareValues(x[0], y[0]); });
            enumMemberCache.set(enumObject, sorted);
            return sorted;
        }
        function formatSyntaxKind(kind) {
            return formatEnum(kind, ts.SyntaxKind, /*isFlags*/ false);
        }
        Debug.formatSyntaxKind = formatSyntaxKind;
        function formatSnippetKind(kind) {
            return formatEnum(kind, ts.SnippetKind, /*isFlags*/ false);
        }
        Debug.formatSnippetKind = formatSnippetKind;
        function formatNodeFlags(flags) {
            return formatEnum(flags, ts.NodeFlags, /*isFlags*/ true);
        }
        Debug.formatNodeFlags = formatNodeFlags;
        function formatModifierFlags(flags) {
            return formatEnum(flags, ts.ModifierFlags, /*isFlags*/ true);
        }
        Debug.formatModifierFlags = formatModifierFlags;
        function formatTransformFlags(flags) {
            return formatEnum(flags, ts.TransformFlags, /*isFlags*/ true);
        }
        Debug.formatTransformFlags = formatTransformFlags;
        function formatEmitFlags(flags) {
            return formatEnum(flags, ts.EmitFlags, /*isFlags*/ true);
        }
        Debug.formatEmitFlags = formatEmitFlags;
        function formatSymbolFlags(flags) {
            return formatEnum(flags, ts.SymbolFlags, /*isFlags*/ true);
        }
        Debug.formatSymbolFlags = formatSymbolFlags;
        function formatTypeFlags(flags) {
            return formatEnum(flags, ts.TypeFlags, /*isFlags*/ true);
        }
        Debug.formatTypeFlags = formatTypeFlags;
        function formatSignatureFlags(flags) {
            return formatEnum(flags, ts.SignatureFlags, /*isFlags*/ true);
        }
        Debug.formatSignatureFlags = formatSignatureFlags;
        function formatObjectFlags(flags) {
            return formatEnum(flags, ts.ObjectFlags, /*isFlags*/ true);
        }
        Debug.formatObjectFlags = formatObjectFlags;
        function formatFlowFlags(flags) {
            return formatEnum(flags, ts.FlowFlags, /*isFlags*/ true);
        }
        Debug.formatFlowFlags = formatFlowFlags;
        function formatRelationComparisonResult(result) {
            return formatEnum(result, ts.RelationComparisonResult, /*isFlags*/ true);
        }
        Debug.formatRelationComparisonResult = formatRelationComparisonResult;
        function formatCheckMode(mode) {
            return formatEnum(mode, ts.CheckMode, /*isFlags*/ true);
        }
        Debug.formatCheckMode = formatCheckMode;
        function formatSignatureCheckMode(mode) {
            return formatEnum(mode, ts.SignatureCheckMode, /*isFlags*/ true);
        }
        Debug.formatSignatureCheckMode = formatSignatureCheckMode;
        function formatTypeFacts(facts) {
            return formatEnum(facts, ts.TypeFacts, /*isFlags*/ true);
        }
        Debug.formatTypeFacts = formatTypeFacts;
        var isDebugInfoEnabled = false;
        var extendedDebugModule;
        function extendedDebug() {
            enableDebugInfo();
            if (!extendedDebugModule) {
                throw new Error("Debugging helpers could not be loaded.");
            }
            return extendedDebugModule;
        }
        function printControlFlowGraph(flowNode) {
            return console.log(formatControlFlowGraph(flowNode));
        }
        Debug.printControlFlowGraph = printControlFlowGraph;
        function formatControlFlowGraph(flowNode) {
            return extendedDebug().formatControlFlowGraph(flowNode);
        }
        Debug.formatControlFlowGraph = formatControlFlowGraph;
        var flowNodeProto;
        function attachFlowNodeDebugInfoWorker(flowNode) {
            if (!("__debugFlowFlags" in flowNode)) { // eslint-disable-line no-in-operator
                Object.defineProperties(flowNode, {
                    // for use with vscode-js-debug's new customDescriptionGenerator in launch.json
                    __tsDebuggerDisplay: {
                        value: function () {
                            var flowHeader = this.flags & 2 /* FlowFlags.Start */ ? "FlowStart" :
                                this.flags & 4 /* FlowFlags.BranchLabel */ ? "FlowBranchLabel" :
                                    this.flags & 8 /* FlowFlags.LoopLabel */ ? "FlowLoopLabel" :
                                        this.flags & 16 /* FlowFlags.Assignment */ ? "FlowAssignment" :
                                            this.flags & 32 /* FlowFlags.TrueCondition */ ? "FlowTrueCondition" :
                                                this.flags & 64 /* FlowFlags.FalseCondition */ ? "FlowFalseCondition" :
                                                    this.flags & 128 /* FlowFlags.SwitchClause */ ? "FlowSwitchClause" :
                                                        this.flags & 256 /* FlowFlags.ArrayMutation */ ? "FlowArrayMutation" :
                                                            this.flags & 512 /* FlowFlags.Call */ ? "FlowCall" :
                                                                this.flags & 1024 /* FlowFlags.ReduceLabel */ ? "FlowReduceLabel" :
                                                                    this.flags & 1 /* FlowFlags.Unreachable */ ? "FlowUnreachable" :
                                                                        "UnknownFlow";
                            var remainingFlags = this.flags & ~(2048 /* FlowFlags.Referenced */ - 1);
                            return "".concat(flowHeader).concat(remainingFlags ? " (".concat(formatFlowFlags(remainingFlags), ")") : "");
                        }
                    },
                    __debugFlowFlags: { get: function () { return formatEnum(this.flags, ts.FlowFlags, /*isFlags*/ true); } },
                    __debugToString: { value: function () { return formatControlFlowGraph(this); } }
                });
            }
        }
        function attachFlowNodeDebugInfo(flowNode) {
            if (isDebugInfoEnabled) {
                if (typeof Object.setPrototypeOf === "function") {
                    // if we're in es2015, attach the method to a shared prototype for `FlowNode`
                    // so the method doesn't show up in the watch window.
                    if (!flowNodeProto) {
                        flowNodeProto = Object.create(Object.prototype);
                        attachFlowNodeDebugInfoWorker(flowNodeProto);
                    }
                    Object.setPrototypeOf(flowNode, flowNodeProto);
                }
                else {
                    // not running in an es2015 environment, attach the method directly.
                    attachFlowNodeDebugInfoWorker(flowNode);
                }
            }
        }
        Debug.attachFlowNodeDebugInfo = attachFlowNodeDebugInfo;
        var nodeArrayProto;
        function attachNodeArrayDebugInfoWorker(array) {
            if (!("__tsDebuggerDisplay" in array)) { // eslint-disable-line no-in-operator
                Object.defineProperties(array, {
                    __tsDebuggerDisplay: {
                        value: function (defaultValue) {
                            // An `Array` with extra properties is rendered as `[A, B, prop1: 1, prop2: 2]`. Most of
                            // these aren't immediately useful so we trim off the `prop1: ..., prop2: ...` part from the
                            // formatted string.
                            // This regex can trigger slow backtracking because of overlapping potential captures.
                            // We don't care, this is debug code that's only enabled with a debugger attached -
                            // we're just taking note of it for anyone checking regex performance in the future.
                            defaultValue = String(defaultValue).replace(/(?:,[\s\w\d_]+:[^,]+)+\]$/, "]");
                            return "NodeArray ".concat(defaultValue);
                        }
                    }
                });
            }
        }
        function attachNodeArrayDebugInfo(array) {
            if (isDebugInfoEnabled) {
                if (typeof Object.setPrototypeOf === "function") {
                    // if we're in es2015, attach the method to a shared prototype for `NodeArray`
                    // so the method doesn't show up in the watch window.
                    if (!nodeArrayProto) {
                        nodeArrayProto = Object.create(Array.prototype);
                        attachNodeArrayDebugInfoWorker(nodeArrayProto);
                    }
                    Object.setPrototypeOf(array, nodeArrayProto);
                }
                else {
                    // not running in an es2015 environment, attach the method directly.
                    attachNodeArrayDebugInfoWorker(array);
                }
            }
        }
        Debug.attachNodeArrayDebugInfo = attachNodeArrayDebugInfo;
        /**
         * Injects debug information into frequently used types.
         */
        function enableDebugInfo() {
            if (isDebugInfoEnabled)
                return;
            // avoid recomputing
            var weakTypeTextMap;
            var weakNodeTextMap;
            function getWeakTypeTextMap() {
                if (weakTypeTextMap === undefined) {
                    if (typeof WeakMap === "function")
                        weakTypeTextMap = new WeakMap();
                }
                return weakTypeTextMap;
            }
            function getWeakNodeTextMap() {
                if (weakNodeTextMap === undefined) {
                    if (typeof WeakMap === "function")
                        weakNodeTextMap = new WeakMap();
                }
                return weakNodeTextMap;
            }
            // Add additional properties in debug mode to assist with debugging.
            Object.defineProperties(ts.objectAllocator.getSymbolConstructor().prototype, {
                // for use with vscode-js-debug's new customDescriptionGenerator in launch.json
                __tsDebuggerDisplay: {
                    value: function () {
                        var symbolHeader = this.flags & 33554432 /* SymbolFlags.Transient */ ? "TransientSymbol" :
                            "Symbol";
                        var remainingSymbolFlags = this.flags & ~33554432 /* SymbolFlags.Transient */;
                        return "".concat(symbolHeader, " '").concat(ts.symbolName(this), "'").concat(remainingSymbolFlags ? " (".concat(formatSymbolFlags(remainingSymbolFlags), ")") : "");
                    }
                },
                __debugFlags: { get: function () { return formatSymbolFlags(this.flags); } }
            });
            Object.defineProperties(ts.objectAllocator.getTypeConstructor().prototype, {
                // for use with vscode-js-debug's new customDescriptionGenerator in launch.json
                __tsDebuggerDisplay: {
                    value: function () {
                        var typeHeader = this.flags & 98304 /* TypeFlags.Nullable */ ? "NullableType" :
                            this.flags & 384 /* TypeFlags.StringOrNumberLiteral */ ? "LiteralType ".concat(JSON.stringify(this.value)) :
                                this.flags & 2048 /* TypeFlags.BigIntLiteral */ ? "LiteralType ".concat(this.value.negative ? "-" : "").concat(this.value.base10Value, "n") :
                                    this.flags & 8192 /* TypeFlags.UniqueESSymbol */ ? "UniqueESSymbolType" :
                                        this.flags & 32 /* TypeFlags.Enum */ ? "EnumType" :
                                            this.flags & 67359327 /* TypeFlags.Intrinsic */ ? "IntrinsicType ".concat(this.intrinsicName) :
                                                this.flags & 1048576 /* TypeFlags.Union */ ? "UnionType" :
                                                    this.flags & 2097152 /* TypeFlags.Intersection */ ? "IntersectionType" :
                                                        this.flags & 4194304 /* TypeFlags.Index */ ? "IndexType" :
                                                            this.flags & 8388608 /* TypeFlags.IndexedAccess */ ? "IndexedAccessType" :
                                                                this.flags & 16777216 /* TypeFlags.Conditional */ ? "ConditionalType" :
                                                                    this.flags & 33554432 /* TypeFlags.Substitution */ ? "SubstitutionType" :
                                                                        this.flags & 262144 /* TypeFlags.TypeParameter */ ? "TypeParameter" :
                                                                            this.flags & 524288 /* TypeFlags.Object */ ?
                                                                                this.objectFlags & 3 /* ObjectFlags.ClassOrInterface */ ? "InterfaceType" :
                                                                                    this.objectFlags & 4 /* ObjectFlags.Reference */ ? "TypeReference" :
                                                                                        this.objectFlags & 8 /* ObjectFlags.Tuple */ ? "TupleType" :
                                                                                            this.objectFlags & 16 /* ObjectFlags.Anonymous */ ? "AnonymousType" :
                                                                                                this.objectFlags & 32 /* ObjectFlags.Mapped */ ? "MappedType" :
                                                                                                    this.objectFlags & 1024 /* ObjectFlags.ReverseMapped */ ? "ReverseMappedType" :
                                                                                                        this.objectFlags & 256 /* ObjectFlags.EvolvingArray */ ? "EvolvingArrayType" :
                                                                                                            "ObjectType" :
                                                                                "Type";
                        var remainingObjectFlags = this.flags & 524288 /* TypeFlags.Object */ ? this.objectFlags & ~1343 /* ObjectFlags.ObjectTypeKindMask */ : 0;
                        return "".concat(typeHeader).concat(this.symbol ? " '".concat(ts.symbolName(this.symbol), "'") : "").concat(remainingObjectFlags ? " (".concat(formatObjectFlags(remainingObjectFlags), ")") : "");
                    }
                },
                __debugFlags: { get: function () { return formatTypeFlags(this.flags); } },
                __debugObjectFlags: { get: function () { return this.flags & 524288 /* TypeFlags.Object */ ? formatObjectFlags(this.objectFlags) : ""; } },
                __debugTypeToString: {
                    value: function () {
                        // avoid recomputing
                        var map = getWeakTypeTextMap();
                        var text = map === null || map === void 0 ? void 0 : map.get(this);
                        if (text === undefined) {
                            text = this.checker.typeToString(this);
                            map === null || map === void 0 ? void 0 : map.set(this, text);
                        }
                        return text;
                    }
                },
            });
            Object.defineProperties(ts.objectAllocator.getSignatureConstructor().prototype, {
                __debugFlags: { get: function () { return formatSignatureFlags(this.flags); } },
                __debugSignatureToString: { value: function () { var _a; return (_a = this.checker) === null || _a === void 0 ? void 0 : _a.signatureToString(this); } }
            });
            var nodeConstructors = [
                ts.objectAllocator.getNodeConstructor(),
                ts.objectAllocator.getIdentifierConstructor(),
                ts.objectAllocator.getTokenConstructor(),
                ts.objectAllocator.getSourceFileConstructor()
            ];
            for (var _i = 0, nodeConstructors_1 = nodeConstructors; _i < nodeConstructors_1.length; _i++) {
                var ctor = nodeConstructors_1[_i];
                if (!ctor.prototype.hasOwnProperty("__debugKind")) {
                    Object.defineProperties(ctor.prototype, {
                        // for use with vscode-js-debug's new customDescriptionGenerator in launch.json
                        __tsDebuggerDisplay: {
                            value: function () {
                                var nodeHeader = ts.isGeneratedIdentifier(this) ? "GeneratedIdentifier" :
                                    ts.isIdentifier(this) ? "Identifier '".concat(ts.idText(this), "'") :
                                        ts.isPrivateIdentifier(this) ? "PrivateIdentifier '".concat(ts.idText(this), "'") :
                                            ts.isStringLiteral(this) ? "StringLiteral ".concat(JSON.stringify(this.text.length < 10 ? this.text : this.text.slice(10) + "...")) :
                                                ts.isNumericLiteral(this) ? "NumericLiteral ".concat(this.text) :
                                                    ts.isBigIntLiteral(this) ? "BigIntLiteral ".concat(this.text, "n") :
                                                        ts.isTypeParameterDeclaration(this) ? "TypeParameterDeclaration" :
                                                            ts.isParameter(this) ? "ParameterDeclaration" :
                                                                ts.isConstructorDeclaration(this) ? "ConstructorDeclaration" :
                                                                    ts.isGetAccessorDeclaration(this) ? "GetAccessorDeclaration" :
                                                                        ts.isSetAccessorDeclaration(this) ? "SetAccessorDeclaration" :
                                                                            ts.isCallSignatureDeclaration(this) ? "CallSignatureDeclaration" :
                                                                                ts.isConstructSignatureDeclaration(this) ? "ConstructSignatureDeclaration" :
                                                                                    ts.isIndexSignatureDeclaration(this) ? "IndexSignatureDeclaration" :
                                                                                        ts.isTypePredicateNode(this) ? "TypePredicateNode" :
                                                                                            ts.isTypeReferenceNode(this) ? "TypeReferenceNode" :
                                                                                                ts.isFunctionTypeNode(this) ? "FunctionTypeNode" :
                                                                                                    ts.isConstructorTypeNode(this) ? "ConstructorTypeNode" :
                                                                                                        ts.isTypeQueryNode(this) ? "TypeQueryNode" :
                                                                                                            ts.isTypeLiteralNode(this) ? "TypeLiteralNode" :
                                                                                                                ts.isArrayTypeNode(this) ? "ArrayTypeNode" :
                                                                                                                    ts.isTupleTypeNode(this) ? "TupleTypeNode" :
                                                                                                                        ts.isOptionalTypeNode(this) ? "OptionalTypeNode" :
                                                                                                                            ts.isRestTypeNode(this) ? "RestTypeNode" :
                                                                                                                                ts.isUnionTypeNode(this) ? "UnionTypeNode" :
                                                                                                                                    ts.isIntersectionTypeNode(this) ? "IntersectionTypeNode" :
                                                                                                                                        ts.isConditionalTypeNode(this) ? "ConditionalTypeNode" :
                                                                                                                                            ts.isInferTypeNode(this) ? "InferTypeNode" :
                                                                                                                                                ts.isParenthesizedTypeNode(this) ? "ParenthesizedTypeNode" :
                                                                                                                                                    ts.isThisTypeNode(this) ? "ThisTypeNode" :
                                                                                                                                                        ts.isTypeOperatorNode(this) ? "TypeOperatorNode" :
                                                                                                                                                            ts.isIndexedAccessTypeNode(this) ? "IndexedAccessTypeNode" :
                                                                                                                                                                ts.isMappedTypeNode(this) ? "MappedTypeNode" :
                                                                                                                                                                    ts.isLiteralTypeNode(this) ? "LiteralTypeNode" :
                                                                                                                                                                        ts.isNamedTupleMember(this) ? "NamedTupleMember" :
                                                                                                                                                                            ts.isImportTypeNode(this) ? "ImportTypeNode" :
                                                                                                                                                                                formatSyntaxKind(this.kind);
                                return "".concat(nodeHeader).concat(this.flags ? " (".concat(formatNodeFlags(this.flags), ")") : "");
                            }
                        },
                        __debugKind: { get: function () { return formatSyntaxKind(this.kind); } },
                        __debugNodeFlags: { get: function () { return formatNodeFlags(this.flags); } },
                        __debugModifierFlags: { get: function () { return formatModifierFlags(ts.getEffectiveModifierFlagsNoCache(this)); } },
                        __debugTransformFlags: { get: function () { return formatTransformFlags(this.transformFlags); } },
                        __debugIsParseTreeNode: { get: function () { return ts.isParseTreeNode(this); } },
                        __debugEmitFlags: { get: function () { return formatEmitFlags(ts.getEmitFlags(this)); } },
                        __debugGetText: {
                            value: function (includeTrivia) {
                                if (ts.nodeIsSynthesized(this))
                                    return "";
                                // avoid recomputing
                                var map = getWeakNodeTextMap();
                                var text = map === null || map === void 0 ? void 0 : map.get(this);
                                if (text === undefined) {
                                    var parseNode = ts.getParseTreeNode(this);
                                    var sourceFile = parseNode && ts.getSourceFileOfNode(parseNode);
                                    text = sourceFile ? ts.getSourceTextOfNodeFromSourceFile(sourceFile, parseNode, includeTrivia) : "";
                                    map === null || map === void 0 ? void 0 : map.set(this, text);
                                }
                                return text;
                            }
                        }
                    });
                }
            }
            // attempt to load extended debugging information
            try {
                if (ts.sys && ts.sys.require) {
                    var basePath = ts.getDirectoryPath(ts.resolvePath(ts.sys.getExecutingFilePath()));
                    var result = ts.sys.require(basePath, "./compiler-debug");
                    if (!result.error) {
                        result.module.init(ts);
                        extendedDebugModule = result.module;
                    }
                }
            }
            catch (_a) {
                // do nothing
            }
            isDebugInfoEnabled = true;
        }
        Debug.enableDebugInfo = enableDebugInfo;
        function formatDeprecationMessage(name, error, errorAfter, since, message) {
            var deprecationMessage = error ? "DeprecationError: " : "DeprecationWarning: ";
            deprecationMessage += "'".concat(name, "' ");
            deprecationMessage += since ? "has been deprecated since v".concat(since) : "is deprecated";
            deprecationMessage += error ? " and can no longer be used." : errorAfter ? " and will no longer be usable after v".concat(errorAfter, ".") : ".";
            deprecationMessage += message ? " ".concat(ts.formatStringFromArgs(message, [name], 0)) : "";
            return deprecationMessage;
        }
        function createErrorDeprecation(name, errorAfter, since, message) {
            var deprecationMessage = formatDeprecationMessage(name, /*error*/ true, errorAfter, since, message);
            return function () {
                throw new TypeError(deprecationMessage);
            };
        }
        function createWarningDeprecation(name, errorAfter, since, message) {
            var hasWrittenDeprecation = false;
            return function () {
                if (Debug.enableDeprecationWarnings && !hasWrittenDeprecation) {
                    log.warn(formatDeprecationMessage(name, /*error*/ false, errorAfter, since, message));
                    hasWrittenDeprecation = true;
                }
            };
        }
        function createDeprecation(name, options) {
            var _a, _b;
            if (options === void 0) { options = {}; }
            var version = typeof options.typeScriptVersion === "string" ? new ts.Version(options.typeScriptVersion) : (_a = options.typeScriptVersion) !== null && _a !== void 0 ? _a : getTypeScriptVersion();
            var errorAfter = typeof options.errorAfter === "string" ? new ts.Version(options.errorAfter) : options.errorAfter;
            var warnAfter = typeof options.warnAfter === "string" ? new ts.Version(options.warnAfter) : options.warnAfter;
            var since = typeof options.since === "string" ? new ts.Version(options.since) : (_b = options.since) !== null && _b !== void 0 ? _b : warnAfter;
            var error = options.error || errorAfter && version.compareTo(errorAfter) <= 0;
            var warn = !warnAfter || version.compareTo(warnAfter) >= 0;
            return error ? createErrorDeprecation(name, errorAfter, since, options.message) :
                warn ? createWarningDeprecation(name, errorAfter, since, options.message) :
                    ts.noop;
        }
        Debug.createDeprecation = createDeprecation;
        function wrapFunction(deprecation, func) {
            return function () {
                deprecation();
                return func.apply(this, arguments);
            };
        }
        function deprecate(func, options) {
            var _a;
            var deprecation = createDeprecation((_a = options === null || options === void 0 ? void 0 : options.name) !== null && _a !== void 0 ? _a : getFunctionName(func), options);
            return wrapFunction(deprecation, func);
        }
        Debug.deprecate = deprecate;
        function formatVariance(varianceFlags) {
            var variance = varianceFlags & 7 /* VarianceFlags.VarianceMask */;
            var result = variance === 0 /* VarianceFlags.Invariant */ ? "in out" :
                variance === 3 /* VarianceFlags.Bivariant */ ? "[bivariant]" :
                    variance === 2 /* VarianceFlags.Contravariant */ ? "in" :
                        variance === 1 /* VarianceFlags.Covariant */ ? "out" :
                            variance === 4 /* VarianceFlags.Independent */ ? "[independent]" : "";
            if (varianceFlags & 8 /* VarianceFlags.Unmeasurable */) {
                result += " (unmeasurable)";
            }
            else if (varianceFlags & 16 /* VarianceFlags.Unreliable */) {
                result += " (unreliable)";
            }
            return result;
        }
        Debug.formatVariance = formatVariance;
        var DebugTypeMapper = /** @class */ (function () {
            function DebugTypeMapper() {
            }
            DebugTypeMapper.prototype.__debugToString = function () {
                var _a;
                type(this);
                switch (this.kind) {
                    case 3 /* TypeMapKind.Function */: return ((_a = this.debugInfo) === null || _a === void 0 ? void 0 : _a.call(this)) || "(function mapper)";
                    case 0 /* TypeMapKind.Simple */: return "".concat(this.source.__debugTypeToString(), " -> ").concat(this.target.__debugTypeToString());
                    case 1 /* TypeMapKind.Array */: return ts.zipWith(this.sources, this.targets || ts.map(this.sources, function () { return "any"; }), function (s, t) { return "".concat(s.__debugTypeToString(), " -> ").concat(typeof t === "string" ? t : t.__debugTypeToString()); }).join(", ");
                    case 2 /* TypeMapKind.Deferred */: return ts.zipWith(this.sources, this.targets, function (s, t) { return "".concat(s.__debugTypeToString(), " -> ").concat(t().__debugTypeToString()); }).join(", ");
                    case 5 /* TypeMapKind.Merged */:
                    case 4 /* TypeMapKind.Composite */: return "m1: ".concat(this.mapper1.__debugToString().split("\n").join("\n    "), "\nm2: ").concat(this.mapper2.__debugToString().split("\n").join("\n    "));
                    default: return assertNever(this);
                }
            };
            return DebugTypeMapper;
        }());
        Debug.DebugTypeMapper = DebugTypeMapper;
        function attachDebugPrototypeIfDebug(mapper) {
            if (Debug.isDebugging) {
                return Object.setPrototypeOf(mapper, DebugTypeMapper.prototype);
            }
            return mapper;
        }
        Debug.attachDebugPrototypeIfDebug = attachDebugPrototypeIfDebug;
    })(Debug = ts.Debug || (ts.Debug = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    // https://semver.org/#spec-item-2
    // > A normal version number MUST take the form X.Y.Z where X, Y, and Z are non-negative
    // > integers, and MUST NOT contain leading zeroes. X is the major version, Y is the minor
    // > version, and Z is the patch version. Each element MUST increase numerically.
    //
    // NOTE: We differ here in that we allow X and X.Y, with missing parts having the default
    // value of `0`.
    var versionRegExp = /^(0|[1-9]\d*)(?:\.(0|[1-9]\d*)(?:\.(0|[1-9]\d*)(?:\-([a-z0-9-.]+))?(?:\+([a-z0-9-.]+))?)?)?$/i;
    // https://semver.org/#spec-item-9
    // > A pre-release version MAY be denoted by appending a hyphen and a series of dot separated
    // > identifiers immediately following the patch version. Identifiers MUST comprise only ASCII
    // > alphanumerics and hyphen [0-9A-Za-z-]. Identifiers MUST NOT be empty. Numeric identifiers
    // > MUST NOT include leading zeroes.
    var prereleaseRegExp = /^(?:0|[1-9]\d*|[a-z-][a-z0-9-]*)(?:\.(?:0|[1-9]\d*|[a-z-][a-z0-9-]*))*$/i;
    // https://semver.org/#spec-item-10
    // > Build metadata MAY be denoted by appending a plus sign and a series of dot separated
    // > identifiers immediately following the patch or pre-release version. Identifiers MUST
    // > comprise only ASCII alphanumerics and hyphen [0-9A-Za-z-]. Identifiers MUST NOT be empty.
    var buildRegExp = /^[a-z0-9-]+(?:\.[a-z0-9-]+)*$/i;
    // https://semver.org/#spec-item-9
    // > Numeric identifiers MUST NOT include leading zeroes.
    var numericIdentifierRegExp = /^(0|[1-9]\d*)$/;
    /**
     * Describes a precise semantic version number, https://semver.org
     */
    var Version = /** @class */ (function () {
        function Version(major, minor, patch, prerelease, build) {
            if (minor === void 0) { minor = 0; }
            if (patch === void 0) { patch = 0; }
            if (prerelease === void 0) { prerelease = ""; }
            if (build === void 0) { build = ""; }
            if (typeof major === "string") {
                var result = ts.Debug.checkDefined(tryParseComponents(major), "Invalid version");
                (major = result.major, minor = result.minor, patch = result.patch, prerelease = result.prerelease, build = result.build);
            }
            ts.Debug.assert(major >= 0, "Invalid argument: major");
            ts.Debug.assert(minor >= 0, "Invalid argument: minor");
            ts.Debug.assert(patch >= 0, "Invalid argument: patch");
            ts.Debug.assert(!prerelease || prereleaseRegExp.test(prerelease), "Invalid argument: prerelease");
            ts.Debug.assert(!build || buildRegExp.test(build), "Invalid argument: build");
            this.major = major;
            this.minor = minor;
            this.patch = patch;
            this.prerelease = prerelease ? prerelease.split(".") : ts.emptyArray;
            this.build = build ? build.split(".") : ts.emptyArray;
        }
        Version.tryParse = function (text) {
            var result = tryParseComponents(text);
            if (!result)
                return undefined;
            var major = result.major, minor = result.minor, patch = result.patch, prerelease = result.prerelease, build = result.build;
            return new Version(major, minor, patch, prerelease, build);
        };
        Version.prototype.compareTo = function (other) {
            // https://semver.org/#spec-item-11
            // > Precedence is determined by the first difference when comparing each of these
            // > identifiers from left to right as follows: Major, minor, and patch versions are
            // > always compared numerically.
            //
            // https://semver.org/#spec-item-11
            // > Precedence for two pre-release versions with the same major, minor, and patch version
            // > MUST be determined by comparing each dot separated identifier from left to right until
            // > a difference is found [...]
            //
            // https://semver.org/#spec-item-11
            // > Build metadata does not figure into precedence
            if (this === other)
                return 0 /* Comparison.EqualTo */;
            if (other === undefined)
                return 1 /* Comparison.GreaterThan */;
            return ts.compareValues(this.major, other.major)
                || ts.compareValues(this.minor, other.minor)
                || ts.compareValues(this.patch, other.patch)
                || comparePrereleaseIdentifiers(this.prerelease, other.prerelease);
        };
        Version.prototype.increment = function (field) {
            switch (field) {
                case "major": return new Version(this.major + 1, 0, 0);
                case "minor": return new Version(this.major, this.minor + 1, 0);
                case "patch": return new Version(this.major, this.minor, this.patch + 1);
                default: return ts.Debug.assertNever(field);
            }
        };
        Version.prototype.toString = function () {
            var result = "".concat(this.major, ".").concat(this.minor, ".").concat(this.patch);
            if (ts.some(this.prerelease))
                result += "-".concat(this.prerelease.join("."));
            if (ts.some(this.build))
                result += "+".concat(this.build.join("."));
            return result;
        };
        Version.zero = new Version(0, 0, 0);
        return Version;
    }());
    ts.Version = Version;
    function tryParseComponents(text) {
        var match = versionRegExp.exec(text);
        if (!match)
            return undefined;
        var major = match[1], _a = match[2], minor = _a === void 0 ? "0" : _a, _b = match[3], patch = _b === void 0 ? "0" : _b, _c = match[4], prerelease = _c === void 0 ? "" : _c, _d = match[5], build = _d === void 0 ? "" : _d;
        if (prerelease && !prereleaseRegExp.test(prerelease))
            return undefined;
        if (build && !buildRegExp.test(build))
            return undefined;
        return {
            major: parseInt(major, 10),
            minor: parseInt(minor, 10),
            patch: parseInt(patch, 10),
            prerelease: prerelease,
            build: build
        };
    }
    function comparePrereleaseIdentifiers(left, right) {
        // https://semver.org/#spec-item-11
        // > When major, minor, and patch are equal, a pre-release version has lower precedence
        // > than a normal version.
        if (left === right)
            return 0 /* Comparison.EqualTo */;
        if (left.length === 0)
            return right.length === 0 ? 0 /* Comparison.EqualTo */ : 1 /* Comparison.GreaterThan */;
        if (right.length === 0)
            return -1 /* Comparison.LessThan */;
        // https://semver.org/#spec-item-11
        // > Precedence for two pre-release versions with the same major, minor, and patch version
        // > MUST be determined by comparing each dot separated identifier from left to right until
        // > a difference is found [...]
        var length = Math.min(left.length, right.length);
        for (var i = 0; i < length; i++) {
            var leftIdentifier = left[i];
            var rightIdentifier = right[i];
            if (leftIdentifier === rightIdentifier)
                continue;
            var leftIsNumeric = numericIdentifierRegExp.test(leftIdentifier);
            var rightIsNumeric = numericIdentifierRegExp.test(rightIdentifier);
            if (leftIsNumeric || rightIsNumeric) {
                // https://semver.org/#spec-item-11
                // > Numeric identifiers always have lower precedence than non-numeric identifiers.
                if (leftIsNumeric !== rightIsNumeric)
                    return leftIsNumeric ? -1 /* Comparison.LessThan */ : 1 /* Comparison.GreaterThan */;
                // https://semver.org/#spec-item-11
                // > identifiers consisting of only digits are compared numerically
                var result = ts.compareValues(+leftIdentifier, +rightIdentifier);
                if (result)
                    return result;
            }
            else {
                // https://semver.org/#spec-item-11
                // > identifiers with letters or hyphens are compared lexically in ASCII sort order.
                var result = ts.compareStringsCaseSensitive(leftIdentifier, rightIdentifier);
                if (result)
                    return result;
            }
        }
        // https://semver.org/#spec-item-11
        // > A larger set of pre-release fields has a higher precedence than a smaller set, if all
        // > of the preceding identifiers are equal.
        return ts.compareValues(left.length, right.length);
    }
    /**
     * Describes a semantic version range, per https://github.com/npm/node-semver#ranges
     */
    var VersionRange = /** @class */ (function () {
        function VersionRange(spec) {
            this._alternatives = spec ? ts.Debug.checkDefined(parseRange(spec), "Invalid range spec.") : ts.emptyArray;
        }
        VersionRange.tryParse = function (text) {
            var sets = parseRange(text);
            if (sets) {
                var range = new VersionRange("");
                range._alternatives = sets;
                return range;
            }
            return undefined;
        };
        VersionRange.prototype.test = function (version) {
            if (typeof version === "string")
                version = new Version(version);
            return testDisjunction(version, this._alternatives);
        };
        VersionRange.prototype.toString = function () {
            return formatDisjunction(this._alternatives);
        };
        return VersionRange;
    }());
    ts.VersionRange = VersionRange;
    // https://github.com/npm/node-semver#range-grammar
    //
    // range-set    ::= range ( logical-or range ) *
    // range        ::= hyphen | simple ( ' ' simple ) * | ''
    // logical-or   ::= ( ' ' ) * '||' ( ' ' ) *
    var logicalOrRegExp = /\|\|/g;
    var whitespaceRegExp = /\s+/g;
    // https://github.com/npm/node-semver#range-grammar
    //
    // partial      ::= xr ( '.' xr ( '.' xr qualifier ? )? )?
    // xr           ::= 'x' | 'X' | '*' | nr
    // nr           ::= '0' | ['1'-'9'] ( ['0'-'9'] ) *
    // qualifier    ::= ( '-' pre )? ( '+' build )?
    // pre          ::= parts
    // build        ::= parts
    // parts        ::= part ( '.' part ) *
    // part         ::= nr | [-0-9A-Za-z]+
    var partialRegExp = /^([xX*0]|[1-9]\d*)(?:\.([xX*0]|[1-9]\d*)(?:\.([xX*0]|[1-9]\d*)(?:-([a-z0-9-.]+))?(?:\+([a-z0-9-.]+))?)?)?$/i;
    // https://github.com/npm/node-semver#range-grammar
    //
    // hyphen       ::= partial ' - ' partial
    var hyphenRegExp = /^\s*([a-z0-9-+.*]+)\s+-\s+([a-z0-9-+.*]+)\s*$/i;
    // https://github.com/npm/node-semver#range-grammar
    //
    // simple       ::= primitive | partial | tilde | caret
    // primitive    ::= ( '<' | '>' | '>=' | '<=' | '=' ) partial
    // tilde        ::= '~' partial
    // caret        ::= '^' partial
    var rangeRegExp = /^(~|\^|<|<=|>|>=|=)?\s*([a-z0-9-+.*]+)$/i;
    function parseRange(text) {
        var alternatives = [];
        for (var _i = 0, _a = ts.trimString(text).split(logicalOrRegExp); _i < _a.length; _i++) {
            var range = _a[_i];
            if (!range)
                continue;
            var comparators = [];
            range = ts.trimString(range);
            var match = hyphenRegExp.exec(range);
            if (match) {
                if (!parseHyphen(match[1], match[2], comparators))
                    return undefined;
            }
            else {
                for (var _b = 0, _c = range.split(whitespaceRegExp); _b < _c.length; _b++) {
                    var simple = _c[_b];
                    var match_1 = rangeRegExp.exec(ts.trimString(simple));
                    if (!match_1 || !parseComparator(match_1[1], match_1[2], comparators))
                        return undefined;
                }
            }
            alternatives.push(comparators);
        }
        return alternatives;
    }
    function parsePartial(text) {
        var match = partialRegExp.exec(text);
        if (!match)
            return undefined;
        var major = match[1], _a = match[2], minor = _a === void 0 ? "*" : _a, _b = match[3], patch = _b === void 0 ? "*" : _b, prerelease = match[4], build = match[5];
        var version = new Version(isWildcard(major) ? 0 : parseInt(major, 10), isWildcard(major) || isWildcard(minor) ? 0 : parseInt(minor, 10), isWildcard(major) || isWildcard(minor) || isWildcard(patch) ? 0 : parseInt(patch, 10), prerelease, build);
        return { version: version, major: major, minor: minor, patch: patch };
    }
    function parseHyphen(left, right, comparators) {
        var leftResult = parsePartial(left);
        if (!leftResult)
            return false;
        var rightResult = parsePartial(right);
        if (!rightResult)
            return false;
        if (!isWildcard(leftResult.major)) {
            comparators.push(createComparator(">=", leftResult.version));
        }
        if (!isWildcard(rightResult.major)) {
            comparators.push(isWildcard(rightResult.minor) ? createComparator("<", rightResult.version.increment("major")) :
                isWildcard(rightResult.patch) ? createComparator("<", rightResult.version.increment("minor")) :
                    createComparator("<=", rightResult.version));
        }
        return true;
    }
    function parseComparator(operator, text, comparators) {
        var result = parsePartial(text);
        if (!result)
            return false;
        var version = result.version, major = result.major, minor = result.minor, patch = result.patch;
        if (!isWildcard(major)) {
            switch (operator) {
                case "~":
                    comparators.push(createComparator(">=", version));
                    comparators.push(createComparator("<", version.increment(isWildcard(minor) ? "major" :
                        "minor")));
                    break;
                case "^":
                    comparators.push(createComparator(">=", version));
                    comparators.push(createComparator("<", version.increment(version.major > 0 || isWildcard(minor) ? "major" :
                        version.minor > 0 || isWildcard(patch) ? "minor" :
                            "patch")));
                    break;
                case "<":
                case ">=":
                    comparators.push(createComparator(operator, version));
                    break;
                case "<=":
                case ">":
                    comparators.push(isWildcard(minor) ? createComparator(operator === "<=" ? "<" : ">=", version.increment("major")) :
                        isWildcard(patch) ? createComparator(operator === "<=" ? "<" : ">=", version.increment("minor")) :
                            createComparator(operator, version));
                    break;
                case "=":
                case undefined:
                    if (isWildcard(minor) || isWildcard(patch)) {
                        comparators.push(createComparator(">=", version));
                        comparators.push(createComparator("<", version.increment(isWildcard(minor) ? "major" : "minor")));
                    }
                    else {
                        comparators.push(createComparator("=", version));
                    }
                    break;
                default:
                    // unrecognized
                    return false;
            }
        }
        else if (operator === "<" || operator === ">") {
            comparators.push(createComparator("<", Version.zero));
        }
        return true;
    }
    function isWildcard(part) {
        return part === "*" || part === "x" || part === "X";
    }
    function createComparator(operator, operand) {
        return { operator: operator, operand: operand };
    }
    function testDisjunction(version, alternatives) {
        // an empty disjunction is treated as "*" (all versions)
        if (alternatives.length === 0)
            return true;
        for (var _i = 0, alternatives_1 = alternatives; _i < alternatives_1.length; _i++) {
            var alternative = alternatives_1[_i];
            if (testAlternative(version, alternative))
                return true;
        }
        return false;
    }
    function testAlternative(version, comparators) {
        for (var _i = 0, comparators_1 = comparators; _i < comparators_1.length; _i++) {
            var comparator = comparators_1[_i];
            if (!testComparator(version, comparator.operator, comparator.operand))
                return false;
        }
        return true;
    }
    function testComparator(version, operator, operand) {
        var cmp = version.compareTo(operand);
        switch (operator) {
            case "<": return cmp < 0;
            case "<=": return cmp <= 0;
            case ">": return cmp > 0;
            case ">=": return cmp >= 0;
            case "=": return cmp === 0;
            default: return ts.Debug.assertNever(operator);
        }
    }
    function formatDisjunction(alternatives) {
        return ts.map(alternatives, formatAlternative).join(" || ") || "*";
    }
    function formatAlternative(comparators) {
        return ts.map(comparators, formatComparator).join(" ");
    }
    function formatComparator(comparator) {
        return "".concat(comparator.operator).concat(comparator.operand);
    }
})(ts || (ts = {}));
/*@internal*/
var ts;
(function (ts) {
    // The following definitions provide the minimum compatible support for the Web Performance User Timings API
    // between browsers and NodeJS:
    // eslint-disable-next-line @typescript-eslint/naming-convention
    function hasRequiredAPI(performance, PerformanceObserver) {
        return typeof performance === "object" &&
            typeof performance.timeOrigin === "number" &&
            typeof performance.mark === "function" &&
            typeof performance.measure === "function" &&
            typeof performance.now === "function" &&
            typeof PerformanceObserver === "function";
    }
    function tryGetWebPerformanceHooks() {
        if (typeof performance === "object" &&
            typeof PerformanceObserver === "function" &&
            hasRequiredAPI(performance, PerformanceObserver)) {
            return {
                // For now we always write native performance events when running in the browser. We may
                // make this conditional in the future if we find that native web performance hooks
                // in the browser also slow down compilation.
                shouldWriteNativeEvents: true,
                performance: performance,
                PerformanceObserver: PerformanceObserver
            };
        }
    }
    function tryGetNodePerformanceHooks() {
        if (typeof process !== "undefined" && process.nextTick && !process.browser && typeof module === "object" && typeof require === "function") {
            try {
                var performance_1;
                var _a = require("perf_hooks"), nodePerformance_1 = _a.performance, PerformanceObserver_1 = _a.PerformanceObserver;
                if (hasRequiredAPI(nodePerformance_1, PerformanceObserver_1)) {
                    performance_1 = nodePerformance_1;
                    // There is a bug in Node's performance.measure prior to 12.16.3/13.13.0 that does not
                    // match the Web Performance API specification. Node's implementation did not allow
                    // optional `start` and `end` arguments for `performance.measure`.
                    // See https://github.com/nodejs/node/pull/32651 for more information.
                    var version_1 = new ts.Version(process.versions.node);
                    var range = new ts.VersionRange("<12.16.3 || 13 <13.13");
                    if (range.test(version_1)) {
                        performance_1 = {
                            get timeOrigin() { return nodePerformance_1.timeOrigin; },
                            now: function () { return nodePerformance_1.now(); },
                            mark: function (name) { return nodePerformance_1.mark(name); },
                            measure: function (name, start, end) {
                                if (start === void 0) { start = "nodeStart"; }
                                if (end === undefined) {
                                    end = "__performance.measure-fix__";
                                    nodePerformance_1.mark(end);
                                }
                                nodePerformance_1.measure(name, start, end);
                                if (end === "__performance.measure-fix__") {
                                    nodePerformance_1.clearMarks("__performance.measure-fix__");
                                }
                            }
                        };
                    }
                    return {
                        // By default, only write native events when generating a cpu profile or using the v8 profiler.
                        shouldWriteNativeEvents: false,
                        performance: performance_1,
                        PerformanceObserver: PerformanceObserver_1
                    };
                }
            }
            catch (_b) {
                // ignore errors
            }
        }
    }
    // Unlike with the native Map/Set 'tryGet' functions in corePublic.ts, we eagerly evaluate these
    // since we will need them for `timestamp`, below.
    var nativePerformanceHooks = tryGetWebPerformanceHooks() || tryGetNodePerformanceHooks();
    var nativePerformance = nativePerformanceHooks === null || nativePerformanceHooks === void 0 ? void 0 : nativePerformanceHooks.performance;
    function tryGetNativePerformanceHooks() {
        return nativePerformanceHooks;
    }
    ts.tryGetNativePerformanceHooks = tryGetNativePerformanceHooks;
    /** Gets a timestamp with (at least) ms resolution */
    ts.timestamp = nativePerformance ? function () { return nativePerformance.now(); } :
        Date.now ? Date.now :
            function () { return +(new Date()); };
})(ts || (ts = {}));
/*@internal*/
/** Performance measurements for the compiler. */
var ts;
(function (ts) {
    var performance;
    (function (performance) {
        var perfHooks;
        // when set, indicates the implementation of `Performance` to use for user timing.
        // when unset, indicates user timing is unavailable or disabled.
        var performanceImpl;
        function createTimerIf(condition, measureName, startMarkName, endMarkName) {
            return condition ? createTimer(measureName, startMarkName, endMarkName) : performance.nullTimer;
        }
        performance.createTimerIf = createTimerIf;
        function createTimer(measureName, startMarkName, endMarkName) {
            var enterCount = 0;
            return {
                enter: enter,
                exit: exit
            };
            function enter() {
                if (++enterCount === 1) {
                    mark(startMarkName);
                }
            }
            function exit() {
                if (--enterCount === 0) {
                    mark(endMarkName);
                    measure(measureName, startMarkName, endMarkName);
                }
                else if (enterCount < 0) {
                    ts.Debug.fail("enter/exit count does not match.");
                }
            }
        }
        performance.createTimer = createTimer;
        performance.nullTimer = { enter: ts.noop, exit: ts.noop };
        var enabled = false;
        var timeorigin = ts.timestamp();
        var marks = new ts.Map();
        var counts = new ts.Map();
        var durations = new ts.Map();
        /**
         * Marks a performance event.
         *
         * @param markName The name of the mark.
         */
        function mark(markName) {
            var _a;
            if (enabled) {
                var count = (_a = counts.get(markName)) !== null && _a !== void 0 ? _a : 0;
                counts.set(markName, count + 1);
                marks.set(markName, ts.timestamp());
                performanceImpl === null || performanceImpl === void 0 ? void 0 : performanceImpl.mark(markName);
            }
        }
        performance.mark = mark;
        /**
         * Adds a performance measurement with the specified name.
         *
         * @param measureName The name of the performance measurement.
         * @param startMarkName The name of the starting mark. If not supplied, the point at which the
         *      profiler was enabled is used.
         * @param endMarkName The name of the ending mark. If not supplied, the current timestamp is
         *      used.
         */
        function measure(measureName, startMarkName, endMarkName) {
            var _a, _b;
            if (enabled) {
                var end = (_a = (endMarkName !== undefined ? marks.get(endMarkName) : undefined)) !== null && _a !== void 0 ? _a : ts.timestamp();
                var start = (_b = (startMarkName !== undefined ? marks.get(startMarkName) : undefined)) !== null && _b !== void 0 ? _b : timeorigin;
                var previousDuration = durations.get(measureName) || 0;
                durations.set(measureName, previousDuration + (end - start));
                performanceImpl === null || performanceImpl === void 0 ? void 0 : performanceImpl.measure(measureName, startMarkName, endMarkName);
            }
        }
        performance.measure = measure;
        /**
         * Gets the number of times a marker was encountered.
         *
         * @param markName The name of the mark.
         */
        function getCount(markName) {
            return counts.get(markName) || 0;
        }
        performance.getCount = getCount;
        /**
         * Gets the total duration of all measurements with the supplied name.
         *
         * @param measureName The name of the measure whose durations should be accumulated.
         */
        function getDuration(measureName) {
            return durations.get(measureName) || 0;
        }
        performance.getDuration = getDuration;
        /**
         * Iterate over each measure, performing some action
         *
         * @param cb The action to perform for each measure
         */
        function forEachMeasure(cb) {
            durations.forEach(function (duration, measureName) { return cb(measureName, duration); });
        }
        performance.forEachMeasure = forEachMeasure;
        /**
         * Indicates whether the performance API is enabled.
         */
        function isEnabled() {
            return enabled;
        }
        performance.isEnabled = isEnabled;
        /** Enables (and resets) performance measurements for the compiler. */
        function enable(system) {
            var _a;
            if (system === void 0) { system = ts.sys; }
            if (!enabled) {
                enabled = true;
                perfHooks || (perfHooks = ts.tryGetNativePerformanceHooks());
                if (perfHooks) {
                    timeorigin = perfHooks.performance.timeOrigin;
                    // NodeJS's Web Performance API is currently slower than expected, but we'd still like
                    // to be able to leverage native trace events when node is run with either `--cpu-prof`
                    // or `--prof`, if we're running with our own `--generateCpuProfile` flag, or when
                    // running in debug mode (since its possible to generate a cpu profile while debugging).
                    if (perfHooks.shouldWriteNativeEvents || ((_a = system === null || system === void 0 ? void 0 : system.cpuProfilingEnabled) === null || _a === void 0 ? void 0 : _a.call(system)) || (system === null || system === void 0 ? void 0 : system.debugMode)) {
                        performanceImpl = perfHooks.performance;
                    }
                }
            }
            return true;
        }
        performance.enable = enable;
        /** Disables performance measurements for the compiler. */
        function disable() {
            if (enabled) {
                marks.clear();
                counts.clear();
                durations.clear();
                performanceImpl = undefined;
                enabled = false;
            }
        }
        performance.disable = disable;
    })(performance = ts.performance || (ts.performance = {}));
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    var _a;
    var nullLogger = {
        logEvent: ts.noop,
        logErrEvent: ts.noop,
        logPerfEvent: ts.noop,
        logInfoEvent: ts.noop,
        logStartCommand: ts.noop,
        logStopCommand: ts.noop,
        logStartUpdateProgram: ts.noop,
        logStopUpdateProgram: ts.noop,
        logStartUpdateGraph: ts.noop,
        logStopUpdateGraph: ts.noop,
        logStartResolveModule: ts.noop,
        logStopResolveModule: ts.noop,
        logStartParseSourceFile: ts.noop,
        logStopParseSourceFile: ts.noop,
        logStartReadFile: ts.noop,
        logStopReadFile: ts.noop,
        logStartBindFile: ts.noop,
        logStopBindFile: ts.noop,
        logStartScheduledOperation: ts.noop,
        logStopScheduledOperation: ts.noop,
    };
    // Load optional module to enable Event Tracing for Windows
    // See https://github.com/microsoft/typescript-etw for more information
    var etwModule;
    try {
        var etwModulePath = (_a = process.env.TS_ETW_MODULE_PATH) !== null && _a !== void 0 ? _a : "./node_modules/@microsoft/typescript-etw";
        // require() will throw an exception if the module is not found
        // It may also return undefined if not installed properly
        etwModule = require(etwModulePath);
    }
    catch (e) {
        etwModule = undefined;
    }
    /** Performance logger that will generate ETW events if possible - check for `logEvent` member, as `etwModule` will be `{}` when browserified */
    ts.perfLogger = etwModule && etwModule.logEvent ? etwModule : nullLogger;
})(ts || (ts = {}));
/* Tracing events for the compiler. */
/*@internal*/
var ts;
(function (ts) {
    // enable the above using startTracing()
    // `tracingEnabled` should never be used directly, only through the above
    var tracingEnabled;
    (function (tracingEnabled) {
        var fs;
        var traceCount = 0;
        var traceFd = 0;
        var mode;
        var typeCatalog = []; // NB: id is index + 1
        var legendPath;
        var legend = [];
        ;
        /** Starts tracing for the given project. */
        function startTracing(tracingMode, traceDir, configFilePath) {
            ts.Debug.assert(!ts.tracing, "Tracing already started");
            if (fs === undefined) {
                try {
                    fs = require("fs");
                }
                catch (e) {
                    throw new Error("tracing requires having fs\n(original error: ".concat(e.message || e, ")"));
                }
            }
            mode = tracingMode;
            typeCatalog.length = 0;
            if (legendPath === undefined) {
                legendPath = ts.combinePaths(traceDir, "legend.json");
            }
            // Note that writing will fail later on if it exists and is not a directory
            if (!fs.existsSync(traceDir)) {
                fs.mkdirSync(traceDir, { recursive: true });
            }
            var countPart = mode === "build" ? ".".concat(process.pid, "-").concat(++traceCount)
                : mode === "server" ? ".".concat(process.pid)
                    : "";
            var tracePath = ts.combinePaths(traceDir, "trace".concat(countPart, ".json"));
            var typesPath = ts.combinePaths(traceDir, "types".concat(countPart, ".json"));
            legend.push({
                configFilePath: configFilePath,
                tracePath: tracePath,
                typesPath: typesPath,
            });
            traceFd = fs.openSync(tracePath, "w");
            ts.tracing = tracingEnabled; // only when traceFd is properly set
            // Start with a prefix that contains some metadata that the devtools profiler expects (also avoids a warning on import)
            var meta = { cat: "__metadata", ph: "M", ts: 1000 * ts.timestamp(), pid: 1, tid: 1 };
            fs.writeSync(traceFd, "[\n"
                + [__assign({ name: "process_name", args: { name: "tsc" } }, meta), __assign({ name: "thread_name", args: { name: "Main" } }, meta), __assign(__assign({ name: "TracingStartedInBrowser" }, meta), { cat: "disabled-by-default-devtools.timeline" })]
                    .map(function (v) { return JSON.stringify(v); }).join(",\n"));
        }
        tracingEnabled.startTracing = startTracing;
        /** Stops tracing for the in-progress project and dumps the type catalog. */
        function stopTracing() {
            ts.Debug.assert(ts.tracing, "Tracing is not in progress");
            ts.Debug.assert(!!typeCatalog.length === (mode !== "server")); // Have a type catalog iff not in server mode
            fs.writeSync(traceFd, "\n]\n");
            fs.closeSync(traceFd);
            ts.tracing = undefined;
            if (typeCatalog.length) {
                dumpTypes(typeCatalog);
            }
            else {
                // We pre-computed this path for convenience, but clear it
                // now that the file won't be created.
                legend[legend.length - 1].typesPath = undefined;
            }
        }
        tracingEnabled.stopTracing = stopTracing;
        function recordType(type) {
            if (mode !== "server") {
                typeCatalog.push(type);
            }
        }
        tracingEnabled.recordType = recordType;
        var Phase;
        (function (Phase) {
            Phase["Parse"] = "parse";
            Phase["Program"] = "program";
            Phase["Bind"] = "bind";
            Phase["Check"] = "check";
            Phase["CheckTypes"] = "checkTypes";
            Phase["Emit"] = "emit";
            Phase["Session"] = "session";
        })(Phase = tracingEnabled.Phase || (tracingEnabled.Phase = {}));
        function instant(phase, name, args) {
            writeEvent("I", phase, name, args, "\"s\":\"g\"");
        }
        tracingEnabled.instant = instant;
        var eventStack = [];
        /**
         * @param separateBeginAndEnd - used for special cases where we need the trace point even if the event
         * never terminates (typically for reducing a scenario too big to trace to one that can be completed).
         * In the future we might implement an exit handler to dump unfinished events which would deprecate
         * these operations.
         */
        function push(phase, name, args, separateBeginAndEnd) {
            if (separateBeginAndEnd === void 0) { separateBeginAndEnd = false; }
            if (separateBeginAndEnd) {
                writeEvent("B", phase, name, args);
            }
            eventStack.push({ phase: phase, name: name, args: args, time: 1000 * ts.timestamp(), separateBeginAndEnd: separateBeginAndEnd });
        }
        tracingEnabled.push = push;
        function pop(results) {
            ts.Debug.assert(eventStack.length > 0);
            writeStackEvent(eventStack.length - 1, 1000 * ts.timestamp(), results);
            eventStack.length--;
        }
        tracingEnabled.pop = pop;
        function popAll() {
            var endTime = 1000 * ts.timestamp();
            for (var i = eventStack.length - 1; i >= 0; i--) {
                writeStackEvent(i, endTime);
            }
            eventStack.length = 0;
        }
        tracingEnabled.popAll = popAll;
        // sample every 10ms
        var sampleInterval = 1000 * 10;
        function writeStackEvent(index, endTime, results) {
            var _a = eventStack[index], phase = _a.phase, name = _a.name, args = _a.args, time = _a.time, separateBeginAndEnd = _a.separateBeginAndEnd;
            if (separateBeginAndEnd) {
                ts.Debug.assert(!results, "`results` are not supported for events with `separateBeginAndEnd`");
                writeEvent("E", phase, name, args, /*extras*/ undefined, endTime);
            }
            // test if [time,endTime) straddles a sampling point
            else if (sampleInterval - (time % sampleInterval) <= endTime - time) {
                writeEvent("X", phase, name, __assign(__assign({}, args), { results: results }), "\"dur\":".concat(endTime - time), time);
            }
        }
        function writeEvent(eventType, phase, name, args, extras, time) {
            if (time === void 0) { time = 1000 * ts.timestamp(); }
            // In server mode, there's no easy way to dump type information, so we drop events that would require it.
            if (mode === "server" && phase === "checkTypes" /* Phase.CheckTypes */)
                return;
            ts.performance.mark("beginTracing");
            fs.writeSync(traceFd, ",\n{\"pid\":1,\"tid\":1,\"ph\":\"".concat(eventType, "\",\"cat\":\"").concat(phase, "\",\"ts\":").concat(time, ",\"name\":\"").concat(name, "\""));
            if (extras)
                fs.writeSync(traceFd, ",".concat(extras));
            if (args)
                fs.writeSync(traceFd, ",\"args\":".concat(JSON.stringify(args)));
            fs.writeSync(traceFd, "}");
            ts.performance.mark("endTracing");
            ts.performance.measure("Tracing", "beginTracing", "endTracing");
        }
        function getLocation(node) {
            var file = ts.getSourceFileOfNode(node);
            return !file
                ? undefined
                : {
                    path: file.path,
                    start: indexFromOne(ts.getLineAndCharacterOfPosition(file, node.pos)),
                    end: indexFromOne(ts.getLineAndCharacterOfPosition(file, node.end)),
                };
            function indexFromOne(lc) {
                return {
                    line: lc.line + 1,
                    character: lc.character + 1,
                };
            }
        }
        function dumpTypes(types) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
            ts.performance.mark("beginDumpTypes");
            var typesPath = legend[legend.length - 1].typesPath;
            var typesFd = fs.openSync(typesPath, "w");
            var recursionIdentityMap = new ts.Map();
            // Cleverness: no line break here so that the type ID will match the line number
            fs.writeSync(typesFd, "[");
            var numTypes = types.length;
            for (var i = 0; i < numTypes; i++) {
                var type = types[i];
                var objectFlags = type.objectFlags;
                var symbol = (_a = type.aliasSymbol) !== null && _a !== void 0 ? _a : type.symbol;
                // It's slow to compute the display text, so skip it unless it's really valuable (or cheap)
                var display = void 0;
                if ((objectFlags & 16 /* ObjectFlags.Anonymous */) | (type.flags & 2944 /* TypeFlags.Literal */)) {
                    try {
                        display = (_b = type.checker) === null || _b === void 0 ? void 0 : _b.typeToString(type);
                    }
                    catch (_y) {
                        display = undefined;
                    }
                }
                var indexedAccessProperties = {};
                if (type.flags & 8388608 /* TypeFlags.IndexedAccess */) {
                    var indexedAccessType = type;
                    indexedAccessProperties = {
                        indexedAccessObjectType: (_c = indexedAccessType.objectType) === null || _c === void 0 ? void 0 : _c.id,
                        indexedAccessIndexType: (_d = indexedAccessType.indexType) === null || _d === void 0 ? void 0 : _d.id,
                    };
                }
                var referenceProperties = {};
                if (objectFlags & 4 /* ObjectFlags.Reference */) {
                    var referenceType = type;
                    referenceProperties = {
                        instantiatedType: (_e = referenceType.target) === null || _e === void 0 ? void 0 : _e.id,
                        typeArguments: (_f = referenceType.resolvedTypeArguments) === null || _f === void 0 ? void 0 : _f.map(function (t) { return t.id; }),
                        referenceLocation: getLocation(referenceType.node),
                    };
                }
                var conditionalProperties = {};
                if (type.flags & 16777216 /* TypeFlags.Conditional */) {
                    var conditionalType = type;
                    conditionalProperties = {
                        conditionalCheckType: (_g = conditionalType.checkType) === null || _g === void 0 ? void 0 : _g.id,
                        conditionalExtendsType: (_h = conditionalType.extendsType) === null || _h === void 0 ? void 0 : _h.id,
                        conditionalTrueType: (_k = (_j = conditionalType.resolvedTrueType) === null || _j === void 0 ? void 0 : _j.id) !== null && _k !== void 0 ? _k : -1,
                        conditionalFalseType: (_m = (_l = conditionalType.resolvedFalseType) === null || _l === void 0 ? void 0 : _l.id) !== null && _m !== void 0 ? _m : -1,
                    };
                }
                var substitutionProperties = {};
                if (type.flags & 33554432 /* TypeFlags.Substitution */) {
                    var substitutionType = type;
                    substitutionProperties = {
                        substitutionBaseType: (_o = substitutionType.baseType) === null || _o === void 0 ? void 0 : _o.id,
                        substituteType: (_p = substitutionType.substitute) === null || _p === void 0 ? void 0 : _p.id,
                    };
                }
                var reverseMappedProperties = {};
                if (objectFlags & 1024 /* ObjectFlags.ReverseMapped */) {
                    var reverseMappedType = type;
                    reverseMappedProperties = {
                        reverseMappedSourceType: (_q = reverseMappedType.source) === null || _q === void 0 ? void 0 : _q.id,
                        reverseMappedMappedType: (_r = reverseMappedType.mappedType) === null || _r === void 0 ? void 0 : _r.id,
                        reverseMappedConstraintType: (_s = reverseMappedType.constraintType) === null || _s === void 0 ? void 0 : _s.id,
                    };
                }
                var evolvingArrayProperties = {};
                if (objectFlags & 256 /* ObjectFlags.EvolvingArray */) {
                    var evolvingArrayType = type;
                    evolvingArrayProperties = {
                        evolvingArrayElementType: evolvingArrayType.elementType.id,
                        evolvingArrayFinalType: (_t = evolvingArrayType.finalArrayType) === null || _t === void 0 ? void 0 : _t.id,
                    };
                }
                // We can't print out an arbitrary object, so just assign each one a unique number.
                // Don't call it an "id" so people don't treat it as a type id.
                var recursionToken = void 0;
                var recursionIdentity = type.checker.getRecursionIdentity(type);
                if (recursionIdentity) {
                    recursionToken = recursionIdentityMap.get(recursionIdentity);
                    if (!recursionToken) {
                        recursionToken = recursionIdentityMap.size;
                        recursionIdentityMap.set(recursionIdentity, recursionToken);
                    }
                }
                var descriptor = __assign(__assign(__assign(__assign(__assign(__assign(__assign({ id: type.id, intrinsicName: type.intrinsicName, symbolName: (symbol === null || symbol === void 0 ? void 0 : symbol.escapedName) && ts.unescapeLeadingUnderscores(symbol.escapedName), recursionId: recursionToken, isTuple: objectFlags & 8 /* ObjectFlags.Tuple */ ? true : undefined, unionTypes: (type.flags & 1048576 /* TypeFlags.Union */) ? (_u = type.types) === null || _u === void 0 ? void 0 : _u.map(function (t) { return t.id; }) : undefined, intersectionTypes: (type.flags & 2097152 /* TypeFlags.Intersection */) ? type.types.map(function (t) { return t.id; }) : undefined, aliasTypeArguments: (_v = type.aliasTypeArguments) === null || _v === void 0 ? void 0 : _v.map(function (t) { return t.id; }), keyofType: (type.flags & 4194304 /* TypeFlags.Index */) ? (_w = type.type) === null || _w === void 0 ? void 0 : _w.id : undefined }, indexedAccessProperties), referenceProperties), conditionalProperties), substitutionProperties), reverseMappedProperties), evolvingArrayProperties), { destructuringPattern: getLocation(type.pattern), firstDeclaration: getLocation((_x = symbol === null || symbol === void 0 ? void 0 : symbol.declarations) === null || _x === void 0 ? void 0 : _x[0]), flags: ts.Debug.formatTypeFlags(type.flags).split("|"), display: display });
                fs.writeSync(typesFd, JSON.stringify(descriptor));
                if (i < numTypes - 1) {
                    fs.writeSync(typesFd, ",\n");
                }
            }
            fs.writeSync(typesFd, "]\n");
            fs.closeSync(typesFd);
            ts.performance.mark("endDumpTypes");
            ts.performance.measure("Dump types", "beginDumpTypes", "endDumpTypes");
        }
        function dumpLegend() {
            if (!legendPath) {
                return;
            }
            fs.writeFileSync(legendPath, JSON.stringify(legend));
        }
        tracingEnabled.dumpLegend = dumpLegend;
    })(tracingEnabled || (tracingEnabled = {}));
    // define after tracingEnabled is initialized
    ts.startTracing = tracingEnabled.startTracing;
    ts.dumpTracingLegend = tracingEnabled.dumpLegend;
})(ts || (ts = {}));
var ts;
(function (ts) {
    // token > SyntaxKind.Identifier => token is a keyword
    // Also, If you add a new SyntaxKind be sure to keep the `Markers` section at the bottom in sync
    var SyntaxKind;
    (function (SyntaxKind) {
        SyntaxKind[SyntaxKind["Unknown"] = 0] = "Unknown";
        SyntaxKind[SyntaxKind["EndOfFileToken"] = 1] = "EndOfFileToken";
        SyntaxKind[SyntaxKind["SingleLineCommentTrivia"] = 2] = "SingleLineCommentTrivia";
        SyntaxKind[SyntaxKind["MultiLineCommentTrivia"] = 3] = "MultiLineCommentTrivia";
        SyntaxKind[SyntaxKind["NewLineTrivia"] = 4] = "NewLineTrivia";
        SyntaxKind[SyntaxKind["WhitespaceTrivia"] = 5] = "WhitespaceTrivia";
        // We detect and preserve #! on the first line
        SyntaxKind[SyntaxKind["ShebangTrivia"] = 6] = "ShebangTrivia";
        // We detect and provide better error recovery when we encounter a git merge marker.  This
        // allows us to edit files with git-conflict markers in them in a much more pleasant manner.
        SyntaxKind[SyntaxKind["ConflictMarkerTrivia"] = 7] = "ConflictMarkerTrivia";
        // Literals
        SyntaxKind[SyntaxKind["NumericLiteral"] = 8] = "NumericLiteral";
        SyntaxKind[SyntaxKind["BigIntLiteral"] = 9] = "BigIntLiteral";
        SyntaxKind[SyntaxKind["StringLiteral"] = 10] = "StringLiteral";
        SyntaxKind[SyntaxKind["JsxText"] = 11] = "JsxText";
        SyntaxKind[SyntaxKind["JsxTextAllWhiteSpaces"] = 12] = "JsxTextAllWhiteSpaces";
        SyntaxKind[SyntaxKind["RegularExpressionLiteral"] = 13] = "RegularExpressionLiteral";
        SyntaxKind[SyntaxKind["NoSubstitutionTemplateLiteral"] = 14] = "NoSubstitutionTemplateLiteral";
        // Pseudo-literals
        SyntaxKind[SyntaxKind["TemplateHead"] = 15] = "TemplateHead";
        SyntaxKind[SyntaxKind["TemplateMiddle"] = 16] = "TemplateMiddle";
        SyntaxKind[SyntaxKind["TemplateTail"] = 17] = "TemplateTail";
        // Punctuation
        SyntaxKind[SyntaxKind["OpenBraceToken"] = 18] = "OpenBraceToken";
        SyntaxKind[SyntaxKind["CloseBraceToken"] = 19] = "CloseBraceToken";
        SyntaxKind[SyntaxKind["OpenParenToken"] = 20] = "OpenParenToken";
        SyntaxKind[SyntaxKind["CloseParenToken"] = 21] = "CloseParenToken";
        SyntaxKind[SyntaxKind["OpenBracketToken"] = 22] = "OpenBracketToken";
        SyntaxKind[SyntaxKind["CloseBracketToken"] = 23] = "CloseBracketToken";
        SyntaxKind[SyntaxKind["DotToken"] = 24] = "DotToken";
        SyntaxKind[SyntaxKind["DotDotDotToken"] = 25] = "DotDotDotToken";
        SyntaxKind[SyntaxKind["SemicolonToken"] = 26] = "SemicolonToken";
        SyntaxKind[SyntaxKind["CommaToken"] = 27] = "CommaToken";
        SyntaxKind[SyntaxKind["QuestionDotToken"] = 28] = "QuestionDotToken";
        SyntaxKind[SyntaxKind["LessThanToken"] = 29] = "LessThanToken";
        SyntaxKind[SyntaxKind["LessThanSlashToken"] = 30] = "LessThanSlashToken";
        SyntaxKind[SyntaxKind["GreaterThanToken"] = 31] = "GreaterThanToken";
        SyntaxKind[SyntaxKind["LessThanEqualsToken"] = 32] = "LessThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanEqualsToken"] = 33] = "GreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["EqualsEqualsToken"] = 34] = "EqualsEqualsToken";
        SyntaxKind[SyntaxKind["ExclamationEqualsToken"] = 35] = "ExclamationEqualsToken";
        SyntaxKind[SyntaxKind["EqualsEqualsEqualsToken"] = 36] = "EqualsEqualsEqualsToken";
        SyntaxKind[SyntaxKind["ExclamationEqualsEqualsToken"] = 37] = "ExclamationEqualsEqualsToken";
        SyntaxKind[SyntaxKind["EqualsGreaterThanToken"] = 38] = "EqualsGreaterThanToken";
        SyntaxKind[SyntaxKind["PlusToken"] = 39] = "PlusToken";
        SyntaxKind[SyntaxKind["MinusToken"] = 40] = "MinusToken";
        SyntaxKind[SyntaxKind["AsteriskToken"] = 41] = "AsteriskToken";
        SyntaxKind[SyntaxKind["AsteriskAsteriskToken"] = 42] = "AsteriskAsteriskToken";
        SyntaxKind[SyntaxKind["SlashToken"] = 43] = "SlashToken";
        SyntaxKind[SyntaxKind["PercentToken"] = 44] = "PercentToken";
        SyntaxKind[SyntaxKind["PlusPlusToken"] = 45] = "PlusPlusToken";
        SyntaxKind[SyntaxKind["MinusMinusToken"] = 46] = "MinusMinusToken";
        SyntaxKind[SyntaxKind["LessThanLessThanToken"] = 47] = "LessThanLessThanToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanToken"] = 48] = "GreaterThanGreaterThanToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanGreaterThanToken"] = 49] = "GreaterThanGreaterThanGreaterThanToken";
        SyntaxKind[SyntaxKind["AmpersandToken"] = 50] = "AmpersandToken";
        SyntaxKind[SyntaxKind["BarToken"] = 51] = "BarToken";
        SyntaxKind[SyntaxKind["CaretToken"] = 52] = "CaretToken";
        SyntaxKind[SyntaxKind["ExclamationToken"] = 53] = "ExclamationToken";
        SyntaxKind[SyntaxKind["TildeToken"] = 54] = "TildeToken";
        SyntaxKind[SyntaxKind["AmpersandAmpersandToken"] = 55] = "AmpersandAmpersandToken";
        SyntaxKind[SyntaxKind["BarBarToken"] = 56] = "BarBarToken";
        SyntaxKind[SyntaxKind["QuestionToken"] = 57] = "QuestionToken";
        SyntaxKind[SyntaxKind["ColonToken"] = 58] = "ColonToken";
        SyntaxKind[SyntaxKind["AtToken"] = 59] = "AtToken";
        SyntaxKind[SyntaxKind["QuestionQuestionToken"] = 60] = "QuestionQuestionToken";
        /** Only the JSDoc scanner produces BacktickToken. The normal scanner produces NoSubstitutionTemplateLiteral and related kinds. */
        SyntaxKind[SyntaxKind["BacktickToken"] = 61] = "BacktickToken";
        /** Only the JSDoc scanner produces HashToken. The normal scanner produces PrivateIdentifier. */
        SyntaxKind[SyntaxKind["HashToken"] = 62] = "HashToken";
        // Assignments
        SyntaxKind[SyntaxKind["EqualsToken"] = 63] = "EqualsToken";
        SyntaxKind[SyntaxKind["PlusEqualsToken"] = 64] = "PlusEqualsToken";
        SyntaxKind[SyntaxKind["MinusEqualsToken"] = 65] = "MinusEqualsToken";
        SyntaxKind[SyntaxKind["AsteriskEqualsToken"] = 66] = "AsteriskEqualsToken";
        SyntaxKind[SyntaxKind["AsteriskAsteriskEqualsToken"] = 67] = "AsteriskAsteriskEqualsToken";
        SyntaxKind[SyntaxKind["SlashEqualsToken"] = 68] = "SlashEqualsToken";
        SyntaxKind[SyntaxKind["PercentEqualsToken"] = 69] = "PercentEqualsToken";
        SyntaxKind[SyntaxKind["LessThanLessThanEqualsToken"] = 70] = "LessThanLessThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanEqualsToken"] = 71] = "GreaterThanGreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanGreaterThanEqualsToken"] = 72] = "GreaterThanGreaterThanGreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["AmpersandEqualsToken"] = 73] = "AmpersandEqualsToken";
        SyntaxKind[SyntaxKind["BarEqualsToken"] = 74] = "BarEqualsToken";
        SyntaxKind[SyntaxKind["BarBarEqualsToken"] = 75] = "BarBarEqualsToken";
        SyntaxKind[SyntaxKind["AmpersandAmpersandEqualsToken"] = 76] = "AmpersandAmpersandEqualsToken";
        SyntaxKind[SyntaxKind["QuestionQuestionEqualsToken"] = 77] = "QuestionQuestionEqualsToken";
        SyntaxKind[SyntaxKind["CaretEqualsToken"] = 78] = "CaretEqualsToken";
        // Identifiers and PrivateIdentifiers
        SyntaxKind[SyntaxKind["Identifier"] = 79] = "Identifier";
        SyntaxKind[SyntaxKind["PrivateIdentifier"] = 80] = "PrivateIdentifier";
        // Reserved words
        SyntaxKind[SyntaxKind["BreakKeyword"] = 81] = "BreakKeyword";
        SyntaxKind[SyntaxKind["CaseKeyword"] = 82] = "CaseKeyword";
        SyntaxKind[SyntaxKind["CatchKeyword"] = 83] = "CatchKeyword";
        SyntaxKind[SyntaxKind["ClassKeyword"] = 84] = "ClassKeyword";
        SyntaxKind[SyntaxKind["ConstKeyword"] = 85] = "ConstKeyword";
        SyntaxKind[SyntaxKind["ContinueKeyword"] = 86] = "ContinueKeyword";
        SyntaxKind[SyntaxKind["DebuggerKeyword"] = 87] = "DebuggerKeyword";
        SyntaxKind[SyntaxKind["DefaultKeyword"] = 88] = "DefaultKeyword";
        SyntaxKind[SyntaxKind["DeleteKeyword"] = 89] = "DeleteKeyword";
        SyntaxKind[SyntaxKind["DoKeyword"] = 90] = "DoKeyword";
        SyntaxKind[SyntaxKind["ElseKeyword"] = 91] = "ElseKeyword";
        SyntaxKind[SyntaxKind["EnumKeyword"] = 92] = "EnumKeyword";
        SyntaxKind[SyntaxKind["ExportKeyword"] = 93] = "ExportKeyword";
        SyntaxKind[SyntaxKind["ExtendsKeyword"] = 94] = "ExtendsKeyword";
        SyntaxKind[SyntaxKind["FalseKeyword"] = 95] = "FalseKeyword";
        SyntaxKind[SyntaxKind["FinallyKeyword"] = 96] = "FinallyKeyword";
        SyntaxKind[SyntaxKind["ForKeyword"] = 97] = "ForKeyword";
        SyntaxKind[SyntaxKind["FunctionKeyword"] = 98] = "FunctionKeyword";
        SyntaxKind[SyntaxKind["IfKeyword"] = 99] = "IfKeyword";
        SyntaxKind[SyntaxKind["ImportKeyword"] = 100] = "ImportKeyword";
        SyntaxKind[SyntaxKind["InKeyword"] = 101] = "InKeyword";
        SyntaxKind[SyntaxKind["InstanceOfKeyword"] = 102] = "InstanceOfKeyword";
        SyntaxKind[SyntaxKind["NewKeyword"] = 103] = "NewKeyword";
        SyntaxKind[SyntaxKind["NullKeyword"] = 104] = "NullKeyword";
        SyntaxKind[SyntaxKind["ReturnKeyword"] = 105] = "ReturnKeyword";
        SyntaxKind[SyntaxKind["SuperKeyword"] = 106] = "SuperKeyword";
        SyntaxKind[SyntaxKind["SwitchKeyword"] = 107] = "SwitchKeyword";
        SyntaxKind[SyntaxKind["ThisKeyword"] = 108] = "ThisKeyword";
        SyntaxKind[SyntaxKind["ThrowKeyword"] = 109] = "ThrowKeyword";
        SyntaxKind[SyntaxKind["TrueKeyword"] = 110] = "TrueKeyword";
        SyntaxKind[SyntaxKind["TryKeyword"] = 111] = "TryKeyword";
        SyntaxKind[SyntaxKind["TypeOfKeyword"] = 112] = "TypeOfKeyword";
        SyntaxKind[SyntaxKind["VarKeyword"] = 113] = "VarKeyword";
        SyntaxKind[SyntaxKind["VoidKeyword"] = 114] = "VoidKeyword";
        SyntaxKind[SyntaxKind["WhileKeyword"] = 115] = "WhileKeyword";
        SyntaxKind[SyntaxKind["WithKeyword"] = 116] = "WithKeyword";
        // Strict mode reserved words
        SyntaxKind[SyntaxKind["ImplementsKeyword"] = 117] = "ImplementsKeyword";
        SyntaxKind[SyntaxKind["InterfaceKeyword"] = 118] = "InterfaceKeyword";
        SyntaxKind[SyntaxKind["LetKeyword"] = 119] = "LetKeyword";
        SyntaxKind[SyntaxKind["PackageKeyword"] = 120] = "PackageKeyword";
        SyntaxKind[SyntaxKind["PrivateKeyword"] = 121] = "PrivateKeyword";
        SyntaxKind[SyntaxKind["ProtectedKeyword"] = 122] = "ProtectedKeyword";
        SyntaxKind[SyntaxKind["PublicKeyword"] = 123] = "PublicKeyword";
        SyntaxKind[SyntaxKind["StaticKeyword"] = 124] = "StaticKeyword";
        SyntaxKind[SyntaxKind["YieldKeyword"] = 125] = "YieldKeyword";
        // Contextual keywords
        SyntaxKind[SyntaxKind["AbstractKeyword"] = 126] = "AbstractKeyword";
        SyntaxKind[SyntaxKind["AsKeyword"] = 127] = "AsKeyword";
        SyntaxKind[SyntaxKind["AssertsKeyword"] = 128] = "AssertsKeyword";
        SyntaxKind[SyntaxKind["AssertKeyword"] = 129] = "AssertKeyword";
        SyntaxKind[SyntaxKind["AnyKeyword"] = 130] = "AnyKeyword";
        SyntaxKind[SyntaxKind["AsyncKeyword"] = 131] = "AsyncKeyword";
        SyntaxKind[SyntaxKind["AwaitKeyword"] = 132] = "AwaitKeyword";
        SyntaxKind[SyntaxKind["BooleanKeyword"] = 133] = "BooleanKeyword";
        SyntaxKind[SyntaxKind["ConstructorKeyword"] = 134] = "ConstructorKeyword";
        SyntaxKind[SyntaxKind["DeclareKeyword"] = 135] = "DeclareKeyword";
        SyntaxKind[SyntaxKind["GetKeyword"] = 136] = "GetKeyword";
        SyntaxKind[SyntaxKind["InferKeyword"] = 137] = "InferKeyword";
        SyntaxKind[SyntaxKind["IntrinsicKeyword"] = 138] = "IntrinsicKeyword";
        SyntaxKind[SyntaxKind["IsKeyword"] = 139] = "IsKeyword";
        SyntaxKind[SyntaxKind["KeyOfKeyword"] = 140] = "KeyOfKeyword";
        SyntaxKind[SyntaxKind["ModuleKeyword"] = 141] = "ModuleKeyword";
        SyntaxKind[SyntaxKind["NamespaceKeyword"] = 142] = "NamespaceKeyword";
        SyntaxKind[SyntaxKind["NeverKeyword"] = 143] = "NeverKeyword";
        SyntaxKind[SyntaxKind["OutKeyword"] = 144] = "OutKeyword";
        SyntaxKind[SyntaxKind["ReadonlyKeyword"] = 145] = "ReadonlyKeyword";
        SyntaxKind[SyntaxKind["RequireKeyword"] = 146] = "RequireKeyword";
        SyntaxKind[SyntaxKind["NumberKeyword"] = 147] = "NumberKeyword";
        SyntaxKind[SyntaxKind["ObjectKeyword"] = 148] = "ObjectKeyword";
        SyntaxKind[SyntaxKind["SetKeyword"] = 149] = "SetKeyword";
        SyntaxKind[SyntaxKind["StringKeyword"] = 150] = "StringKeyword";
        SyntaxKind[SyntaxKind["SymbolKeyword"] = 151] = "SymbolKeyword";
        SyntaxKind[SyntaxKind["TypeKeyword"] = 152] = "TypeKeyword";
        SyntaxKind[SyntaxKind["UndefinedKeyword"] = 153] = "UndefinedKeyword";
        SyntaxKind[SyntaxKind["UniqueKeyword"] = 154] = "UniqueKeyword";
        SyntaxKind[SyntaxKind["UnknownKeyword"] = 155] = "UnknownKeyword";
        SyntaxKind[SyntaxKind["FromKeyword"] = 156] = "FromKeyword";
        SyntaxKind[SyntaxKind["GlobalKeyword"] = 157] = "GlobalKeyword";
        SyntaxKind[SyntaxKind["BigIntKeyword"] = 158] = "BigIntKeyword";
        SyntaxKind[SyntaxKind["OverrideKeyword"] = 159] = "OverrideKeyword";
        SyntaxKind[SyntaxKind["OfKeyword"] = 160] = "OfKeyword";
        // Parse tree nodes
        // Names
        SyntaxKind[SyntaxKind["QualifiedName"] = 161] = "QualifiedName";
        SyntaxKind[SyntaxKind["ComputedPropertyName"] = 162] = "ComputedPropertyName";
        // Signature elements
        SyntaxKind[SyntaxKind["TypeParameter"] = 163] = "TypeParameter";
        SyntaxKind[SyntaxKind["Parameter"] = 164] = "Parameter";
        SyntaxKind[SyntaxKind["Decorator"] = 165] = "Decorator";
        // TypeMember
        SyntaxKind[SyntaxKind["PropertySignature"] = 166] = "PropertySignature";
        SyntaxKind[SyntaxKind["PropertyDeclaration"] = 167] = "PropertyDeclaration";
        SyntaxKind[SyntaxKind["MethodSignature"] = 168] = "MethodSignature";
        SyntaxKind[SyntaxKind["MethodDeclaration"] = 169] = "MethodDeclaration";
        SyntaxKind[SyntaxKind["ClassStaticBlockDeclaration"] = 170] = "ClassStaticBlockDeclaration";
        SyntaxKind[SyntaxKind["Constructor"] = 171] = "Constructor";
        SyntaxKind[SyntaxKind["GetAccessor"] = 172] = "GetAccessor";
        SyntaxKind[SyntaxKind["SetAccessor"] = 173] = "SetAccessor";
        SyntaxKind[SyntaxKind["CallSignature"] = 174] = "CallSignature";
        SyntaxKind[SyntaxKind["ConstructSignature"] = 175] = "ConstructSignature";
        SyntaxKind[SyntaxKind["IndexSignature"] = 176] = "IndexSignature";
        // Type
        SyntaxKind[SyntaxKind["TypePredicate"] = 177] = "TypePredicate";
        SyntaxKind[SyntaxKind["TypeReference"] = 178] = "TypeReference";
        SyntaxKind[SyntaxKind["FunctionType"] = 179] = "FunctionType";
        SyntaxKind[SyntaxKind["ConstructorType"] = 180] = "ConstructorType";
        SyntaxKind[SyntaxKind["TypeQuery"] = 181] = "TypeQuery";
        SyntaxKind[SyntaxKind["TypeLiteral"] = 182] = "TypeLiteral";
        SyntaxKind[SyntaxKind["ArrayType"] = 183] = "ArrayType";
        SyntaxKind[SyntaxKind["TupleType"] = 184] = "TupleType";
        SyntaxKind[SyntaxKind["OptionalType"] = 185] = "OptionalType";
        SyntaxKind[SyntaxKind["RestType"] = 186] = "RestType";
        SyntaxKind[SyntaxKind["UnionType"] = 187] = "UnionType";
        SyntaxKind[SyntaxKind["IntersectionType"] = 188] = "IntersectionType";
        SyntaxKind[SyntaxKind["ConditionalType"] = 189] = "ConditionalType";
        SyntaxKind[SyntaxKind["InferType"] = 190] = "InferType";
        SyntaxKind[SyntaxKind["ParenthesizedType"] = 191] = "ParenthesizedType";
        SyntaxKind[SyntaxKind["ThisType"] = 192] = "ThisType";
        SyntaxKind[SyntaxKind["TypeOperator"] = 193] = "TypeOperator";
        SyntaxKind[SyntaxKind["IndexedAccessType"] = 194] = "IndexedAccessType";
        SyntaxKind[SyntaxKind["MappedType"] = 195] = "MappedType";
        SyntaxKind[SyntaxKind["LiteralType"] = 196] = "LiteralType";
        SyntaxKind[SyntaxKind["NamedTupleMember"] = 197] = "NamedTupleMember";
        SyntaxKind[SyntaxKind["TemplateLiteralType"] = 198] = "TemplateLiteralType";
        SyntaxKind[SyntaxKind["TemplateLiteralTypeSpan"] = 199] = "TemplateLiteralTypeSpan";
        SyntaxKind[SyntaxKind["ImportType"] = 200] = "ImportType";
        // Binding patterns
        SyntaxKind[SyntaxKind["ObjectBindingPattern"] = 201] = "ObjectBindingPattern";
        SyntaxKind[SyntaxKind["ArrayBindingPattern"] = 202] = "ArrayBindingPattern";
        SyntaxKind[SyntaxKind["BindingElement"] = 203] = "BindingElement";
        // Expression
        SyntaxKind[SyntaxKind["ArrayLiteralExpression"] = 204] = "ArrayLiteralExpression";
        SyntaxKind[SyntaxKind["ObjectLiteralExpression"] = 205] = "ObjectLiteralExpression";
        SyntaxKind[SyntaxKind["PropertyAccessExpression"] = 206] = "PropertyAccessExpression";
        SyntaxKind[SyntaxKind["ElementAccessExpression"] = 207] = "ElementAccessExpression";
        SyntaxKind[SyntaxKind["CallExpression"] = 208] = "CallExpression";
        SyntaxKind[SyntaxKind["NewExpression"] = 209] = "NewExpression";
        SyntaxKind[SyntaxKind["TaggedTemplateExpression"] = 210] = "TaggedTemplateExpression";
        SyntaxKind[SyntaxKind["TypeAssertionExpression"] = 211] = "TypeAssertionExpression";
        SyntaxKind[SyntaxKind["ParenthesizedExpression"] = 212] = "ParenthesizedExpression";
        SyntaxKind[SyntaxKind["FunctionExpression"] = 213] = "FunctionExpression";
        SyntaxKind[SyntaxKind["ArrowFunction"] = 214] = "ArrowFunction";
        SyntaxKind[SyntaxKind["DeleteExpression"] = 215] = "DeleteExpression";
        SyntaxKind[SyntaxKind["TypeOfExpression"] = 216] = "TypeOfExpression";
        SyntaxKind[SyntaxKind["VoidExpression"] = 217] = "VoidExpression";
        SyntaxKind[SyntaxKind["AwaitExpression"] = 218] = "AwaitExpression";
        SyntaxKind[SyntaxKind["PrefixUnaryExpression"] = 219] = "PrefixUnaryExpression";
        SyntaxKind[SyntaxKind["PostfixUnaryExpression"] = 220] = "PostfixUnaryExpression";
        SyntaxKind[SyntaxKind["BinaryExpression"] = 221] = "BinaryExpression";
        SyntaxKind[SyntaxKind["ConditionalExpression"] = 222] = "ConditionalExpression";
        SyntaxKind[SyntaxKind["TemplateExpression"] = 223] = "TemplateExpression";
        SyntaxKind[SyntaxKind["YieldExpression"] = 224] = "YieldExpression";
        SyntaxKind[SyntaxKind["SpreadElement"] = 225] = "SpreadElement";
        SyntaxKind[SyntaxKind["ClassExpression"] = 226] = "ClassExpression";
        SyntaxKind[SyntaxKind["OmittedExpression"] = 227] = "OmittedExpression";
        SyntaxKind[SyntaxKind["ExpressionWithTypeArguments"] = 228] = "ExpressionWithTypeArguments";
        SyntaxKind[SyntaxKind["AsExpression"] = 229] = "AsExpression";
        SyntaxKind[SyntaxKind["NonNullExpression"] = 230] = "NonNullExpression";
        SyntaxKind[SyntaxKind["MetaProperty"] = 231] = "MetaProperty";
        SyntaxKind[SyntaxKind["SyntheticExpression"] = 232] = "SyntheticExpression";
        // Misc
        SyntaxKind[SyntaxKind["TemplateSpan"] = 233] = "TemplateSpan";
        SyntaxKind[SyntaxKind["SemicolonClassElement"] = 234] = "SemicolonClassElement";
        // Element
        SyntaxKind[SyntaxKind["Block"] = 235] = "Block";
        SyntaxKind[SyntaxKind["EmptyStatement"] = 236] = "EmptyStatement";
        SyntaxKind[SyntaxKind["VariableStatement"] = 237] = "VariableStatement";
        SyntaxKind[SyntaxKind["ExpressionStatement"] = 238] = "ExpressionStatement";
        SyntaxKind[SyntaxKind["IfStatement"] = 239] = "IfStatement";
        SyntaxKind[SyntaxKind["DoStatement"] = 240] = "DoStatement";
        SyntaxKind[SyntaxKind["WhileStatement"] = 241] = "WhileStatement";
        SyntaxKind[SyntaxKind["ForStatement"] = 242] = "ForStatement";
        SyntaxKind[SyntaxKind["ForInStatement"] = 243] = "ForInStatement";
        SyntaxKind[SyntaxKind["ForOfStatement"] = 244] = "ForOfStatement";
        SyntaxKind[SyntaxKind["ContinueStatement"] = 245] = "ContinueStatement";
        SyntaxKind[SyntaxKind["BreakStatement"] = 246] = "BreakStatement";
        SyntaxKind[SyntaxKind["ReturnStatement"] = 247] = "ReturnStatement";
        SyntaxKind[SyntaxKind["WithStatement"] = 248] = "WithStatement";
        SyntaxKind[SyntaxKind["SwitchStatement"] = 249] = "SwitchStatement";
        SyntaxKind[SyntaxKind["LabeledStatement"] = 250] = "LabeledStatement";
        SyntaxKind[SyntaxKind["ThrowStatement"] = 251] = "ThrowStatement";
        SyntaxKind[SyntaxKind["TryStatement"] = 252] = "TryStatement";
        SyntaxKind[SyntaxKind["DebuggerStatement"] = 253] = "DebuggerStatement";
        SyntaxKind[SyntaxKind["VariableDeclaration"] = 254] = "VariableDeclaration";
        SyntaxKind[SyntaxKind["VariableDeclarationList"] = 255] = "VariableDeclarationList";
        SyntaxKind[SyntaxKind["FunctionDeclaration"] = 256] = "FunctionDeclaration";
        SyntaxKind[SyntaxKind["ClassDeclaration"] = 257] = "ClassDeclaration";
        SyntaxKind[SyntaxKind["InterfaceDeclaration"] = 258] = "InterfaceDeclaration";
        SyntaxKind[SyntaxKind["TypeAliasDeclaration"] = 259] = "TypeAliasDeclaration";
        SyntaxKind[SyntaxKind["EnumDeclaration"] = 260] = "EnumDeclaration";
        SyntaxKind[SyntaxKind["ModuleDeclaration"] = 261] = "ModuleDeclaration";
        SyntaxKind[SyntaxKind["ModuleBlock"] = 262] = "ModuleBlock";
        SyntaxKind[SyntaxKind["CaseBlock"] = 263] = "CaseBlock";
        SyntaxKind[SyntaxKind["NamespaceExportDeclaration"] = 264] = "NamespaceExportDeclaration";
        SyntaxKind[SyntaxKind["ImportEqualsDeclaration"] = 265] = "ImportEqualsDeclaration";
        SyntaxKind[SyntaxKind["ImportDeclaration"] = 266] = "ImportDeclaration";
        SyntaxKind[SyntaxKind["ImportClause"] = 267] = "ImportClause";
        SyntaxKind[SyntaxKind["NamespaceImport"] = 268] = "NamespaceImport";
        SyntaxKind[SyntaxKind["NamedImports"] = 269] = "NamedImports";
        SyntaxKind[SyntaxKind["ImportSpecifier"] = 270] = "ImportSpecifier";
        SyntaxKind[SyntaxKind["ExportAssignment"] = 271] = "ExportAssignment";
        SyntaxKind[SyntaxKind["ExportDeclaration"] = 272] = "ExportDeclaration";
        SyntaxKind[SyntaxKind["NamedExports"] = 273] = "NamedExports";
        SyntaxKind[SyntaxKind["NamespaceExport"] = 274] = "NamespaceExport";
        SyntaxKind[SyntaxKind["ExportSpecifier"] = 275] = "ExportSpecifier";
        SyntaxKind[SyntaxKind["MissingDeclaration"] = 276] = "MissingDeclaration";
        // Module references
        SyntaxKind[SyntaxKind["ExternalModuleReference"] = 277] = "ExternalModuleReference";
        // JSX
        SyntaxKind[SyntaxKind["JsxElement"] = 278] = "JsxElement";
        SyntaxKind[SyntaxKind["JsxSelfClosingElement"] = 279] = "JsxSelfClosingElement";
        SyntaxKind[SyntaxKind["JsxOpeningElement"] = 280] = "JsxOpeningElement";
        SyntaxKind[SyntaxKind["JsxClosingElement"] = 281] = "JsxClosingElement";
        SyntaxKind[SyntaxKind["JsxFragment"] = 282] = "JsxFragment";
        SyntaxKind[SyntaxKind["JsxOpeningFragment"] = 283] = "JsxOpeningFragment";
        SyntaxKind[SyntaxKind["JsxClosingFragment"] = 284] = "JsxClosingFragment";
        SyntaxKind[SyntaxKind["JsxAttribute"] = 285] = "JsxAttribute";
        SyntaxKind[SyntaxKind["JsxAttributes"] = 286] = "JsxAttributes";
        SyntaxKind[SyntaxKind["JsxSpreadAttribute"] = 287] = "JsxSpreadAttribute";
        SyntaxKind[SyntaxKind["JsxExpression"] = 288] = "JsxExpression";
        // Clauses
        SyntaxKind[SyntaxKind["CaseClause"] = 289] = "CaseClause";
        SyntaxKind[SyntaxKind["DefaultClause"] = 290] = "DefaultClause";
        SyntaxKind[SyntaxKind["HeritageClause"] = 291] = "HeritageClause";
        SyntaxKind[SyntaxKind["CatchClause"] = 292] = "CatchClause";
        SyntaxKind[SyntaxKind["AssertClause"] = 293] = "AssertClause";
        SyntaxKind[SyntaxKind["AssertEntry"] = 294] = "AssertEntry";
        SyntaxKind[SyntaxKind["ImportTypeAssertionContainer"] = 295] = "ImportTypeAssertionContainer";
        // Property assignments
        SyntaxKind[SyntaxKind["PropertyAssignment"] = 296] = "PropertyAssignment";
        SyntaxKind[SyntaxKind["ShorthandPropertyAssignment"] = 297] = "ShorthandPropertyAssignment";
        SyntaxKind[SyntaxKind["SpreadAssignment"] = 298] = "SpreadAssignment";
        // Enum
        SyntaxKind[SyntaxKind["EnumMember"] = 299] = "EnumMember";
        // Unparsed
        SyntaxKind[SyntaxKind["UnparsedPrologue"] = 300] = "UnparsedPrologue";
        SyntaxKind[SyntaxKind["UnparsedPrepend"] = 301] = "UnparsedPrepend";
        SyntaxKind[SyntaxKind["UnparsedText"] = 302] = "UnparsedText";
        SyntaxKind[SyntaxKind["UnparsedInternalText"] = 303] = "UnparsedInternalText";
        SyntaxKind[SyntaxKind["UnparsedSyntheticReference"] = 304] = "UnparsedSyntheticReference";
        // Top-level nodes
        SyntaxKind[SyntaxKind["SourceFile"] = 305] = "SourceFile";
        SyntaxKind[SyntaxKind["Bundle"] = 306] = "Bundle";
        SyntaxKind[SyntaxKind["UnparsedSource"] = 307] = "UnparsedSource";
        SyntaxKind[SyntaxKind["InputFiles"] = 308] = "InputFiles";
        // JSDoc nodes
        SyntaxKind[SyntaxKind["JSDocTypeExpression"] = 309] = "JSDocTypeExpression";
        SyntaxKind[SyntaxKind["JSDocNameReference"] = 310] = "JSDocNameReference";
        SyntaxKind[SyntaxKind["JSDocMemberName"] = 311] = "JSDocMemberName";
        SyntaxKind[SyntaxKind["JSDocAllType"] = 312] = "JSDocAllType";
        SyntaxKind[SyntaxKind["JSDocUnknownType"] = 313] = "JSDocUnknownType";
        SyntaxKind[SyntaxKind["JSDocNullableType"] = 314] = "JSDocNullableType";
        SyntaxKind[SyntaxKind["JSDocNonNullableType"] = 315] = "JSDocNonNullableType";
        SyntaxKind[SyntaxKind["JSDocOptionalType"] = 316] = "JSDocOptionalType";
        SyntaxKind[SyntaxKind["JSDocFunctionType"] = 317] = "JSDocFunctionType";
        SyntaxKind[SyntaxKind["JSDocVariadicType"] = 318] = "JSDocVariadicType";
        SyntaxKind[SyntaxKind["JSDocNamepathType"] = 319] = "JSDocNamepathType";
        SyntaxKind[SyntaxKind["JSDoc"] = 320] = "JSDoc";
        /** @deprecated Use SyntaxKind.JSDoc */
        SyntaxKind[SyntaxKind["JSDocComment"] = 320] = "JSDocComment";
        SyntaxKind[SyntaxKind["JSDocText"] = 321] = "JSDocText";
        SyntaxKind[SyntaxKind["JSDocTypeLiteral"] = 322] = "JSDocTypeLiteral";
        SyntaxKind[SyntaxKind["JSDocSignature"] = 323] = "JSDocSignature";
        SyntaxKind[SyntaxKind["JSDocLink"] = 324] = "JSDocLink";
        SyntaxKind[SyntaxKind["JSDocLinkCode"] = 325] = "JSDocLinkCode";
        SyntaxKind[SyntaxKind["JSDocLinkPlain"] = 326] = "JSDocLinkPlain";
        SyntaxKind[SyntaxKind["JSDocTag"] = 327] = "JSDocTag";
        SyntaxKind[SyntaxKind["JSDocAugmentsTag"] = 328] = "JSDocAugmentsTag";
        SyntaxKind[SyntaxKind["JSDocImplementsTag"] = 329] = "JSDocImplementsTag";
        SyntaxKind[SyntaxKind["JSDocAuthorTag"] = 330] = "JSDocAuthorTag";
        SyntaxKind[SyntaxKind["JSDocDeprecatedTag"] = 331] = "JSDocDeprecatedTag";
        SyntaxKind[SyntaxKind["JSDocClassTag"] = 332] = "JSDocClassTag";
        SyntaxKind[SyntaxKind["JSDocPublicTag"] = 333] = "JSDocPublicTag";
        SyntaxKind[SyntaxKind["JSDocPrivateTag"] = 334] = "JSDocPrivateTag";
        SyntaxKind[SyntaxKind["JSDocProtectedTag"] = 335] = "JSDocProtectedTag";
        SyntaxKind[SyntaxKind["JSDocReadonlyTag"] = 336] = "JSDocReadonlyTag";
        SyntaxKind[SyntaxKind["JSDocOverrideTag"] = 337] = "JSDocOverrideTag";
        SyntaxKind[SyntaxKind["JSDocCallbackTag"] = 338] = "JSDocCallbackTag";
        SyntaxKind[SyntaxKind["JSDocEnumTag"] = 339] = "JSDocEnumTag";
        SyntaxKind[SyntaxKind["JSDocParameterTag"] = 340] = "JSDocParameterTag";
        SyntaxKind[SyntaxKind["JSDocReturnTag"] = 341] = "JSDocReturnTag";
        SyntaxKind[SyntaxKind["JSDocThisTag"] = 342] = "JSDocThisTag";
        SyntaxKind[SyntaxKind["JSDocTypeTag"] = 343] = "JSDocTypeTag";
        SyntaxKind[SyntaxKind["JSDocTemplateTag"] = 344] = "JSDocTemplateTag";
        SyntaxKind[SyntaxKind["JSDocTypedefTag"] = 345] = "JSDocTypedefTag";
        SyntaxKind[SyntaxKind["JSDocSeeTag"] = 346] = "JSDocSeeTag";
        SyntaxKind[SyntaxKind["JSDocPropertyTag"] = 347] = "JSDocPropertyTag";
        // Synthesized list
        SyntaxKind[SyntaxKind["SyntaxList"] = 348] = "SyntaxList";
        // Transformation nodes
        SyntaxKind[SyntaxKind["NotEmittedStatement"] = 349] = "NotEmittedStatement";
        SyntaxKind[SyntaxKind["PartiallyEmittedExpression"] = 350] = "PartiallyEmittedExpression";
        SyntaxKind[SyntaxKind["CommaListExpression"] = 351] = "CommaListExpression";
        SyntaxKind[SyntaxKind["MergeDeclarationMarker"] = 352] = "MergeDeclarationMarker";
        SyntaxKind[SyntaxKind["EndOfDeclarationMarker"] = 353] = "EndOfDeclarationMarker";
        SyntaxKind[SyntaxKind["SyntheticReferenceExpression"] = 354] = "SyntheticReferenceExpression";
        // Enum value count
        SyntaxKind[SyntaxKind["Count"] = 355] = "Count";
        // Markers
        SyntaxKind[SyntaxKind["FirstAssignment"] = 63] = "FirstAssignment";
        SyntaxKind[SyntaxKind["LastAssignment"] = 78] = "LastAssignment";
        SyntaxKind[SyntaxKind["FirstCompoundAssignment"] = 64] = "FirstCompoundAssignment";
        SyntaxKind[SyntaxKind["LastCompoundAssignment"] = 78] = "LastCompoundAssignment";
        SyntaxKind[SyntaxKind["FirstReservedWord"] = 81] = "FirstReservedWord";
        SyntaxKind[SyntaxKind["LastReservedWord"] = 116] = "LastReservedWord";
        SyntaxKind[SyntaxKind["FirstKeyword"] = 81] = "FirstKeyword";
        SyntaxKind[SyntaxKind["LastKeyword"] = 160] = "LastKeyword";
        SyntaxKind[SyntaxKind["FirstFutureReservedWord"] = 117] = "FirstFutureReservedWord";
        SyntaxKind[SyntaxKind["LastFutureReservedWord"] = 125] = "LastFutureReservedWord";
        SyntaxKind[SyntaxKind["FirstTypeNode"] = 177] = "FirstTypeNode";
        SyntaxKind[SyntaxKind["LastTypeNode"] = 200] = "LastTypeNode";
        SyntaxKind[SyntaxKind["FirstPunctuation"] = 18] = "FirstPunctuation";
        SyntaxKind[SyntaxKind["LastPunctuation"] = 78] = "LastPunctuation";
        SyntaxKind[SyntaxKind["FirstToken"] = 0] = "FirstToken";
        SyntaxKind[SyntaxKind["LastToken"] = 160] = "LastToken";
        SyntaxKind[SyntaxKind["FirstTriviaToken"] = 2] = "FirstTriviaToken";
        SyntaxKind[SyntaxKind["LastTriviaToken"] = 7] = "LastTriviaToken";
        SyntaxKind[SyntaxKind["FirstLiteralToken"] = 8] = "FirstLiteralToken";
        SyntaxKind[SyntaxKind["LastLiteralToken"] = 14] = "LastLiteralToken";
        SyntaxKind[SyntaxKind["FirstTemplateToken"] = 14] = "FirstTemplateToken";
        SyntaxKind[SyntaxKind["LastTemplateToken"] = 17] = "LastTemplateToken";
        SyntaxKind[SyntaxKind["FirstBinaryOperator"] = 29] = "FirstBinaryOperator";
        SyntaxKind[SyntaxKind["LastBinaryOperator"] = 78] = "LastBinaryOperator";
        SyntaxKind[SyntaxKind["FirstStatement"] = 237] = "FirstStatement";
        SyntaxKind[SyntaxKind["LastStatement"] = 253] = "LastStatement";
        SyntaxKind[SyntaxKind["FirstNode"] = 161] = "FirstNode";
        SyntaxKind[SyntaxKind["FirstJSDocNode"] = 309] = "FirstJSDocNode";
        SyntaxKind[SyntaxKind["LastJSDocNode"] = 347] = "LastJSDocNode";
        SyntaxKind[SyntaxKind["FirstJSDocTagNode"] = 327] = "FirstJSDocTagNode";
        SyntaxKind[SyntaxKind["LastJSDocTagNode"] = 347] = "LastJSDocTagNode";
        /* @internal */ SyntaxKind[SyntaxKind["FirstContextualKeyword"] = 126] = "FirstContextualKeyword";
        /* @internal */ SyntaxKind[SyntaxKind["LastContextualKeyword"] = 160] = "LastContextualKeyword";
    })(SyntaxKind = ts.SyntaxKind || (ts.SyntaxKind = {}));
    var NodeFlags;
    (function (NodeFlags) {
        NodeFlags[NodeFlags["None"] = 0] = "None";
        NodeFlags[NodeFlags["Let"] = 1] = "Let";
        NodeFlags[NodeFlags["Const"] = 2] = "Const";
        NodeFlags[NodeFlags["NestedNamespace"] = 4] = "NestedNamespace";
        NodeFlags[NodeFlags["Synthesized"] = 8] = "Synthesized";
        NodeFlags[NodeFlags["Namespace"] = 16] = "Namespace";
        NodeFlags[NodeFlags["OptionalChain"] = 32] = "OptionalChain";
        NodeFlags[NodeFlags["ExportContext"] = 64] = "ExportContext";
        NodeFlags[NodeFlags["ContainsThis"] = 128] = "ContainsThis";
        NodeFlags[NodeFlags["HasImplicitReturn"] = 256] = "HasImplicitReturn";
        NodeFlags[NodeFlags["HasExplicitReturn"] = 512] = "HasExplicitReturn";
        NodeFlags[NodeFlags["GlobalAugmentation"] = 1024] = "GlobalAugmentation";
        NodeFlags[NodeFlags["HasAsyncFunctions"] = 2048] = "HasAsyncFunctions";
        NodeFlags[NodeFlags["DisallowInContext"] = 4096] = "DisallowInContext";
        NodeFlags[NodeFlags["YieldContext"] = 8192] = "YieldContext";
        NodeFlags[NodeFlags["DecoratorContext"] = 16384] = "DecoratorContext";
        NodeFlags[NodeFlags["AwaitContext"] = 32768] = "AwaitContext";
        NodeFlags[NodeFlags["DisallowConditionalTypesContext"] = 65536] = "DisallowConditionalTypesContext";
        NodeFlags[NodeFlags["ThisNodeHasError"] = 131072] = "ThisNodeHasError";
        NodeFlags[NodeFlags["JavaScriptFile"] = 262144] = "JavaScriptFile";
        NodeFlags[NodeFlags["ThisNodeOrAnySubNodesHasError"] = 524288] = "ThisNodeOrAnySubNodesHasError";
        NodeFlags[NodeFlags["HasAggregatedChildData"] = 1048576] = "HasAggregatedChildData";
        // These flags will be set when the parser encounters a dynamic import expression or 'import.meta' to avoid
        // walking the tree if the flags are not set. However, these flags are just a approximation
        // (hence why it's named "PossiblyContainsDynamicImport") because once set, the flags never get cleared.
        // During editing, if a dynamic import is removed, incremental parsing will *NOT* clear this flag.
        // This means that the tree will always be traversed during module resolution, or when looking for external module indicators.
        // However, the removal operation should not occur often and in the case of the
        // removal, it is likely that users will add the import anyway.
        // The advantage of this approach is its simplicity. For the case of batch compilation,
        // we guarantee that users won't have to pay the price of walking the tree if a dynamic import isn't used.
        /* @internal */ NodeFlags[NodeFlags["PossiblyContainsDynamicImport"] = 2097152] = "PossiblyContainsDynamicImport";
        /* @internal */ NodeFlags[NodeFlags["PossiblyContainsImportMeta"] = 4194304] = "PossiblyContainsImportMeta";
        NodeFlags[NodeFlags["JSDoc"] = 8388608] = "JSDoc";
        /* @internal */ NodeFlags[NodeFlags["Ambient"] = 16777216] = "Ambient";
        /* @internal */ NodeFlags[NodeFlags["InWithStatement"] = 33554432] = "InWithStatement";
        NodeFlags[NodeFlags["JsonFile"] = 67108864] = "JsonFile";
        /* @internal */ NodeFlags[NodeFlags["TypeCached"] = 134217728] = "TypeCached";
        /* @internal */ NodeFlags[NodeFlags["Deprecated"] = 268435456] = "Deprecated";
        NodeFlags[NodeFlags["BlockScoped"] = 3] = "BlockScoped";
        NodeFlags[NodeFlags["ReachabilityCheckFlags"] = 768] = "ReachabilityCheckFlags";
        NodeFlags[NodeFlags["ReachabilityAndEmitFlags"] = 2816] = "ReachabilityAndEmitFlags";
        // Parsing context flags
        NodeFlags[NodeFlags["ContextFlags"] = 50720768] = "ContextFlags";
        // Exclude these flags when parsing a Type
        NodeFlags[NodeFlags["TypeExcludesFlags"] = 40960] = "TypeExcludesFlags";
        // Represents all flags that are potentially set once and
        // never cleared on SourceFiles which get re-used in between incremental parses.
        // See the comment above on `PossiblyContainsDynamicImport` and `PossiblyContainsImportMeta`.
        /* @internal */ NodeFlags[NodeFlags["PermanentlySetIncrementalFlags"] = 6291456] = "PermanentlySetIncrementalFlags";
    })(NodeFlags = ts.NodeFlags || (ts.NodeFlags = {}));
    var ModifierFlags;
    (function (ModifierFlags) {
        ModifierFlags[ModifierFlags["None"] = 0] = "None";
        ModifierFlags[ModifierFlags["Export"] = 1] = "Export";
        ModifierFlags[ModifierFlags["Ambient"] = 2] = "Ambient";
        ModifierFlags[ModifierFlags["Public"] = 4] = "Public";
        ModifierFlags[ModifierFlags["Private"] = 8] = "Private";
        ModifierFlags[ModifierFlags["Protected"] = 16] = "Protected";
        ModifierFlags[ModifierFlags["Static"] = 32] = "Static";
        ModifierFlags[ModifierFlags["Readonly"] = 64] = "Readonly";
        ModifierFlags[ModifierFlags["Abstract"] = 128] = "Abstract";
        ModifierFlags[ModifierFlags["Async"] = 256] = "Async";
        ModifierFlags[ModifierFlags["Default"] = 512] = "Default";
        ModifierFlags[ModifierFlags["Const"] = 2048] = "Const";
        ModifierFlags[ModifierFlags["HasComputedJSDocModifiers"] = 4096] = "HasComputedJSDocModifiers";
        ModifierFlags[ModifierFlags["Deprecated"] = 8192] = "Deprecated";
        ModifierFlags[ModifierFlags["Override"] = 16384] = "Override";
        ModifierFlags[ModifierFlags["In"] = 32768] = "In";
        ModifierFlags[ModifierFlags["Out"] = 65536] = "Out";
        ModifierFlags[ModifierFlags["Decorator"] = 131072] = "Decorator";
        ModifierFlags[ModifierFlags["HasComputedFlags"] = 536870912] = "HasComputedFlags";
        ModifierFlags[ModifierFlags["AccessibilityModifier"] = 28] = "AccessibilityModifier";
        // Accessibility modifiers and 'readonly' can be attached to a parameter in a constructor to make it a property.
        ModifierFlags[ModifierFlags["ParameterPropertyModifier"] = 16476] = "ParameterPropertyModifier";
        ModifierFlags[ModifierFlags["NonPublicAccessibilityModifier"] = 24] = "NonPublicAccessibilityModifier";
        ModifierFlags[ModifierFlags["TypeScriptModifier"] = 116958] = "TypeScriptModifier";
        ModifierFlags[ModifierFlags["ExportDefault"] = 513] = "ExportDefault";
        ModifierFlags[ModifierFlags["All"] = 257023] = "All";
        ModifierFlags[ModifierFlags["Modifier"] = 125951] = "Modifier";
    })(ModifierFlags = ts.ModifierFlags || (ts.ModifierFlags = {}));
    var JsxFlags;
    (function (JsxFlags) {
        JsxFlags[JsxFlags["None"] = 0] = "None";
        /** An element from a named property of the JSX.IntrinsicElements interface */
        JsxFlags[JsxFlags["IntrinsicNamedElement"] = 1] = "IntrinsicNamedElement";
        /** An element inferred from the string index signature of the JSX.IntrinsicElements interface */
        JsxFlags[JsxFlags["IntrinsicIndexedElement"] = 2] = "IntrinsicIndexedElement";
        JsxFlags[JsxFlags["IntrinsicElement"] = 3] = "IntrinsicElement";
    })(JsxFlags = ts.JsxFlags || (ts.JsxFlags = {}));
    /* @internal */
    var RelationComparisonResult;
    (function (RelationComparisonResult) {
        RelationComparisonResult[RelationComparisonResult["Succeeded"] = 1] = "Succeeded";
        RelationComparisonResult[RelationComparisonResult["Failed"] = 2] = "Failed";
        RelationComparisonResult[RelationComparisonResult["Reported"] = 4] = "Reported";
        RelationComparisonResult[RelationComparisonResult["ReportsUnmeasurable"] = 8] = "ReportsUnmeasurable";
        RelationComparisonResult[RelationComparisonResult["ReportsUnreliable"] = 16] = "ReportsUnreliable";
        RelationComparisonResult[RelationComparisonResult["ReportsMask"] = 24] = "ReportsMask";
    })(RelationComparisonResult = ts.RelationComparisonResult || (ts.RelationComparisonResult = {}));
    var GeneratedIdentifierFlags;
    (function (GeneratedIdentifierFlags) {
        // Kinds
        GeneratedIdentifierFlags[GeneratedIdentifierFlags["None"] = 0] = "None";
        /*@internal*/ GeneratedIdentifierFlags[GeneratedIdentifierFlags["Auto"] = 1] = "Auto";
        /*@internal*/ GeneratedIdentifierFlags[GeneratedIdentifierFlags["Loop"] = 2] = "Loop";
        /*@internal*/ GeneratedIdentifierFlags[GeneratedIdentifierFlags["Unique"] = 3] = "Unique";
        /*@internal*/ GeneratedIdentifierFlags[GeneratedIdentifierFlags["Node"] = 4] = "Node";
        /*@internal*/ GeneratedIdentifierFlags[GeneratedIdentifierFlags["KindMask"] = 7] = "KindMask";
        // Flags
        GeneratedIdentifierFlags[GeneratedIdentifierFlags["ReservedInNestedScopes"] = 8] = "ReservedInNestedScopes";
        GeneratedIdentifierFlags[GeneratedIdentifierFlags["Optimistic"] = 16] = "Optimistic";
        GeneratedIdentifierFlags[GeneratedIdentifierFlags["FileLevel"] = 32] = "FileLevel";
        GeneratedIdentifierFlags[GeneratedIdentifierFlags["AllowNameSubstitution"] = 64] = "AllowNameSubstitution";
    })(GeneratedIdentifierFlags = ts.GeneratedIdentifierFlags || (ts.GeneratedIdentifierFlags = {}));
    var TokenFlags;
    (function (TokenFlags) {
        TokenFlags[TokenFlags["None"] = 0] = "None";
        /* @internal */
        TokenFlags[TokenFlags["PrecedingLineBreak"] = 1] = "PrecedingLineBreak";
        /* @internal */
        TokenFlags[TokenFlags["PrecedingJSDocComment"] = 2] = "PrecedingJSDocComment";
        /* @internal */
        TokenFlags[TokenFlags["Unterminated"] = 4] = "Unterminated";
        /* @internal */
        TokenFlags[TokenFlags["ExtendedUnicodeEscape"] = 8] = "ExtendedUnicodeEscape";
        TokenFlags[TokenFlags["Scientific"] = 16] = "Scientific";
        TokenFlags[TokenFlags["Octal"] = 32] = "Octal";
        TokenFlags[TokenFlags["HexSpecifier"] = 64] = "HexSpecifier";
        TokenFlags[TokenFlags["BinarySpecifier"] = 128] = "BinarySpecifier";
        TokenFlags[TokenFlags["OctalSpecifier"] = 256] = "OctalSpecifier";
        /* @internal */
        TokenFlags[TokenFlags["ContainsSeparator"] = 512] = "ContainsSeparator";
        /* @internal */
        TokenFlags[TokenFlags["UnicodeEscape"] = 1024] = "UnicodeEscape";
        /* @internal */
        TokenFlags[TokenFlags["ContainsInvalidEscape"] = 2048] = "ContainsInvalidEscape";
        /* @internal */
        TokenFlags[TokenFlags["BinaryOrOctalSpecifier"] = 384] = "BinaryOrOctalSpecifier";
        /* @internal */
        TokenFlags[TokenFlags["NumericLiteralFlags"] = 1008] = "NumericLiteralFlags";
        /* @internal */
        TokenFlags[TokenFlags["TemplateLiteralLikeFlags"] = 2048] = "TemplateLiteralLikeFlags";
    })(TokenFlags = ts.TokenFlags || (ts.TokenFlags = {}));
    // NOTE: Ensure this is up-to-date with src/debug/debug.ts
    var FlowFlags;
    (function (FlowFlags) {
        FlowFlags[FlowFlags["Unreachable"] = 1] = "Unreachable";
        FlowFlags[FlowFlags["Start"] = 2] = "Start";
        FlowFlags[FlowFlags["BranchLabel"] = 4] = "BranchLabel";
        FlowFlags[FlowFlags["LoopLabel"] = 8] = "LoopLabel";
        FlowFlags[FlowFlags["Assignment"] = 16] = "Assignment";
        FlowFlags[FlowFlags["TrueCondition"] = 32] = "TrueCondition";
        FlowFlags[FlowFlags["FalseCondition"] = 64] = "FalseCondition";
        FlowFlags[FlowFlags["SwitchClause"] = 128] = "SwitchClause";
        FlowFlags[FlowFlags["ArrayMutation"] = 256] = "ArrayMutation";
        FlowFlags[FlowFlags["Call"] = 512] = "Call";
        FlowFlags[FlowFlags["ReduceLabel"] = 1024] = "ReduceLabel";
        FlowFlags[FlowFlags["Referenced"] = 2048] = "Referenced";
        FlowFlags[FlowFlags["Shared"] = 4096] = "Shared";
        FlowFlags[FlowFlags["Label"] = 12] = "Label";
        FlowFlags[FlowFlags["Condition"] = 96] = "Condition";
    })(FlowFlags = ts.FlowFlags || (ts.FlowFlags = {}));
    /* @internal */
    var CommentDirectiveType;
    (function (CommentDirectiveType) {
        CommentDirectiveType[CommentDirectiveType["ExpectError"] = 0] = "ExpectError";
        CommentDirectiveType[CommentDirectiveType["Ignore"] = 1] = "Ignore";
    })(CommentDirectiveType = ts.CommentDirectiveType || (ts.CommentDirectiveType = {}));
    var OperationCanceledException = /** @class */ (function () {
        function OperationCanceledException() {
        }
        return OperationCanceledException;
    }());
    ts.OperationCanceledException = OperationCanceledException;
    /*@internal*/
    var FileIncludeKind;
    (function (FileIncludeKind) {
        FileIncludeKind[FileIncludeKind["RootFile"] = 0] = "RootFile";
        FileIncludeKind[FileIncludeKind["SourceFromProjectReference"] = 1] = "SourceFromProjectReference";
        FileIncludeKind[FileIncludeKind["OutputFromProjectReference"] = 2] = "OutputFromProjectReference";
        FileIncludeKind[FileIncludeKind["Import"] = 3] = "Import";
        FileIncludeKind[FileIncludeKind["ReferenceFile"] = 4] = "ReferenceFile";
        FileIncludeKind[FileIncludeKind["TypeReferenceDirective"] = 5] = "TypeReferenceDirective";
        FileIncludeKind[FileIncludeKind["LibFile"] = 6] = "LibFile";
        FileIncludeKind[FileIncludeKind["LibReferenceDirective"] = 7] = "LibReferenceDirective";
        FileIncludeKind[FileIncludeKind["AutomaticTypeDirectiveFile"] = 8] = "AutomaticTypeDirectiveFile";
    })(FileIncludeKind = ts.FileIncludeKind || (ts.FileIncludeKind = {}));
    /*@internal*/
    var FilePreprocessingDiagnosticsKind;
    (function (FilePreprocessingDiagnosticsKind) {
        FilePreprocessingDiagnosticsKind[FilePreprocessingDiagnosticsKind["FilePreprocessingReferencedDiagnostic"] = 0] = "FilePreprocessingReferencedDiagnostic";
        FilePreprocessingDiagnosticsKind[FilePreprocessingDiagnosticsKind["FilePreprocessingFileExplainingDiagnostic"] = 1] = "FilePreprocessingFileExplainingDiagnostic";
    })(FilePreprocessingDiagnosticsKind = ts.FilePreprocessingDiagnosticsKind || (ts.FilePreprocessingDiagnosticsKind = {}));
    /* @internal */
    var StructureIsReused;
    (function (StructureIsReused) {
        StructureIsReused[StructureIsReused["Not"] = 0] = "Not";
        StructureIsReused[StructureIsReused["SafeModules"] = 1] = "SafeModules";
        StructureIsReused[StructureIsReused["Completely"] = 2] = "Completely";
    })(StructureIsReused = ts.StructureIsReused || (ts.StructureIsReused = {}));
    /** Return code used by getEmitOutput function to indicate status of the function */
    var ExitStatus;
    (function (ExitStatus) {
        // Compiler ran successfully.  Either this was a simple do-nothing compilation (for example,
        // when -version or -help was provided, or this was a normal compilation, no diagnostics
        // were produced, and all outputs were generated successfully.
        ExitStatus[ExitStatus["Success"] = 0] = "Success";
        // Diagnostics were produced and because of them no code was generated.
        ExitStatus[ExitStatus["DiagnosticsPresent_OutputsSkipped"] = 1] = "DiagnosticsPresent_OutputsSkipped";
        // Diagnostics were produced and outputs were generated in spite of them.
        ExitStatus[ExitStatus["DiagnosticsPresent_OutputsGenerated"] = 2] = "DiagnosticsPresent_OutputsGenerated";
        // When build skipped because passed in project is invalid
        ExitStatus[ExitStatus["InvalidProject_OutputsSkipped"] = 3] = "InvalidProject_OutputsSkipped";
        // When build is skipped because project references form cycle
        ExitStatus[ExitStatus["ProjectReferenceCycle_OutputsSkipped"] = 4] = "ProjectReferenceCycle_OutputsSkipped";
        /** @deprecated Use ProjectReferenceCycle_OutputsSkipped instead. */
        ExitStatus[ExitStatus["ProjectReferenceCycle_OutputsSkupped"] = 4] = "ProjectReferenceCycle_OutputsSkupped";
    })(ExitStatus = ts.ExitStatus || (ts.ExitStatus = {}));
    /* @internal */
    var MemberOverrideStatus;
    (function (MemberOverrideStatus) {
        MemberOverrideStatus[MemberOverrideStatus["Ok"] = 0] = "Ok";
        MemberOverrideStatus[MemberOverrideStatus["NeedsOverride"] = 1] = "NeedsOverride";
        MemberOverrideStatus[MemberOverrideStatus["HasInvalidOverride"] = 2] = "HasInvalidOverride";
    })(MemberOverrideStatus = ts.MemberOverrideStatus || (ts.MemberOverrideStatus = {}));
    /* @internal */
    var UnionReduction;
    (function (UnionReduction) {
        UnionReduction[UnionReduction["None"] = 0] = "None";
        UnionReduction[UnionReduction["Literal"] = 1] = "Literal";
        UnionReduction[UnionReduction["Subtype"] = 2] = "Subtype";
    })(UnionReduction = ts.UnionReduction || (ts.UnionReduction = {}));
    /* @internal */
    var ContextFlags;
    (function (ContextFlags) {
        ContextFlags[ContextFlags["None"] = 0] = "None";
        ContextFlags[ContextFlags["Signature"] = 1] = "Signature";
        ContextFlags[ContextFlags["NoConstraints"] = 2] = "NoConstraints";
        ContextFlags[ContextFlags["Completions"] = 4] = "Completions";
        ContextFlags[ContextFlags["SkipBindingPatterns"] = 8] = "SkipBindingPatterns";
    })(ContextFlags = ts.ContextFlags || (ts.ContextFlags = {}));
    // NOTE: If modifying this enum, must modify `TypeFormatFlags` too!
    var NodeBuilderFlags;
    (function (NodeBuilderFlags) {
        NodeBuilderFlags[NodeBuilderFlags["None"] = 0] = "None";
        // Options
        NodeBuilderFlags[NodeBuilderFlags["NoTruncation"] = 1] = "NoTruncation";
        NodeBuilderFlags[NodeBuilderFlags["WriteArrayAsGenericType"] = 2] = "WriteArrayAsGenericType";
        NodeBuilderFlags[NodeBuilderFlags["GenerateNamesForShadowedTypeParams"] = 4] = "GenerateNamesForShadowedTypeParams";
        NodeBuilderFlags[NodeBuilderFlags["UseStructuralFallback"] = 8] = "UseStructuralFallback";
        NodeBuilderFlags[NodeBuilderFlags["ForbidIndexedAccessSymbolReferences"] = 16] = "ForbidIndexedAccessSymbolReferences";
        NodeBuilderFlags[NodeBuilderFlags["WriteTypeArgumentsOfSignature"] = 32] = "WriteTypeArgumentsOfSignature";
        NodeBuilderFlags[NodeBuilderFlags["UseFullyQualifiedType"] = 64] = "UseFullyQualifiedType";
        NodeBuilderFlags[NodeBuilderFlags["UseOnlyExternalAliasing"] = 128] = "UseOnlyExternalAliasing";
        NodeBuilderFlags[NodeBuilderFlags["SuppressAnyReturnType"] = 256] = "SuppressAnyReturnType";
        NodeBuilderFlags[NodeBuilderFlags["WriteTypeParametersInQualifiedName"] = 512] = "WriteTypeParametersInQualifiedName";
        NodeBuilderFlags[NodeBuilderFlags["MultilineObjectLiterals"] = 1024] = "MultilineObjectLiterals";
        NodeBuilderFlags[NodeBuilderFlags["WriteClassExpressionAsTypeLiteral"] = 2048] = "WriteClassExpressionAsTypeLiteral";
        NodeBuilderFlags[NodeBuilderFlags["UseTypeOfFunction"] = 4096] = "UseTypeOfFunction";
        NodeBuilderFlags[NodeBuilderFlags["OmitParameterModifiers"] = 8192] = "OmitParameterModifiers";
        NodeBuilderFlags[NodeBuilderFlags["UseAliasDefinedOutsideCurrentScope"] = 16384] = "UseAliasDefinedOutsideCurrentScope";
        NodeBuilderFlags[NodeBuilderFlags["UseSingleQuotesForStringLiteralType"] = 268435456] = "UseSingleQuotesForStringLiteralType";
        NodeBuilderFlags[NodeBuilderFlags["NoTypeReduction"] = 536870912] = "NoTypeReduction";
        NodeBuilderFlags[NodeBuilderFlags["OmitThisParameter"] = 33554432] = "OmitThisParameter";
        // Error handling
        NodeBuilderFlags[NodeBuilderFlags["AllowThisInObjectLiteral"] = 32768] = "AllowThisInObjectLiteral";
        NodeBuilderFlags[NodeBuilderFlags["AllowQualifiedNameInPlaceOfIdentifier"] = 65536] = "AllowQualifiedNameInPlaceOfIdentifier";
        /** @deprecated AllowQualifedNameInPlaceOfIdentifier. Use AllowQualifiedNameInPlaceOfIdentifier instead. */
        NodeBuilderFlags[NodeBuilderFlags["AllowQualifedNameInPlaceOfIdentifier"] = 65536] = "AllowQualifedNameInPlaceOfIdentifier";
        NodeBuilderFlags[NodeBuilderFlags["AllowAnonymousIdentifier"] = 131072] = "AllowAnonymousIdentifier";
        NodeBuilderFlags[NodeBuilderFlags["AllowEmptyUnionOrIntersection"] = 262144] = "AllowEmptyUnionOrIntersection";
        NodeBuilderFlags[NodeBuilderFlags["AllowEmptyTuple"] = 524288] = "AllowEmptyTuple";
        NodeBuilderFlags[NodeBuilderFlags["AllowUniqueESSymbolType"] = 1048576] = "AllowUniqueESSymbolType";
        NodeBuilderFlags[NodeBuilderFlags["AllowEmptyIndexInfoType"] = 2097152] = "AllowEmptyIndexInfoType";
        // Errors (cont.)
        NodeBuilderFlags[NodeBuilderFlags["AllowNodeModulesRelativePaths"] = 67108864] = "AllowNodeModulesRelativePaths";
        /* @internal */ NodeBuilderFlags[NodeBuilderFlags["DoNotIncludeSymbolChain"] = 134217728] = "DoNotIncludeSymbolChain";
        NodeBuilderFlags[NodeBuilderFlags["IgnoreErrors"] = 70221824] = "IgnoreErrors";
        // State
        NodeBuilderFlags[NodeBuilderFlags["InObjectTypeLiteral"] = 4194304] = "InObjectTypeLiteral";
        NodeBuilderFlags[NodeBuilderFlags["InTypeAlias"] = 8388608] = "InTypeAlias";
        NodeBuilderFlags[NodeBuilderFlags["InInitialEntityName"] = 16777216] = "InInitialEntityName";
    })(NodeBuilderFlags = ts.NodeBuilderFlags || (ts.NodeBuilderFlags = {}));
    // Ensure the shared flags between this and `NodeBuilderFlags` stay in alignment
    var TypeFormatFlags;
    (function (TypeFormatFlags) {
        TypeFormatFlags[TypeFormatFlags["None"] = 0] = "None";
        TypeFormatFlags[TypeFormatFlags["NoTruncation"] = 1] = "NoTruncation";
        TypeFormatFlags[TypeFormatFlags["WriteArrayAsGenericType"] = 2] = "WriteArrayAsGenericType";
        // hole because there's a hole in node builder flags
        TypeFormatFlags[TypeFormatFlags["UseStructuralFallback"] = 8] = "UseStructuralFallback";
        // hole because there's a hole in node builder flags
        TypeFormatFlags[TypeFormatFlags["WriteTypeArgumentsOfSignature"] = 32] = "WriteTypeArgumentsOfSignature";
        TypeFormatFlags[TypeFormatFlags["UseFullyQualifiedType"] = 64] = "UseFullyQualifiedType";
        // hole because `UseOnlyExternalAliasing` is here in node builder flags, but functions which take old flags use `SymbolFormatFlags` instead
        TypeFormatFlags[TypeFormatFlags["SuppressAnyReturnType"] = 256] = "SuppressAnyReturnType";
        // hole because `WriteTypeParametersInQualifiedName` is here in node builder flags, but functions which take old flags use `SymbolFormatFlags` for this instead
        TypeFormatFlags[TypeFormatFlags["MultilineObjectLiterals"] = 1024] = "MultilineObjectLiterals";
        TypeFormatFlags[TypeFormatFlags["WriteClassExpressionAsTypeLiteral"] = 2048] = "WriteClassExpressionAsTypeLiteral";
        TypeFormatFlags[TypeFormatFlags["UseTypeOfFunction"] = 4096] = "UseTypeOfFunction";
        TypeFormatFlags[TypeFormatFlags["OmitParameterModifiers"] = 8192] = "OmitParameterModifiers";
        TypeFormatFlags[TypeFormatFlags["UseAliasDefinedOutsideCurrentScope"] = 16384] = "UseAliasDefinedOutsideCurrentScope";
        TypeFormatFlags[TypeFormatFlags["UseSingleQuotesForStringLiteralType"] = 268435456] = "UseSingleQuotesForStringLiteralType";
        TypeFormatFlags[TypeFormatFlags["NoTypeReduction"] = 536870912] = "NoTypeReduction";
        TypeFormatFlags[TypeFormatFlags["OmitThisParameter"] = 33554432] = "OmitThisParameter";
        // Error Handling
        TypeFormatFlags[TypeFormatFlags["AllowUniqueESSymbolType"] = 1048576] = "AllowUniqueESSymbolType";
        // TypeFormatFlags exclusive
        TypeFormatFlags[TypeFormatFlags["AddUndefined"] = 131072] = "AddUndefined";
        TypeFormatFlags[TypeFormatFlags["WriteArrowStyleSignature"] = 262144] = "WriteArrowStyleSignature";
        // State
        TypeFormatFlags[TypeFormatFlags["InArrayType"] = 524288] = "InArrayType";
        TypeFormatFlags[TypeFormatFlags["InElementType"] = 2097152] = "InElementType";
        TypeFormatFlags[TypeFormatFlags["InFirstTypeArgument"] = 4194304] = "InFirstTypeArgument";
        TypeFormatFlags[TypeFormatFlags["InTypeAlias"] = 8388608] = "InTypeAlias";
        /** @deprecated */ TypeFormatFlags[TypeFormatFlags["WriteOwnNameForAnyLike"] = 0] = "WriteOwnNameForAnyLike";
        TypeFormatFlags[TypeFormatFlags["NodeBuilderFlagsMask"] = 848330091] = "NodeBuilderFlagsMask";
    })(TypeFormatFlags = ts.TypeFormatFlags || (ts.TypeFormatFlags = {}));
    var SymbolFormatFlags;
    (function (SymbolFormatFlags) {
        SymbolFormatFlags[SymbolFormatFlags["None"] = 0] = "None";
        // Write symbols's type argument if it is instantiated symbol
        // eg. class C<T> { p: T }   <-- Show p as C<T>.p here
        //     var a: C<number>;
        //     var p = a.p; <--- Here p is property of C<number> so show it as C<number>.p instead of just C.p
        SymbolFormatFlags[SymbolFormatFlags["WriteTypeParametersOrArguments"] = 1] = "WriteTypeParametersOrArguments";
        // Use only external alias information to get the symbol name in the given context
        // eg.  module m { export class c { } } import x = m.c;
        // When this flag is specified m.c will be used to refer to the class instead of alias symbol x
        SymbolFormatFlags[SymbolFormatFlags["UseOnlyExternalAliasing"] = 2] = "UseOnlyExternalAliasing";
        // Build symbol name using any nodes needed, instead of just components of an entity name
        SymbolFormatFlags[SymbolFormatFlags["AllowAnyNodeKind"] = 4] = "AllowAnyNodeKind";
        // Prefer aliases which are not directly visible
        SymbolFormatFlags[SymbolFormatFlags["UseAliasDefinedOutsideCurrentScope"] = 8] = "UseAliasDefinedOutsideCurrentScope";
        // Skip building an accessible symbol chain
        /* @internal */ SymbolFormatFlags[SymbolFormatFlags["DoNotIncludeSymbolChain"] = 16] = "DoNotIncludeSymbolChain";
    })(SymbolFormatFlags = ts.SymbolFormatFlags || (ts.SymbolFormatFlags = {}));
    /* @internal */
    var SymbolAccessibility;
    (function (SymbolAccessibility) {
        SymbolAccessibility[SymbolAccessibility["Accessible"] = 0] = "Accessible";
        SymbolAccessibility[SymbolAccessibility["NotAccessible"] = 1] = "NotAccessible";
        SymbolAccessibility[SymbolAccessibility["CannotBeNamed"] = 2] = "CannotBeNamed";
    })(SymbolAccessibility = ts.SymbolAccessibility || (ts.SymbolAccessibility = {}));
    /* @internal */
    var SyntheticSymbolKind;
    (function (SyntheticSymbolKind) {
        SyntheticSymbolKind[SyntheticSymbolKind["UnionOrIntersection"] = 0] = "UnionOrIntersection";
        SyntheticSymbolKind[SyntheticSymbolKind["Spread"] = 1] = "Spread";
    })(SyntheticSymbolKind = ts.SyntheticSymbolKind || (ts.SyntheticSymbolKind = {}));
    var TypePredicateKind;
    (function (TypePredicateKind) {
        TypePredicateKind[TypePredicateKind["This"] = 0] = "This";
        TypePredicateKind[TypePredicateKind["Identifier"] = 1] = "Identifier";
        TypePredicateKind[TypePredicateKind["AssertsThis"] = 2] = "AssertsThis";
        TypePredicateKind[TypePredicateKind["AssertsIdentifier"] = 3] = "AssertsIdentifier";
    })(TypePredicateKind = ts.TypePredicateKind || (ts.TypePredicateKind = {}));
    /** Indicates how to serialize the name for a TypeReferenceNode when emitting decorator metadata */
    /* @internal */
    var TypeReferenceSerializationKind;
    (function (TypeReferenceSerializationKind) {
        // The TypeReferenceNode could not be resolved.
        // The type name should be emitted using a safe fallback.
        TypeReferenceSerializationKind[TypeReferenceSerializationKind["Unknown"] = 0] = "Unknown";
        // The TypeReferenceNode resolves to a type with a constructor
        // function that can be reached at runtime (e.g. a `class`
        // declaration or a `var` declaration for the static side
        // of a type, such as the global `Promise` type in lib.d.ts).
        TypeReferenceSerializationKind[TypeReferenceSerializationKind["TypeWithConstructSignatureAndValue"] = 1] = "TypeWithConstructSignatureAndValue";
        // The TypeReferenceNode resolves to a Void-like, Nullable, or Never type.
        TypeReferenceSerializationKind[TypeReferenceSerializationKind["VoidNullableOrNeverType"] = 2] = "VoidNullableOrNeverType";
        // The TypeReferenceNode resolves to a Number-like type.
        TypeReferenceSerializationKind[TypeReferenceSerializationKind["NumberLikeType"] = 3] = "NumberLikeType";
        // The TypeReferenceNode resolves to a BigInt-like type.
        TypeReferenceSerializationKind[TypeReferenceSerializationKind["BigIntLikeType"] = 4] = "BigIntLikeType";
        // The TypeReferenceNode resolves to a String-like type.
        TypeReferenceSerializationKind[TypeReferenceSerializationKind["StringLikeType"] = 5] = "StringLikeType";
        // The TypeReferenceNode resolves to a Boolean-like type.
        TypeReferenceSerializationKind[TypeReferenceSerializationKind["BooleanType"] = 6] = "BooleanType";
        // The TypeReferenceNode resolves to an Array-like type.
        TypeReferenceSerializationKind[TypeReferenceSerializationKind["ArrayLikeType"] = 7] = "ArrayLikeType";
        // The TypeReferenceNode resolves to the ESSymbol type.
        TypeReferenceSerializationKind[TypeReferenceSerializationKind["ESSymbolType"] = 8] = "ESSymbolType";
        // The TypeReferenceNode resolved to the global Promise constructor symbol.
        TypeReferenceSerializationKind[TypeReferenceSerializationKind["Promise"] = 9] = "Promise";
        // The TypeReferenceNode resolves to a Function type or a type with call signatures.
        TypeReferenceSerializationKind[TypeReferenceSerializationKind["TypeWithCallSignature"] = 10] = "TypeWithCallSignature";
        // The TypeReferenceNode resolves to any other type.
        TypeReferenceSerializationKind[TypeReferenceSerializationKind["ObjectType"] = 11] = "ObjectType";
    })(TypeReferenceSerializationKind = ts.TypeReferenceSerializationKind || (ts.TypeReferenceSerializationKind = {}));
    var SymbolFlags;
    (function (SymbolFlags) {
        SymbolFlags[SymbolFlags["None"] = 0] = "None";
        SymbolFlags[SymbolFlags["FunctionScopedVariable"] = 1] = "FunctionScopedVariable";
        SymbolFlags[SymbolFlags["BlockScopedVariable"] = 2] = "BlockScopedVariable";
        SymbolFlags[SymbolFlags["Property"] = 4] = "Property";
        SymbolFlags[SymbolFlags["EnumMember"] = 8] = "EnumMember";
        SymbolFlags[SymbolFlags["Function"] = 16] = "Function";
        SymbolFlags[SymbolFlags["Class"] = 32] = "Class";
        SymbolFlags[SymbolFlags["Interface"] = 64] = "Interface";
        SymbolFlags[SymbolFlags["ConstEnum"] = 128] = "ConstEnum";
        SymbolFlags[SymbolFlags["RegularEnum"] = 256] = "RegularEnum";
        SymbolFlags[SymbolFlags["ValueModule"] = 512] = "ValueModule";
        SymbolFlags[SymbolFlags["NamespaceModule"] = 1024] = "NamespaceModule";
        SymbolFlags[SymbolFlags["TypeLiteral"] = 2048] = "TypeLiteral";
        SymbolFlags[SymbolFlags["ObjectLiteral"] = 4096] = "ObjectLiteral";
        SymbolFlags[SymbolFlags["Method"] = 8192] = "Method";
        SymbolFlags[SymbolFlags["Constructor"] = 16384] = "Constructor";
        SymbolFlags[SymbolFlags["GetAccessor"] = 32768] = "GetAccessor";
        SymbolFlags[SymbolFlags["SetAccessor"] = 65536] = "SetAccessor";
        SymbolFlags[SymbolFlags["Signature"] = 131072] = "Signature";
        SymbolFlags[SymbolFlags["TypeParameter"] = 262144] = "TypeParameter";
        SymbolFlags[SymbolFlags["TypeAlias"] = 524288] = "TypeAlias";
        SymbolFlags[SymbolFlags["ExportValue"] = 1048576] = "ExportValue";
        SymbolFlags[SymbolFlags["Alias"] = 2097152] = "Alias";
        SymbolFlags[SymbolFlags["Prototype"] = 4194304] = "Prototype";
        SymbolFlags[SymbolFlags["ExportStar"] = 8388608] = "ExportStar";
        SymbolFlags[SymbolFlags["Optional"] = 16777216] = "Optional";
        SymbolFlags[SymbolFlags["Transient"] = 33554432] = "Transient";
        SymbolFlags[SymbolFlags["Assignment"] = 67108864] = "Assignment";
        SymbolFlags[SymbolFlags["ModuleExports"] = 134217728] = "ModuleExports";
        /* @internal */
        SymbolFlags[SymbolFlags["All"] = 67108863] = "All";
        SymbolFlags[SymbolFlags["Enum"] = 384] = "Enum";
        SymbolFlags[SymbolFlags["Variable"] = 3] = "Variable";
        SymbolFlags[SymbolFlags["Value"] = 111551] = "Value";
        SymbolFlags[SymbolFlags["Type"] = 788968] = "Type";
        SymbolFlags[SymbolFlags["Namespace"] = 1920] = "Namespace";
        SymbolFlags[SymbolFlags["Module"] = 1536] = "Module";
        SymbolFlags[SymbolFlags["Accessor"] = 98304] = "Accessor";
        // Variables can be redeclared, but can not redeclare a block-scoped declaration with the
        // same name, or any other value that is not a variable, e.g. ValueModule or Class
        SymbolFlags[SymbolFlags["FunctionScopedVariableExcludes"] = 111550] = "FunctionScopedVariableExcludes";
        // Block-scoped declarations are not allowed to be re-declared
        // they can not merge with anything in the value space
        SymbolFlags[SymbolFlags["BlockScopedVariableExcludes"] = 111551] = "BlockScopedVariableExcludes";
        SymbolFlags[SymbolFlags["ParameterExcludes"] = 111551] = "ParameterExcludes";
        SymbolFlags[SymbolFlags["PropertyExcludes"] = 0] = "PropertyExcludes";
        SymbolFlags[SymbolFlags["EnumMemberExcludes"] = 900095] = "EnumMemberExcludes";
        SymbolFlags[SymbolFlags["FunctionExcludes"] = 110991] = "FunctionExcludes";
        SymbolFlags[SymbolFlags["ClassExcludes"] = 899503] = "ClassExcludes";
        SymbolFlags[SymbolFlags["InterfaceExcludes"] = 788872] = "InterfaceExcludes";
        SymbolFlags[SymbolFlags["RegularEnumExcludes"] = 899327] = "RegularEnumExcludes";
        SymbolFlags[SymbolFlags["ConstEnumExcludes"] = 899967] = "ConstEnumExcludes";
        SymbolFlags[SymbolFlags["ValueModuleExcludes"] = 110735] = "ValueModuleExcludes";
        SymbolFlags[SymbolFlags["NamespaceModuleExcludes"] = 0] = "NamespaceModuleExcludes";
        SymbolFlags[SymbolFlags["MethodExcludes"] = 103359] = "MethodExcludes";
        SymbolFlags[SymbolFlags["GetAccessorExcludes"] = 46015] = "GetAccessorExcludes";
        SymbolFlags[SymbolFlags["SetAccessorExcludes"] = 78783] = "SetAccessorExcludes";
        SymbolFlags[SymbolFlags["TypeParameterExcludes"] = 526824] = "TypeParameterExcludes";
        SymbolFlags[SymbolFlags["TypeAliasExcludes"] = 788968] = "TypeAliasExcludes";
        SymbolFlags[SymbolFlags["AliasExcludes"] = 2097152] = "AliasExcludes";
        SymbolFlags[SymbolFlags["ModuleMember"] = 2623475] = "ModuleMember";
        SymbolFlags[SymbolFlags["ExportHasLocal"] = 944] = "ExportHasLocal";
        SymbolFlags[SymbolFlags["BlockScoped"] = 418] = "BlockScoped";
        SymbolFlags[SymbolFlags["PropertyOrAccessor"] = 98308] = "PropertyOrAccessor";
        SymbolFlags[SymbolFlags["ClassMember"] = 106500] = "ClassMember";
        /* @internal */
        SymbolFlags[SymbolFlags["ExportSupportsDefaultModifier"] = 112] = "ExportSupportsDefaultModifier";
        /* @internal */
        SymbolFlags[SymbolFlags["ExportDoesNotSupportDefaultModifier"] = -113] = "ExportDoesNotSupportDefaultModifier";
        /* @internal */
        // The set of things we consider semantically classifiable.  Used to speed up the LS during
        // classification.
        SymbolFlags[SymbolFlags["Classifiable"] = 2885600] = "Classifiable";
        /* @internal */
        SymbolFlags[SymbolFlags["LateBindingContainer"] = 6256] = "LateBindingContainer";
    })(SymbolFlags = ts.SymbolFlags || (ts.SymbolFlags = {}));
    /* @internal */
    var EnumKind;
    (function (EnumKind) {
        EnumKind[EnumKind["Numeric"] = 0] = "Numeric";
        EnumKind[EnumKind["Literal"] = 1] = "Literal"; // Literal enum (each member has a TypeFlags.EnumLiteral type)
    })(EnumKind = ts.EnumKind || (ts.EnumKind = {}));
    /* @internal */
    var CheckFlags;
    (function (CheckFlags) {
        CheckFlags[CheckFlags["Instantiated"] = 1] = "Instantiated";
        CheckFlags[CheckFlags["SyntheticProperty"] = 2] = "SyntheticProperty";
        CheckFlags[CheckFlags["SyntheticMethod"] = 4] = "SyntheticMethod";
        CheckFlags[CheckFlags["Readonly"] = 8] = "Readonly";
        CheckFlags[CheckFlags["ReadPartial"] = 16] = "ReadPartial";
        CheckFlags[CheckFlags["WritePartial"] = 32] = "WritePartial";
        CheckFlags[CheckFlags["HasNonUniformType"] = 64] = "HasNonUniformType";
        CheckFlags[CheckFlags["HasLiteralType"] = 128] = "HasLiteralType";
        CheckFlags[CheckFlags["ContainsPublic"] = 256] = "ContainsPublic";
        CheckFlags[CheckFlags["ContainsProtected"] = 512] = "ContainsProtected";
        CheckFlags[CheckFlags["ContainsPrivate"] = 1024] = "ContainsPrivate";
        CheckFlags[CheckFlags["ContainsStatic"] = 2048] = "ContainsStatic";
        CheckFlags[CheckFlags["Late"] = 4096] = "Late";
        CheckFlags[CheckFlags["ReverseMapped"] = 8192] = "ReverseMapped";
        CheckFlags[CheckFlags["OptionalParameter"] = 16384] = "OptionalParameter";
        CheckFlags[CheckFlags["RestParameter"] = 32768] = "RestParameter";
        CheckFlags[CheckFlags["DeferredType"] = 65536] = "DeferredType";
        CheckFlags[CheckFlags["HasNeverType"] = 131072] = "HasNeverType";
        CheckFlags[CheckFlags["Mapped"] = 262144] = "Mapped";
        CheckFlags[CheckFlags["StripOptional"] = 524288] = "StripOptional";
        CheckFlags[CheckFlags["Unresolved"] = 1048576] = "Unresolved";
        CheckFlags[CheckFlags["Synthetic"] = 6] = "Synthetic";
        CheckFlags[CheckFlags["Discriminant"] = 192] = "Discriminant";
        CheckFlags[CheckFlags["Partial"] = 48] = "Partial";
    })(CheckFlags = ts.CheckFlags || (ts.CheckFlags = {}));
    var InternalSymbolName;
    (function (InternalSymbolName) {
        InternalSymbolName["Call"] = "__call";
        InternalSymbolName["Constructor"] = "__constructor";
        InternalSymbolName["New"] = "__new";
        InternalSymbolName["Index"] = "__index";
        InternalSymbolName["ExportStar"] = "__export";
        InternalSymbolName["Global"] = "__global";
        InternalSymbolName["Missing"] = "__missing";
        InternalSymbolName["Type"] = "__type";
        InternalSymbolName["Object"] = "__object";
        InternalSymbolName["JSXAttributes"] = "__jsxAttributes";
        InternalSymbolName["Class"] = "__class";
        InternalSymbolName["Function"] = "__function";
        InternalSymbolName["Computed"] = "__computed";
        InternalSymbolName["Resolving"] = "__resolving__";
        InternalSymbolName["ExportEquals"] = "export=";
        InternalSymbolName["Default"] = "default";
        InternalSymbolName["This"] = "this";
    })(InternalSymbolName = ts.InternalSymbolName || (ts.InternalSymbolName = {}));
    /* @internal */
    var NodeCheckFlags;
    (function (NodeCheckFlags) {
        NodeCheckFlags[NodeCheckFlags["TypeChecked"] = 1] = "TypeChecked";
        NodeCheckFlags[NodeCheckFlags["LexicalThis"] = 2] = "LexicalThis";
        NodeCheckFlags[NodeCheckFlags["CaptureThis"] = 4] = "CaptureThis";
        NodeCheckFlags[NodeCheckFlags["CaptureNewTarget"] = 8] = "CaptureNewTarget";
        NodeCheckFlags[NodeCheckFlags["SuperInstance"] = 256] = "SuperInstance";
        NodeCheckFlags[NodeCheckFlags["SuperStatic"] = 512] = "SuperStatic";
        NodeCheckFlags[NodeCheckFlags["ContextChecked"] = 1024] = "ContextChecked";
        NodeCheckFlags[NodeCheckFlags["AsyncMethodWithSuper"] = 2048] = "AsyncMethodWithSuper";
        NodeCheckFlags[NodeCheckFlags["AsyncMethodWithSuperBinding"] = 4096] = "AsyncMethodWithSuperBinding";
        NodeCheckFlags[NodeCheckFlags["CaptureArguments"] = 8192] = "CaptureArguments";
        NodeCheckFlags[NodeCheckFlags["EnumValuesComputed"] = 16384] = "EnumValuesComputed";
        NodeCheckFlags[NodeCheckFlags["LexicalModuleMergesWithClass"] = 32768] = "LexicalModuleMergesWithClass";
        NodeCheckFlags[NodeCheckFlags["LoopWithCapturedBlockScopedBinding"] = 65536] = "LoopWithCapturedBlockScopedBinding";
        NodeCheckFlags[NodeCheckFlags["ContainsCapturedBlockScopeBinding"] = 131072] = "ContainsCapturedBlockScopeBinding";
        NodeCheckFlags[NodeCheckFlags["CapturedBlockScopedBinding"] = 262144] = "CapturedBlockScopedBinding";
        NodeCheckFlags[NodeCheckFlags["BlockScopedBindingInLoop"] = 524288] = "BlockScopedBindingInLoop";
        NodeCheckFlags[NodeCheckFlags["ClassWithBodyScopedClassBinding"] = 1048576] = "ClassWithBodyScopedClassBinding";
        NodeCheckFlags[NodeCheckFlags["BodyScopedClassBinding"] = 2097152] = "BodyScopedClassBinding";
        NodeCheckFlags[NodeCheckFlags["NeedsLoopOutParameter"] = 4194304] = "NeedsLoopOutParameter";
        NodeCheckFlags[NodeCheckFlags["AssignmentsMarked"] = 8388608] = "AssignmentsMarked";
        NodeCheckFlags[NodeCheckFlags["ClassWithConstructorReference"] = 16777216] = "ClassWithConstructorReference";
        NodeCheckFlags[NodeCheckFlags["ConstructorReferenceInClass"] = 33554432] = "ConstructorReferenceInClass";
        NodeCheckFlags[NodeCheckFlags["ContainsClassWithPrivateIdentifiers"] = 67108864] = "ContainsClassWithPrivateIdentifiers";
        NodeCheckFlags[NodeCheckFlags["ContainsSuperPropertyInStaticInitializer"] = 134217728] = "ContainsSuperPropertyInStaticInitializer";
        NodeCheckFlags[NodeCheckFlags["InCheckIdentifier"] = 268435456] = "InCheckIdentifier";
    })(NodeCheckFlags = ts.NodeCheckFlags || (ts.NodeCheckFlags = {}));
    var TypeFlags;
    (function (TypeFlags) {
        TypeFlags[TypeFlags["Any"] = 1] = "Any";
        TypeFlags[TypeFlags["Unknown"] = 2] = "Unknown";
        TypeFlags[TypeFlags["String"] = 4] = "String";
        TypeFlags[TypeFlags["Number"] = 8] = "Number";
        TypeFlags[TypeFlags["Boolean"] = 16] = "Boolean";
        TypeFlags[TypeFlags["Enum"] = 32] = "Enum";
        TypeFlags[TypeFlags["BigInt"] = 64] = "BigInt";
        TypeFlags[TypeFlags["StringLiteral"] = 128] = "StringLiteral";
        TypeFlags[TypeFlags["NumberLiteral"] = 256] = "NumberLiteral";
        TypeFlags[TypeFlags["BooleanLiteral"] = 512] = "BooleanLiteral";
        TypeFlags[TypeFlags["EnumLiteral"] = 1024] = "EnumLiteral";
        TypeFlags[TypeFlags["BigIntLiteral"] = 2048] = "BigIntLiteral";
        TypeFlags[TypeFlags["ESSymbol"] = 4096] = "ESSymbol";
        TypeFlags[TypeFlags["UniqueESSymbol"] = 8192] = "UniqueESSymbol";
        TypeFlags[TypeFlags["Void"] = 16384] = "Void";
        TypeFlags[TypeFlags["Undefined"] = 32768] = "Undefined";
        TypeFlags[TypeFlags["Null"] = 65536] = "Null";
        TypeFlags[TypeFlags["Never"] = 131072] = "Never";
        TypeFlags[TypeFlags["TypeParameter"] = 262144] = "TypeParameter";
        TypeFlags[TypeFlags["Object"] = 524288] = "Object";
        TypeFlags[TypeFlags["Union"] = 1048576] = "Union";
        TypeFlags[TypeFlags["Intersection"] = 2097152] = "Intersection";
        TypeFlags[TypeFlags["Index"] = 4194304] = "Index";
        TypeFlags[TypeFlags["IndexedAccess"] = 8388608] = "IndexedAccess";
        TypeFlags[TypeFlags["Conditional"] = 16777216] = "Conditional";
        TypeFlags[TypeFlags["Substitution"] = 33554432] = "Substitution";
        TypeFlags[TypeFlags["NonPrimitive"] = 67108864] = "NonPrimitive";
        TypeFlags[TypeFlags["TemplateLiteral"] = 134217728] = "TemplateLiteral";
        TypeFlags[TypeFlags["StringMapping"] = 268435456] = "StringMapping";
        /* @internal */
        TypeFlags[TypeFlags["AnyOrUnknown"] = 3] = "AnyOrUnknown";
        /* @internal */
        TypeFlags[TypeFlags["Nullable"] = 98304] = "Nullable";
        TypeFlags[TypeFlags["Literal"] = 2944] = "Literal";
        TypeFlags[TypeFlags["Unit"] = 109440] = "Unit";
        TypeFlags[TypeFlags["StringOrNumberLiteral"] = 384] = "StringOrNumberLiteral";
        /* @internal */
        TypeFlags[TypeFlags["StringOrNumberLiteralOrUnique"] = 8576] = "StringOrNumberLiteralOrUnique";
        /* @internal */
        TypeFlags[TypeFlags["DefinitelyFalsy"] = 117632] = "DefinitelyFalsy";
        TypeFlags[TypeFlags["PossiblyFalsy"] = 117724] = "PossiblyFalsy";
        /* @internal */
        TypeFlags[TypeFlags["Intrinsic"] = 67359327] = "Intrinsic";
        /* @internal */
        TypeFlags[TypeFlags["Primitive"] = 131068] = "Primitive";
        TypeFlags[TypeFlags["StringLike"] = 402653316] = "StringLike";
        TypeFlags[TypeFlags["NumberLike"] = 296] = "NumberLike";
        TypeFlags[TypeFlags["BigIntLike"] = 2112] = "BigIntLike";
        TypeFlags[TypeFlags["BooleanLike"] = 528] = "BooleanLike";
        TypeFlags[TypeFlags["EnumLike"] = 1056] = "EnumLike";
        TypeFlags[TypeFlags["ESSymbolLike"] = 12288] = "ESSymbolLike";
        TypeFlags[TypeFlags["VoidLike"] = 49152] = "VoidLike";
        /* @internal */
        TypeFlags[TypeFlags["DefinitelyNonNullable"] = 470302716] = "DefinitelyNonNullable";
        /* @internal */
        TypeFlags[TypeFlags["DisjointDomains"] = 469892092] = "DisjointDomains";
        TypeFlags[TypeFlags["UnionOrIntersection"] = 3145728] = "UnionOrIntersection";
        TypeFlags[TypeFlags["StructuredType"] = 3670016] = "StructuredType";
        TypeFlags[TypeFlags["TypeVariable"] = 8650752] = "TypeVariable";
        TypeFlags[TypeFlags["InstantiableNonPrimitive"] = 58982400] = "InstantiableNonPrimitive";
        TypeFlags[TypeFlags["InstantiablePrimitive"] = 406847488] = "InstantiablePrimitive";
        TypeFlags[TypeFlags["Instantiable"] = 465829888] = "Instantiable";
        TypeFlags[TypeFlags["StructuredOrInstantiable"] = 469499904] = "StructuredOrInstantiable";
        /* @internal */
        TypeFlags[TypeFlags["ObjectFlagsType"] = 3899393] = "ObjectFlagsType";
        /* @internal */
        TypeFlags[TypeFlags["Simplifiable"] = 25165824] = "Simplifiable";
        /* @internal */
        TypeFlags[TypeFlags["Singleton"] = 67358815] = "Singleton";
        // 'Narrowable' types are types where narrowing actually narrows.
        // This *should* be every type other than null, undefined, void, and never
        TypeFlags[TypeFlags["Narrowable"] = 536624127] = "Narrowable";
        // The following flags are aggregated during union and intersection type construction
        /* @internal */
        TypeFlags[TypeFlags["IncludesMask"] = 205258751] = "IncludesMask";
        // The following flags are used for different purposes during union and intersection type construction
        /* @internal */
        TypeFlags[TypeFlags["IncludesMissingType"] = 262144] = "IncludesMissingType";
        /* @internal */
        TypeFlags[TypeFlags["IncludesNonWideningType"] = 4194304] = "IncludesNonWideningType";
        /* @internal */
        TypeFlags[TypeFlags["IncludesWildcard"] = 8388608] = "IncludesWildcard";
        /* @internal */
        TypeFlags[TypeFlags["IncludesEmptyObject"] = 16777216] = "IncludesEmptyObject";
        /* @internal */
        TypeFlags[TypeFlags["IncludesInstantiable"] = 33554432] = "IncludesInstantiable";
        /* @internal */
        TypeFlags[TypeFlags["NotPrimitiveUnion"] = 36323363] = "NotPrimitiveUnion";
    })(TypeFlags = ts.TypeFlags || (ts.TypeFlags = {}));
    // Types included in TypeFlags.ObjectFlagsType have an objectFlags property. Some ObjectFlags
    // are specific to certain types and reuse the same bit position. Those ObjectFlags require a check
    // for a certain TypeFlags value to determine their meaning.
    var ObjectFlags;
    (function (ObjectFlags) {
        ObjectFlags[ObjectFlags["Class"] = 1] = "Class";
        ObjectFlags[ObjectFlags["Interface"] = 2] = "Interface";
        ObjectFlags[ObjectFlags["Reference"] = 4] = "Reference";
        ObjectFlags[ObjectFlags["Tuple"] = 8] = "Tuple";
        ObjectFlags[ObjectFlags["Anonymous"] = 16] = "Anonymous";
        ObjectFlags[ObjectFlags["Mapped"] = 32] = "Mapped";
        ObjectFlags[ObjectFlags["Instantiated"] = 64] = "Instantiated";
        ObjectFlags[ObjectFlags["ObjectLiteral"] = 128] = "ObjectLiteral";
        ObjectFlags[ObjectFlags["EvolvingArray"] = 256] = "EvolvingArray";
        ObjectFlags[ObjectFlags["ObjectLiteralPatternWithComputedProperties"] = 512] = "ObjectLiteralPatternWithComputedProperties";
        ObjectFlags[ObjectFlags["ReverseMapped"] = 1024] = "ReverseMapped";
        ObjectFlags[ObjectFlags["JsxAttributes"] = 2048] = "JsxAttributes";
        ObjectFlags[ObjectFlags["JSLiteral"] = 4096] = "JSLiteral";
        ObjectFlags[ObjectFlags["FreshLiteral"] = 8192] = "FreshLiteral";
        ObjectFlags[ObjectFlags["ArrayLiteral"] = 16384] = "ArrayLiteral";
        /* @internal */
        ObjectFlags[ObjectFlags["PrimitiveUnion"] = 32768] = "PrimitiveUnion";
        /* @internal */
        ObjectFlags[ObjectFlags["ContainsWideningType"] = 65536] = "ContainsWideningType";
        /* @internal */
        ObjectFlags[ObjectFlags["ContainsObjectOrArrayLiteral"] = 131072] = "ContainsObjectOrArrayLiteral";
        /* @internal */
        ObjectFlags[ObjectFlags["NonInferrableType"] = 262144] = "NonInferrableType";
        /* @internal */
        ObjectFlags[ObjectFlags["CouldContainTypeVariablesComputed"] = 524288] = "CouldContainTypeVariablesComputed";
        /* @internal */
        ObjectFlags[ObjectFlags["CouldContainTypeVariables"] = 1048576] = "CouldContainTypeVariables";
        ObjectFlags[ObjectFlags["ClassOrInterface"] = 3] = "ClassOrInterface";
        /* @internal */
        ObjectFlags[ObjectFlags["RequiresWidening"] = 196608] = "RequiresWidening";
        /* @internal */
        ObjectFlags[ObjectFlags["PropagatingFlags"] = 458752] = "PropagatingFlags";
        // Object flags that uniquely identify the kind of ObjectType
        /* @internal */
        ObjectFlags[ObjectFlags["ObjectTypeKindMask"] = 1343] = "ObjectTypeKindMask";
        // Flags that require TypeFlags.Object
        ObjectFlags[ObjectFlags["ContainsSpread"] = 2097152] = "ContainsSpread";
        ObjectFlags[ObjectFlags["ObjectRestType"] = 4194304] = "ObjectRestType";
        ObjectFlags[ObjectFlags["InstantiationExpressionType"] = 8388608] = "InstantiationExpressionType";
        /* @internal */
        ObjectFlags[ObjectFlags["IsClassInstanceClone"] = 16777216] = "IsClassInstanceClone";
        // Flags that require TypeFlags.Object and ObjectFlags.Reference
        /* @internal */
        ObjectFlags[ObjectFlags["IdenticalBaseTypeCalculated"] = 33554432] = "IdenticalBaseTypeCalculated";
        /* @internal */
        ObjectFlags[ObjectFlags["IdenticalBaseTypeExists"] = 67108864] = "IdenticalBaseTypeExists";
        // Flags that require TypeFlags.UnionOrIntersection or TypeFlags.Substitution
        /* @internal */
        ObjectFlags[ObjectFlags["IsGenericTypeComputed"] = 2097152] = "IsGenericTypeComputed";
        /* @internal */
        ObjectFlags[ObjectFlags["IsGenericObjectType"] = 4194304] = "IsGenericObjectType";
        /* @internal */
        ObjectFlags[ObjectFlags["IsGenericIndexType"] = 8388608] = "IsGenericIndexType";
        /* @internal */
        ObjectFlags[ObjectFlags["IsGenericType"] = 12582912] = "IsGenericType";
        // Flags that require TypeFlags.Union
        /* @internal */
        ObjectFlags[ObjectFlags["ContainsIntersections"] = 16777216] = "ContainsIntersections";
        /* @internal */
        ObjectFlags[ObjectFlags["IsUnknownLikeUnionComputed"] = 33554432] = "IsUnknownLikeUnionComputed";
        /* @internal */
        ObjectFlags[ObjectFlags["IsUnknownLikeUnion"] = 67108864] = "IsUnknownLikeUnion";
        /* @internal */
        // Flags that require TypeFlags.Intersection
        /* @internal */
        ObjectFlags[ObjectFlags["IsNeverIntersectionComputed"] = 16777216] = "IsNeverIntersectionComputed";
        /* @internal */
        ObjectFlags[ObjectFlags["IsNeverIntersection"] = 33554432] = "IsNeverIntersection";
    })(ObjectFlags = ts.ObjectFlags || (ts.ObjectFlags = {}));
    /* @internal */
    var VarianceFlags;
    (function (VarianceFlags) {
        VarianceFlags[VarianceFlags["Invariant"] = 0] = "Invariant";
        VarianceFlags[VarianceFlags["Covariant"] = 1] = "Covariant";
        VarianceFlags[VarianceFlags["Contravariant"] = 2] = "Contravariant";
        VarianceFlags[VarianceFlags["Bivariant"] = 3] = "Bivariant";
        VarianceFlags[VarianceFlags["Independent"] = 4] = "Independent";
        VarianceFlags[VarianceFlags["VarianceMask"] = 7] = "VarianceMask";
        VarianceFlags[VarianceFlags["Unmeasurable"] = 8] = "Unmeasurable";
        VarianceFlags[VarianceFlags["Unreliable"] = 16] = "Unreliable";
        VarianceFlags[VarianceFlags["AllowsStructuralFallback"] = 24] = "AllowsStructuralFallback";
    })(VarianceFlags = ts.VarianceFlags || (ts.VarianceFlags = {}));
    var ElementFlags;
    (function (ElementFlags) {
        ElementFlags[ElementFlags["Required"] = 1] = "Required";
        ElementFlags[ElementFlags["Optional"] = 2] = "Optional";
        ElementFlags[ElementFlags["Rest"] = 4] = "Rest";
        ElementFlags[ElementFlags["Variadic"] = 8] = "Variadic";
        ElementFlags[ElementFlags["Fixed"] = 3] = "Fixed";
        ElementFlags[ElementFlags["Variable"] = 12] = "Variable";
        ElementFlags[ElementFlags["NonRequired"] = 14] = "NonRequired";
        ElementFlags[ElementFlags["NonRest"] = 11] = "NonRest";
    })(ElementFlags = ts.ElementFlags || (ts.ElementFlags = {}));
    /* @internal */
    var AccessFlags;
    (function (AccessFlags) {
        AccessFlags[AccessFlags["None"] = 0] = "None";
        AccessFlags[AccessFlags["IncludeUndefined"] = 1] = "IncludeUndefined";
        AccessFlags[AccessFlags["NoIndexSignatures"] = 2] = "NoIndexSignatures";
        AccessFlags[AccessFlags["Writing"] = 4] = "Writing";
        AccessFlags[AccessFlags["CacheSymbol"] = 8] = "CacheSymbol";
        AccessFlags[AccessFlags["NoTupleBoundsCheck"] = 16] = "NoTupleBoundsCheck";
        AccessFlags[AccessFlags["ExpressionPosition"] = 32] = "ExpressionPosition";
        AccessFlags[AccessFlags["ReportDeprecated"] = 64] = "ReportDeprecated";
        AccessFlags[AccessFlags["SuppressNoImplicitAnyError"] = 128] = "SuppressNoImplicitAnyError";
        AccessFlags[AccessFlags["Contextual"] = 256] = "Contextual";
        AccessFlags[AccessFlags["Persistent"] = 1] = "Persistent";
    })(AccessFlags = ts.AccessFlags || (ts.AccessFlags = {}));
    /* @internal */
    var JsxReferenceKind;
    (function (JsxReferenceKind) {
        JsxReferenceKind[JsxReferenceKind["Component"] = 0] = "Component";
        JsxReferenceKind[JsxReferenceKind["Function"] = 1] = "Function";
        JsxReferenceKind[JsxReferenceKind["Mixed"] = 2] = "Mixed";
    })(JsxReferenceKind = ts.JsxReferenceKind || (ts.JsxReferenceKind = {}));
    var SignatureKind;
    (function (SignatureKind) {
        SignatureKind[SignatureKind["Call"] = 0] = "Call";
        SignatureKind[SignatureKind["Construct"] = 1] = "Construct";
    })(SignatureKind = ts.SignatureKind || (ts.SignatureKind = {}));
    /* @internal */
    var SignatureFlags;
    (function (SignatureFlags) {
        SignatureFlags[SignatureFlags["None"] = 0] = "None";
        // Propagating flags
        SignatureFlags[SignatureFlags["HasRestParameter"] = 1] = "HasRestParameter";
        SignatureFlags[SignatureFlags["HasLiteralTypes"] = 2] = "HasLiteralTypes";
        SignatureFlags[SignatureFlags["Abstract"] = 4] = "Abstract";
        // Non-propagating flags
        SignatureFlags[SignatureFlags["IsInnerCallChain"] = 8] = "IsInnerCallChain";
        SignatureFlags[SignatureFlags["IsOuterCallChain"] = 16] = "IsOuterCallChain";
        SignatureFlags[SignatureFlags["IsUntypedSignatureInJSFile"] = 32] = "IsUntypedSignatureInJSFile";
        // We do not propagate `IsInnerCallChain` or `IsOuterCallChain` to instantiated signatures, as that would result in us
        // attempting to add `| undefined` on each recursive call to `getReturnTypeOfSignature` when
        // instantiating the return type.
        SignatureFlags[SignatureFlags["PropagatingFlags"] = 39] = "PropagatingFlags";
        SignatureFlags[SignatureFlags["CallChainFlags"] = 24] = "CallChainFlags";
    })(SignatureFlags = ts.SignatureFlags || (ts.SignatureFlags = {}));
    var IndexKind;
    (function (IndexKind) {
        IndexKind[IndexKind["String"] = 0] = "String";
        IndexKind[IndexKind["Number"] = 1] = "Number";
    })(IndexKind = ts.IndexKind || (ts.IndexKind = {}));
    /* @internal */
    var TypeMapKind;
    (function (TypeMapKind) {
        TypeMapKind[TypeMapKind["Simple"] = 0] = "Simple";
        TypeMapKind[TypeMapKind["Array"] = 1] = "Array";
        TypeMapKind[TypeMapKind["Deferred"] = 2] = "Deferred";
        TypeMapKind[TypeMapKind["Function"] = 3] = "Function";
        TypeMapKind[TypeMapKind["Composite"] = 4] = "Composite";
        TypeMapKind[TypeMapKind["Merged"] = 5] = "Merged";
    })(TypeMapKind = ts.TypeMapKind || (ts.TypeMapKind = {}));
    var InferencePriority;
    (function (InferencePriority) {
        InferencePriority[InferencePriority["NakedTypeVariable"] = 1] = "NakedTypeVariable";
        InferencePriority[InferencePriority["SpeculativeTuple"] = 2] = "SpeculativeTuple";
        InferencePriority[InferencePriority["SubstituteSource"] = 4] = "SubstituteSource";
        InferencePriority[InferencePriority["HomomorphicMappedType"] = 8] = "HomomorphicMappedType";
        InferencePriority[InferencePriority["PartialHomomorphicMappedType"] = 16] = "PartialHomomorphicMappedType";
        InferencePriority[InferencePriority["MappedTypeConstraint"] = 32] = "MappedTypeConstraint";
        InferencePriority[InferencePriority["ContravariantConditional"] = 64] = "ContravariantConditional";
        InferencePriority[InferencePriority["ReturnType"] = 128] = "ReturnType";
        InferencePriority[InferencePriority["LiteralKeyof"] = 256] = "LiteralKeyof";
        InferencePriority[InferencePriority["NoConstraints"] = 512] = "NoConstraints";
        InferencePriority[InferencePriority["AlwaysStrict"] = 1024] = "AlwaysStrict";
        InferencePriority[InferencePriority["MaxValue"] = 2048] = "MaxValue";
        InferencePriority[InferencePriority["PriorityImpliesCombination"] = 416] = "PriorityImpliesCombination";
        InferencePriority[InferencePriority["Circularity"] = -1] = "Circularity";
    })(InferencePriority = ts.InferencePriority || (ts.InferencePriority = {}));
    /* @internal */
    var InferenceFlags;
    (function (InferenceFlags) {
        InferenceFlags[InferenceFlags["None"] = 0] = "None";
        InferenceFlags[InferenceFlags["NoDefault"] = 1] = "NoDefault";
        InferenceFlags[InferenceFlags["AnyDefault"] = 2] = "AnyDefault";
        InferenceFlags[InferenceFlags["SkippedGenericFunction"] = 4] = "SkippedGenericFunction";
    })(InferenceFlags = ts.InferenceFlags || (ts.InferenceFlags = {}));
    /**
     * Ternary values are defined such that
     * x & y picks the lesser in the order False < Unknown < Maybe < True, and
     * x | y picks the greater in the order False < Unknown < Maybe < True.
     * Generally, Ternary.Maybe is used as the result of a relation that depends on itself, and
     * Ternary.Unknown is used as the result of a variance check that depends on itself. We make
     * a distinction because we don't want to cache circular variance check results.
     */
    /* @internal */
    var Ternary;
    (function (Ternary) {
        Ternary[Ternary["False"] = 0] = "False";
        Ternary[Ternary["Unknown"] = 1] = "Unknown";
        Ternary[Ternary["Maybe"] = 3] = "Maybe";
        Ternary[Ternary["True"] = -1] = "True";
    })(Ternary = ts.Ternary || (ts.Ternary = {}));
    /* @internal */
    var AssignmentDeclarationKind;
    (function (AssignmentDeclarationKind) {
        AssignmentDeclarationKind[AssignmentDeclarationKind["None"] = 0] = "None";
        /// exports.name = expr
        /// module.exports.name = expr
        AssignmentDeclarationKind[AssignmentDeclarationKind["ExportsProperty"] = 1] = "ExportsProperty";
        /// module.exports = expr
        AssignmentDeclarationKind[AssignmentDeclarationKind["ModuleExports"] = 2] = "ModuleExports";
        /// className.prototype.name = expr
        AssignmentDeclarationKind[AssignmentDeclarationKind["PrototypeProperty"] = 3] = "PrototypeProperty";
        /// this.name = expr
        AssignmentDeclarationKind[AssignmentDeclarationKind["ThisProperty"] = 4] = "ThisProperty";
        // F.name = expr
        AssignmentDeclarationKind[AssignmentDeclarationKind["Property"] = 5] = "Property";
        // F.prototype = { ... }
        AssignmentDeclarationKind[AssignmentDeclarationKind["Prototype"] = 6] = "Prototype";
        // Object.defineProperty(x, 'name', { value: any, writable?: boolean (false by default) });
        // Object.defineProperty(x, 'name', { get: Function, set: Function });
        // Object.defineProperty(x, 'name', { get: Function });
        // Object.defineProperty(x, 'name', { set: Function });
        AssignmentDeclarationKind[AssignmentDeclarationKind["ObjectDefinePropertyValue"] = 7] = "ObjectDefinePropertyValue";
        // Object.defineProperty(exports || module.exports, 'name', ...);
        AssignmentDeclarationKind[AssignmentDeclarationKind["ObjectDefinePropertyExports"] = 8] = "ObjectDefinePropertyExports";
        // Object.defineProperty(Foo.prototype, 'name', ...);
        AssignmentDeclarationKind[AssignmentDeclarationKind["ObjectDefinePrototypeProperty"] = 9] = "ObjectDefinePrototypeProperty";
    })(AssignmentDeclarationKind = ts.AssignmentDeclarationKind || (ts.AssignmentDeclarationKind = {}));
    var DiagnosticCategory;
    (function (DiagnosticCategory) {
        DiagnosticCategory[DiagnosticCategory["Warning"] = 0] = "Warning";
        DiagnosticCategory[DiagnosticCategory["Error"] = 1] = "Error";
        DiagnosticCategory[DiagnosticCategory["Suggestion"] = 2] = "Suggestion";
        DiagnosticCategory[DiagnosticCategory["Message"] = 3] = "Message";
    })(DiagnosticCategory = ts.DiagnosticCategory || (ts.DiagnosticCategory = {}));
    /* @internal */
    function diagnosticCategoryName(d, lowerCase) {
        if (lowerCase === void 0) { lowerCase = true; }
        var name = DiagnosticCategory[d.category];
        return lowerCase ? name.toLowerCase() : name;
    }
    ts.diagnosticCategoryName = diagnosticCategoryName;
    var ModuleResolutionKind;
    (function (ModuleResolutionKind) {
        ModuleResolutionKind[ModuleResolutionKind["Classic"] = 1] = "Classic";
        ModuleResolutionKind[ModuleResolutionKind["NodeJs"] = 2] = "NodeJs";
        // Starting with node12, node's module resolver has significant departures from traditional cjs resolution
        // to better support ecmascript modules and their use within node - however more features are still being added.
        // TypeScript's Node ESM support was introduced after Node 12 went end-of-life, and Node 14 is the earliest stable
        // version that supports both pattern trailers - *but*, Node 16 is the first version that also supports ECMASCript 2022.
        // In turn, we offer both a `NodeNext` moving resolution target, and a `Node16` version-anchored resolution target
        ModuleResolutionKind[ModuleResolutionKind["Node16"] = 3] = "Node16";
        ModuleResolutionKind[ModuleResolutionKind["NodeNext"] = 99] = "NodeNext";
    })(ModuleResolutionKind = ts.ModuleResolutionKind || (ts.ModuleResolutionKind = {}));
    var ModuleDetectionKind;
    (function (ModuleDetectionKind) {
        /**
         * Files with imports, exports and/or import.meta are considered modules
         */
        ModuleDetectionKind[ModuleDetectionKind["Legacy"] = 1] = "Legacy";
        /**
         * Legacy, but also files with jsx under react-jsx or react-jsxdev and esm mode files under moduleResolution: node16+
         */
        ModuleDetectionKind[ModuleDetectionKind["Auto"] = 2] = "Auto";
        /**
         * Consider all non-declaration files modules, regardless of present syntax
         */
        ModuleDetectionKind[ModuleDetectionKind["Force"] = 3] = "Force";
    })(ModuleDetectionKind = ts.ModuleDetectionKind || (ts.ModuleDetectionKind = {}));
    var WatchFileKind;
    (function (WatchFileKind) {
        WatchFileKind[WatchFileKind["FixedPollingInterval"] = 0] = "FixedPollingInterval";
        WatchFileKind[WatchFileKind["PriorityPollingInterval"] = 1] = "PriorityPollingInterval";
        WatchFileKind[WatchFileKind["DynamicPriorityPolling"] = 2] = "DynamicPriorityPolling";
        WatchFileKind[WatchFileKind["FixedChunkSizePolling"] = 3] = "FixedChunkSizePolling";
        WatchFileKind[WatchFileKind["UseFsEvents"] = 4] = "UseFsEvents";
        WatchFileKind[WatchFileKind["UseFsEventsOnParentDirectory"] = 5] = "UseFsEventsOnParentDirectory";
    })(WatchFileKind = ts.WatchFileKind || (ts.WatchFileKind = {}));
    var WatchDirectoryKind;
    (function (WatchDirectoryKind) {
        WatchDirectoryKind[WatchDirectoryKind["UseFsEvents"] = 0] = "UseFsEvents";
        WatchDirectoryKind[WatchDirectoryKind["FixedPollingInterval"] = 1] = "FixedPollingInterval";
        WatchDirectoryKind[WatchDirectoryKind["DynamicPriorityPolling"] = 2] = "DynamicPriorityPolling";
        WatchDirectoryKind[WatchDirectoryKind["FixedChunkSizePolling"] = 3] = "FixedChunkSizePolling";
    })(WatchDirectoryKind = ts.WatchDirectoryKind || (ts.WatchDirectoryKind = {}));
    var PollingWatchKind;
    (function (PollingWatchKind) {
        PollingWatchKind[PollingWatchKind["FixedInterval"] = 0] = "FixedInterval";
        PollingWatchKind[PollingWatchKind["PriorityInterval"] = 1] = "PriorityInterval";
        PollingWatchKind[PollingWatchKind["DynamicPriority"] = 2] = "DynamicPriority";
        PollingWatchKind[PollingWatchKind["FixedChunkSize"] = 3] = "FixedChunkSize";
    })(PollingWatchKind = ts.PollingWatchKind || (ts.PollingWatchKind = {}));
    var ModuleKind;
    (function (ModuleKind) {
        ModuleKind[ModuleKind["None"] = 0] = "None";
        ModuleKind[ModuleKind["CommonJS"] = 1] = "CommonJS";
        ModuleKind[ModuleKind["AMD"] = 2] = "AMD";
        ModuleKind[ModuleKind["UMD"] = 3] = "UMD";
        ModuleKind[ModuleKind["System"] = 4] = "System";
        // NOTE: ES module kinds should be contiguous to more easily check whether a module kind is *any* ES module kind.
        //       Non-ES module kinds should not come between ES2015 (the earliest ES module kind) and ESNext (the last ES
        //       module kind).
        ModuleKind[ModuleKind["ES2015"] = 5] = "ES2015";
        ModuleKind[ModuleKind["ES2020"] = 6] = "ES2020";
        ModuleKind[ModuleKind["ES2022"] = 7] = "ES2022";
        ModuleKind[ModuleKind["ESNext"] = 99] = "ESNext";
        // Node16+ is an amalgam of commonjs (albeit updated) and es2022+, and represents a distinct module system from es2020/esnext
        ModuleKind[ModuleKind["Node16"] = 100] = "Node16";
        ModuleKind[ModuleKind["NodeNext"] = 199] = "NodeNext";
    })(ModuleKind = ts.ModuleKind || (ts.ModuleKind = {}));
    var JsxEmit;
    (function (JsxEmit) {
        JsxEmit[JsxEmit["None"] = 0] = "None";
        JsxEmit[JsxEmit["Preserve"] = 1] = "Preserve";
        JsxEmit[JsxEmit["React"] = 2] = "React";
        JsxEmit[JsxEmit["ReactNative"] = 3] = "ReactNative";
        JsxEmit[JsxEmit["ReactJSX"] = 4] = "ReactJSX";
        JsxEmit[JsxEmit["ReactJSXDev"] = 5] = "ReactJSXDev";
    })(JsxEmit = ts.JsxEmit || (ts.JsxEmit = {}));
    var ImportsNotUsedAsValues;
    (function (ImportsNotUsedAsValues) {
        ImportsNotUsedAsValues[ImportsNotUsedAsValues["Remove"] = 0] = "Remove";
        ImportsNotUsedAsValues[ImportsNotUsedAsValues["Preserve"] = 1] = "Preserve";
        ImportsNotUsedAsValues[ImportsNotUsedAsValues["Error"] = 2] = "Error";
    })(ImportsNotUsedAsValues = ts.ImportsNotUsedAsValues || (ts.ImportsNotUsedAsValues = {}));
    var NewLineKind;
    (function (NewLineKind) {
        NewLineKind[NewLineKind["CarriageReturnLineFeed"] = 0] = "CarriageReturnLineFeed";
        NewLineKind[NewLineKind["LineFeed"] = 1] = "LineFeed";
    })(NewLineKind = ts.NewLineKind || (ts.NewLineKind = {}));
    var ScriptKind;
    (function (ScriptKind) {
        ScriptKind[ScriptKind["Unknown"] = 0] = "Unknown";
        ScriptKind[ScriptKind["JS"] = 1] = "JS";
        ScriptKind[ScriptKind["JSX"] = 2] = "JSX";
        ScriptKind[ScriptKind["TS"] = 3] = "TS";
        ScriptKind[ScriptKind["TSX"] = 4] = "TSX";
        ScriptKind[ScriptKind["External"] = 5] = "External";
        ScriptKind[ScriptKind["JSON"] = 6] = "JSON";
        /**
         * Used on extensions that doesn't define the ScriptKind but the content defines it.
         * Deferred extensions are going to be included in all project contexts.
         */
        ScriptKind[ScriptKind["Deferred"] = 7] = "Deferred";
    })(ScriptKind = ts.ScriptKind || (ts.ScriptKind = {}));
    var ScriptTarget;
    (function (ScriptTarget) {
        ScriptTarget[ScriptTarget["ES3"] = 0] = "ES3";
        ScriptTarget[ScriptTarget["ES5"] = 1] = "ES5";
        ScriptTarget[ScriptTarget["ES2015"] = 2] = "ES2015";
        ScriptTarget[ScriptTarget["ES2016"] = 3] = "ES2016";
        ScriptTarget[ScriptTarget["ES2017"] = 4] = "ES2017";
        ScriptTarget[ScriptTarget["ES2018"] = 5] = "ES2018";
        ScriptTarget[ScriptTarget["ES2019"] = 6] = "ES2019";
        ScriptTarget[ScriptTarget["ES2020"] = 7] = "ES2020";
        ScriptTarget[ScriptTarget["ES2021"] = 8] = "ES2021";
        ScriptTarget[ScriptTarget["ES2022"] = 9] = "ES2022";
        ScriptTarget[ScriptTarget["ESNext"] = 99] = "ESNext";
        ScriptTarget[ScriptTarget["JSON"] = 100] = "JSON";
        ScriptTarget[ScriptTarget["Latest"] = 99] = "Latest";
    })(ScriptTarget = ts.ScriptTarget || (ts.ScriptTarget = {}));
    var LanguageVariant;
    (function (LanguageVariant) {
        LanguageVariant[LanguageVariant["Standard"] = 0] = "Standard";
        LanguageVariant[LanguageVariant["JSX"] = 1] = "JSX";
    })(LanguageVariant = ts.LanguageVariant || (ts.LanguageVariant = {}));
    var WatchDirectoryFlags;
    (function (WatchDirectoryFlags) {
        WatchDirectoryFlags[WatchDirectoryFlags["None"] = 0] = "None";
        WatchDirectoryFlags[WatchDirectoryFlags["Recursive"] = 1] = "Recursive";
    })(WatchDirectoryFlags = ts.WatchDirectoryFlags || (ts.WatchDirectoryFlags = {}));
    /* @internal */
    var CharacterCodes;
    (function (CharacterCodes) {
        CharacterCodes[CharacterCodes["nullCharacter"] = 0] = "nullCharacter";
        CharacterCodes[CharacterCodes["maxAsciiCharacter"] = 127] = "maxAsciiCharacter";
        CharacterCodes[CharacterCodes["lineFeed"] = 10] = "lineFeed";
        CharacterCodes[CharacterCodes["carriageReturn"] = 13] = "carriageReturn";
        CharacterCodes[CharacterCodes["lineSeparator"] = 8232] = "lineSeparator";
        CharacterCodes[CharacterCodes["paragraphSeparator"] = 8233] = "paragraphSeparator";
        CharacterCodes[CharacterCodes["nextLine"] = 133] = "nextLine";
        // Unicode 3.0 space characters
        CharacterCodes[CharacterCodes["space"] = 32] = "space";
        CharacterCodes[CharacterCodes["nonBreakingSpace"] = 160] = "nonBreakingSpace";
        CharacterCodes[CharacterCodes["enQuad"] = 8192] = "enQuad";
        CharacterCodes[CharacterCodes["emQuad"] = 8193] = "emQuad";
        CharacterCodes[CharacterCodes["enSpace"] = 8194] = "enSpace";
        CharacterCodes[CharacterCodes["emSpace"] = 8195] = "emSpace";
        CharacterCodes[CharacterCodes["threePerEmSpace"] = 8196] = "threePerEmSpace";
        CharacterCodes[CharacterCodes["fourPerEmSpace"] = 8197] = "fourPerEmSpace";
        CharacterCodes[CharacterCodes["sixPerEmSpace"] = 8198] = "sixPerEmSpace";
        CharacterCodes[CharacterCodes["figureSpace"] = 8199] = "figureSpace";
        CharacterCodes[CharacterCodes["punctuationSpace"] = 8200] = "punctuationSpace";
        CharacterCodes[CharacterCodes["thinSpace"] = 8201] = "thinSpace";
        CharacterCodes[CharacterCodes["hairSpace"] = 8202] = "hairSpace";
        CharacterCodes[CharacterCodes["zeroWidthSpace"] = 8203] = "zeroWidthSpace";
        CharacterCodes[CharacterCodes["narrowNoBreakSpace"] = 8239] = "narrowNoBreakSpace";
        CharacterCodes[CharacterCodes["ideographicSpace"] = 12288] = "ideographicSpace";
        CharacterCodes[CharacterCodes["mathematicalSpace"] = 8287] = "mathematicalSpace";
        CharacterCodes[CharacterCodes["ogham"] = 5760] = "ogham";
        CharacterCodes[CharacterCodes["_"] = 95] = "_";
        CharacterCodes[CharacterCodes["$"] = 36] = "$";
        CharacterCodes[CharacterCodes["_0"] = 48] = "_0";
        CharacterCodes[CharacterCodes["_1"] = 49] = "_1";
        CharacterCodes[CharacterCodes["_2"] = 50] = "_2";
        CharacterCodes[CharacterCodes["_3"] = 51] = "_3";
        CharacterCodes[CharacterCodes["_4"] = 52] = "_4";
        CharacterCodes[CharacterCodes["_5"] = 53] = "_5";
        CharacterCodes[CharacterCodes["_6"] = 54] = "_6";
        CharacterCodes[CharacterCodes["_7"] = 55] = "_7";
        CharacterCodes[CharacterCodes["_8"] = 56] = "_8";
        CharacterCodes[CharacterCodes["_9"] = 57] = "_9";
        CharacterCodes[CharacterCodes["a"] = 97] = "a";
        CharacterCodes[CharacterCodes["b"] = 98] = "b";
        CharacterCodes[CharacterCodes["c"] = 99] = "c";
        CharacterCodes[CharacterCodes["d"] = 100] = "d";
        CharacterCodes[CharacterCodes["e"] = 101] = "e";
        CharacterCodes[CharacterCodes["f"] = 102] = "f";
        CharacterCodes[CharacterCodes["g"] = 103] = "g";
        CharacterCodes[CharacterCodes["h"] = 104] = "h";
        CharacterCodes[CharacterCodes["i"] = 105] = "i";
        CharacterCodes[CharacterCodes["j"] = 106] = "j";
        CharacterCodes[CharacterCodes["k"] = 107] = "k";
        CharacterCodes[CharacterCodes["l"] = 108] = "l";
        CharacterCodes[CharacterCodes["m"] = 109] = "m";
        CharacterCodes[CharacterCodes["n"] = 110] = "n";
        CharacterCodes[CharacterCodes["o"] = 111] = "o";
        CharacterCodes[CharacterCodes["p"] = 112] = "p";
        CharacterCodes[CharacterCodes["q"] = 113] = "q";
        CharacterCodes[CharacterCodes["r"] = 114] = "r";
        CharacterCodes[CharacterCodes["s"] = 115] = "s";
        CharacterCodes[CharacterCodes["t"] = 116] = "t";
        CharacterCodes[CharacterCodes["u"] = 117] = "u";
        CharacterCodes[CharacterCodes["v"] = 118] = "v";
        CharacterCodes[CharacterCodes["w"] = 119] = "w";
        CharacterCodes[CharacterCodes["x"] = 120] = "x";
        CharacterCodes[CharacterCodes["y"] = 121] = "y";
        CharacterCodes[CharacterCodes["z"] = 122] = "z";
        CharacterCodes[CharacterCodes["A"] = 65] = "A";
        CharacterCodes[CharacterCodes["B"] = 66] = "B";
        CharacterCodes[CharacterCodes["C"] = 67] = "C";
        CharacterCodes[CharacterCodes["D"] = 68] = "D";
        CharacterCodes[CharacterCodes["E"] = 69] = "E";
        CharacterCodes[CharacterCodes["F"] = 70] = "F";
        CharacterCodes[CharacterCodes["G"] = 71] = "G";
        CharacterCodes[CharacterCodes["H"] = 72] = "H";
        CharacterCodes[CharacterCodes["I"] = 73] = "I";
        CharacterCodes[CharacterCodes["J"] = 74] = "J";
        CharacterCodes[CharacterCodes["K"] = 75] = "K";
        CharacterCodes[CharacterCodes["L"] = 76] = "L";
        CharacterCodes[CharacterCodes["M"] = 77] = "M";
        CharacterCodes[CharacterCodes["N"] = 78] = "N";
        CharacterCodes[CharacterCodes["O"] = 79] = "O";
        CharacterCodes[CharacterCodes["P"] = 80] = "P";
        CharacterCodes[CharacterCodes["Q"] = 81] = "Q";
        CharacterCodes[CharacterCodes["R"] = 82] = "R";
        CharacterCodes[CharacterCodes["S"] = 83] = "S";
        CharacterCodes[CharacterCodes["T"] = 84] = "T";
        CharacterCodes[CharacterCodes["U"] = 85] = "U";
        CharacterCodes[CharacterCodes["V"] = 86] = "V";
        CharacterCodes[CharacterCodes["W"] = 87] = "W";
        CharacterCodes[CharacterCodes["X"] = 88] = "X";
        CharacterCodes[CharacterCodes["Y"] = 89] = "Y";
        CharacterCodes[CharacterCodes["Z"] = 90] = "Z";
        CharacterCodes[CharacterCodes["ampersand"] = 38] = "ampersand";
        CharacterCodes[CharacterCodes["asterisk"] = 42] = "asterisk";
        CharacterCodes[CharacterCodes["at"] = 64] = "at";
        CharacterCodes[CharacterCodes["backslash"] = 92] = "backslash";
        CharacterCodes[CharacterCodes["backtick"] = 96] = "backtick";
        CharacterCodes[CharacterCodes["bar"] = 124] = "bar";
        CharacterCodes[CharacterCodes["caret"] = 94] = "caret";
        CharacterCodes[CharacterCodes["closeBrace"] = 125] = "closeBrace";
        CharacterCodes[CharacterCodes["closeBracket"] = 93] = "closeBracket";
        CharacterCodes[CharacterCodes["closeParen"] = 41] = "closeParen";
        CharacterCodes[CharacterCodes["colon"] = 58] = "colon";
        CharacterCodes[CharacterCodes["comma"] = 44] = "comma";
        CharacterCodes[CharacterCodes["dot"] = 46] = "dot";
        CharacterCodes[CharacterCodes["doubleQuote"] = 34] = "doubleQuote";
        CharacterCodes[CharacterCodes["equals"] = 61] = "equals";
        CharacterCodes[CharacterCodes["exclamation"] = 33] = "exclamation";
        CharacterCodes[CharacterCodes["greaterThan"] = 62] = "greaterThan";
        CharacterCodes[CharacterCodes["hash"] = 35] = "hash";
        CharacterCodes[CharacterCodes["lessThan"] = 60] = "lessThan";
        CharacterCodes[CharacterCodes["minus"] = 45] = "minus";
        CharacterCodes[CharacterCodes["openBrace"] = 123] = "openBrace";
        CharacterCodes[CharacterCodes["openBracket"] = 91] = "openBracket";
        CharacterCodes[CharacterCodes["openParen"] = 40] = "openParen";
        CharacterCodes[CharacterCodes["percent"] = 37] = "percent";
        CharacterCodes[CharacterCodes["plus"] = 43] = "plus";
        CharacterCodes[CharacterCodes["question"] = 63] = "question";
        CharacterCodes[CharacterCodes["semicolon"] = 59] = "semicolon";
        CharacterCodes[CharacterCodes["singleQuote"] = 39] = "singleQuote";
        CharacterCodes[CharacterCodes["slash"] = 47] = "slash";
        CharacterCodes[CharacterCodes["tilde"] = 126] = "tilde";
        CharacterCodes[CharacterCodes["backspace"] = 8] = "backspace";
        CharacterCodes[CharacterCodes["formFeed"] = 12] = "formFeed";
        CharacterCodes[CharacterCodes["byteOrderMark"] = 65279] = "byteOrderMark";
        CharacterCodes[CharacterCodes["tab"] = 9] = "tab";
        CharacterCodes[CharacterCodes["verticalTab"] = 11] = "verticalTab";
    })(CharacterCodes = ts.CharacterCodes || (ts.CharacterCodes = {}));
    var Extension;
    (function (Extension) {
        Extension["Ts"] = ".ts";
        Extension["Tsx"] = ".tsx";
        Extension["Dts"] = ".d.ts";
        Extension["Js"] = ".js";
        Extension["Jsx"] = ".jsx";
        Extension["Json"] = ".json";
        Extension["TsBuildInfo"] = ".tsbuildinfo";
        Extension["Mjs"] = ".mjs";
        Extension["Mts"] = ".mts";
        Extension["Dmts"] = ".d.mts";
        Extension["Cjs"] = ".cjs";
        Extension["Cts"] = ".cts";
        Extension["Dcts"] = ".d.cts";
    })(Extension = ts.Extension || (ts.Extension = {}));
    /* @internal */
    var TransformFlags;
    (function (TransformFlags) {
        TransformFlags[TransformFlags["None"] = 0] = "None";
        // Facts
        // - Flags used to indicate that a node or subtree contains syntax that requires transformation.
        TransformFlags[TransformFlags["ContainsTypeScript"] = 1] = "ContainsTypeScript";
        TransformFlags[TransformFlags["ContainsJsx"] = 2] = "ContainsJsx";
        TransformFlags[TransformFlags["ContainsESNext"] = 4] = "ContainsESNext";
        TransformFlags[TransformFlags["ContainsES2022"] = 8] = "ContainsES2022";
        TransformFlags[TransformFlags["ContainsES2021"] = 16] = "ContainsES2021";
        TransformFlags[TransformFlags["ContainsES2020"] = 32] = "ContainsES2020";
        TransformFlags[TransformFlags["ContainsES2019"] = 64] = "ContainsES2019";
        TransformFlags[TransformFlags["ContainsES2018"] = 128] = "ContainsES2018";
        TransformFlags[TransformFlags["ContainsES2017"] = 256] = "ContainsES2017";
        TransformFlags[TransformFlags["ContainsES2016"] = 512] = "ContainsES2016";
        TransformFlags[TransformFlags["ContainsES2015"] = 1024] = "ContainsES2015";
        TransformFlags[TransformFlags["ContainsGenerator"] = 2048] = "ContainsGenerator";
        TransformFlags[TransformFlags["ContainsDestructuringAssignment"] = 4096] = "ContainsDestructuringAssignment";
        // Markers
        // - Flags used to indicate that a subtree contains a specific transformation.
        TransformFlags[TransformFlags["ContainsTypeScriptClassSyntax"] = 8192] = "ContainsTypeScriptClassSyntax";
        TransformFlags[TransformFlags["ContainsLexicalThis"] = 16384] = "ContainsLexicalThis";
        TransformFlags[TransformFlags["ContainsRestOrSpread"] = 32768] = "ContainsRestOrSpread";
        TransformFlags[TransformFlags["ContainsObjectRestOrSpread"] = 65536] = "ContainsObjectRestOrSpread";
        TransformFlags[TransformFlags["ContainsComputedPropertyName"] = 131072] = "ContainsComputedPropertyName";
        TransformFlags[TransformFlags["ContainsBlockScopedBinding"] = 262144] = "ContainsBlockScopedBinding";
        TransformFlags[TransformFlags["ContainsBindingPattern"] = 524288] = "ContainsBindingPattern";
        TransformFlags[TransformFlags["ContainsYield"] = 1048576] = "ContainsYield";
        TransformFlags[TransformFlags["ContainsAwait"] = 2097152] = "ContainsAwait";
        TransformFlags[TransformFlags["ContainsHoistedDeclarationOrCompletion"] = 4194304] = "ContainsHoistedDeclarationOrCompletion";
        TransformFlags[TransformFlags["ContainsDynamicImport"] = 8388608] = "ContainsDynamicImport";
        TransformFlags[TransformFlags["ContainsClassFields"] = 16777216] = "ContainsClassFields";
        TransformFlags[TransformFlags["ContainsDecorators"] = 33554432] = "ContainsDecorators";
        TransformFlags[TransformFlags["ContainsPossibleTopLevelAwait"] = 67108864] = "ContainsPossibleTopLevelAwait";
        TransformFlags[TransformFlags["ContainsLexicalSuper"] = 134217728] = "ContainsLexicalSuper";
        TransformFlags[TransformFlags["ContainsUpdateExpressionForIdentifier"] = 268435456] = "ContainsUpdateExpressionForIdentifier";
        TransformFlags[TransformFlags["ContainsPrivateIdentifierInExpression"] = 536870912] = "ContainsPrivateIdentifierInExpression";
        TransformFlags[TransformFlags["HasComputedFlags"] = -2147483648] = "HasComputedFlags";
        // Assertions
        // - Bitmasks that are used to assert facts about the syntax of a node and its subtree.
        TransformFlags[TransformFlags["AssertTypeScript"] = 1] = "AssertTypeScript";
        TransformFlags[TransformFlags["AssertJsx"] = 2] = "AssertJsx";
        TransformFlags[TransformFlags["AssertESNext"] = 4] = "AssertESNext";
        TransformFlags[TransformFlags["AssertES2022"] = 8] = "AssertES2022";
        TransformFlags[TransformFlags["AssertES2021"] = 16] = "AssertES2021";
        TransformFlags[TransformFlags["AssertES2020"] = 32] = "AssertES2020";
        TransformFlags[TransformFlags["AssertES2019"] = 64] = "AssertES2019";
        TransformFlags[TransformFlags["AssertES2018"] = 128] = "AssertES2018";
        TransformFlags[TransformFlags["AssertES2017"] = 256] = "AssertES2017";
        TransformFlags[TransformFlags["AssertES2016"] = 512] = "AssertES2016";
        TransformFlags[TransformFlags["AssertES2015"] = 1024] = "AssertES2015";
        TransformFlags[TransformFlags["AssertGenerator"] = 2048] = "AssertGenerator";
        TransformFlags[TransformFlags["AssertDestructuringAssignment"] = 4096] = "AssertDestructuringAssignment";
        // Scope Exclusions
        // - Bitmasks that exclude flags from propagating out of a specific context
        //   into the subtree flags of their container.
        TransformFlags[TransformFlags["OuterExpressionExcludes"] = -2147483648] = "OuterExpressionExcludes";
        TransformFlags[TransformFlags["PropertyAccessExcludes"] = -2147483648] = "PropertyAccessExcludes";
        TransformFlags[TransformFlags["NodeExcludes"] = -2147483648] = "NodeExcludes";
        TransformFlags[TransformFlags["ArrowFunctionExcludes"] = -2072174592] = "ArrowFunctionExcludes";
        TransformFlags[TransformFlags["FunctionExcludes"] = -1937940480] = "FunctionExcludes";
        TransformFlags[TransformFlags["ConstructorExcludes"] = -1937948672] = "ConstructorExcludes";
        TransformFlags[TransformFlags["MethodOrAccessorExcludes"] = -2005057536] = "MethodOrAccessorExcludes";
        TransformFlags[TransformFlags["PropertyExcludes"] = -2013249536] = "PropertyExcludes";
        TransformFlags[TransformFlags["ClassExcludes"] = -2147344384] = "ClassExcludes";
        TransformFlags[TransformFlags["ModuleExcludes"] = -1941676032] = "ModuleExcludes";
        TransformFlags[TransformFlags["TypeExcludes"] = -2] = "TypeExcludes";
        TransformFlags[TransformFlags["ObjectLiteralExcludes"] = -2147278848] = "ObjectLiteralExcludes";
        TransformFlags[TransformFlags["ArrayLiteralOrCallOrNewExcludes"] = -2147450880] = "ArrayLiteralOrCallOrNewExcludes";
        TransformFlags[TransformFlags["VariableDeclarationListExcludes"] = -2146893824] = "VariableDeclarationListExcludes";
        TransformFlags[TransformFlags["ParameterExcludes"] = -2147483648] = "ParameterExcludes";
        TransformFlags[TransformFlags["CatchClauseExcludes"] = -2147418112] = "CatchClauseExcludes";
        TransformFlags[TransformFlags["BindingPatternExcludes"] = -2147450880] = "BindingPatternExcludes";
        TransformFlags[TransformFlags["ContainsLexicalThisOrSuper"] = 134234112] = "ContainsLexicalThisOrSuper";
        // Propagating flags
        // - Bitmasks for flags that should propagate from a child
        TransformFlags[TransformFlags["PropertyNamePropagatingFlags"] = 134234112] = "PropertyNamePropagatingFlags";
        // Masks
        // - Additional bitmasks
    })(TransformFlags = ts.TransformFlags || (ts.TransformFlags = {}));
    // Reference: https://code.visualstudio.com/docs/editor/userdefinedsnippets#_snippet-syntax
    /* @internal */
    var SnippetKind;
    (function (SnippetKind) {
        SnippetKind[SnippetKind["TabStop"] = 0] = "TabStop";
        SnippetKind[SnippetKind["Placeholder"] = 1] = "Placeholder";
        SnippetKind[SnippetKind["Choice"] = 2] = "Choice";
        SnippetKind[SnippetKind["Variable"] = 3] = "Variable";
    })(SnippetKind = ts.SnippetKind || (ts.SnippetKind = {}));
    var EmitFlags;
    (function (EmitFlags) {
        EmitFlags[EmitFlags["None"] = 0] = "None";
        EmitFlags[EmitFlags["SingleLine"] = 1] = "SingleLine";
        EmitFlags[EmitFlags["AdviseOnEmitNode"] = 2] = "AdviseOnEmitNode";
        EmitFlags[EmitFlags["NoSubstitution"] = 4] = "NoSubstitution";
        EmitFlags[EmitFlags["CapturesThis"] = 8] = "CapturesThis";
        EmitFlags[EmitFlags["NoLeadingSourceMap"] = 16] = "NoLeadingSourceMap";
        EmitFlags[EmitFlags["NoTrailingSourceMap"] = 32] = "NoTrailingSourceMap";
        EmitFlags[EmitFlags["NoSourceMap"] = 48] = "NoSourceMap";
        EmitFlags[EmitFlags["NoNestedSourceMaps"] = 64] = "NoNestedSourceMaps";
        EmitFlags[EmitFlags["NoTokenLeadingSourceMaps"] = 128] = "NoTokenLeadingSourceMaps";
        EmitFlags[EmitFlags["NoTokenTrailingSourceMaps"] = 256] = "NoTokenTrailingSourceMaps";
        EmitFlags[EmitFlags["NoTokenSourceMaps"] = 384] = "NoTokenSourceMaps";
        EmitFlags[EmitFlags["NoLeadingComments"] = 512] = "NoLeadingComments";
        EmitFlags[EmitFlags["NoTrailingComments"] = 1024] = "NoTrailingComments";
        EmitFlags[EmitFlags["NoComments"] = 1536] = "NoComments";
        EmitFlags[EmitFlags["NoNestedComments"] = 2048] = "NoNestedComments";
        EmitFlags[EmitFlags["HelperName"] = 4096] = "HelperName";
        EmitFlags[EmitFlags["ExportName"] = 8192] = "ExportName";
        EmitFlags[EmitFlags["LocalName"] = 16384] = "LocalName";
        EmitFlags[EmitFlags["InternalName"] = 32768] = "InternalName";
        EmitFlags[EmitFlags["Indented"] = 65536] = "Indented";
        EmitFlags[EmitFlags["NoIndentation"] = 131072] = "NoIndentation";
        EmitFlags[EmitFlags["AsyncFunctionBody"] = 262144] = "AsyncFunctionBody";
        EmitFlags[EmitFlags["ReuseTempVariableScope"] = 524288] = "ReuseTempVariableScope";
        EmitFlags[EmitFlags["CustomPrologue"] = 1048576] = "CustomPrologue";
        EmitFlags[EmitFlags["NoHoisting"] = 2097152] = "NoHoisting";
        EmitFlags[EmitFlags["HasEndOfDeclarationMarker"] = 4194304] = "HasEndOfDeclarationMarker";
        EmitFlags[EmitFlags["Iterator"] = 8388608] = "Iterator";
        EmitFlags[EmitFlags["NoAsciiEscaping"] = 16777216] = "NoAsciiEscaping";
        /*@internal*/ EmitFlags[EmitFlags["TypeScriptClassWrapper"] = 33554432] = "TypeScriptClassWrapper";
        /*@internal*/ EmitFlags[EmitFlags["NeverApplyImportHelper"] = 67108864] = "NeverApplyImportHelper";
        /*@internal*/ EmitFlags[EmitFlags["IgnoreSourceNewlines"] = 134217728] = "IgnoreSourceNewlines";
        /*@internal*/ EmitFlags[EmitFlags["Immutable"] = 268435456] = "Immutable";
        /*@internal*/ EmitFlags[EmitFlags["IndirectCall"] = 536870912] = "IndirectCall";
    })(EmitFlags = ts.EmitFlags || (ts.EmitFlags = {}));
    /**
     * Used by the checker, this enum keeps track of external emit helpers that should be type
     * checked.
     */
    /* @internal */
    var ExternalEmitHelpers;
    (function (ExternalEmitHelpers) {
        ExternalEmitHelpers[ExternalEmitHelpers["Extends"] = 1] = "Extends";
        ExternalEmitHelpers[ExternalEmitHelpers["Assign"] = 2] = "Assign";
        ExternalEmitHelpers[ExternalEmitHelpers["Rest"] = 4] = "Rest";
        ExternalEmitHelpers[ExternalEmitHelpers["Decorate"] = 8] = "Decorate";
        ExternalEmitHelpers[ExternalEmitHelpers["Metadata"] = 16] = "Metadata";
        ExternalEmitHelpers[ExternalEmitHelpers["Param"] = 32] = "Param";
        ExternalEmitHelpers[ExternalEmitHelpers["Awaiter"] = 64] = "Awaiter";
        ExternalEmitHelpers[ExternalEmitHelpers["Generator"] = 128] = "Generator";
        ExternalEmitHelpers[ExternalEmitHelpers["Values"] = 256] = "Values";
        ExternalEmitHelpers[ExternalEmitHelpers["Read"] = 512] = "Read";
        ExternalEmitHelpers[ExternalEmitHelpers["SpreadArray"] = 1024] = "SpreadArray";
        ExternalEmitHelpers[ExternalEmitHelpers["Await"] = 2048] = "Await";
        ExternalEmitHelpers[ExternalEmitHelpers["AsyncGenerator"] = 4096] = "AsyncGenerator";
        ExternalEmitHelpers[ExternalEmitHelpers["AsyncDelegator"] = 8192] = "AsyncDelegator";
        ExternalEmitHelpers[ExternalEmitHelpers["AsyncValues"] = 16384] = "AsyncValues";
        ExternalEmitHelpers[ExternalEmitHelpers["ExportStar"] = 32768] = "ExportStar";
        ExternalEmitHelpers[ExternalEmitHelpers["ImportStar"] = 65536] = "ImportStar";
        ExternalEmitHelpers[ExternalEmitHelpers["ImportDefault"] = 131072] = "ImportDefault";
        ExternalEmitHelpers[ExternalEmitHelpers["MakeTemplateObject"] = 262144] = "MakeTemplateObject";
        ExternalEmitHelpers[ExternalEmitHelpers["ClassPrivateFieldGet"] = 524288] = "ClassPrivateFieldGet";
        ExternalEmitHelpers[ExternalEmitHelpers["ClassPrivateFieldSet"] = 1048576] = "ClassPrivateFieldSet";
        ExternalEmitHelpers[ExternalEmitHelpers["ClassPrivateFieldIn"] = 2097152] = "ClassPrivateFieldIn";
        ExternalEmitHelpers[ExternalEmitHelpers["CreateBinding"] = 4194304] = "CreateBinding";
        ExternalEmitHelpers[ExternalEmitHelpers["FirstEmitHelper"] = 1] = "FirstEmitHelper";
        ExternalEmitHelpers[ExternalEmitHelpers["LastEmitHelper"] = 4194304] = "LastEmitHelper";
        // Helpers included by ES2015 for..of
        ExternalEmitHelpers[ExternalEmitHelpers["ForOfIncludes"] = 256] = "ForOfIncludes";
        // Helpers included by ES2017 for..await..of
        ExternalEmitHelpers[ExternalEmitHelpers["ForAwaitOfIncludes"] = 16384] = "ForAwaitOfIncludes";
        // Helpers included by ES2017 async generators
        ExternalEmitHelpers[ExternalEmitHelpers["AsyncGeneratorIncludes"] = 6144] = "AsyncGeneratorIncludes";
        // Helpers included by yield* in ES2017 async generators
        ExternalEmitHelpers[ExternalEmitHelpers["AsyncDelegatorIncludes"] = 26624] = "AsyncDelegatorIncludes";
        // Helpers included by ES2015 spread
        ExternalEmitHelpers[ExternalEmitHelpers["SpreadIncludes"] = 1536] = "SpreadIncludes";
    })(ExternalEmitHelpers = ts.ExternalEmitHelpers || (ts.ExternalEmitHelpers = {}));
    var EmitHint;
    (function (EmitHint) {
        EmitHint[EmitHint["SourceFile"] = 0] = "SourceFile";
        EmitHint[EmitHint["Expression"] = 1] = "Expression";
        EmitHint[EmitHint["IdentifierName"] = 2] = "IdentifierName";
        EmitHint[EmitHint["MappedTypeParameter"] = 3] = "MappedTypeParameter";
        EmitHint[EmitHint["Unspecified"] = 4] = "Unspecified";
        EmitHint[EmitHint["EmbeddedStatement"] = 5] = "EmbeddedStatement";
        EmitHint[EmitHint["JsxAttributeValue"] = 6] = "JsxAttributeValue";
    })(EmitHint = ts.EmitHint || (ts.EmitHint = {}));
    var OuterExpressionKinds;
    (function (OuterExpressionKinds) {
        OuterExpressionKinds[OuterExpressionKinds["Parentheses"] = 1] = "Parentheses";
        OuterExpressionKinds[OuterExpressionKinds["TypeAssertions"] = 2] = "TypeAssertions";
        OuterExpressionKinds[OuterExpressionKinds["NonNullAssertions"] = 4] = "NonNullAssertions";
        OuterExpressionKinds[OuterExpressionKinds["PartiallyEmittedExpressions"] = 8] = "PartiallyEmittedExpressions";
        OuterExpressionKinds[OuterExpressionKinds["Assertions"] = 6] = "Assertions";
        OuterExpressionKinds[OuterExpressionKinds["All"] = 15] = "All";
        OuterExpressionKinds[OuterExpressionKinds["ExcludeJSDocTypeAssertion"] = 16] = "ExcludeJSDocTypeAssertion";
    })(OuterExpressionKinds = ts.OuterExpressionKinds || (ts.OuterExpressionKinds = {}));
    /* @internal */
    var LexicalEnvironmentFlags;
    (function (LexicalEnvironmentFlags) {
        LexicalEnvironmentFlags[LexicalEnvironmentFlags["None"] = 0] = "None";
        LexicalEnvironmentFlags[LexicalEnvironmentFlags["InParameters"] = 1] = "InParameters";
        LexicalEnvironmentFlags[LexicalEnvironmentFlags["VariablesHoistedInParameters"] = 2] = "VariablesHoistedInParameters"; // a temp variable was hoisted while visiting a parameter list
    })(LexicalEnvironmentFlags = ts.LexicalEnvironmentFlags || (ts.LexicalEnvironmentFlags = {}));
    /*@internal*/
    var BundleFileSectionKind;
    (function (BundleFileSectionKind) {
        BundleFileSectionKind["Prologue"] = "prologue";
        BundleFileSectionKind["EmitHelpers"] = "emitHelpers";
        BundleFileSectionKind["NoDefaultLib"] = "no-default-lib";
        BundleFileSectionKind["Reference"] = "reference";
        BundleFileSectionKind["Type"] = "type";
        BundleFileSectionKind["TypeResolutionModeRequire"] = "type-require";
        BundleFileSectionKind["TypeResolutionModeImport"] = "type-import";
        BundleFileSectionKind["Lib"] = "lib";
        BundleFileSectionKind["Prepend"] = "prepend";
        BundleFileSectionKind["Text"] = "text";
        BundleFileSectionKind["Internal"] = "internal";
        // comments?
    })(BundleFileSectionKind = ts.BundleFileSectionKind || (ts.BundleFileSectionKind = {}));
    var ListFormat;
    (function (ListFormat) {
        ListFormat[ListFormat["None"] = 0] = "None";
        // Line separators
        ListFormat[ListFormat["SingleLine"] = 0] = "SingleLine";
        ListFormat[ListFormat["MultiLine"] = 1] = "MultiLine";
        ListFormat[ListFormat["PreserveLines"] = 2] = "PreserveLines";
        ListFormat[ListFormat["LinesMask"] = 3] = "LinesMask";
        // Delimiters
        ListFormat[ListFormat["NotDelimited"] = 0] = "NotDelimited";
        ListFormat[ListFormat["BarDelimited"] = 4] = "BarDelimited";
        ListFormat[ListFormat["AmpersandDelimited"] = 8] = "AmpersandDelimited";
        ListFormat[ListFormat["CommaDelimited"] = 16] = "CommaDelimited";
        ListFormat[ListFormat["AsteriskDelimited"] = 32] = "AsteriskDelimited";
        ListFormat[ListFormat["DelimitersMask"] = 60] = "DelimitersMask";
        ListFormat[ListFormat["AllowTrailingComma"] = 64] = "AllowTrailingComma";
        // Whitespace
        ListFormat[ListFormat["Indented"] = 128] = "Indented";
        ListFormat[ListFormat["SpaceBetweenBraces"] = 256] = "SpaceBetweenBraces";
        ListFormat[ListFormat["SpaceBetweenSiblings"] = 512] = "SpaceBetweenSiblings";
        // Brackets/Braces
        ListFormat[ListFormat["Braces"] = 1024] = "Braces";
        ListFormat[ListFormat["Parenthesis"] = 2048] = "Parenthesis";
        ListFormat[ListFormat["AngleBrackets"] = 4096] = "AngleBrackets";
        ListFormat[ListFormat["SquareBrackets"] = 8192] = "SquareBrackets";
        ListFormat[ListFormat["BracketsMask"] = 15360] = "BracketsMask";
        ListFormat[ListFormat["OptionalIfUndefined"] = 16384] = "OptionalIfUndefined";
        ListFormat[ListFormat["OptionalIfEmpty"] = 32768] = "OptionalIfEmpty";
        ListFormat[ListFormat["Optional"] = 49152] = "Optional";
        // Other
        ListFormat[ListFormat["PreferNewLine"] = 65536] = "PreferNewLine";
        ListFormat[ListFormat["NoTrailingNewLine"] = 131072] = "NoTrailingNewLine";
        ListFormat[ListFormat["NoInterveningComments"] = 262144] = "NoInterveningComments";
        ListFormat[ListFormat["NoSpaceIfEmpty"] = 524288] = "NoSpaceIfEmpty";
        ListFormat[ListFormat["SingleElement"] = 1048576] = "SingleElement";
        ListFormat[ListFormat["SpaceAfterList"] = 2097152] = "SpaceAfterList";
        // Precomputed Formats
        ListFormat[ListFormat["Modifiers"] = 2359808] = "Modifiers";
        ListFormat[ListFormat["HeritageClauses"] = 512] = "HeritageClauses";
        ListFormat[ListFormat["SingleLineTypeLiteralMembers"] = 768] = "SingleLineTypeLiteralMembers";
        ListFormat[ListFormat["MultiLineTypeLiteralMembers"] = 32897] = "MultiLineTypeLiteralMembers";
        ListFormat[ListFormat["SingleLineTupleTypeElements"] = 528] = "SingleLineTupleTypeElements";
        ListFormat[ListFormat["MultiLineTupleTypeElements"] = 657] = "MultiLineTupleTypeElements";
        ListFormat[ListFormat["UnionTypeConstituents"] = 516] = "UnionTypeConstituents";
        ListFormat[ListFormat["IntersectionTypeConstituents"] = 520] = "IntersectionTypeConstituents";
        ListFormat[ListFormat["ObjectBindingPatternElements"] = 525136] = "ObjectBindingPatternElements";
        ListFormat[ListFormat["ArrayBindingPatternElements"] = 524880] = "ArrayBindingPatternElements";
        ListFormat[ListFormat["ObjectLiteralExpressionProperties"] = 526226] = "ObjectLiteralExpressionProperties";
        ListFormat[ListFormat["ImportClauseEntries"] = 526226] = "ImportClauseEntries";
        ListFormat[ListFormat["ArrayLiteralExpressionElements"] = 8914] = "ArrayLiteralExpressionElements";
        ListFormat[ListFormat["CommaListElements"] = 528] = "CommaListElements";
        ListFormat[ListFormat["CallExpressionArguments"] = 2576] = "CallExpressionArguments";
        ListFormat[ListFormat["NewExpressionArguments"] = 18960] = "NewExpressionArguments";
        ListFormat[ListFormat["TemplateExpressionSpans"] = 262144] = "TemplateExpressionSpans";
        ListFormat[ListFormat["SingleLineBlockStatements"] = 768] = "SingleLineBlockStatements";
        ListFormat[ListFormat["MultiLineBlockStatements"] = 129] = "MultiLineBlockStatements";
        ListFormat[ListFormat["VariableDeclarationList"] = 528] = "VariableDeclarationList";
        ListFormat[ListFormat["SingleLineFunctionBodyStatements"] = 768] = "SingleLineFunctionBodyStatements";
        ListFormat[ListFormat["MultiLineFunctionBodyStatements"] = 1] = "MultiLineFunctionBodyStatements";
        ListFormat[ListFormat["ClassHeritageClauses"] = 0] = "ClassHeritageClauses";
        ListFormat[ListFormat["ClassMembers"] = 129] = "ClassMembers";
        ListFormat[ListFormat["InterfaceMembers"] = 129] = "InterfaceMembers";
        ListFormat[ListFormat["EnumMembers"] = 145] = "EnumMembers";
        ListFormat[ListFormat["CaseBlockClauses"] = 129] = "CaseBlockClauses";
        ListFormat[ListFormat["NamedImportsOrExportsElements"] = 525136] = "NamedImportsOrExportsElements";
        ListFormat[ListFormat["JsxElementOrFragmentChildren"] = 262144] = "JsxElementOrFragmentChildren";
        ListFormat[ListFormat["JsxElementAttributes"] = 262656] = "JsxElementAttributes";
        ListFormat[ListFormat["CaseOrDefaultClauseStatements"] = 163969] = "CaseOrDefaultClauseStatements";
        ListFormat[ListFormat["HeritageClauseTypes"] = 528] = "HeritageClauseTypes";
        ListFormat[ListFormat["SourceFileStatements"] = 131073] = "SourceFileStatements";
        ListFormat[ListFormat["Decorators"] = 2146305] = "Decorators";
        ListFormat[ListFormat["TypeArguments"] = 53776] = "TypeArguments";
        ListFormat[ListFormat["TypeParameters"] = 53776] = "TypeParameters";
        ListFormat[ListFormat["Parameters"] = 2576] = "Parameters";
        ListFormat[ListFormat["IndexSignatureParameters"] = 8848] = "IndexSignatureParameters";
        ListFormat[ListFormat["JSDocComment"] = 33] = "JSDocComment";
    })(ListFormat = ts.ListFormat || (ts.ListFormat = {}));
    /* @internal */
    var PragmaKindFlags;
    (function (PragmaKindFlags) {
        PragmaKindFlags[PragmaKindFlags["None"] = 0] = "None";
        /**
         * Triple slash comment of the form
         * /// <pragma-name argname="value" />
         */
        PragmaKindFlags[PragmaKindFlags["TripleSlashXML"] = 1] = "TripleSlashXML";
        /**
         * Single line comment of the form
         * // @pragma-name argval1 argval2
         * or
         * /// @pragma-name argval1 argval2
         */
        PragmaKindFlags[PragmaKindFlags["SingleLine"] = 2] = "SingleLine";
        /**
         * Multiline non-jsdoc pragma of the form
         * /* @pragma-name argval1 argval2 * /
         */
        PragmaKindFlags[PragmaKindFlags["MultiLine"] = 4] = "MultiLine";
        PragmaKindFlags[PragmaKindFlags["All"] = 7] = "All";
        PragmaKindFlags[PragmaKindFlags["Default"] = 7] = "Default";
    })(PragmaKindFlags = ts.PragmaKindFlags || (ts.PragmaKindFlags = {}));
    // While not strictly a type, this is here because `PragmaMap` needs to be here to be used with `SourceFile`, and we don't
    //  fancy effectively defining it twice, once in value-space and once in type-space
    /* @internal */
    ts.commentPragmas = {
        "reference": {
            args: [
                { name: "types", optional: true, captureSpan: true },
                { name: "lib", optional: true, captureSpan: true },
                { name: "path", optional: true, captureSpan: true },
                { name: "no-default-lib", optional: true },
                { name: "resolution-mode", optional: true }
            ],
            kind: 1 /* PragmaKindFlags.TripleSlashXML */
        },
        "amd-dependency": {
            args: [{ name: "path" }, { name: "name", optional: true }],
            kind: 1 /* PragmaKindFlags.TripleSlashXML */
        },
        "amd-module": {
            args: [{ name: "name" }],
            kind: 1 /* PragmaKindFlags.TripleSlashXML */
        },
        "ts-check": {
            kind: 2 /* PragmaKindFlags.SingleLine */
        },
        "ts-nocheck": {
            kind: 2 /* PragmaKindFlags.SingleLine */
        },
        "jsx": {
            args: [{ name: "factory" }],
            kind: 4 /* PragmaKindFlags.MultiLine */
        },
        "jsxfrag": {
            args: [{ name: "factory" }],
            kind: 4 /* PragmaKindFlags.MultiLine */
        },
        "jsximportsource": {
            args: [{ name: "factory" }],
            kind: 4 /* PragmaKindFlags.MultiLine */
        },
        "jsxruntime": {
            args: [{ name: "factory" }],
            kind: 4 /* PragmaKindFlags.MultiLine */
        },
    };
})(ts || (ts = {}));
var ts;
(function (ts) {
    /**
     * djb2 hashing algorithm
     * http://www.cse.yorku.ca/~oz/hash.html
     */
    /* @internal */
    function generateDjb2Hash(data) {
        var acc = 5381;
        for (var i = 0; i < data.length; i++) {
            acc = ((acc << 5) + acc) + data.charCodeAt(i);
        }
        return acc.toString();
    }
    ts.generateDjb2Hash = generateDjb2Hash;
    /**
     * Set a high stack trace limit to provide more information in case of an error.
     * Called for command-line and server use cases.
     * Not called if TypeScript is used as a library.
     */
    /* @internal */
    function setStackTraceLimit() {
        if (Error.stackTraceLimit < 100) { // Also tests that we won't set the property if it doesn't exist.
            Error.stackTraceLimit = 100;
        }
    }
    ts.setStackTraceLimit = setStackTraceLimit;
    var FileWatcherEventKind;
    (function (FileWatcherEventKind) {
        FileWatcherEventKind[FileWatcherEventKind["Created"] = 0] = "Created";
        FileWatcherEventKind[FileWatcherEventKind["Changed"] = 1] = "Changed";
        FileWatcherEventKind[FileWatcherEventKind["Deleted"] = 2] = "Deleted";
    })(FileWatcherEventKind = ts.FileWatcherEventKind || (ts.FileWatcherEventKind = {}));
    /* @internal */
    var PollingInterval;
    (function (PollingInterval) {
        PollingInterval[PollingInterval["High"] = 2000] = "High";
        PollingInterval[PollingInterval["Medium"] = 500] = "Medium";
        PollingInterval[PollingInterval["Low"] = 250] = "Low";
    })(PollingInterval = ts.PollingInterval || (ts.PollingInterval = {}));
    /* @internal */
    ts.missingFileModifiedTime = new Date(0); // Any subsequent modification will occur after this time
    /* @internal */
    function getModifiedTime(host, fileName) {
        return host.getModifiedTime(fileName) || ts.missingFileModifiedTime;
    }
    ts.getModifiedTime = getModifiedTime;
    function createPollingIntervalBasedLevels(levels) {
        var _a;
        return _a = {},
            _a[PollingInterval.Low] = levels.Low,
            _a[PollingInterval.Medium] = levels.Medium,
            _a[PollingInterval.High] = levels.High,
            _a;
    }
    var defaultChunkLevels = { Low: 32, Medium: 64, High: 256 };
    var pollingChunkSize = createPollingIntervalBasedLevels(defaultChunkLevels);
    /* @internal */
    ts.unchangedPollThresholds = createPollingIntervalBasedLevels(defaultChunkLevels);
    /* @internal */
    function setCustomPollingValues(system) {
        if (!system.getEnvironmentVariable) {
            return;
        }
        var pollingIntervalChanged = setCustomLevels("TSC_WATCH_POLLINGINTERVAL", PollingInterval);
        pollingChunkSize = getCustomPollingBasedLevels("TSC_WATCH_POLLINGCHUNKSIZE", defaultChunkLevels) || pollingChunkSize;
        ts.unchangedPollThresholds = getCustomPollingBasedLevels("TSC_WATCH_UNCHANGEDPOLLTHRESHOLDS", defaultChunkLevels) || ts.unchangedPollThresholds;
        function getLevel(envVar, level) {
            return system.getEnvironmentVariable("".concat(envVar, "_").concat(level.toUpperCase()));
        }
        function getCustomLevels(baseVariable) {
            var customLevels;
            setCustomLevel("Low");
            setCustomLevel("Medium");
            setCustomLevel("High");
            return customLevels;
            function setCustomLevel(level) {
                var customLevel = getLevel(baseVariable, level);
                if (customLevel) {
                    (customLevels || (customLevels = {}))[level] = Number(customLevel);
                }
            }
        }
        function setCustomLevels(baseVariable, levels) {
            var customLevels = getCustomLevels(baseVariable);
            if (customLevels) {
                setLevel("Low");
                setLevel("Medium");
                setLevel("High");
                return true;
            }
            return false;
            function setLevel(level) {
                levels[level] = customLevels[level] || levels[level];
            }
        }
        function getCustomPollingBasedLevels(baseVariable, defaultLevels) {
            var customLevels = getCustomLevels(baseVariable);
            return (pollingIntervalChanged || customLevels) &&
                createPollingIntervalBasedLevels(customLevels ? __assign(__assign({}, defaultLevels), customLevels) : defaultLevels);
        }
    }
    ts.setCustomPollingValues = setCustomPollingValues;
    function pollWatchedFileQueue(host, queue, pollIndex, chunkSize, callbackOnWatchFileStat) {
        var definedValueCopyToIndex = pollIndex;
        // Max visit would be all elements of the queue
        for (var canVisit = queue.length; chunkSize && canVisit; nextPollIndex(), canVisit--) {
            var watchedFile = queue[pollIndex];
            if (!watchedFile) {
                continue;
            }
            else if (watchedFile.isClosed) {
                queue[pollIndex] = undefined;
                continue;
            }
            // Only files polled count towards chunkSize
            chunkSize--;
            var fileChanged = onWatchedFileStat(watchedFile, getModifiedTime(host, watchedFile.fileName));
            if (watchedFile.isClosed) {
                // Closed watcher as part of callback
                queue[pollIndex] = undefined;
                continue;
            }
            callbackOnWatchFileStat === null || callbackOnWatchFileStat === void 0 ? void 0 : callbackOnWatchFileStat(watchedFile, pollIndex, fileChanged);
            // Defragment the queue while we are at it
            if (queue[pollIndex]) {
                // Copy this file to the non hole location
                if (definedValueCopyToIndex < pollIndex) {
                    queue[definedValueCopyToIndex] = watchedFile;
                    queue[pollIndex] = undefined;
                }
                definedValueCopyToIndex++;
            }
        }
        // Return next poll index
        return pollIndex;
        function nextPollIndex() {
            pollIndex++;
            if (pollIndex === queue.length) {
                if (definedValueCopyToIndex < pollIndex) {
                    // There are holes from definedValueCopyToIndex to end of queue, change queue size
                    queue.length = definedValueCopyToIndex;
                }
                pollIndex = 0;
                definedValueCopyToIndex = 0;
            }
        }
    }
    /* @internal */
    function createDynamicPriorityPollingWatchFile(host) {
        var watchedFiles = [];
        var changedFilesInLastPoll = [];
        var lowPollingIntervalQueue = createPollingIntervalQueue(PollingInterval.Low);
        var mediumPollingIntervalQueue = createPollingIntervalQueue(PollingInterval.Medium);
        var highPollingIntervalQueue = createPollingIntervalQueue(PollingInterval.High);
        return watchFile;
        function watchFile(fileName, callback, defaultPollingInterval) {
            var file = {
                fileName: fileName,
                callback: callback,
                unchangedPolls: 0,
                mtime: getModifiedTime(host, fileName)
            };
            watchedFiles.push(file);
            addToPollingIntervalQueue(file, defaultPollingInterval);
            return {
                close: function () {
                    file.isClosed = true;
                    // Remove from watchedFiles
                    ts.unorderedRemoveItem(watchedFiles, file);
                    // Do not update polling interval queue since that will happen as part of polling
                }
            };
        }
        function createPollingIntervalQueue(pollingInterval) {
            var queue = [];
            queue.pollingInterval = pollingInterval;
            queue.pollIndex = 0;
            queue.pollScheduled = false;
            return queue;
        }
        function pollPollingIntervalQueue(queue) {
            queue.pollIndex = pollQueue(queue, queue.pollingInterval, queue.pollIndex, pollingChunkSize[queue.pollingInterval]);
            // Set the next polling index and timeout
            if (queue.length) {
                scheduleNextPoll(queue.pollingInterval);
            }
            else {
                ts.Debug.assert(queue.pollIndex === 0);
                queue.pollScheduled = false;
            }
        }
        function pollLowPollingIntervalQueue(queue) {
            // Always poll complete list of changedFilesInLastPoll
            pollQueue(changedFilesInLastPoll, PollingInterval.Low, /*pollIndex*/ 0, changedFilesInLastPoll.length);
            // Finally do the actual polling of the queue
            pollPollingIntervalQueue(queue);
            // Schedule poll if there are files in changedFilesInLastPoll but no files in the actual queue
            // as pollPollingIntervalQueue wont schedule for next poll
            if (!queue.pollScheduled && changedFilesInLastPoll.length) {
                scheduleNextPoll(PollingInterval.Low);
            }
        }
        function pollQueue(queue, pollingInterval, pollIndex, chunkSize) {
            return pollWatchedFileQueue(host, queue, pollIndex, chunkSize, onWatchFileStat);
            function onWatchFileStat(watchedFile, pollIndex, fileChanged) {
                if (fileChanged) {
                    watchedFile.unchangedPolls = 0;
                    // Changed files go to changedFilesInLastPoll queue
                    if (queue !== changedFilesInLastPoll) {
                        queue[pollIndex] = undefined;
                        addChangedFileToLowPollingIntervalQueue(watchedFile);
                    }
                }
                else if (watchedFile.unchangedPolls !== ts.unchangedPollThresholds[pollingInterval]) {
                    watchedFile.unchangedPolls++;
                }
                else if (queue === changedFilesInLastPoll) {
                    // Restart unchangedPollCount for unchanged file and move to low polling interval queue
                    watchedFile.unchangedPolls = 1;
                    queue[pollIndex] = undefined;
                    addToPollingIntervalQueue(watchedFile, PollingInterval.Low);
                }
                else if (pollingInterval !== PollingInterval.High) {
                    watchedFile.unchangedPolls++;
                    queue[pollIndex] = undefined;
                    addToPollingIntervalQueue(watchedFile, pollingInterval === PollingInterval.Low ? PollingInterval.Medium : PollingInterval.High);
                }
            }
        }
        function pollingIntervalQueue(pollingInterval) {
            switch (pollingInterval) {
                case PollingInterval.Low:
                    return lowPollingIntervalQueue;
                case PollingInterval.Medium:
                    return mediumPollingIntervalQueue;
                case PollingInterval.High:
                    return highPollingIntervalQueue;
            }
        }
        function addToPollingIntervalQueue(file, pollingInterval) {
            pollingIntervalQueue(pollingInterval).push(file);
            scheduleNextPollIfNotAlreadyScheduled(pollingInterval);
        }
        function addChangedFileToLowPollingIntervalQueue(file) {
            changedFilesInLastPoll.push(file);
            scheduleNextPollIfNotAlreadyScheduled(PollingInterval.Low);
        }
        function scheduleNextPollIfNotAlreadyScheduled(pollingInterval) {
            if (!pollingIntervalQueue(pollingInterval).pollScheduled) {
                scheduleNextPoll(pollingInterval);
            }
        }
        function scheduleNextPoll(pollingInterval) {
            pollingIntervalQueue(pollingInterval).pollScheduled = host.setTimeout(pollingInterval === PollingInterval.Low ? pollLowPollingIntervalQueue : pollPollingIntervalQueue, pollingInterval, pollingIntervalQueue(pollingInterval));
        }
    }
    ts.createDynamicPriorityPollingWatchFile = createDynamicPriorityPollingWatchFile;
    function createUseFsEventsOnParentDirectoryWatchFile(fsWatch, useCaseSensitiveFileNames) {
        // One file can have multiple watchers
        var fileWatcherCallbacks = ts.createMultiMap();
        var dirWatchers = new ts.Map();
        var toCanonicalName = ts.createGetCanonicalFileName(useCaseSensitiveFileNames);
        return nonPollingWatchFile;
        function nonPollingWatchFile(fileName, callback, _pollingInterval, fallbackOptions) {
            var filePath = toCanonicalName(fileName);
            fileWatcherCallbacks.add(filePath, callback);
            var dirPath = ts.getDirectoryPath(filePath) || ".";
            var watcher = dirWatchers.get(dirPath) ||
                createDirectoryWatcher(ts.getDirectoryPath(fileName) || ".", dirPath, fallbackOptions);
            watcher.referenceCount++;
            return {
                close: function () {
                    if (watcher.referenceCount === 1) {
                        watcher.close();
                        dirWatchers.delete(dirPath);
                    }
                    else {
                        watcher.referenceCount--;
                    }
                    fileWatcherCallbacks.remove(filePath, callback);
                }
            };
        }
        function createDirectoryWatcher(dirName, dirPath, fallbackOptions) {
            var watcher = fsWatch(dirName, 1 /* FileSystemEntryKind.Directory */, function (_eventName, relativeFileName, modifiedTime) {
                // When files are deleted from disk, the triggered "rename" event would have a relativefileName of "undefined"
                if (!ts.isString(relativeFileName))
                    return;
                var fileName = ts.getNormalizedAbsolutePath(relativeFileName, dirName);
                // Some applications save a working file via rename operations
                var callbacks = fileName && fileWatcherCallbacks.get(toCanonicalName(fileName));
                if (callbacks) {
                    for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {
                        var fileCallback = callbacks_1[_i];
                        fileCallback(fileName, FileWatcherEventKind.Changed, modifiedTime);
                    }
                }
            }, 
            /*recursive*/ false, PollingInterval.Medium, fallbackOptions);
            watcher.referenceCount = 0;
            dirWatchers.set(dirPath, watcher);
            return watcher;
        }
    }
    function createFixedChunkSizePollingWatchFile(host) {
        var watchedFiles = [];
        var pollIndex = 0;
        var pollScheduled;
        return watchFile;
        function watchFile(fileName, callback) {
            var file = {
                fileName: fileName,
                callback: callback,
                mtime: getModifiedTime(host, fileName)
            };
            watchedFiles.push(file);
            scheduleNextPoll();
            return {
                close: function () {
                    file.isClosed = true;
                    ts.unorderedRemoveItem(watchedFiles, file);
                }
            };
        }
        function pollQueue() {
            pollScheduled = undefined;
            pollIndex = pollWatchedFileQueue(host, watchedFiles, pollIndex, pollingChunkSize[PollingInterval.Low]);
            scheduleNextPoll();
        }
        function scheduleNextPoll() {
            if (!watchedFiles.length || pollScheduled)
                return;
            pollScheduled = host.setTimeout(pollQueue, PollingInterval.High);
        }
    }
    /* @internal */
    function createSingleFileWatcherPerName(watchFile, useCaseSensitiveFileNames) {
        var cache = new ts.Map();
        var callbacksCache = ts.createMultiMap();
        var toCanonicalFileName = ts.createGetCanonicalFileName(useCaseSensitiveFileNames);
        return function (fileName, callback, pollingInterval, options) {
            var path = toCanonicalFileName(fileName);
            var existing = cache.get(path);
            if (existing) {
                existing.refCount++;
            }
            else {
                cache.set(path, {
                    watcher: watchFile(fileName, function (fileName, eventKind, modifiedTime) { return ts.forEach(callbacksCache.get(path), function (cb) { return cb(fileName, eventKind, modifiedTime); }); }, pollingInterval, options),
                    refCount: 1
                });
            }
            callbacksCache.add(path, callback);
            return {
                close: function () {
                    var watcher = ts.Debug.checkDefined(cache.get(path));
                    callbacksCache.remove(path, callback);
                    watcher.refCount--;
                    if (watcher.refCount)
                        return;
                    cache.delete(path);
                    ts.closeFileWatcherOf(watcher);
                }
            };
        };
    }
    ts.createSingleFileWatcherPerName = createSingleFileWatcherPerName;
    /**
     * Returns true if file status changed
     */
    /*@internal*/
    function onWatchedFileStat(watchedFile, modifiedTime) {
        var oldTime = watchedFile.mtime.getTime();
        var newTime = modifiedTime.getTime();
        if (oldTime !== newTime) {
            watchedFile.mtime = modifiedTime;
            // Pass modified times so tsc --build can use it
            watchedFile.callback(watchedFile.fileName, getFileWatcherEventKind(oldTime, newTime), modifiedTime);
            return true;
        }
        return false;
    }
    ts.onWatchedFileStat = onWatchedFileStat;
    /*@internal*/
    function getFileWatcherEventKind(oldTime, newTime) {
        return oldTime === 0
            ? FileWatcherEventKind.Created
            : newTime === 0
                ? FileWatcherEventKind.Deleted
                : FileWatcherEventKind.Changed;
    }
    ts.getFileWatcherEventKind = getFileWatcherEventKind;
    /*@internal*/
    ts.ignoredPaths = ["/node_modules/.", "/.git", "/.#"];
    var curSysLog = ts.noop; // eslint-disable-line prefer-const
    /*@internal*/
    function sysLog(s) {
        return curSysLog(s);
    }
    ts.sysLog = sysLog;
    /*@internal*/
    function setSysLog(logger) {
        curSysLog = logger;
    }
    ts.setSysLog = setSysLog;
    /**
     * Watch the directory recursively using host provided method to watch child directories
     * that means if this is recursive watcher, watch the children directories as well
     * (eg on OS that dont support recursive watch using fs.watch use fs.watchFile)
     */
    /*@internal*/
    function createDirectoryWatcherSupportingRecursive(_a) {
        var watchDirectory = _a.watchDirectory, useCaseSensitiveFileNames = _a.useCaseSensitiveFileNames, getCurrentDirectory = _a.getCurrentDirectory, getAccessibleSortedChildDirectories = _a.getAccessibleSortedChildDirectories, fileSystemEntryExists = _a.fileSystemEntryExists, realpath = _a.realpath, setTimeout = _a.setTimeout, clearTimeout = _a.clearTimeout;
        var cache = new ts.Map();
        var callbackCache = ts.createMultiMap();
        var cacheToUpdateChildWatches = new ts.Map();
        var timerToUpdateChildWatches;
        var filePathComparer = ts.getStringComparer(!useCaseSensitiveFileNames);
        var toCanonicalFilePath = ts.createGetCanonicalFileName(useCaseSensitiveFileNames);
        return function (dirName, callback, recursive, options) { return recursive ?
            createDirectoryWatcher(dirName, options, callback) :
            watchDirectory(dirName, callback, recursive, options); };
        /**
         * Create the directory watcher for the dirPath.
         */
        function createDirectoryWatcher(dirName, options, callback) {
            var dirPath = toCanonicalFilePath(dirName);
            var directoryWatcher = cache.get(dirPath);
            if (directoryWatcher) {
                directoryWatcher.refCount++;
            }
            else {
                directoryWatcher = {
                    watcher: watchDirectory(dirName, function (fileName) {
                        if (isIgnoredPath(fileName, options))
                            return;
                        if (options === null || options === void 0 ? void 0 : options.synchronousWatchDirectory) {
                            // Call the actual callback
                            invokeCallbacks(dirPath, fileName);
                            // Iterate through existing children and update the watches if needed
                            updateChildWatches(dirName, dirPath, options);
                        }
                        else {
                            nonSyncUpdateChildWatches(dirName, dirPath, fileName, options);
                        }
                    }, /*recursive*/ false, options),
                    refCount: 1,
                    childWatches: ts.emptyArray
                };
                cache.set(dirPath, directoryWatcher);
                updateChildWatches(dirName, dirPath, options);
            }
            var callbackToAdd = callback && { dirName: dirName, callback: callback };
            if (callbackToAdd) {
                callbackCache.add(dirPath, callbackToAdd);
            }
            return {
                dirName: dirName,
                close: function () {
                    var directoryWatcher = ts.Debug.checkDefined(cache.get(dirPath));
                    if (callbackToAdd)
                        callbackCache.remove(dirPath, callbackToAdd);
                    directoryWatcher.refCount--;
                    if (directoryWatcher.refCount)
                        return;
                    cache.delete(dirPath);
                    ts.closeFileWatcherOf(directoryWatcher);
                    directoryWatcher.childWatches.forEach(ts.closeFileWatcher);
                }
            };
        }
        function invokeCallbacks(dirPath, fileNameOrInvokeMap, fileNames) {
            var fileName;
            var invokeMap;
            if (ts.isString(fileNameOrInvokeMap)) {
                fileName = fileNameOrInvokeMap;
            }
            else {
                invokeMap = fileNameOrInvokeMap;
            }
            // Call the actual callback
            callbackCache.forEach(function (callbacks, rootDirName) {
                var _a;
                if (invokeMap && invokeMap.get(rootDirName) === true)
                    return;
                if (rootDirName === dirPath || (ts.startsWith(dirPath, rootDirName) && dirPath[rootDirName.length] === ts.directorySeparator)) {
                    if (invokeMap) {
                        if (fileNames) {
                            var existing = invokeMap.get(rootDirName);
                            if (existing) {
                                (_a = existing).push.apply(_a, fileNames);
                            }
                            else {
                                invokeMap.set(rootDirName, fileNames.slice());
                            }
                        }
                        else {
                            invokeMap.set(rootDirName, true);
                        }
                    }
                    else {
                        callbacks.forEach(function (_a) {
                            var callback = _a.callback;
                            return callback(fileName);
                        });
                    }
                }
            });
        }
        function nonSyncUpdateChildWatches(dirName, dirPath, fileName, options) {
            // Iterate through existing children and update the watches if needed
            var parentWatcher = cache.get(dirPath);
            if (parentWatcher && fileSystemEntryExists(dirName, 1 /* FileSystemEntryKind.Directory */)) {
                // Schedule the update and postpone invoke for callbacks
                scheduleUpdateChildWatches(dirName, dirPath, fileName, options);
                return;
            }
            // Call the actual callbacks and remove child watches
            invokeCallbacks(dirPath, fileName);
            removeChildWatches(parentWatcher);
        }
        function scheduleUpdateChildWatches(dirName, dirPath, fileName, options) {
            var existing = cacheToUpdateChildWatches.get(dirPath);
            if (existing) {
                existing.fileNames.push(fileName);
            }
            else {
                cacheToUpdateChildWatches.set(dirPath, { dirName: dirName, options: options, fileNames: [fileName] });
            }
            if (timerToUpdateChildWatches) {
                clearTimeout(timerToUpdateChildWatches);
                timerToUpdateChildWatches = undefined;
            }
            timerToUpdateChildWatches = setTimeout(onTimerToUpdateChildWatches, 1000);
        }
        function onTimerToUpdateChildWatches() {
            timerToUpdateChildWatches = undefined;
            sysLog("sysLog:: onTimerToUpdateChildWatches:: ".concat(cacheToUpdateChildWatches.size));
            var start = ts.timestamp();
            var invokeMap = new ts.Map();
            while (!timerToUpdateChildWatches && cacheToUpdateChildWatches.size) {
                var result = cacheToUpdateChildWatches.entries().next();
                ts.Debug.assert(!result.done);
                var _a = result.value, dirPath = _a[0], _b = _a[1], dirName = _b.dirName, options = _b.options, fileNames = _b.fileNames;
                cacheToUpdateChildWatches.delete(dirPath);
                // Because the child refresh is fresh, we would need to invalidate whole root directory being watched
                // to ensure that all the changes are reflected at this time
                var hasChanges = updateChildWatches(dirName, dirPath, options);
                invokeCallbacks(dirPath, invokeMap, hasChanges ? undefined : fileNames);
            }
            sysLog("sysLog:: invokingWatchers:: Elapsed:: ".concat(ts.timestamp() - start, "ms:: ").concat(cacheToUpdateChildWatches.size));
            callbackCache.forEach(function (callbacks, rootDirName) {
                var existing = invokeMap.get(rootDirName);
                if (existing) {
                    callbacks.forEach(function (_a) {
                        var callback = _a.callback, dirName = _a.dirName;
                        if (ts.isArray(existing)) {
                            existing.forEach(callback);
                        }
                        else {
                            callback(dirName);
                        }
                    });
                }
            });
            var elapsed = ts.timestamp() - start;
            sysLog("sysLog:: Elapsed:: ".concat(elapsed, "ms:: onTimerToUpdateChildWatches:: ").concat(cacheToUpdateChildWatches.size, " ").concat(timerToUpdateChildWatches));
        }
        function removeChildWatches(parentWatcher) {
            if (!parentWatcher)
                return;
            var existingChildWatches = parentWatcher.childWatches;
            parentWatcher.childWatches = ts.emptyArray;
            for (var _i = 0, existingChildWatches_1 = existingChildWatches; _i < existingChildWatches_1.length; _i++) {
                var childWatcher = existingChildWatches_1[_i];
                childWatcher.close();
                removeChildWatches(cache.get(toCanonicalFilePath(childWatcher.dirName)));
            }
        }
        function updateChildWatches(parentDir, parentDirPath, options) {
            // Iterate through existing children and update the watches if needed
            var parentWatcher = cache.get(parentDirPath);
            if (!parentWatcher)
                return false;
            var newChildWatches;
            var hasChanges = ts.enumerateInsertsAndDeletes(fileSystemEntryExists(parentDir, 1 /* FileSystemEntryKind.Directory */) ? ts.mapDefined(getAccessibleSortedChildDirectories(parentDir), function (child) {
                var childFullName = ts.getNormalizedAbsolutePath(child, parentDir);
                // Filter our the symbolic link directories since those arent included in recursive watch
                // which is same behaviour when recursive: true is passed to fs.watch
                return !isIgnoredPath(childFullName, options) && filePathComparer(childFullName, ts.normalizePath(realpath(childFullName))) === 0 /* Comparison.EqualTo */ ? childFullName : undefined;
            }) : ts.emptyArray, parentWatcher.childWatches, function (child, childWatcher) { return filePathComparer(child, childWatcher.dirName); }, createAndAddChildDirectoryWatcher, ts.closeFileWatcher, addChildDirectoryWatcher);
            parentWatcher.childWatches = newChildWatches || ts.emptyArray;
            return hasChanges;
            /**
             * Create new childDirectoryWatcher and add it to the new ChildDirectoryWatcher list
             */
            function createAndAddChildDirectoryWatcher(childName) {
                var result = createDirectoryWatcher(childName, options);
                addChildDirectoryWatcher(result);
            }
            /**
             * Add child directory watcher to the new ChildDirectoryWatcher list
             */
            function addChildDirectoryWatcher(childWatcher) {
                (newChildWatches || (newChildWatches = [])).push(childWatcher);
            }
        }
        function isIgnoredPath(path, options) {
            return ts.some(ts.ignoredPaths, function (searchPath) { return isInPath(path, searchPath); }) ||
                isIgnoredByWatchOptions(path, options, useCaseSensitiveFileNames, getCurrentDirectory);
        }
        function isInPath(path, searchPath) {
            if (ts.stringContains(path, searchPath))
                return true;
            if (useCaseSensitiveFileNames)
                return false;
            return ts.stringContains(toCanonicalFilePath(path), searchPath);
        }
    }
    ts.createDirectoryWatcherSupportingRecursive = createDirectoryWatcherSupportingRecursive;
    /*@internal*/
    var FileSystemEntryKind;
    (function (FileSystemEntryKind) {
        FileSystemEntryKind[FileSystemEntryKind["File"] = 0] = "File";
        FileSystemEntryKind[FileSystemEntryKind["Directory"] = 1] = "Directory";
    })(FileSystemEntryKind = ts.FileSystemEntryKind || (ts.FileSystemEntryKind = {}));
    /*@internal*/
    function createFileWatcherCallback(callback) {
        return function (_fileName, eventKind, modifiedTime) { return callback(eventKind === FileWatcherEventKind.Changed ? "change" : "rename", "", modifiedTime); };
    }
    ts.createFileWatcherCallback = createFileWatcherCallback;
    function createFsWatchCallbackForFileWatcherCallback(fileName, callback, getModifiedTime) {
        return function (eventName, _relativeFileName, modifiedTime) {
            if (eventName === "rename") {
                // Check time stamps rather than file system entry checks
                modifiedTime || (modifiedTime = getModifiedTime(fileName) || ts.missingFileModifiedTime);
                callback(fileName, modifiedTime !== ts.missingFileModifiedTime ? FileWatcherEventKind.Created : FileWatcherEventKind.Deleted, modifiedTime);
            }
            else {
                // Change
                callback(fileName, FileWatcherEventKind.Changed, modifiedTime);
            }
        };
    }
    function isIgnoredByWatchOptions(pathToCheck, options, useCaseSensitiveFileNames, getCurrentDirectory) {
        return ((options === null || options === void 0 ? void 0 : options.excludeDirectories) || (options === null || options === void 0 ? void 0 : options.excludeFiles)) && (ts.matchesExclude(pathToCheck, options === null || options === void 0 ? void 0 : options.excludeFiles, useCaseSensitiveFileNames, getCurrentDirectory()) ||
            ts.matchesExclude(pathToCheck, options === null || options === void 0 ? void 0 : options.excludeDirectories, useCaseSensitiveFileNames, getCurrentDirectory()));
    }
    function createFsWatchCallbackForDirectoryWatcherCallback(directoryName, callback, options, useCaseSensitiveFileNames, getCurrentDirectory) {
        return function (eventName, relativeFileName) {
            // In watchDirectory we only care about adding and removing files (when event name is
            // "rename"); changes made within files are handled by corresponding fileWatchers (when
            // event name is "change")
            if (eventName === "rename") {
                // When deleting a file, the passed baseFileName is null
                var fileName = !relativeFileName ? directoryName : ts.normalizePath(ts.combinePaths(directoryName, relativeFileName));
                if (!relativeFileName || !isIgnoredByWatchOptions(fileName, options, useCaseSensitiveFileNames, getCurrentDirectory)) {
                    callback(fileName);
                }
            }
        };
    }
    /*@internal*/
    function createSystemWatchFunctions(_a) {
        var pollingWatchFile = _a.pollingWatchFile, getModifiedTime = _a.getModifiedTime, setTimeout = _a.setTimeout, clearTimeout = _a.clearTimeout, fsWatchWorker = _a.fsWatchWorker, fileSystemEntryExists = _a.fileSystemEntryExists, useCaseSensitiveFileNames = _a.useCaseSensitiveFileNames, getCurrentDirectory = _a.getCurrentDirectory, fsSupportsRecursiveFsWatch = _a.fsSupportsRecursiveFsWatch, getAccessibleSortedChildDirectories = _a.getAccessibleSortedChildDirectories, realpath = _a.realpath, tscWatchFile = _a.tscWatchFile, useNonPollingWatchers = _a.useNonPollingWatchers, tscWatchDirectory = _a.tscWatchDirectory, defaultWatchFileKind = _a.defaultWatchFileKind, inodeWatching = _a.inodeWatching, sysLog = _a.sysLog;
        var dynamicPollingWatchFile;
        var fixedChunkSizePollingWatchFile;
        var nonPollingWatchFile;
        var hostRecursiveDirectoryWatcher;
        var hitSystemWatcherLimit = false;
        return {
            watchFile: watchFile,
            watchDirectory: watchDirectory
        };
        function watchFile(fileName, callback, pollingInterval, options) {
            options = updateOptionsForWatchFile(options, useNonPollingWatchers);
            var watchFileKind = ts.Debug.checkDefined(options.watchFile);
            switch (watchFileKind) {
                case ts.WatchFileKind.FixedPollingInterval:
                    return pollingWatchFile(fileName, callback, PollingInterval.Low, /*options*/ undefined);
                case ts.WatchFileKind.PriorityPollingInterval:
                    return pollingWatchFile(fileName, callback, pollingInterval, /*options*/ undefined);
                case ts.WatchFileKind.DynamicPriorityPolling:
                    return ensureDynamicPollingWatchFile()(fileName, callback, pollingInterval, /*options*/ undefined);
                case ts.WatchFileKind.FixedChunkSizePolling:
                    return ensureFixedChunkSizePollingWatchFile()(fileName, callback, /* pollingInterval */ undefined, /*options*/ undefined);
                case ts.WatchFileKind.UseFsEvents:
                    return fsWatch(fileName, 0 /* FileSystemEntryKind.File */, createFsWatchCallbackForFileWatcherCallback(fileName, callback, getModifiedTime), 
                    /*recursive*/ false, pollingInterval, ts.getFallbackOptions(options));
                case ts.WatchFileKind.UseFsEventsOnParentDirectory:
                    if (!nonPollingWatchFile) {
                        nonPollingWatchFile = createUseFsEventsOnParentDirectoryWatchFile(fsWatch, useCaseSensitiveFileNames);
                    }
                    return nonPollingWatchFile(fileName, callback, pollingInterval, ts.getFallbackOptions(options));
                default:
                    ts.Debug.assertNever(watchFileKind);
            }
        }
        function ensureDynamicPollingWatchFile() {
            return dynamicPollingWatchFile || (dynamicPollingWatchFile = createDynamicPriorityPollingWatchFile({ getModifiedTime: getModifiedTime, setTimeout: setTimeout }));
        }
        function ensureFixedChunkSizePollingWatchFile() {
            return fixedChunkSizePollingWatchFile || (fixedChunkSizePollingWatchFile = createFixedChunkSizePollingWatchFile({ getModifiedTime: getModifiedTime, setTimeout: setTimeout }));
        }
        function updateOptionsForWatchFile(options, useNonPollingWatchers) {
            if (options && options.watchFile !== undefined)
                return options;
            switch (tscWatchFile) {
                case "PriorityPollingInterval":
                    // Use polling interval based on priority when create watch using host.watchFile
                    return { watchFile: ts.WatchFileKind.PriorityPollingInterval };
                case "DynamicPriorityPolling":
                    // Use polling interval but change the interval depending on file changes and their default polling interval
                    return { watchFile: ts.WatchFileKind.DynamicPriorityPolling };
                case "UseFsEvents":
                    // Use notifications from FS to watch with falling back to fs.watchFile
                    return generateWatchFileOptions(ts.WatchFileKind.UseFsEvents, ts.PollingWatchKind.PriorityInterval, options);
                case "UseFsEventsWithFallbackDynamicPolling":
                    // Use notifications from FS to watch with falling back to dynamic watch file
                    return generateWatchFileOptions(ts.WatchFileKind.UseFsEvents, ts.PollingWatchKind.DynamicPriority, options);
                case "UseFsEventsOnParentDirectory":
                    useNonPollingWatchers = true;
                // fall through
                default:
                    return useNonPollingWatchers ?
                        // Use notifications from FS to watch with falling back to fs.watchFile
                        generateWatchFileOptions(ts.WatchFileKind.UseFsEventsOnParentDirectory, ts.PollingWatchKind.PriorityInterval, options) :
                        // Default to do not use fixed polling interval
                        { watchFile: (defaultWatchFileKind === null || defaultWatchFileKind === void 0 ? void 0 : defaultWatchFileKind()) || ts.WatchFileKind.FixedPollingInterval };
            }
        }
        function generateWatchFileOptions(watchFile, fallbackPolling, options) {
            var defaultFallbackPolling = options === null || options === void 0 ? void 0 : options.fallbackPolling;
            return {
                watchFile: watchFile,
                fallbackPolling: defaultFallbackPolling === undefined ?
                    fallbackPolling :
                    defaultFallbackPolling
            };
        }
        function watchDirectory(directoryName, callback, recursive, options) {
            if (fsSupportsRecursiveFsWatch) {
                return fsWatch(directoryName, 1 /* FileSystemEntryKind.Directory */, createFsWatchCallbackForDirectoryWatcherCallback(directoryName, callback, options, useCaseSensitiveFileNames, getCurrentDirectory), recursive, PollingInterval.Medium, ts.getFallbackOptions(options));
            }
            if (!hostRecursiveDirectoryWatcher) {
                hostRecursiveDirectoryWatcher = createDirectoryWatcherSupportingRecursive({
                    useCaseSensitiveFileNames: useCaseSensitiveFileNames,
                    getCurrentDirectory: getCurrentDirectory,
                    fileSystemEntryExists: fileSystemEntryExists,
                    getAccessibleSortedChildDirectories: getAccessibleSortedChildDirectories,
                    watchDirectory: nonRecursiveWatchDirectory,
                    realpath: realpath,
                    setTimeout: setTimeout,
                    clearTimeout: clearTimeout
                });
            }
            return hostRecursiveDirectoryWatcher(directoryName, callback, recursive, options);
        }
        function nonRecursiveWatchDirectory(directoryName, callback, recursive, options) {
            ts.Debug.assert(!recursive);
            var watchDirectoryOptions = updateOptionsForWatchDirectory(options);
            var watchDirectoryKind = ts.Debug.checkDefined(watchDirectoryOptions.watchDirectory);
            switch (watchDirectoryKind) {
                case ts.WatchDirectoryKind.FixedPollingInterval:
                    return pollingWatchFile(directoryName, function () { return callback(directoryName); }, PollingInterval.Medium, 
                    /*options*/ undefined);
                case ts.WatchDirectoryKind.DynamicPriorityPolling:
                    return ensureDynamicPollingWatchFile()(directoryName, function () { return callback(directoryName); }, PollingInterval.Medium, 
                    /*options*/ undefined);
                case ts.WatchDirectoryKind.FixedChunkSizePolling:
                    return ensureFixedChunkSizePollingWatchFile()(directoryName, function () { return callback(directoryName); }, 
                    /* pollingInterval */ undefined, 
                    /*options*/ undefined);
                case ts.WatchDirectoryKind.UseFsEvents:
                    return fsWatch(directoryName, 1 /* FileSystemEntryKind.Directory */, createFsWatchCallbackForDirectoryWatcherCallback(directoryName, callback, options, useCaseSensitiveFileNames, getCurrentDirectory), recursive, PollingInterval.Medium, ts.getFallbackOptions(watchDirectoryOptions));
                default:
                    ts.Debug.assertNever(watchDirectoryKind);
            }
        }
        function updateOptionsForWatchDirectory(options) {
            if (options && options.watchDirectory !== undefined)
                return options;
            switch (tscWatchDirectory) {
                case "RecursiveDirectoryUsingFsWatchFile":
                    // Use polling interval based on priority when create watch using host.watchFile
                    return { watchDirectory: ts.WatchDirectoryKind.FixedPollingInterval };
                case "RecursiveDirectoryUsingDynamicPriorityPolling":
                    // Use polling interval but change the interval depending on file changes and their default polling interval
                    return { watchDirectory: ts.WatchDirectoryKind.DynamicPriorityPolling };
                default:
                    var defaultFallbackPolling = options === null || options === void 0 ? void 0 : options.fallbackPolling;
                    return {
                        watchDirectory: ts.WatchDirectoryKind.UseFsEvents,
                        fallbackPolling: defaultFallbackPolling !== undefined ?
                            defaultFallbackPolling :
                            undefined
                    };
            }
        }
        function fsWatch(fileOrDirectory, entryKind, callback, recursive, fallbackPollingInterval, fallbackOptions) {
            var lastDirectoryPartWithDirectorySeparator;
            var lastDirectoryPart;
            if (inodeWatching) {
                lastDirectoryPartWithDirectorySeparator = fileOrDirectory.substring(fileOrDirectory.lastIndexOf(ts.directorySeparator));
                lastDirectoryPart = lastDirectoryPartWithDirectorySeparator.slice(ts.directorySeparator.length);
            }
            /** Watcher for the file system entry depending on whether it is missing or present */
            var watcher = !fileSystemEntryExists(fileOrDirectory, entryKind) ?
                watchMissingFileSystemEntry() :
                watchPresentFileSystemEntry();
            return {
                close: function () {
                    // Close the watcher (either existing file system entry watcher or missing file system entry watcher)
                    if (watcher) {
                        watcher.close();
                        watcher = undefined;
                    }
                }
            };
            function updateWatcher(createWatcher) {
                // If watcher is not closed, update it
                if (watcher) {
                    sysLog("sysLog:: ".concat(fileOrDirectory, ":: Changing watcher to ").concat(createWatcher === watchPresentFileSystemEntry ? "Present" : "Missing", "FileSystemEntryWatcher"));
                    watcher.close();
                    watcher = createWatcher();
                }
            }
            /**
             * Watch the file or directory that is currently present
             * and when the watched file or directory is deleted, switch to missing file system entry watcher
             */
            function watchPresentFileSystemEntry() {
                if (hitSystemWatcherLimit) {
                    sysLog("sysLog:: ".concat(fileOrDirectory, ":: Defaulting to watchFile"));
                    return watchPresentFileSystemEntryWithFsWatchFile();
                }
                try {
                    var presentWatcher = fsWatchWorker(fileOrDirectory, recursive, inodeWatching ?
                        callbackChangingToMissingFileSystemEntry :
                        callback);
                    // Watch the missing file or directory or error
                    presentWatcher.on("error", function () {
                        callback("rename", "");
                        updateWatcher(watchMissingFileSystemEntry);
                    });
                    return presentWatcher;
                }
                catch (e) {
                    // Catch the exception and use polling instead
                    // Eg. on linux the number of watches are limited and one could easily exhaust watches and the exception ENOSPC is thrown when creating watcher at that point
                    // so instead of throwing error, use fs.watchFile
                    hitSystemWatcherLimit || (hitSystemWatcherLimit = e.code === "ENOSPC");
                    sysLog("sysLog:: ".concat(fileOrDirectory, ":: Changing to watchFile"));
                    return watchPresentFileSystemEntryWithFsWatchFile();
                }
            }
            function callbackChangingToMissingFileSystemEntry(event, relativeName) {
                // In some scenarios, file save operation fires event with fileName.ext~ instead of fileName.ext
                // To ensure we see the file going missing and coming back up (file delete and then recreated)
                // and watches being updated correctly we are calling back with fileName.ext as well as fileName.ext~
                // The worst is we have fired event that was not needed but we wont miss any changes
                // especially in cases where file goes missing and watches wrong inode
                var originalRelativeName;
                if (relativeName && ts.endsWith(relativeName, "~")) {
                    originalRelativeName = relativeName;
                    relativeName = relativeName.slice(0, relativeName.length - 1);
                }
                // because relativeName is not guaranteed to be correct we need to check on each rename with few combinations
                // Eg on ubuntu while watching app/node_modules the relativeName is "node_modules" which is neither relative nor full path
                if (event === "rename" &&
                    (!relativeName ||
                        relativeName === lastDirectoryPart ||
                        ts.endsWith(relativeName, lastDirectoryPartWithDirectorySeparator))) {
                    var modifiedTime = getModifiedTime(fileOrDirectory) || ts.missingFileModifiedTime;
                    if (originalRelativeName)
                        callback(event, originalRelativeName, modifiedTime);
                    callback(event, relativeName, modifiedTime);
                    if (inodeWatching) {
                        // If this was rename event, inode has changed means we need to update watcher
                        updateWatcher(modifiedTime === ts.missingFileModifiedTime ? watchMissingFileSystemEntry : watchPresentFileSystemEntry);
                    }
                    else if (modifiedTime === ts.missingFileModifiedTime) {
                        updateWatcher(watchMissingFileSystemEntry);
                    }
                }
                else {
                    if (originalRelativeName)
                        callback(event, originalRelativeName);
                    callback(event, relativeName);
                }
            }
            /**
             * Watch the file or directory using fs.watchFile since fs.watch threw exception
             * Eg. on linux the number of watches are limited and one could easily exhaust watches and the exception ENOSPC is thrown when creating watcher at that point
             */
            function watchPresentFileSystemEntryWithFsWatchFile() {
                return watchFile(fileOrDirectory, createFileWatcherCallback(callback), fallbackPollingInterval, fallbackOptions);
            }
            /**
             * Watch the file or directory that is missing
             * and switch to existing file or directory when the missing filesystem entry is created
             */
            function watchMissingFileSystemEntry() {
                return watchFile(fileOrDirectory, function (_fileName, eventKind, modifiedTime) {
                    if (eventKind === FileWatcherEventKind.Created) {
                        modifiedTime || (modifiedTime = getModifiedTime(fileOrDirectory) || ts.missingFileModifiedTime);
                        if (modifiedTime !== ts.missingFileModifiedTime) {
                            callback("rename", "", modifiedTime);
                            // Call the callback for current file or directory
                            // For now it could be callback for the inner directory creation,
                            // but just return current directory, better than current no-op
                            updateWatcher(watchPresentFileSystemEntry);
                        }
                    }
                }, fallbackPollingInterval, fallbackOptions);
            }
        }
    }
    ts.createSystemWatchFunctions = createSystemWatchFunctions;
    /**
     * patch writefile to create folder before writing the file
     */
    /*@internal*/
    function patchWriteFileEnsuringDirectory(sys) {
        // patch writefile to create folder before writing the file
        var originalWriteFile = sys.writeFile;
        sys.writeFile = function (path, data, writeBom) {
            return ts.writeFileEnsuringDirectories(path, data, !!writeBom, function (path, data, writeByteOrderMark) { return originalWriteFile.call(sys, path, data, writeByteOrderMark); }, function (path) { return sys.createDirectory(path); }, function (path) { return sys.directoryExists(path); });
        };
    }
    ts.patchWriteFileEnsuringDirectory = patchWriteFileEnsuringDirectory;
    function getNodeMajorVersion() {
        if (typeof process === "undefined") {
            return undefined;
        }
        var version = process.version;
        if (!version) {
            return undefined;
        }
        var dot = version.indexOf(".");
        if (dot === -1) {
            return undefined;
        }
        return parseInt(version.substring(1, dot));
    }
    ts.getNodeMajorVersion = getNodeMajorVersion;
    // TODO: GH#18217 this is used as if it's certainly defined in many places.
    // eslint-disable-next-line prefer-const
    ts.sys = (function () {
        // NodeJS detects "\uFEFF" at the start of the string and *replaces* it with the actual
        // byte order mark from the specified encoding. Using any other byte order mark does
        // not actually work.
        var byteOrderMarkIndicator = "\uFEFF";
        function getNodeSystem() {
            var nativePattern = /^native |^\([^)]+\)$|^(internal[\\/]|[a-zA-Z0-9_\s]+(\.js)?$)/;
            var _fs = require("fs");
            var _path = require("path");
            var _os = require("os");
            // crypto can be absent on reduced node installations
            var _crypto;
            try {
                _crypto = require("crypto");
            }
            catch (_a) {
                _crypto = undefined;
            }
            var activeSession;
            var profilePath = "./profile.cpuprofile";
            var Buffer = require("buffer").Buffer;
            var nodeVersion = getNodeMajorVersion();
            var isNode4OrLater = nodeVersion >= 4;
            var isLinuxOrMacOs = process.platform === "linux" || process.platform === "darwin";
            var platform = _os.platform();
            var useCaseSensitiveFileNames = isFileSystemCaseSensitive();
            var fsRealpath = !!_fs.realpathSync.native ? process.platform === "win32" ? fsRealPathHandlingLongPath : _fs.realpathSync.native : _fs.realpathSync;
            var fsSupportsRecursiveFsWatch = isNode4OrLater && (process.platform === "win32" || process.platform === "darwin");
            var getCurrentDirectory = ts.memoize(function () { return process.cwd(); });
            var _b = createSystemWatchFunctions({
                pollingWatchFile: createSingleFileWatcherPerName(fsWatchFileWorker, useCaseSensitiveFileNames),
                getModifiedTime: getModifiedTime,
                setTimeout: setTimeout,
                clearTimeout: clearTimeout,
                fsWatchWorker: fsWatchWorker,
                useCaseSensitiveFileNames: useCaseSensitiveFileNames,
                getCurrentDirectory: getCurrentDirectory,
                fileSystemEntryExists: fileSystemEntryExists,
                // Node 4.0 `fs.watch` function supports the "recursive" option on both OSX and Windows
                // (ref: https://github.com/nodejs/node/pull/2649 and https://github.com/Microsoft/TypeScript/issues/4643)
                fsSupportsRecursiveFsWatch: fsSupportsRecursiveFsWatch,
                getAccessibleSortedChildDirectories: function (path) { return getAccessibleFileSystemEntries(path).directories; },
                realpath: realpath,
                tscWatchFile: process.env.TSC_WATCHFILE,
                useNonPollingWatchers: process.env.TSC_NONPOLLING_WATCHER,
                tscWatchDirectory: process.env.TSC_WATCHDIRECTORY,
                defaultWatchFileKind: function () { var _a, _b; return (_b = (_a = sys).defaultWatchFileKind) === null || _b === void 0 ? void 0 : _b.call(_a); },
                inodeWatching: isLinuxOrMacOs,
                sysLog: sysLog,
            }), watchFile = _b.watchFile, watchDirectory = _b.watchDirectory;
            var nodeSystem = {
                args: process.argv.slice(2),
                newLine: _os.EOL,
                useCaseSensitiveFileNames: useCaseSensitiveFileNames,
                write: function (s) {
                    process.stdout.write(s);
                },
                getWidthOfTerminal: function () {
                    return process.stdout.columns;
                },
                writeOutputIsTTY: function () {
                    return process.stdout.isTTY;
                },
                readFile: readFile,
                writeFile: writeFile,
                watchFile: watchFile,
                watchDirectory: watchDirectory,
                resolvePath: function (path) { return _path.resolve(path); },
                fileExists: fileExists,
                directoryExists: directoryExists,
                createDirectory: function (directoryName) {
                    if (!nodeSystem.directoryExists(directoryName)) {
                        // Wrapped in a try-catch to prevent crashing if we are in a race
                        // with another copy of ourselves to create the same directory
                        try {
                            _fs.mkdirSync(directoryName);
                        }
                        catch (e) {
                            if (e.code !== "EEXIST") {
                                // Failed for some other reason (access denied?); still throw
                                throw e;
                            }
                        }
                    }
                },
                getExecutingFilePath: function () {
                    return __filename;
                },
                getCurrentDirectory: getCurrentDirectory,
                getDirectories: getDirectories,
                getEnvironmentVariable: function (name) {
                    return process.env[name] || "";
                },
                readDirectory: readDirectory,
                getModifiedTime: getModifiedTime,
                setModifiedTime: setModifiedTime,
                deleteFile: deleteFile,
                createHash: _crypto ? createSHA256Hash : generateDjb2Hash,
                createSHA256Hash: _crypto ? createSHA256Hash : undefined,
                getMemoryUsage: function () {
                    if (global.gc) {
                        global.gc();
                    }
                    return process.memoryUsage().heapUsed;
                },
                getFileSize: function (path) {
                    try {
                        var stat = statSync(path);
                        if (stat === null || stat === void 0 ? void 0 : stat.isFile()) {
                            return stat.size;
                        }
                    }
                    catch ( /*ignore*/_a) { /*ignore*/ }
                    return 0;
                },
                exit: function (exitCode) {
                    disableCPUProfiler(function () { return process.exit(exitCode); });
                },
                enableCPUProfiler: enableCPUProfiler,
                disableCPUProfiler: disableCPUProfiler,
                cpuProfilingEnabled: function () { return !!activeSession || ts.contains(process.execArgv, "--cpu-prof") || ts.contains(process.execArgv, "--prof"); },
                realpath: realpath,
                debugMode: !!process.env.NODE_INSPECTOR_IPC || !!process.env.VSCODE_INSPECTOR_OPTIONS || ts.some(process.execArgv, function (arg) { return /^--(inspect|debug)(-brk)?(=\d+)?$/i.test(arg); }),
                tryEnableSourceMapsForHost: function () {
                    try {
                        require("source-map-support").install();
                    }
                    catch (_a) {
                        // Could not enable source maps.
                    }
                },
                setTimeout: setTimeout,
                clearTimeout: clearTimeout,
                clearScreen: function () {
                    process.stdout.write("\x1Bc");
                },
                setBlocking: function () {
                    if (process.stdout && process.stdout._handle && process.stdout._handle.setBlocking) {
                        process.stdout._handle.setBlocking(true);
                    }
                },
                bufferFrom: bufferFrom,
                base64decode: function (input) { return bufferFrom(input, "base64").toString("utf8"); },
                base64encode: function (input) { return bufferFrom(input).toString("base64"); },
                require: function (baseDir, moduleName) {
                    try {
                        var modulePath = ts.resolveJSModule(moduleName, baseDir, nodeSystem);
                        return { module: require(modulePath), modulePath: modulePath, error: undefined };
                    }
                    catch (error) {
                        return { module: undefined, modulePath: undefined, error: error };
                    }
                }
            };
            return nodeSystem;
            /**
             * `throwIfNoEntry` was added so recently that it's not in the node types.
             * This helper encapsulates the mitigating usage of `any`.
             * See https://github.com/nodejs/node/pull/33716
             */
            function statSync(path) {
                // throwIfNoEntry will be ignored by older versions of node
                return _fs.statSync(path, { throwIfNoEntry: false });
            }
            /**
             * Uses the builtin inspector APIs to capture a CPU profile
             * See https://nodejs.org/api/inspector.html#inspector_example_usage for details
             */
            function enableCPUProfiler(path, cb) {
                if (activeSession) {
                    cb();
                    return false;
                }
                var inspector = require("inspector");
                if (!inspector || !inspector.Session) {
                    cb();
                    return false;
                }
                var session = new inspector.Session();
                session.connect();
                session.post("Profiler.enable", function () {
                    session.post("Profiler.start", function () {
                        activeSession = session;
                        profilePath = path;
                        cb();
                    });
                });
                return true;
            }
            /**
             * Strips non-TS paths from the profile, so users with private projects shouldn't
             * need to worry about leaking paths by submitting a cpu profile to us
             */
            function cleanupPaths(profile) {
                var externalFileCounter = 0;
                var remappedPaths = new ts.Map();
                var normalizedDir = ts.normalizeSlashes(__dirname);
                // Windows rooted dir names need an extra `/` prepended to be valid file:/// urls
                var fileUrlRoot = "file://".concat(ts.getRootLength(normalizedDir) === 1 ? "" : "/").concat(normalizedDir);
                for (var _i = 0, _a = profile.nodes; _i < _a.length; _i++) {
                    var node = _a[_i];
                    if (node.callFrame.url) {
                        var url = ts.normalizeSlashes(node.callFrame.url);
                        if (ts.containsPath(fileUrlRoot, url, useCaseSensitiveFileNames)) {
                            node.callFrame.url = ts.getRelativePathToDirectoryOrUrl(fileUrlRoot, url, fileUrlRoot, ts.createGetCanonicalFileName(useCaseSensitiveFileNames), /*isAbsolutePathAnUrl*/ true);
                        }
                        else if (!nativePattern.test(url)) {
                            node.callFrame.url = (remappedPaths.has(url) ? remappedPaths : remappedPaths.set(url, "external".concat(externalFileCounter, ".js"))).get(url);
                            externalFileCounter++;
                        }
                    }
                }
                return profile;
            }
            function disableCPUProfiler(cb) {
                if (activeSession && activeSession !== "stopping") {
                    var s_1 = activeSession;
                    activeSession.post("Profiler.stop", function (err, _a) {
                        var _b;
                        var profile = _a.profile;
                        if (!err) {
                            try {
                                if ((_b = statSync(profilePath)) === null || _b === void 0 ? void 0 : _b.isDirectory()) {
                                    profilePath = _path.join(profilePath, "".concat((new Date()).toISOString().replace(/:/g, "-"), "+P").concat(process.pid, ".cpuprofile"));
                                }
                            }
                            catch (_c) {
                                // do nothing and ignore fallible fs operation
                            }
                            try {
                                _fs.mkdirSync(_path.dirname(profilePath), { recursive: true });
                            }
                            catch (_d) {
                                // do nothing and ignore fallible fs operation
                            }
                            _fs.writeFileSync(profilePath, JSON.stringify(cleanupPaths(profile)));
                        }
                        activeSession = undefined;
                        s_1.disconnect();
                        cb();
                    });
                    activeSession = "stopping";
                    return true;
                }
                else {
                    cb();
                    return false;
                }
            }
            function bufferFrom(input, encoding) {
                // See https://github.com/Microsoft/TypeScript/issues/25652
                return Buffer.from && Buffer.from !== Int8Array.from
                    ? Buffer.from(input, encoding)
                    : new Buffer(input, encoding);
            }
            function isFileSystemCaseSensitive() {
                // win32\win64 are case insensitive platforms
                if (platform === "win32" || platform === "win64") {
                    return false;
                }
                // If this file exists under a different case, we must be case-insensitve.
                return !fileExists(swapCase(__filename));
            }
            /** Convert all lowercase chars to uppercase, and vice-versa */
            function swapCase(s) {
                return s.replace(/\w/g, function (ch) {
                    var up = ch.toUpperCase();
                    return ch === up ? ch.toLowerCase() : up;
                });
            }
            function fsWatchFileWorker(fileName, callback, pollingInterval) {
                _fs.watchFile(fileName, { persistent: true, interval: pollingInterval }, fileChanged);
                var eventKind;
                return {
                    close: function () { return _fs.unwatchFile(fileName, fileChanged); }
                };
                function fileChanged(curr, prev) {
                    // previous event kind check is to ensure we recongnize the file as previously also missing when it is restored or renamed twice (that is it disappears and reappears)
                    // In such case, prevTime returned is same as prev time of event when file was deleted as per node documentation
                    var isPreviouslyDeleted = +prev.mtime === 0 || eventKind === FileWatcherEventKind.Deleted;
                    if (+curr.mtime === 0) {
                        if (isPreviouslyDeleted) {
                            // Already deleted file, no need to callback again
                            return;
                        }
                        eventKind = FileWatcherEventKind.Deleted;
                    }
                    else if (isPreviouslyDeleted) {
                        eventKind = FileWatcherEventKind.Created;
                    }
                    // If there is no change in modified time, ignore the event
                    else if (+curr.mtime === +prev.mtime) {
                        return;
                    }
                    else {
                        // File changed
                        eventKind = FileWatcherEventKind.Changed;
                    }
                    callback(fileName, eventKind, curr.mtime);
                }
            }
            function fsWatchWorker(fileOrDirectory, recursive, callback) {
                // Node 4.0 `fs.watch` function supports the "recursive" option on both OSX and Windows
                // (ref: https://github.com/nodejs/node/pull/2649 and https://github.com/Microsoft/TypeScript/issues/4643)
                return _fs.watch(fileOrDirectory, fsSupportsRecursiveFsWatch ?
                    { persistent: true, recursive: !!recursive } : { persistent: true }, callback);
            }
            function readFileWorker(fileName, _encoding) {
                var buffer;
                try {
                    buffer = _fs.readFileSync(fileName);
                }
                catch (e) {
                    return undefined;
                }
                var len = buffer.length;
                if (len >= 2 && buffer[0] === 0xFE && buffer[1] === 0xFF) {
                    // Big endian UTF-16 byte order mark detected. Since big endian is not supported by node.js,
                    // flip all byte pairs and treat as little endian.
                    len &= ~1; // Round down to a multiple of 2
                    for (var i = 0; i < len; i += 2) {
                        var temp = buffer[i];
                        buffer[i] = buffer[i + 1];
                        buffer[i + 1] = temp;
                    }
                    return buffer.toString("utf16le", 2);
                }
                if (len >= 2 && buffer[0] === 0xFF && buffer[1] === 0xFE) {
                    // Little endian UTF-16 byte order mark detected
                    return buffer.toString("utf16le", 2);
                }
                if (len >= 3 && buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {
                    // UTF-8 byte order mark detected
                    return buffer.toString("utf8", 3);
                }
                // Default is UTF-8 with no byte order mark
                return buffer.toString("utf8");
            }
            function readFile(fileName, _encoding) {
                ts.perfLogger.logStartReadFile(fileName);
                var file = readFileWorker(fileName, _encoding);
                ts.perfLogger.logStopReadFile();
                return file;
            }
            function writeFile(fileName, data, writeByteOrderMark) {
                ts.perfLogger.logEvent("WriteFile: " + fileName);
                // If a BOM is required, emit one
                if (writeByteOrderMark) {
                    data = byteOrderMarkIndicator + data;
                }
                var fd;
                try {
                    fd = _fs.openSync(fileName, "w");
                    _fs.writeSync(fd, data, /*position*/ undefined, "utf8");
                }
                finally {
                    if (fd !== undefined) {
                        _fs.closeSync(fd);
                    }
                }
            }
            function getAccessibleFileSystemEntries(path) {
                ts.perfLogger.logEvent("ReadDir: " + (path || "."));
                try {
                    var entries = _fs.readdirSync(path || ".", { withFileTypes: true });
                    var files = [];
                    var directories = [];
                    for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {
                        var dirent = entries_1[_i];
                        // withFileTypes is not supported before Node 10.10.
                        var entry = typeof dirent === "string" ? dirent : dirent.name;
                        // This is necessary because on some file system node fails to exclude
                        // "." and "..". See https://github.com/nodejs/node/issues/4002
                        if (entry === "." || entry === "..") {
                            continue;
                        }
                        var stat = void 0;
                        if (typeof dirent === "string" || dirent.isSymbolicLink()) {
                            var name = ts.combinePaths(path, entry);
                            try {
                                stat = statSync(name);
                                if (!stat) {
                                    continue;
                                }
                            }
                            catch (e) {
                                continue;
                            }
                        }
                        else {
                            stat = dirent;
                        }
                        if (stat.isFile()) {
                            files.push(entry);
                        }
                        else if (stat.isDirectory()) {
                            directories.push(entry);
                        }
                    }
                    files.sort();
                    directories.sort();
                    return { files: files, directories: directories };
                }
                catch (e) {
                    return ts.emptyFileSystemEntries;
                }
            }
            function readDirectory(path, extensions, excludes, includes, depth) {
                return ts.matchFiles(path, extensions, excludes, includes, useCaseSensitiveFileNames, process.cwd(), depth, getAccessibleFileSystemEntries, realpath);
            }
            function fileSystemEntryExists(path, entryKind) {
                // Since the error thrown by fs.statSync isn't used, we can avoid collecting a stack trace to improve
                // the CPU time performance.
                var originalStackTraceLimit = Error.stackTraceLimit;
                Error.stackTraceLimit = 0;
                try {
                    var stat = statSync(path);
                    if (!stat) {
                        return false;
                    }
                    switch (entryKind) {
                        case 0 /* FileSystemEntryKind.File */: return stat.isFile();
                        case 1 /* FileSystemEntryKind.Directory */: return stat.isDirectory();
                        default: return false;
                    }
                }
                catch (e) {
                    return false;
                }
                finally {
                    Error.stackTraceLimit = originalStackTraceLimit;
                }
            }
            function fileExists(path) {
                return fileSystemEntryExists(path, 0 /* FileSystemEntryKind.File */);
            }
            function directoryExists(path) {
                return fileSystemEntryExists(path, 1 /* FileSystemEntryKind.Directory */);
            }
            function getDirectories(path) {
                return getAccessibleFileSystemEntries(path).directories.slice();
            }
            function fsRealPathHandlingLongPath(path) {
                return path.length < 260 ? _fs.realpathSync.native(path) : _fs.realpathSync(path);
            }
            function realpath(path) {
                try {
                    return fsRealpath(path);
                }
                catch (_a) {
                    return path;
                }
            }
            function getModifiedTime(path) {
                var _a;
                // Since the error thrown by fs.statSync isn't used, we can avoid collecting a stack trace to improve
                // the CPU time performance.
                var originalStackTraceLimit = Error.stackTraceLimit;
                Error.stackTraceLimit = 0;
                try {
                    return (_a = statSync(path)) === null || _a === void 0 ? void 0 : _a.mtime;
                }
                catch (e) {
                    return undefined;
                }
                finally {
                    Error.stackTraceLimit = originalStackTraceLimit;
                }
            }
            function setModifiedTime(path, time) {
                try {
                    _fs.utimesSync(path, time, time);
                }
                catch (e) {
                    return;
                }
            }
            function deleteFile(path) {
                try {
                    return _fs.unlinkSync(path);
                }
                catch (e) {
                    return;
                }
            }
            function createSHA256Hash(data) {
                var hash = _crypto.createHash("sha256");
                hash.update(data);
                return hash.digest("hex");
            }
        }
        var sys;
        if (typeof process !== "undefined" && process.nextTick && !process.browser && typeof require !== "undefined") {
            // process and process.nextTick checks if current environment is node-like
            // process.browser check excludes webpack and browserify
            sys = getNodeSystem();
        }
        if (sys) {
            // patch writefile to create folder before writing the file
            patchWriteFileEnsuringDirectory(sys);
        }
        return sys;
    })();
    /*@internal*/
    function setSys(s) {
        ts.sys = s;
    }
    ts.setSys = setSys;
    if (ts.sys && ts.sys.getEnvironmentVariable) {
        setCustomPollingValues(ts.sys);
        ts.Debug.setAssertionLevel(/^development$/i.test(ts.sys.getEnvironmentVariable("NODE_ENV"))
            ? 1 /* AssertionLevel.Normal */
            : 0 /* AssertionLevel.None */);
    }
    if (ts.sys && ts.sys.debugMode) {
        ts.Debug.isDebugging = true;
    }
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    /**
     * Internally, we represent paths as strings with '/' as the directory separator.
     * When we make system calls (eg: LanguageServiceHost.getDirectory()),
     * we expect the host to correctly handle paths in our specified format.
     */
    ts.directorySeparator = "/";
    ts.altDirectorySeparator = "\\";
    var urlSchemeSeparator = "://";
    var backslashRegExp = /\\/g;
    //// Path Tests
    /**
     * Determines whether a charCode corresponds to `/` or `\`.
     */
    function isAnyDirectorySeparator(charCode) {
        return charCode === 47 /* CharacterCodes.slash */ || charCode === 92 /* CharacterCodes.backslash */;
    }
    ts.isAnyDirectorySeparator = isAnyDirectorySeparator;
    /**
     * Determines whether a path starts with a URL scheme (e.g. starts with `http://`, `ftp://`, `file://`, etc.).
     */
    function isUrl(path) {
        return getEncodedRootLength(path) < 0;
    }
    ts.isUrl = isUrl;
    /**
     * Determines whether a path is an absolute disk path (e.g. starts with `/`, or a dos path
     * like `c:`, `c:\` or `c:/`).
     */
    function isRootedDiskPath(path) {
        return getEncodedRootLength(path) > 0;
    }
    ts.isRootedDiskPath = isRootedDiskPath;
    /**
     * Determines whether a path consists only of a path root.
     */
    function isDiskPathRoot(path) {
        var rootLength = getEncodedRootLength(path);
        return rootLength > 0 && rootLength === path.length;
    }
    ts.isDiskPathRoot = isDiskPathRoot;
    /**
     * Determines whether a path starts with an absolute path component (i.e. `/`, `c:/`, `file://`, etc.).
     *
     * ```ts
     * // POSIX
     * pathIsAbsolute("/path/to/file.ext") === true
     * // DOS
     * pathIsAbsolute("c:/path/to/file.ext") === true
     * // URL
     * pathIsAbsolute("file:///path/to/file.ext") === true
     * // Non-absolute
     * pathIsAbsolute("path/to/file.ext") === false
     * pathIsAbsolute("./path/to/file.ext") === false
     * ```
     */
    function pathIsAbsolute(path) {
        return getEncodedRootLength(path) !== 0;
    }
    ts.pathIsAbsolute = pathIsAbsolute;
    /**
     * Determines whether a path starts with a relative path component (i.e. `.` or `..`).
     */
    function pathIsRelative(path) {
        return /^\.\.?($|[\\/])/.test(path);
    }
    ts.pathIsRelative = pathIsRelative;
    /**
     * Determines whether a path is neither relative nor absolute, e.g. "path/to/file".
     * Also known misleadingly as "non-relative".
     */
    function pathIsBareSpecifier(path) {
        return !pathIsAbsolute(path) && !pathIsRelative(path);
    }
    ts.pathIsBareSpecifier = pathIsBareSpecifier;
    function hasExtension(fileName) {
        return ts.stringContains(getBaseFileName(fileName), ".");
    }
    ts.hasExtension = hasExtension;
    function fileExtensionIs(path, extension) {
        return path.length > extension.length && ts.endsWith(path, extension);
    }
    ts.fileExtensionIs = fileExtensionIs;
    function fileExtensionIsOneOf(path, extensions) {
        for (var _i = 0, extensions_1 = extensions; _i < extensions_1.length; _i++) {
            var extension = extensions_1[_i];
            if (fileExtensionIs(path, extension)) {
                return true;
            }
        }
        return false;
    }
    ts.fileExtensionIsOneOf = fileExtensionIsOneOf;
    /**
     * Determines whether a path has a trailing separator (`/` or `\\`).
     */
    function hasTrailingDirectorySeparator(path) {
        return path.length > 0 && isAnyDirectorySeparator(path.charCodeAt(path.length - 1));
    }
    ts.hasTrailingDirectorySeparator = hasTrailingDirectorySeparator;
    //// Path Parsing
    function isVolumeCharacter(charCode) {
        return (charCode >= 97 /* CharacterCodes.a */ && charCode <= 122 /* CharacterCodes.z */) ||
            (charCode >= 65 /* CharacterCodes.A */ && charCode <= 90 /* CharacterCodes.Z */);
    }
    function getFileUrlVolumeSeparatorEnd(url, start) {
        var ch0 = url.charCodeAt(start);
        if (ch0 === 58 /* CharacterCodes.colon */)
            return start + 1;
        if (ch0 === 37 /* CharacterCodes.percent */ && url.charCodeAt(start + 1) === 51 /* CharacterCodes._3 */) {
            var ch2 = url.charCodeAt(start + 2);
            if (ch2 === 97 /* CharacterCodes.a */ || ch2 === 65 /* CharacterCodes.A */)
                return start + 3;
        }
        return -1;
    }
    /**
     * Returns length of the root part of a path or URL (i.e. length of "/", "x:/", "//server/share/, file:///user/files").
     * If the root is part of a URL, the twos-complement of the root length is returned.
     */
    function getEncodedRootLength(path) {
        if (!path)
            return 0;
        var ch0 = path.charCodeAt(0);
        // POSIX or UNC
        if (ch0 === 47 /* CharacterCodes.slash */ || ch0 === 92 /* CharacterCodes.backslash */) {
            if (path.charCodeAt(1) !== ch0)
                return 1; // POSIX: "/" (or non-normalized "\")
            var p1 = path.indexOf(ch0 === 47 /* CharacterCodes.slash */ ? ts.directorySeparator : ts.altDirectorySeparator, 2);
            if (p1 < 0)
                return path.length; // UNC: "//server" or "\\server"
            return p1 + 1; // UNC: "//server/" or "\\server\"
        }
        // DOS
        if (isVolumeCharacter(ch0) && path.charCodeAt(1) === 58 /* CharacterCodes.colon */) {
            var ch2 = path.charCodeAt(2);
            if (ch2 === 47 /* CharacterCodes.slash */ || ch2 === 92 /* CharacterCodes.backslash */)
                return 3; // DOS: "c:/" or "c:\"
            if (path.length === 2)
                return 2; // DOS: "c:" (but not "c:d")
        }
        // URL
        var schemeEnd = path.indexOf(urlSchemeSeparator);
        if (schemeEnd !== -1) {
            var authorityStart = schemeEnd + urlSchemeSeparator.length;
            var authorityEnd = path.indexOf(ts.directorySeparator, authorityStart);
            if (authorityEnd !== -1) { // URL: "file:///", "file://server/", "file://server/path"
                // For local "file" URLs, include the leading DOS volume (if present).
                // Per https://www.ietf.org/rfc/rfc1738.txt, a host of "" or "localhost" is a
                // special case interpreted as "the machine from which the URL is being interpreted".
                var scheme = path.slice(0, schemeEnd);
                var authority = path.slice(authorityStart, authorityEnd);
                if (scheme === "file" && (authority === "" || authority === "localhost") &&
                    isVolumeCharacter(path.charCodeAt(authorityEnd + 1))) {
                    var volumeSeparatorEnd = getFileUrlVolumeSeparatorEnd(path, authorityEnd + 2);
                    if (volumeSeparatorEnd !== -1) {
                        if (path.charCodeAt(volumeSeparatorEnd) === 47 /* CharacterCodes.slash */) {
                            // URL: "file:///c:/", "file://localhost/c:/", "file:///c%3a/", "file://localhost/c%3a/"
                            return ~(volumeSeparatorEnd + 1);
                        }
                        if (volumeSeparatorEnd === path.length) {
                            // URL: "file:///c:", "file://localhost/c:", "file:///c$3a", "file://localhost/c%3a"
                            // but not "file:///c:d" or "file:///c%3ad"
                            return ~volumeSeparatorEnd;
                        }
                    }
                }
                return ~(authorityEnd + 1); // URL: "file://server/", "http://server/"
            }
            return ~path.length; // URL: "file://server", "http://server"
        }
        // relative
        return 0;
    }
    /**
     * Returns length of the root part of a path or URL (i.e. length of "/", "x:/", "//server/share/, file:///user/files").
     *
     * For example:
     * ```ts
     * getRootLength("a") === 0                   // ""
     * getRootLength("/") === 1                   // "/"
     * getRootLength("c:") === 2                  // "c:"
     * getRootLength("c:d") === 0                 // ""
     * getRootLength("c:/") === 3                 // "c:/"
     * getRootLength("c:\\") === 3                // "c:\\"
     * getRootLength("//server") === 7            // "//server"
     * getRootLength("//server/share") === 8      // "//server/"
     * getRootLength("\\\\server") === 7          // "\\\\server"
     * getRootLength("\\\\server\\share") === 8   // "\\\\server\\"
     * getRootLength("file:///path") === 8        // "file:///"
     * getRootLength("file:///c:") === 10         // "file:///c:"
     * getRootLength("file:///c:d") === 8         // "file:///"
     * getRootLength("file:///c:/path") === 11    // "file:///c:/"
     * getRootLength("file://server") === 13      // "file://server"
     * getRootLength("file://server/path") === 14 // "file://server/"
     * getRootLength("http://server") === 13      // "http://server"
     * getRootLength("http://server/path") === 14 // "http://server/"
     * ```
     */
    function getRootLength(path) {
        var rootLength = getEncodedRootLength(path);
        return rootLength < 0 ? ~rootLength : rootLength;
    }
    ts.getRootLength = getRootLength;
    function getDirectoryPath(path) {
        path = normalizeSlashes(path);
        // If the path provided is itself the root, then return it.
        var rootLength = getRootLength(path);
        if (rootLength === path.length)
            return path;
        // return the leading portion of the path up to the last (non-terminal) directory separator
        // but not including any trailing directory separator.
        path = removeTrailingDirectorySeparator(path);
        return path.slice(0, Math.max(rootLength, path.lastIndexOf(ts.directorySeparator)));
    }
    ts.getDirectoryPath = getDirectoryPath;
    function getBaseFileName(path, extensions, ignoreCase) {
        path = normalizeSlashes(path);
        // if the path provided is itself the root, then it has not file name.
        var rootLength = getRootLength(path);
        if (rootLength === path.length)
            return "";
        // return the trailing portion of the path starting after the last (non-terminal) directory
        // separator but not including any trailing directory separator.
        path = removeTrailingDirectorySeparator(path);
        var name = path.slice(Math.max(getRootLength(path), path.lastIndexOf(ts.directorySeparator) + 1));
        var extension = extensions !== undefined && ignoreCase !== undefined ? getAnyExtensionFromPath(name, extensions, ignoreCase) : undefined;
        return extension ? name.slice(0, name.length - extension.length) : name;
    }
    ts.getBaseFileName = getBaseFileName;
    function tryGetExtensionFromPath(path, extension, stringEqualityComparer) {
        if (!ts.startsWith(extension, "."))
            extension = "." + extension;
        if (path.length >= extension.length && path.charCodeAt(path.length - extension.length) === 46 /* CharacterCodes.dot */) {
            var pathExtension = path.slice(path.length - extension.length);
            if (stringEqualityComparer(pathExtension, extension)) {
                return pathExtension;
            }
        }
    }
    function getAnyExtensionFromPathWorker(path, extensions, stringEqualityComparer) {
        if (typeof extensions === "string") {
            return tryGetExtensionFromPath(path, extensions, stringEqualityComparer) || "";
        }
        for (var _i = 0, extensions_2 = extensions; _i < extensions_2.length; _i++) {
            var extension = extensions_2[_i];
            var result = tryGetExtensionFromPath(path, extension, stringEqualityComparer);
            if (result)
                return result;
        }
        return "";
    }
    function getAnyExtensionFromPath(path, extensions, ignoreCase) {
        // Retrieves any string from the final "." onwards from a base file name.
        // Unlike extensionFromPath, which throws an exception on unrecognized extensions.
        if (extensions) {
            return getAnyExtensionFromPathWorker(removeTrailingDirectorySeparator(path), extensions, ignoreCase ? ts.equateStringsCaseInsensitive : ts.equateStringsCaseSensitive);
        }
        var baseFileName = getBaseFileName(path);
        var extensionIndex = baseFileName.lastIndexOf(".");
        if (extensionIndex >= 0) {
            return baseFileName.substring(extensionIndex);
        }
        return "";
    }
    ts.getAnyExtensionFromPath = getAnyExtensionFromPath;
    function pathComponents(path, rootLength) {
        var root = path.substring(0, rootLength);
        var rest = path.substring(rootLength).split(ts.directorySeparator);
        if (rest.length && !ts.lastOrUndefined(rest))
            rest.pop();
        return __spreadArray([root], rest, true);
    }
    /**
     * Parse a path into an array containing a root component (at index 0) and zero or more path
     * components (at indices > 0). The result is not normalized.
     * If the path is relative, the root component is `""`.
     * If the path is absolute, the root component includes the first path separator (`/`).
     *
     * ```ts
     * // POSIX
     * getPathComponents("/path/to/file.ext") === ["/", "path", "to", "file.ext"]
     * getPathComponents("/path/to/") === ["/", "path", "to"]
     * getPathComponents("/") === ["/"]
     * // DOS
     * getPathComponents("c:/path/to/file.ext") === ["c:/", "path", "to", "file.ext"]
     * getPathComponents("c:/path/to/") === ["c:/", "path", "to"]
     * getPathComponents("c:/") === ["c:/"]
     * getPathComponents("c:") === ["c:"]
     * // URL
     * getPathComponents("http://typescriptlang.org/path/to/file.ext") === ["http://typescriptlang.org/", "path", "to", "file.ext"]
     * getPathComponents("http://typescriptlang.org/path/to/") === ["http://typescriptlang.org/", "path", "to"]
     * getPathComponents("http://typescriptlang.org/") === ["http://typescriptlang.org/"]
     * getPathComponents("http://typescriptlang.org") === ["http://typescriptlang.org"]
     * getPathComponents("file://server/path/to/file.ext") === ["file://server/", "path", "to", "file.ext"]
     * getPathComponents("file://server/path/to/") === ["file://server/", "path", "to"]
     * getPathComponents("file://server/") === ["file://server/"]
     * getPathComponents("file://server") === ["file://server"]
     * getPathComponents("file:///path/to/file.ext") === ["file:///", "path", "to", "file.ext"]
     * getPathComponents("file:///path/to/") === ["file:///", "path", "to"]
     * getPathComponents("file:///") === ["file:///"]
     * getPathComponents("file://") === ["file://"]
     */
    function getPathComponents(path, currentDirectory) {
        if (currentDirectory === void 0) { currentDirectory = ""; }
        path = combinePaths(currentDirectory, path);
        return pathComponents(path, getRootLength(path));
    }
    ts.getPathComponents = getPathComponents;
    //// Path Formatting
    /**
     * Formats a parsed path consisting of a root component (at index 0) and zero or more path
     * segments (at indices > 0).
     *
     * ```ts
     * getPathFromPathComponents(["/", "path", "to", "file.ext"]) === "/path/to/file.ext"
     * ```
     */
    function getPathFromPathComponents(pathComponents) {
        if (pathComponents.length === 0)
            return "";
        var root = pathComponents[0] && ensureTrailingDirectorySeparator(pathComponents[0]);
        return root + pathComponents.slice(1).join(ts.directorySeparator);
    }
    ts.getPathFromPathComponents = getPathFromPathComponents;
    //// Path Normalization
    /**
     * Normalize path separators, converting `\` into `/`.
     */
    function normalizeSlashes(path) {
        var index = path.indexOf("\\");
        if (index === -1) {
            return path;
        }
        backslashRegExp.lastIndex = index; // prime regex with known position
        return path.replace(backslashRegExp, ts.directorySeparator);
    }
    ts.normalizeSlashes = normalizeSlashes;
    /**
     * Reduce an array of path components to a more simplified path by navigating any
     * `"."` or `".."` entries in the path.
     */
    function reducePathComponents(components) {
        if (!ts.some(components))
            return [];
        var reduced = [components[0]];
        for (var i = 1; i < components.length; i++) {
            var component = components[i];
            if (!component)
                continue;
            if (component === ".")
                continue;
            if (component === "..") {
                if (reduced.length > 1) {
                    if (reduced[reduced.length - 1] !== "..") {
                        reduced.pop();
                        continue;
                    }
                }
                else if (reduced[0])
                    continue;
            }
            reduced.push(component);
        }
        return reduced;
    }
    ts.reducePathComponents = reducePathComponents;
    /**
     * Combines paths. If a path is absolute, it replaces any previous path. Relative paths are not simplified.
     *
     * ```ts
     * // Non-rooted
     * combinePaths("path", "to", "file.ext") === "path/to/file.ext"
     * combinePaths("path", "dir", "..", "to", "file.ext") === "path/dir/../to/file.ext"
     * // POSIX
     * combinePaths("/path", "to", "file.ext") === "/path/to/file.ext"
     * combinePaths("/path", "/to", "file.ext") === "/to/file.ext"
     * // DOS
     * combinePaths("c:/path", "to", "file.ext") === "c:/path/to/file.ext"
     * combinePaths("c:/path", "c:/to", "file.ext") === "c:/to/file.ext"
     * // URL
     * combinePaths("file:///path", "to", "file.ext") === "file:///path/to/file.ext"
     * combinePaths("file:///path", "file:///to", "file.ext") === "file:///to/file.ext"
     * ```
     */
    function combinePaths(path) {
        var paths = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            paths[_i - 1] = arguments[_i];
        }
        if (path)
            path = normalizeSlashes(path);
        for (var _a = 0, paths_1 = paths; _a < paths_1.length; _a++) {
            var relativePath = paths_1[_a];
            if (!relativePath)
                continue;
            relativePath = normalizeSlashes(relativePath);
            if (!path || getRootLength(relativePath) !== 0) {
                path = relativePath;
            }
            else {
                path = ensureTrailingDirectorySeparator(path) + relativePath;
            }
        }
        return path;
    }
    ts.combinePaths = combinePaths;
    /**
     * Combines and resolves paths. If a path is absolute, it replaces any previous path. Any
     * `.` and `..` path components are resolved. Trailing directory separators are preserved.
     *
     * ```ts
     * resolvePath("/path", "to", "file.ext") === "path/to/file.ext"
     * resolvePath("/path", "to", "file.ext/") === "path/to/file.ext/"
     * resolvePath("/path", "dir", "..", "to", "file.ext") === "path/to/file.ext"
     * ```
     */
    function resolvePath(path) {
        var paths = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            paths[_i - 1] = arguments[_i];
        }
        return normalizePath(ts.some(paths) ? combinePaths.apply(void 0, __spreadArray([path], paths, false)) : normalizeSlashes(path));
    }
    ts.resolvePath = resolvePath;
    /**
     * Parse a path into an array containing a root component (at index 0) and zero or more path
     * components (at indices > 0). The result is normalized.
     * If the path is relative, the root component is `""`.
     * If the path is absolute, the root component includes the first path separator (`/`).
     *
     * ```ts
     * getNormalizedPathComponents("to/dir/../file.ext", "/path/") === ["/", "path", "to", "file.ext"]
     * ```
     */
    function getNormalizedPathComponents(path, currentDirectory) {
        return reducePathComponents(getPathComponents(path, currentDirectory));
    }
    ts.getNormalizedPathComponents = getNormalizedPathComponents;
    function getNormalizedAbsolutePath(fileName, currentDirectory) {
        return getPathFromPathComponents(getNormalizedPathComponents(fileName, currentDirectory));
    }
    ts.getNormalizedAbsolutePath = getNormalizedAbsolutePath;
    function normalizePath(path) {
        path = normalizeSlashes(path);
        // Most paths don't require normalization
        if (!relativePathSegmentRegExp.test(path)) {
            return path;
        }
        // Some paths only require cleanup of `/./` or leading `./`
        var simplified = path.replace(/\/\.\//g, "/").replace(/^\.\//, "");
        if (simplified !== path) {
            path = simplified;
            if (!relativePathSegmentRegExp.test(path)) {
                return path;
            }
        }
        // Other paths require full normalization
        var normalized = getPathFromPathComponents(reducePathComponents(getPathComponents(path)));
        return normalized && hasTrailingDirectorySeparator(path) ? ensureTrailingDirectorySeparator(normalized) : normalized;
    }
    ts.normalizePath = normalizePath;
    function getPathWithoutRoot(pathComponents) {
        if (pathComponents.length === 0)
            return "";
        return pathComponents.slice(1).join(ts.directorySeparator);
    }
    function getNormalizedAbsolutePathWithoutRoot(fileName, currentDirectory) {
        return getPathWithoutRoot(getNormalizedPathComponents(fileName, currentDirectory));
    }
    ts.getNormalizedAbsolutePathWithoutRoot = getNormalizedAbsolutePathWithoutRoot;
    function toPath(fileName, basePath, getCanonicalFileName) {
        var nonCanonicalizedPath = isRootedDiskPath(fileName)
            ? normalizePath(fileName)
            : getNormalizedAbsolutePath(fileName, basePath);
        return getCanonicalFileName(nonCanonicalizedPath);
    }
    ts.toPath = toPath;
    function removeTrailingDirectorySeparator(path) {
        if (hasTrailingDirectorySeparator(path)) {
            return path.substr(0, path.length - 1);
        }
        return path;
    }
    ts.removeTrailingDirectorySeparator = removeTrailingDirectorySeparator;
    function ensureTrailingDirectorySeparator(path) {
        if (!hasTrailingDirectorySeparator(path)) {
            return path + ts.directorySeparator;
        }
        return path;
    }
    ts.ensureTrailingDirectorySeparator = ensureTrailingDirectorySeparator;
    /**
     * Ensures a path is either absolute (prefixed with `/` or `c:`) or dot-relative (prefixed
     * with `./` or `../`) so as not to be confused with an unprefixed module name.
     *
     * ```ts
     * ensurePathIsNonModuleName("/path/to/file.ext") === "/path/to/file.ext"
     * ensurePathIsNonModuleName("./path/to/file.ext") === "./path/to/file.ext"
     * ensurePathIsNonModuleName("../path/to/file.ext") === "../path/to/file.ext"
     * ensurePathIsNonModuleName("path/to/file.ext") === "./path/to/file.ext"
     * ```
     */
    function ensurePathIsNonModuleName(path) {
        return !pathIsAbsolute(path) && !pathIsRelative(path) ? "./" + path : path;
    }
    ts.ensurePathIsNonModuleName = ensurePathIsNonModuleName;
    function changeAnyExtension(path, ext, extensions, ignoreCase) {
        var pathext = extensions !== undefined && ignoreCase !== undefined ? getAnyExtensionFromPath(path, extensions, ignoreCase) : getAnyExtensionFromPath(path);
        return pathext ? path.slice(0, path.length - pathext.length) + (ts.startsWith(ext, ".") ? ext : "." + ext) : path;
    }
    ts.changeAnyExtension = changeAnyExtension;
    //// Path Comparisons
    // check path for these segments: '', '.'. '..'
    var relativePathSegmentRegExp = /(?:\/\/)|(?:^|\/)\.\.?(?:$|\/)/;
    function comparePathsWorker(a, b, componentComparer) {
        if (a === b)
            return 0 /* Comparison.EqualTo */;
        if (a === undefined)
            return -1 /* Comparison.LessThan */;
        if (b === undefined)
            return 1 /* Comparison.GreaterThan */;
        // NOTE: Performance optimization - shortcut if the root segments differ as there would be no
        //       need to perform path reduction.
        var aRoot = a.substring(0, getRootLength(a));
        var bRoot = b.substring(0, getRootLength(b));
        var result = ts.compareStringsCaseInsensitive(aRoot, bRoot);
        if (result !== 0 /* Comparison.EqualTo */) {
            return result;
        }
        // NOTE: Performance optimization - shortcut if there are no relative path segments in
        //       the non-root portion of the path
        var aRest = a.substring(aRoot.length);
        var bRest = b.substring(bRoot.length);
        if (!relativePathSegmentRegExp.test(aRest) && !relativePathSegmentRegExp.test(bRest)) {
            return componentComparer(aRest, bRest);
        }
        // The path contains a relative path segment. Normalize the paths and perform a slower component
        // by component comparison.
        var aComponents = reducePathComponents(getPathComponents(a));
        var bComponents = reducePathComponents(getPathComponents(b));
        var sharedLength = Math.min(aComponents.length, bComponents.length);
        for (var i = 1; i < sharedLength; i++) {
            var result_2 = componentComparer(aComponents[i], bComponents[i]);
            if (result_2 !== 0 /* Comparison.EqualTo */) {
                return result_2;
            }
        }
        return ts.compareValues(aComponents.length, bComponents.length);
    }
    /**
     * Performs a case-sensitive comparison of two paths. Path roots are always compared case-insensitively.
     */
    function comparePathsCaseSensitive(a, b) {
        return comparePathsWorker(a, b, ts.compareStringsCaseSensitive);
    }
    ts.comparePathsCaseSensitive = comparePathsCaseSensitive;
    /**
     * Performs a case-insensitive comparison of two paths.
     */
    function comparePathsCaseInsensitive(a, b) {
        return comparePathsWorker(a, b, ts.compareStringsCaseInsensitive);
    }
    ts.comparePathsCaseInsensitive = comparePathsCaseInsensitive;
    function comparePaths(a, b, currentDirectory, ignoreCase) {
        if (typeof currentDirectory === "string") {
            a = combinePaths(currentDirectory, a);
            b = combinePaths(currentDirectory, b);
        }
        else if (typeof currentDirectory === "boolean") {
            ignoreCase = currentDirectory;
        }
        return comparePathsWorker(a, b, ts.getStringComparer(ignoreCase));
    }
    ts.comparePaths = comparePaths;
    function containsPath(parent, child, currentDirectory, ignoreCase) {
        if (typeof currentDirectory === "string") {
            parent = combinePaths(currentDirectory, parent);
            child = combinePaths(currentDirectory, child);
        }
        else if (typeof currentDirectory === "boolean") {
            ignoreCase = currentDirectory;
        }
        if (parent === undefined || child === undefined)
            return false;
        if (parent === child)
            return true;
        var parentComponents = reducePathComponents(getPathComponents(parent));
        var childComponents = reducePathComponents(getPathComponents(child));
        if (childComponents.length < parentComponents.length) {
            return false;
        }
        var componentEqualityComparer = ignoreCase ? ts.equateStringsCaseInsensitive : ts.equateStringsCaseSensitive;
        for (var i = 0; i < parentComponents.length; i++) {
            var equalityComparer = i === 0 ? ts.equateStringsCaseInsensitive : componentEqualityComparer;
            if (!equalityComparer(parentComponents[i], childComponents[i])) {
                return false;
            }
        }
        return true;
    }
    ts.containsPath = containsPath;
    /**
     * Determines whether `fileName` starts with the specified `directoryName` using the provided path canonicalization callback.
     * Comparison is case-sensitive between the canonical paths.
     *
     * Use `containsPath` if file names are not already reduced and absolute.
     */
    function startsWithDirectory(fileName, directoryName, getCanonicalFileName) {
        var canonicalFileName = getCanonicalFileName(fileName);
        var canonicalDirectoryName = getCanonicalFileName(directoryName);
        return ts.startsWith(canonicalFileName, canonicalDirectoryName + "/") || ts.startsWith(canonicalFileName, canonicalDirectoryName + "\\");
    }
    ts.startsWithDirectory = startsWithDirectory;
    //// Relative Paths
    function getPathComponentsRelativeTo(from, to, stringEqualityComparer, getCanonicalFileName) {
        var fromComponents = reducePathComponents(getPathComponents(from));
        var toComponents = reducePathComponents(getPathComponents(to));
        var start;
        for (start = 0; start < fromComponents.length && start < toComponents.length; start++) {
            var fromComponent = getCanonicalFileName(fromComponents[start]);
            var toComponent = getCanonicalFileName(toComponents[start]);
            var comparer = start === 0 ? ts.equateStringsCaseInsensitive : stringEqualityComparer;
            if (!comparer(fromComponent, toComponent))
                break;
        }
        if (start === 0) {
            return toComponents;
        }
        var components = toComponents.slice(start);
        var relative = [];
        for (; start < fromComponents.length; start++) {
            relative.push("..");
        }
        return __spreadArray(__spreadArray([""], relative, true), components, true);
    }
    ts.getPathComponentsRelativeTo = getPathComponentsRelativeTo;
    function getRelativePathFromDirectory(fromDirectory, to, getCanonicalFileNameOrIgnoreCase) {
        ts.Debug.assert((getRootLength(fromDirectory) > 0) === (getRootLength(to) > 0), "Paths must either both be absolute or both be relative");
        var getCanonicalFileName = typeof getCanonicalFileNameOrIgnoreCase === "function" ? getCanonicalFileNameOrIgnoreCase : ts.identity;
        var ignoreCase = typeof getCanonicalFileNameOrIgnoreCase === "boolean" ? getCanonicalFileNameOrIgnoreCase : false;
        var pathComponents = getPathComponentsRelativeTo(fromDirectory, to, ignoreCase ? ts.equateStringsCaseInsensitive : ts.equateStringsCaseSensitive, getCanonicalFileName);
        return getPathFromPathComponents(pathComponents);
    }
    ts.getRelativePathFromDirectory = getRelativePathFromDirectory;
    function convertToRelativePath(absoluteOrRelativePath, basePath, getCanonicalFileName) {
        return !isRootedDiskPath(absoluteOrRelativePath)
            ? absoluteOrRelativePath
            : getRelativePathToDirectoryOrUrl(basePath, absoluteOrRelativePath, basePath, getCanonicalFileName, /*isAbsolutePathAnUrl*/ false);
    }
    ts.convertToRelativePath = convertToRelativePath;
    function getRelativePathFromFile(from, to, getCanonicalFileName) {
        return ensurePathIsNonModuleName(getRelativePathFromDirectory(getDirectoryPath(from), to, getCanonicalFileName));
    }
    ts.getRelativePathFromFile = getRelativePathFromFile;
    function getRelativePathToDirectoryOrUrl(directoryPathOrUrl, relativeOrAbsolutePath, currentDirectory, getCanonicalFileName, isAbsolutePathAnUrl) {
        var pathComponents = getPathComponentsRelativeTo(resolvePath(currentDirectory, directoryPathOrUrl), resolvePath(currentDirectory, relativeOrAbsolutePath), ts.equateStringsCaseSensitive, getCanonicalFileName);
        var firstComponent = pathComponents[0];
        if (isAbsolutePathAnUrl && isRootedDiskPath(firstComponent)) {
            var prefix = firstComponent.charAt(0) === ts.directorySeparator ? "file://" : "file:///";
            pathComponents[0] = prefix + firstComponent;
        }
        return getPathFromPathComponents(pathComponents);
    }
    ts.getRelativePathToDirectoryOrUrl = getRelativePathToDirectoryOrUrl;
    function forEachAncestorDirectory(directory, callback) {
        while (true) {
            var result = callback(directory);
            if (result !== undefined) {
                return result;
            }
            var parentPath = getDirectoryPath(directory);
            if (parentPath === directory) {
                return undefined;
            }
            directory = parentPath;
        }
    }
    ts.forEachAncestorDirectory = forEachAncestorDirectory;
    function isNodeModulesDirectory(dirPath) {
        return ts.endsWith(dirPath, "/node_modules");
    }
    ts.isNodeModulesDirectory = isNodeModulesDirectory;
})(ts || (ts = {}));
// <auto-generated />
// generated from './diagnosticMessages.json' in 'src/compiler'
/* @internal */
var ts;
(function (ts) {
    function diag(code, category, key, message, reportsUnnecessary, elidedInCompatabilityPyramid, reportsDeprecated) {
        return { code: code, category: category, key: key, message: message, reportsUnnecessary: reportsUnnecessary, elidedInCompatabilityPyramid: elidedInCompatabilityPyramid, reportsDeprecated: reportsDeprecated };
    }
    ts.Diagnostics = {
        Unterminated_string_literal: diag(1002, ts.DiagnosticCategory.Error, "Unterminated_string_literal_1002", "Unterminated string literal."),
        Identifier_expected: diag(1003, ts.DiagnosticCategory.Error, "Identifier_expected_1003", "Identifier expected."),
        _0_expected: diag(1005, ts.DiagnosticCategory.Error, "_0_expected_1005", "'{0}' expected."),
        A_file_cannot_have_a_reference_to_itself: diag(1006, ts.DiagnosticCategory.Error, "A_file_cannot_have_a_reference_to_itself_1006", "A file cannot have a reference to itself."),
        The_parser_expected_to_find_a_1_to_match_the_0_token_here: diag(1007, ts.DiagnosticCategory.Error, "The_parser_expected_to_find_a_1_to_match_the_0_token_here_1007", "The parser expected to find a '{1}' to match the '{0}' token here."),
        Trailing_comma_not_allowed: diag(1009, ts.DiagnosticCategory.Error, "Trailing_comma_not_allowed_1009", "Trailing comma not allowed."),
        Asterisk_Slash_expected: diag(1010, ts.DiagnosticCategory.Error, "Asterisk_Slash_expected_1010", "'*/' expected."),
        An_element_access_expression_should_take_an_argument: diag(1011, ts.DiagnosticCategory.Error, "An_element_access_expression_should_take_an_argument_1011", "An element access expression should take an argument."),
        Unexpected_token: diag(1012, ts.DiagnosticCategory.Error, "Unexpected_token_1012", "Unexpected token."),
        A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma: diag(1013, ts.DiagnosticCategory.Error, "A_rest_parameter_or_binding_pattern_may_not_have_a_trailing_comma_1013", "A rest parameter or binding pattern may not have a trailing comma."),
        A_rest_parameter_must_be_last_in_a_parameter_list: diag(1014, ts.DiagnosticCategory.Error, "A_rest_parameter_must_be_last_in_a_parameter_list_1014", "A rest parameter must be last in a parameter list."),
        Parameter_cannot_have_question_mark_and_initializer: diag(1015, ts.DiagnosticCategory.Error, "Parameter_cannot_have_question_mark_and_initializer_1015", "Parameter cannot have question mark and initializer."),
        A_required_parameter_cannot_follow_an_optional_parameter: diag(1016, ts.DiagnosticCategory.Error, "A_required_parameter_cannot_follow_an_optional_parameter_1016", "A required parameter cannot follow an optional parameter."),
        An_index_signature_cannot_have_a_rest_parameter: diag(1017, ts.DiagnosticCategory.Error, "An_index_signature_cannot_have_a_rest_parameter_1017", "An index signature cannot have a rest parameter."),
        An_index_signature_parameter_cannot_have_an_accessibility_modifier: diag(1018, ts.DiagnosticCategory.Error, "An_index_signature_parameter_cannot_have_an_accessibility_modifier_1018", "An index signature parameter cannot have an accessibility modifier."),
        An_index_signature_parameter_cannot_have_a_question_mark: diag(1019, ts.DiagnosticCategory.Error, "An_index_signature_parameter_cannot_have_a_question_mark_1019", "An index signature parameter cannot have a question mark."),
        An_index_signature_parameter_cannot_have_an_initializer: diag(1020, ts.DiagnosticCategory.Error, "An_index_signature_parameter_cannot_have_an_initializer_1020", "An index signature parameter cannot have an initializer."),
        An_index_signature_must_have_a_type_annotation: diag(1021, ts.DiagnosticCategory.Error, "An_index_signature_must_have_a_type_annotation_1021", "An index signature must have a type annotation."),
        An_index_signature_parameter_must_have_a_type_annotation: diag(1022, ts.DiagnosticCategory.Error, "An_index_signature_parameter_must_have_a_type_annotation_1022", "An index signature parameter must have a type annotation."),
        readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature: diag(1024, ts.DiagnosticCategory.Error, "readonly_modifier_can_only_appear_on_a_property_declaration_or_index_signature_1024", "'readonly' modifier can only appear on a property declaration or index signature."),
        An_index_signature_cannot_have_a_trailing_comma: diag(1025, ts.DiagnosticCategory.Error, "An_index_signature_cannot_have_a_trailing_comma_1025", "An index signature cannot have a trailing comma."),
        Accessibility_modifier_already_seen: diag(1028, ts.DiagnosticCategory.Error, "Accessibility_modifier_already_seen_1028", "Accessibility modifier already seen."),
        _0_modifier_must_precede_1_modifier: diag(1029, ts.DiagnosticCategory.Error, "_0_modifier_must_precede_1_modifier_1029", "'{0}' modifier must precede '{1}' modifier."),
        _0_modifier_already_seen: diag(1030, ts.DiagnosticCategory.Error, "_0_modifier_already_seen_1030", "'{0}' modifier already seen."),
        _0_modifier_cannot_appear_on_class_elements_of_this_kind: diag(1031, ts.DiagnosticCategory.Error, "_0_modifier_cannot_appear_on_class_elements_of_this_kind_1031", "'{0}' modifier cannot appear on class elements of this kind."),
        super_must_be_followed_by_an_argument_list_or_member_access: diag(1034, ts.DiagnosticCategory.Error, "super_must_be_followed_by_an_argument_list_or_member_access_1034", "'super' must be followed by an argument list or member access."),
        Only_ambient_modules_can_use_quoted_names: diag(1035, ts.DiagnosticCategory.Error, "Only_ambient_modules_can_use_quoted_names_1035", "Only ambient modules can use quoted names."),
        Statements_are_not_allowed_in_ambient_contexts: diag(1036, ts.DiagnosticCategory.Error, "Statements_are_not_allowed_in_ambient_contexts_1036", "Statements are not allowed in ambient contexts."),
        A_declare_modifier_cannot_be_used_in_an_already_ambient_context: diag(1038, ts.DiagnosticCategory.Error, "A_declare_modifier_cannot_be_used_in_an_already_ambient_context_1038", "A 'declare' modifier cannot be used in an already ambient context."),
        Initializers_are_not_allowed_in_ambient_contexts: diag(1039, ts.DiagnosticCategory.Error, "Initializers_are_not_allowed_in_ambient_contexts_1039", "Initializers are not allowed in ambient contexts."),
        _0_modifier_cannot_be_used_in_an_ambient_context: diag(1040, ts.DiagnosticCategory.Error, "_0_modifier_cannot_be_used_in_an_ambient_context_1040", "'{0}' modifier cannot be used in an ambient context."),
        _0_modifier_cannot_be_used_here: diag(1042, ts.DiagnosticCategory.Error, "_0_modifier_cannot_be_used_here_1042", "'{0}' modifier cannot be used here."),
        _0_modifier_cannot_appear_on_a_module_or_namespace_element: diag(1044, ts.DiagnosticCategory.Error, "_0_modifier_cannot_appear_on_a_module_or_namespace_element_1044", "'{0}' modifier cannot appear on a module or namespace element."),
        Top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier: diag(1046, ts.DiagnosticCategory.Error, "Top_level_declarations_in_d_ts_files_must_start_with_either_a_declare_or_export_modifier_1046", "Top-level declarations in .d.ts files must start with either a 'declare' or 'export' modifier."),
        A_rest_parameter_cannot_be_optional: diag(1047, ts.DiagnosticCategory.Error, "A_rest_parameter_cannot_be_optional_1047", "A rest parameter cannot be optional."),
        A_rest_parameter_cannot_have_an_initializer: diag(1048, ts.DiagnosticCategory.Error, "A_rest_parameter_cannot_have_an_initializer_1048", "A rest parameter cannot have an initializer."),
        A_set_accessor_must_have_exactly_one_parameter: diag(1049, ts.DiagnosticCategory.Error, "A_set_accessor_must_have_exactly_one_parameter_1049", "A 'set' accessor must have exactly one parameter."),
        A_set_accessor_cannot_have_an_optional_parameter: diag(1051, ts.DiagnosticCategory.Error, "A_set_accessor_cannot_have_an_optional_parameter_1051", "A 'set' accessor cannot have an optional parameter."),
        A_set_accessor_parameter_cannot_have_an_initializer: diag(1052, ts.DiagnosticCategory.Error, "A_set_accessor_parameter_cannot_have_an_initializer_1052", "A 'set' accessor parameter cannot have an initializer."),
        A_set_accessor_cannot_have_rest_parameter: diag(1053, ts.DiagnosticCategory.Error, "A_set_accessor_cannot_have_rest_parameter_1053", "A 'set' accessor cannot have rest parameter."),
        A_get_accessor_cannot_have_parameters: diag(1054, ts.DiagnosticCategory.Error, "A_get_accessor_cannot_have_parameters_1054", "A 'get' accessor cannot have parameters."),
        Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Promise_compatible_constructor_value: diag(1055, ts.DiagnosticCategory.Error, "Type_0_is_not_a_valid_async_function_return_type_in_ES5_SlashES3_because_it_does_not_refer_to_a_Prom_1055", "Type '{0}' is not a valid async function return type in ES5/ES3 because it does not refer to a Promise-compatible constructor value."),
        Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher: diag(1056, ts.DiagnosticCategory.Error, "Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher_1056", "Accessors are only available when targeting ECMAScript 5 and higher."),
        The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: diag(1058, ts.DiagnosticCategory.Error, "The_return_type_of_an_async_function_must_either_be_a_valid_promise_or_must_not_contain_a_callable_t_1058", "The return type of an async function must either be a valid promise or must not contain a callable 'then' member."),
        A_promise_must_have_a_then_method: diag(1059, ts.DiagnosticCategory.Error, "A_promise_must_have_a_then_method_1059", "A promise must have a 'then' method."),
        The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback: diag(1060, ts.DiagnosticCategory.Error, "The_first_parameter_of_the_then_method_of_a_promise_must_be_a_callback_1060", "The first parameter of the 'then' method of a promise must be a callback."),
        Enum_member_must_have_initializer: diag(1061, ts.DiagnosticCategory.Error, "Enum_member_must_have_initializer_1061", "Enum member must have initializer."),
        Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method: diag(1062, ts.DiagnosticCategory.Error, "Type_is_referenced_directly_or_indirectly_in_the_fulfillment_callback_of_its_own_then_method_1062", "Type is referenced directly or indirectly in the fulfillment callback of its own 'then' method."),
        An_export_assignment_cannot_be_used_in_a_namespace: diag(1063, ts.DiagnosticCategory.Error, "An_export_assignment_cannot_be_used_in_a_namespace_1063", "An export assignment cannot be used in a namespace."),
        The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_write_Promise_0: diag(1064, ts.DiagnosticCategory.Error, "The_return_type_of_an_async_function_or_method_must_be_the_global_Promise_T_type_Did_you_mean_to_wri_1064", "The return type of an async function or method must be the global Promise<T> type. Did you mean to write 'Promise<{0}>'?"),
        In_ambient_enum_declarations_member_initializer_must_be_constant_expression: diag(1066, ts.DiagnosticCategory.Error, "In_ambient_enum_declarations_member_initializer_must_be_constant_expression_1066", "In ambient enum declarations member initializer must be constant expression."),
        Unexpected_token_A_constructor_method_accessor_or_property_was_expected: diag(1068, ts.DiagnosticCategory.Error, "Unexpected_token_A_constructor_method_accessor_or_property_was_expected_1068", "Unexpected token. A constructor, method, accessor, or property was expected."),
        Unexpected_token_A_type_parameter_name_was_expected_without_curly_braces: diag(1069, ts.DiagnosticCategory.Error, "Unexpected_token_A_type_parameter_name_was_expected_without_curly_braces_1069", "Unexpected token. A type parameter name was expected without curly braces."),
        _0_modifier_cannot_appear_on_a_type_member: diag(1070, ts.DiagnosticCategory.Error, "_0_modifier_cannot_appear_on_a_type_member_1070", "'{0}' modifier cannot appear on a type member."),
        _0_modifier_cannot_appear_on_an_index_signature: diag(1071, ts.DiagnosticCategory.Error, "_0_modifier_cannot_appear_on_an_index_signature_1071", "'{0}' modifier cannot appear on an index signature."),
        A_0_modifier_cannot_be_used_with_an_import_declaration: diag(1079, ts.DiagnosticCategory.Error, "A_0_modifier_cannot_be_used_with_an_import_declaration_1079", "A '{0}' modifier cannot be used with an import declaration."),
        Invalid_reference_directive_syntax: diag(1084, ts.DiagnosticCategory.Error, "Invalid_reference_directive_syntax_1084", "Invalid 'reference' directive syntax."),
        Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher_Use_the_syntax_0: diag(1085, ts.DiagnosticCategory.Error, "Octal_literals_are_not_available_when_targeting_ECMAScript_5_and_higher_Use_the_syntax_0_1085", "Octal literals are not available when targeting ECMAScript 5 and higher. Use the syntax '{0}'."),
        _0_modifier_cannot_appear_on_a_constructor_declaration: diag(1089, ts.DiagnosticCategory.Error, "_0_modifier_cannot_appear_on_a_constructor_declaration_1089", "'{0}' modifier cannot appear on a constructor declaration."),
        _0_modifier_cannot_appear_on_a_parameter: diag(1090, ts.DiagnosticCategory.Error, "_0_modifier_cannot_appear_on_a_parameter_1090", "'{0}' modifier cannot appear on a parameter."),
        Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement: diag(1091, ts.DiagnosticCategory.Error, "Only_a_single_variable_declaration_is_allowed_in_a_for_in_statement_1091", "Only a single variable declaration is allowed in a 'for...in' statement."),
        Type_parameters_cannot_appear_on_a_constructor_declaration: diag(1092, ts.DiagnosticCategory.Error, "Type_parameters_cannot_appear_on_a_constructor_declaration_1092", "Type parameters cannot appear on a constructor declaration."),
        Type_annotation_cannot_appear_on_a_constructor_declaration: diag(1093, ts.DiagnosticCategory.Error, "Type_annotation_cannot_appear_on_a_constructor_declaration_1093", "Type annotation cannot appear on a constructor declaration."),
        An_accessor_cannot_have_type_parameters: diag(1094, ts.DiagnosticCategory.Error, "An_accessor_cannot_have_type_parameters_1094", "An accessor cannot have type parameters."),
        A_set_accessor_cannot_have_a_return_type_annotation: diag(1095, ts.DiagnosticCategory.Error, "A_set_accessor_cannot_have_a_return_type_annotation_1095", "A 'set' accessor cannot have a return type annotation."),
        An_index_signature_must_have_exactly_one_parameter: diag(1096, ts.DiagnosticCategory.Error, "An_index_signature_must_have_exactly_one_parameter_1096", "An index signature must have exactly one parameter."),
        _0_list_cannot_be_empty: diag(1097, ts.DiagnosticCategory.Error, "_0_list_cannot_be_empty_1097", "'{0}' list cannot be empty."),
        Type_parameter_list_cannot_be_empty: diag(1098, ts.DiagnosticCategory.Error, "Type_parameter_list_cannot_be_empty_1098", "Type parameter list cannot be empty."),
        Type_argument_list_cannot_be_empty: diag(1099, ts.DiagnosticCategory.Error, "Type_argument_list_cannot_be_empty_1099", "Type argument list cannot be empty."),
        Invalid_use_of_0_in_strict_mode: diag(1100, ts.DiagnosticCategory.Error, "Invalid_use_of_0_in_strict_mode_1100", "Invalid use of '{0}' in strict mode."),
        with_statements_are_not_allowed_in_strict_mode: diag(1101, ts.DiagnosticCategory.Error, "with_statements_are_not_allowed_in_strict_mode_1101", "'with' statements are not allowed in strict mode."),
        delete_cannot_be_called_on_an_identifier_in_strict_mode: diag(1102, ts.DiagnosticCategory.Error, "delete_cannot_be_called_on_an_identifier_in_strict_mode_1102", "'delete' cannot be called on an identifier in strict mode."),
        for_await_loops_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules: diag(1103, ts.DiagnosticCategory.Error, "for_await_loops_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules_1103", "'for await' loops are only allowed within async functions and at the top levels of modules."),
        A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement: diag(1104, ts.DiagnosticCategory.Error, "A_continue_statement_can_only_be_used_within_an_enclosing_iteration_statement_1104", "A 'continue' statement can only be used within an enclosing iteration statement."),
        A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement: diag(1105, ts.DiagnosticCategory.Error, "A_break_statement_can_only_be_used_within_an_enclosing_iteration_or_switch_statement_1105", "A 'break' statement can only be used within an enclosing iteration or switch statement."),
        The_left_hand_side_of_a_for_of_statement_may_not_be_async: diag(1106, ts.DiagnosticCategory.Error, "The_left_hand_side_of_a_for_of_statement_may_not_be_async_1106", "The left-hand side of a 'for...of' statement may not be 'async'."),
        Jump_target_cannot_cross_function_boundary: diag(1107, ts.DiagnosticCategory.Error, "Jump_target_cannot_cross_function_boundary_1107", "Jump target cannot cross function boundary."),
        A_return_statement_can_only_be_used_within_a_function_body: diag(1108, ts.DiagnosticCategory.Error, "A_return_statement_can_only_be_used_within_a_function_body_1108", "A 'return' statement can only be used within a function body."),
        Expression_expected: diag(1109, ts.DiagnosticCategory.Error, "Expression_expected_1109", "Expression expected."),
        Type_expected: diag(1110, ts.DiagnosticCategory.Error, "Type_expected_1110", "Type expected."),
        A_default_clause_cannot_appear_more_than_once_in_a_switch_statement: diag(1113, ts.DiagnosticCategory.Error, "A_default_clause_cannot_appear_more_than_once_in_a_switch_statement_1113", "A 'default' clause cannot appear more than once in a 'switch' statement."),
        Duplicate_label_0: diag(1114, ts.DiagnosticCategory.Error, "Duplicate_label_0_1114", "Duplicate label '{0}'."),
        A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement: diag(1115, ts.DiagnosticCategory.Error, "A_continue_statement_can_only_jump_to_a_label_of_an_enclosing_iteration_statement_1115", "A 'continue' statement can only jump to a label of an enclosing iteration statement."),
        A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement: diag(1116, ts.DiagnosticCategory.Error, "A_break_statement_can_only_jump_to_a_label_of_an_enclosing_statement_1116", "A 'break' statement can only jump to a label of an enclosing statement."),
        An_object_literal_cannot_have_multiple_properties_with_the_same_name: diag(1117, ts.DiagnosticCategory.Error, "An_object_literal_cannot_have_multiple_properties_with_the_same_name_1117", "An object literal cannot have multiple properties with the same name."),
        An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name: diag(1118, ts.DiagnosticCategory.Error, "An_object_literal_cannot_have_multiple_get_Slashset_accessors_with_the_same_name_1118", "An object literal cannot have multiple get/set accessors with the same name."),
        An_object_literal_cannot_have_property_and_accessor_with_the_same_name: diag(1119, ts.DiagnosticCategory.Error, "An_object_literal_cannot_have_property_and_accessor_with_the_same_name_1119", "An object literal cannot have property and accessor with the same name."),
        An_export_assignment_cannot_have_modifiers: diag(1120, ts.DiagnosticCategory.Error, "An_export_assignment_cannot_have_modifiers_1120", "An export assignment cannot have modifiers."),
        Octal_literals_are_not_allowed_in_strict_mode: diag(1121, ts.DiagnosticCategory.Error, "Octal_literals_are_not_allowed_in_strict_mode_1121", "Octal literals are not allowed in strict mode."),
        Variable_declaration_list_cannot_be_empty: diag(1123, ts.DiagnosticCategory.Error, "Variable_declaration_list_cannot_be_empty_1123", "Variable declaration list cannot be empty."),
        Digit_expected: diag(1124, ts.DiagnosticCategory.Error, "Digit_expected_1124", "Digit expected."),
        Hexadecimal_digit_expected: diag(1125, ts.DiagnosticCategory.Error, "Hexadecimal_digit_expected_1125", "Hexadecimal digit expected."),
        Unexpected_end_of_text: diag(1126, ts.DiagnosticCategory.Error, "Unexpected_end_of_text_1126", "Unexpected end of text."),
        Invalid_character: diag(1127, ts.DiagnosticCategory.Error, "Invalid_character_1127", "Invalid character."),
        Declaration_or_statement_expected: diag(1128, ts.DiagnosticCategory.Error, "Declaration_or_statement_expected_1128", "Declaration or statement expected."),
        Statement_expected: diag(1129, ts.DiagnosticCategory.Error, "Statement_expected_1129", "Statement expected."),
        case_or_default_expected: diag(1130, ts.DiagnosticCategory.Error, "case_or_default_expected_1130", "'case' or 'default' expected."),
        Property_or_signature_expected: diag(1131, ts.DiagnosticCategory.Error, "Property_or_signature_expected_1131", "Property or signature expected."),
        Enum_member_expected: diag(1132, ts.DiagnosticCategory.Error, "Enum_member_expected_1132", "Enum member expected."),
        Variable_declaration_expected: diag(1134, ts.DiagnosticCategory.Error, "Variable_declaration_expected_1134", "Variable declaration expected."),
        Argument_expression_expected: diag(1135, ts.DiagnosticCategory.Error, "Argument_expression_expected_1135", "Argument expression expected."),
        Property_assignment_expected: diag(1136, ts.DiagnosticCategory.Error, "Property_assignment_expected_1136", "Property assignment expected."),
        Expression_or_comma_expected: diag(1137, ts.DiagnosticCategory.Error, "Expression_or_comma_expected_1137", "Expression or comma expected."),
        Parameter_declaration_expected: diag(1138, ts.DiagnosticCategory.Error, "Parameter_declaration_expected_1138", "Parameter declaration expected."),
        Type_parameter_declaration_expected: diag(1139, ts.DiagnosticCategory.Error, "Type_parameter_declaration_expected_1139", "Type parameter declaration expected."),
        Type_argument_expected: diag(1140, ts.DiagnosticCategory.Error, "Type_argument_expected_1140", "Type argument expected."),
        String_literal_expected: diag(1141, ts.DiagnosticCategory.Error, "String_literal_expected_1141", "String literal expected."),
        Line_break_not_permitted_here: diag(1142, ts.DiagnosticCategory.Error, "Line_break_not_permitted_here_1142", "Line break not permitted here."),
        or_expected: diag(1144, ts.DiagnosticCategory.Error, "or_expected_1144", "'{' or ';' expected."),
        or_JSX_element_expected: diag(1145, ts.DiagnosticCategory.Error, "or_JSX_element_expected_1145", "'{' or JSX element expected."),
        Declaration_expected: diag(1146, ts.DiagnosticCategory.Error, "Declaration_expected_1146", "Declaration expected."),
        Import_declarations_in_a_namespace_cannot_reference_a_module: diag(1147, ts.DiagnosticCategory.Error, "Import_declarations_in_a_namespace_cannot_reference_a_module_1147", "Import declarations in a namespace cannot reference a module."),
        Cannot_use_imports_exports_or_module_augmentations_when_module_is_none: diag(1148, ts.DiagnosticCategory.Error, "Cannot_use_imports_exports_or_module_augmentations_when_module_is_none_1148", "Cannot use imports, exports, or module augmentations when '--module' is 'none'."),
        File_name_0_differs_from_already_included_file_name_1_only_in_casing: diag(1149, ts.DiagnosticCategory.Error, "File_name_0_differs_from_already_included_file_name_1_only_in_casing_1149", "File name '{0}' differs from already included file name '{1}' only in casing."),
        const_declarations_must_be_initialized: diag(1155, ts.DiagnosticCategory.Error, "const_declarations_must_be_initialized_1155", "'const' declarations must be initialized."),
        const_declarations_can_only_be_declared_inside_a_block: diag(1156, ts.DiagnosticCategory.Error, "const_declarations_can_only_be_declared_inside_a_block_1156", "'const' declarations can only be declared inside a block."),
        let_declarations_can_only_be_declared_inside_a_block: diag(1157, ts.DiagnosticCategory.Error, "let_declarations_can_only_be_declared_inside_a_block_1157", "'let' declarations can only be declared inside a block."),
        Unterminated_template_literal: diag(1160, ts.DiagnosticCategory.Error, "Unterminated_template_literal_1160", "Unterminated template literal."),
        Unterminated_regular_expression_literal: diag(1161, ts.DiagnosticCategory.Error, "Unterminated_regular_expression_literal_1161", "Unterminated regular expression literal."),
        An_object_member_cannot_be_declared_optional: diag(1162, ts.DiagnosticCategory.Error, "An_object_member_cannot_be_declared_optional_1162", "An object member cannot be declared optional."),
        A_yield_expression_is_only_allowed_in_a_generator_body: diag(1163, ts.DiagnosticCategory.Error, "A_yield_expression_is_only_allowed_in_a_generator_body_1163", "A 'yield' expression is only allowed in a generator body."),
        Computed_property_names_are_not_allowed_in_enums: diag(1164, ts.DiagnosticCategory.Error, "Computed_property_names_are_not_allowed_in_enums_1164", "Computed property names are not allowed in enums."),
        A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: diag(1165, ts.DiagnosticCategory.Error, "A_computed_property_name_in_an_ambient_context_must_refer_to_an_expression_whose_type_is_a_literal_t_1165", "A computed property name in an ambient context must refer to an expression whose type is a literal type or a 'unique symbol' type."),
        A_computed_property_name_in_a_class_property_declaration_must_have_a_simple_literal_type_or_a_unique_symbol_type: diag(1166, ts.DiagnosticCategory.Error, "A_computed_property_name_in_a_class_property_declaration_must_have_a_simple_literal_type_or_a_unique_1166", "A computed property name in a class property declaration must have a simple literal type or a 'unique symbol' type."),
        A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: diag(1168, ts.DiagnosticCategory.Error, "A_computed_property_name_in_a_method_overload_must_refer_to_an_expression_whose_type_is_a_literal_ty_1168", "A computed property name in a method overload must refer to an expression whose type is a literal type or a 'unique symbol' type."),
        A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: diag(1169, ts.DiagnosticCategory.Error, "A_computed_property_name_in_an_interface_must_refer_to_an_expression_whose_type_is_a_literal_type_or_1169", "A computed property name in an interface must refer to an expression whose type is a literal type or a 'unique symbol' type."),
        A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type_or_a_unique_symbol_type: diag(1170, ts.DiagnosticCategory.Error, "A_computed_property_name_in_a_type_literal_must_refer_to_an_expression_whose_type_is_a_literal_type__1170", "A computed property name in a type literal must refer to an expression whose type is a literal type or a 'unique symbol' type."),
        A_comma_expression_is_not_allowed_in_a_computed_property_name: diag(1171, ts.DiagnosticCategory.Error, "A_comma_expression_is_not_allowed_in_a_computed_property_name_1171", "A comma expression is not allowed in a computed property name."),
        extends_clause_already_seen: diag(1172, ts.DiagnosticCategory.Error, "extends_clause_already_seen_1172", "'extends' clause already seen."),
        extends_clause_must_precede_implements_clause: diag(1173, ts.DiagnosticCategory.Error, "extends_clause_must_precede_implements_clause_1173", "'extends' clause must precede 'implements' clause."),
        Classes_can_only_extend_a_single_class: diag(1174, ts.DiagnosticCategory.Error, "Classes_can_only_extend_a_single_class_1174", "Classes can only extend a single class."),
        implements_clause_already_seen: diag(1175, ts.DiagnosticCategory.Error, "implements_clause_already_seen_1175", "'implements' clause already seen."),
        Interface_declaration_cannot_have_implements_clause: diag(1176, ts.DiagnosticCategory.Error, "Interface_declaration_cannot_have_implements_clause_1176", "Interface declaration cannot have 'implements' clause."),
        Binary_digit_expected: diag(1177, ts.DiagnosticCategory.Error, "Binary_digit_expected_1177", "Binary digit expected."),
        Octal_digit_expected: diag(1178, ts.DiagnosticCategory.Error, "Octal_digit_expected_1178", "Octal digit expected."),
        Unexpected_token_expected: diag(1179, ts.DiagnosticCategory.Error, "Unexpected_token_expected_1179", "Unexpected token. '{' expected."),
        Property_destructuring_pattern_expected: diag(1180, ts.DiagnosticCategory.Error, "Property_destructuring_pattern_expected_1180", "Property destructuring pattern expected."),
        Array_element_destructuring_pattern_expected: diag(1181, ts.DiagnosticCategory.Error, "Array_element_destructuring_pattern_expected_1181", "Array element destructuring pattern expected."),
        A_destructuring_declaration_must_have_an_initializer: diag(1182, ts.DiagnosticCategory.Error, "A_destructuring_declaration_must_have_an_initializer_1182", "A destructuring declaration must have an initializer."),
        An_implementation_cannot_be_declared_in_ambient_contexts: diag(1183, ts.DiagnosticCategory.Error, "An_implementation_cannot_be_declared_in_ambient_contexts_1183", "An implementation cannot be declared in ambient contexts."),
        Modifiers_cannot_appear_here: diag(1184, ts.DiagnosticCategory.Error, "Modifiers_cannot_appear_here_1184", "Modifiers cannot appear here."),
        Merge_conflict_marker_encountered: diag(1185, ts.DiagnosticCategory.Error, "Merge_conflict_marker_encountered_1185", "Merge conflict marker encountered."),
        A_rest_element_cannot_have_an_initializer: diag(1186, ts.DiagnosticCategory.Error, "A_rest_element_cannot_have_an_initializer_1186", "A rest element cannot have an initializer."),
        A_parameter_property_may_not_be_declared_using_a_binding_pattern: diag(1187, ts.DiagnosticCategory.Error, "A_parameter_property_may_not_be_declared_using_a_binding_pattern_1187", "A parameter property may not be declared using a binding pattern."),
        Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement: diag(1188, ts.DiagnosticCategory.Error, "Only_a_single_variable_declaration_is_allowed_in_a_for_of_statement_1188", "Only a single variable declaration is allowed in a 'for...of' statement."),
        The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer: diag(1189, ts.DiagnosticCategory.Error, "The_variable_declaration_of_a_for_in_statement_cannot_have_an_initializer_1189", "The variable declaration of a 'for...in' statement cannot have an initializer."),
        The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer: diag(1190, ts.DiagnosticCategory.Error, "The_variable_declaration_of_a_for_of_statement_cannot_have_an_initializer_1190", "The variable declaration of a 'for...of' statement cannot have an initializer."),
        An_import_declaration_cannot_have_modifiers: diag(1191, ts.DiagnosticCategory.Error, "An_import_declaration_cannot_have_modifiers_1191", "An import declaration cannot have modifiers."),
        Module_0_has_no_default_export: diag(1192, ts.DiagnosticCategory.Error, "Module_0_has_no_default_export_1192", "Module '{0}' has no default export."),
        An_export_declaration_cannot_have_modifiers: diag(1193, ts.DiagnosticCategory.Error, "An_export_declaration_cannot_have_modifiers_1193", "An export declaration cannot have modifiers."),
        Export_declarations_are_not_permitted_in_a_namespace: diag(1194, ts.DiagnosticCategory.Error, "Export_declarations_are_not_permitted_in_a_namespace_1194", "Export declarations are not permitted in a namespace."),
        export_Asterisk_does_not_re_export_a_default: diag(1195, ts.DiagnosticCategory.Error, "export_Asterisk_does_not_re_export_a_default_1195", "'export *' does not re-export a default."),
        Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified: diag(1196, ts.DiagnosticCategory.Error, "Catch_clause_variable_type_annotation_must_be_any_or_unknown_if_specified_1196", "Catch clause variable type annotation must be 'any' or 'unknown' if specified."),
        Catch_clause_variable_cannot_have_an_initializer: diag(1197, ts.DiagnosticCategory.Error, "Catch_clause_variable_cannot_have_an_initializer_1197", "Catch clause variable cannot have an initializer."),
        An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive: diag(1198, ts.DiagnosticCategory.Error, "An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive_1198", "An extended Unicode escape value must be between 0x0 and 0x10FFFF inclusive."),
        Unterminated_Unicode_escape_sequence: diag(1199, ts.DiagnosticCategory.Error, "Unterminated_Unicode_escape_sequence_1199", "Unterminated Unicode escape sequence."),
        Line_terminator_not_permitted_before_arrow: diag(1200, ts.DiagnosticCategory.Error, "Line_terminator_not_permitted_before_arrow_1200", "Line terminator not permitted before arrow."),
        Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_ns_from_mod_import_a_from_mod_import_d_from_mod_or_another_module_format_instead: diag(1202, ts.DiagnosticCategory.Error, "Import_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_import_Asterisk_as_1202", "Import assignment cannot be used when targeting ECMAScript modules. Consider using 'import * as ns from \"mod\"', 'import {a} from \"mod\"', 'import d from \"mod\"', or another module format instead."),
        Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or_another_module_format_instead: diag(1203, ts.DiagnosticCategory.Error, "Export_assignment_cannot_be_used_when_targeting_ECMAScript_modules_Consider_using_export_default_or__1203", "Export assignment cannot be used when targeting ECMAScript modules. Consider using 'export default' or another module format instead."),
        Re_exporting_a_type_when_the_isolatedModules_flag_is_provided_requires_using_export_type: diag(1205, ts.DiagnosticCategory.Error, "Re_exporting_a_type_when_the_isolatedModules_flag_is_provided_requires_using_export_type_1205", "Re-exporting a type when the '--isolatedModules' flag is provided requires using 'export type'."),
        Decorators_are_not_valid_here: diag(1206, ts.DiagnosticCategory.Error, "Decorators_are_not_valid_here_1206", "Decorators are not valid here."),
        Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name: diag(1207, ts.DiagnosticCategory.Error, "Decorators_cannot_be_applied_to_multiple_get_Slashset_accessors_of_the_same_name_1207", "Decorators cannot be applied to multiple get/set accessors of the same name."),
        _0_cannot_be_compiled_under_isolatedModules_because_it_is_considered_a_global_script_file_Add_an_import_export_or_an_empty_export_statement_to_make_it_a_module: diag(1208, ts.DiagnosticCategory.Error, "_0_cannot_be_compiled_under_isolatedModules_because_it_is_considered_a_global_script_file_Add_an_imp_1208", "'{0}' cannot be compiled under '--isolatedModules' because it is considered a global script file. Add an import, export, or an empty 'export {}' statement to make it a module."),
        Invalid_optional_chain_from_new_expression_Did_you_mean_to_call_0: diag(1209, ts.DiagnosticCategory.Error, "Invalid_optional_chain_from_new_expression_Did_you_mean_to_call_0_1209", "Invalid optional chain from new expression. Did you mean to call '{0}()'?"),
        Code_contained_in_a_class_is_evaluated_in_JavaScript_s_strict_mode_which_does_not_allow_this_use_of_0_For_more_information_see_https_Colon_Slash_Slashdeveloper_mozilla_org_Slashen_US_Slashdocs_SlashWeb_SlashJavaScript_SlashReference_SlashStrict_mode: diag(1210, ts.DiagnosticCategory.Error, "Code_contained_in_a_class_is_evaluated_in_JavaScript_s_strict_mode_which_does_not_allow_this_use_of__1210", "Code contained in a class is evaluated in JavaScript's strict mode which does not allow this use of '{0}'. For more information, see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode."),
        A_class_declaration_without_the_default_modifier_must_have_a_name: diag(1211, ts.DiagnosticCategory.Error, "A_class_declaration_without_the_default_modifier_must_have_a_name_1211", "A class declaration without the 'default' modifier must have a name."),
        Identifier_expected_0_is_a_reserved_word_in_strict_mode: diag(1212, ts.DiagnosticCategory.Error, "Identifier_expected_0_is_a_reserved_word_in_strict_mode_1212", "Identifier expected. '{0}' is a reserved word in strict mode."),
        Identifier_expected_0_is_a_reserved_word_in_strict_mode_Class_definitions_are_automatically_in_strict_mode: diag(1213, ts.DiagnosticCategory.Error, "Identifier_expected_0_is_a_reserved_word_in_strict_mode_Class_definitions_are_automatically_in_stric_1213", "Identifier expected. '{0}' is a reserved word in strict mode. Class definitions are automatically in strict mode."),
        Identifier_expected_0_is_a_reserved_word_in_strict_mode_Modules_are_automatically_in_strict_mode: diag(1214, ts.DiagnosticCategory.Error, "Identifier_expected_0_is_a_reserved_word_in_strict_mode_Modules_are_automatically_in_strict_mode_1214", "Identifier expected. '{0}' is a reserved word in strict mode. Modules are automatically in strict mode."),
        Invalid_use_of_0_Modules_are_automatically_in_strict_mode: diag(1215, ts.DiagnosticCategory.Error, "Invalid_use_of_0_Modules_are_automatically_in_strict_mode_1215", "Invalid use of '{0}'. Modules are automatically in strict mode."),
        Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules: diag(1216, ts.DiagnosticCategory.Error, "Identifier_expected_esModule_is_reserved_as_an_exported_marker_when_transforming_ECMAScript_modules_1216", "Identifier expected. '__esModule' is reserved as an exported marker when transforming ECMAScript modules."),
        Export_assignment_is_not_supported_when_module_flag_is_system: diag(1218, ts.DiagnosticCategory.Error, "Export_assignment_is_not_supported_when_module_flag_is_system_1218", "Export assignment is not supported when '--module' flag is 'system'."),
        Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Set_the_experimentalDecorators_option_in_your_tsconfig_or_jsconfig_to_remove_this_warning: diag(1219, ts.DiagnosticCategory.Error, "Experimental_support_for_decorators_is_a_feature_that_is_subject_to_change_in_a_future_release_Set_t_1219", "Experimental support for decorators is a feature that is subject to change in a future release. Set the 'experimentalDecorators' option in your 'tsconfig' or 'jsconfig' to remove this warning."),
        Generators_are_not_allowed_in_an_ambient_context: diag(1221, ts.DiagnosticCategory.Error, "Generators_are_not_allowed_in_an_ambient_context_1221", "Generators are not allowed in an ambient context."),
        An_overload_signature_cannot_be_declared_as_a_generator: diag(1222, ts.DiagnosticCategory.Error, "An_overload_signature_cannot_be_declared_as_a_generator_1222", "An overload signature cannot be declared as a generator."),
        _0_tag_already_specified: diag(1223, ts.DiagnosticCategory.Error, "_0_tag_already_specified_1223", "'{0}' tag already specified."),
        Signature_0_must_be_a_type_predicate: diag(1224, ts.DiagnosticCategory.Error, "Signature_0_must_be_a_type_predicate_1224", "Signature '{0}' must be a type predicate."),
        Cannot_find_parameter_0: diag(1225, ts.DiagnosticCategory.Error, "Cannot_find_parameter_0_1225", "Cannot find parameter '{0}'."),
        Type_predicate_0_is_not_assignable_to_1: diag(1226, ts.DiagnosticCategory.Error, "Type_predicate_0_is_not_assignable_to_1_1226", "Type predicate '{0}' is not assignable to '{1}'."),
        Parameter_0_is_not_in_the_same_position_as_parameter_1: diag(1227, ts.DiagnosticCategory.Error, "Parameter_0_is_not_in_the_same_position_as_parameter_1_1227", "Parameter '{0}' is not in the same position as parameter '{1}'."),
        A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods: diag(1228, ts.DiagnosticCategory.Error, "A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods_1228", "A type predicate is only allowed in return type position for functions and methods."),
        A_type_predicate_cannot_reference_a_rest_parameter: diag(1229, ts.DiagnosticCategory.Error, "A_type_predicate_cannot_reference_a_rest_parameter_1229", "A type predicate cannot reference a rest parameter."),
        A_type_predicate_cannot_reference_element_0_in_a_binding_pattern: diag(1230, ts.DiagnosticCategory.Error, "A_type_predicate_cannot_reference_element_0_in_a_binding_pattern_1230", "A type predicate cannot reference element '{0}' in a binding pattern."),
        An_export_assignment_must_be_at_the_top_level_of_a_file_or_module_declaration: diag(1231, ts.DiagnosticCategory.Error, "An_export_assignment_must_be_at_the_top_level_of_a_file_or_module_declaration_1231", "An export assignment must be at the top level of a file or module declaration."),
        An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module: diag(1232, ts.DiagnosticCategory.Error, "An_import_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module_1232", "An import declaration can only be used at the top level of a namespace or module."),
        An_export_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module: diag(1233, ts.DiagnosticCategory.Error, "An_export_declaration_can_only_be_used_at_the_top_level_of_a_namespace_or_module_1233", "An export declaration can only be used at the top level of a namespace or module."),
        An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file: diag(1234, ts.DiagnosticCategory.Error, "An_ambient_module_declaration_is_only_allowed_at_the_top_level_in_a_file_1234", "An ambient module declaration is only allowed at the top level in a file."),
        A_namespace_declaration_is_only_allowed_at_the_top_level_of_a_namespace_or_module: diag(1235, ts.DiagnosticCategory.Error, "A_namespace_declaration_is_only_allowed_at_the_top_level_of_a_namespace_or_module_1235", "A namespace declaration is only allowed at the top level of a namespace or module."),
        The_return_type_of_a_property_decorator_function_must_be_either_void_or_any: diag(1236, ts.DiagnosticCategory.Error, "The_return_type_of_a_property_decorator_function_must_be_either_void_or_any_1236", "The return type of a property decorator function must be either 'void' or 'any'."),
        The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any: diag(1237, ts.DiagnosticCategory.Error, "The_return_type_of_a_parameter_decorator_function_must_be_either_void_or_any_1237", "The return type of a parameter decorator function must be either 'void' or 'any'."),
        Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression: diag(1238, ts.DiagnosticCategory.Error, "Unable_to_resolve_signature_of_class_decorator_when_called_as_an_expression_1238", "Unable to resolve signature of class decorator when called as an expression."),
        Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression: diag(1239, ts.DiagnosticCategory.Error, "Unable_to_resolve_signature_of_parameter_decorator_when_called_as_an_expression_1239", "Unable to resolve signature of parameter decorator when called as an expression."),
        Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression: diag(1240, ts.DiagnosticCategory.Error, "Unable_to_resolve_signature_of_property_decorator_when_called_as_an_expression_1240", "Unable to resolve signature of property decorator when called as an expression."),
        Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression: diag(1241, ts.DiagnosticCategory.Error, "Unable_to_resolve_signature_of_method_decorator_when_called_as_an_expression_1241", "Unable to resolve signature of method decorator when called as an expression."),
        abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration: diag(1242, ts.DiagnosticCategory.Error, "abstract_modifier_can_only_appear_on_a_class_method_or_property_declaration_1242", "'abstract' modifier can only appear on a class, method, or property declaration."),
        _0_modifier_cannot_be_used_with_1_modifier: diag(1243, ts.DiagnosticCategory.Error, "_0_modifier_cannot_be_used_with_1_modifier_1243", "'{0}' modifier cannot be used with '{1}' modifier."),
        Abstract_methods_can_only_appear_within_an_abstract_class: diag(1244, ts.DiagnosticCategory.Error, "Abstract_methods_can_only_appear_within_an_abstract_class_1244", "Abstract methods can only appear within an abstract class."),
        Method_0_cannot_have_an_implementation_because_it_is_marked_abstract: diag(1245, ts.DiagnosticCategory.Error, "Method_0_cannot_have_an_implementation_because_it_is_marked_abstract_1245", "Method '{0}' cannot have an implementation because it is marked abstract."),
        An_interface_property_cannot_have_an_initializer: diag(1246, ts.DiagnosticCategory.Error, "An_interface_property_cannot_have_an_initializer_1246", "An interface property cannot have an initializer."),
        A_type_literal_property_cannot_have_an_initializer: diag(1247, ts.DiagnosticCategory.Error, "A_type_literal_property_cannot_have_an_initializer_1247", "A type literal property cannot have an initializer."),
        A_class_member_cannot_have_the_0_keyword: diag(1248, ts.DiagnosticCategory.Error, "A_class_member_cannot_have_the_0_keyword_1248", "A class member cannot have the '{0}' keyword."),
        A_decorator_can_only_decorate_a_method_implementation_not_an_overload: diag(1249, ts.DiagnosticCategory.Error, "A_decorator_can_only_decorate_a_method_implementation_not_an_overload_1249", "A decorator can only decorate a method implementation, not an overload."),
        Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5: diag(1250, ts.DiagnosticCategory.Error, "Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_1250", "Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'."),
        Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Class_definitions_are_automatically_in_strict_mode: diag(1251, ts.DiagnosticCategory.Error, "Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Class_d_1251", "Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'. Class definitions are automatically in strict mode."),
        Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Modules_are_automatically_in_strict_mode: diag(1252, ts.DiagnosticCategory.Error, "Function_declarations_are_not_allowed_inside_blocks_in_strict_mode_when_targeting_ES3_or_ES5_Modules_1252", "Function declarations are not allowed inside blocks in strict mode when targeting 'ES3' or 'ES5'. Modules are automatically in strict mode."),
        A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_reference: diag(1254, ts.DiagnosticCategory.Error, "A_const_initializer_in_an_ambient_context_must_be_a_string_or_numeric_literal_or_literal_enum_refere_1254", "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference."),
        A_definite_assignment_assertion_is_not_permitted_in_this_context: diag(1255, ts.DiagnosticCategory.Error, "A_definite_assignment_assertion_is_not_permitted_in_this_context_1255", "A definite assignment assertion '!' is not permitted in this context."),
        A_required_element_cannot_follow_an_optional_element: diag(1257, ts.DiagnosticCategory.Error, "A_required_element_cannot_follow_an_optional_element_1257", "A required element cannot follow an optional element."),
        A_default_export_must_be_at_the_top_level_of_a_file_or_module_declaration: diag(1258, ts.DiagnosticCategory.Error, "A_default_export_must_be_at_the_top_level_of_a_file_or_module_declaration_1258", "A default export must be at the top level of a file or module declaration."),
        Module_0_can_only_be_default_imported_using_the_1_flag: diag(1259, ts.DiagnosticCategory.Error, "Module_0_can_only_be_default_imported_using_the_1_flag_1259", "Module '{0}' can only be default-imported using the '{1}' flag"),
        Keywords_cannot_contain_escape_characters: diag(1260, ts.DiagnosticCategory.Error, "Keywords_cannot_contain_escape_characters_1260", "Keywords cannot contain escape characters."),
        Already_included_file_name_0_differs_from_file_name_1_only_in_casing: diag(1261, ts.DiagnosticCategory.Error, "Already_included_file_name_0_differs_from_file_name_1_only_in_casing_1261", "Already included file name '{0}' differs from file name '{1}' only in casing."),
        Identifier_expected_0_is_a_reserved_word_at_the_top_level_of_a_module: diag(1262, ts.DiagnosticCategory.Error, "Identifier_expected_0_is_a_reserved_word_at_the_top_level_of_a_module_1262", "Identifier expected. '{0}' is a reserved word at the top-level of a module."),
        Declarations_with_initializers_cannot_also_have_definite_assignment_assertions: diag(1263, ts.DiagnosticCategory.Error, "Declarations_with_initializers_cannot_also_have_definite_assignment_assertions_1263", "Declarations with initializers cannot also have definite assignment assertions."),
        Declarations_with_definite_assignment_assertions_must_also_have_type_annotations: diag(1264, ts.DiagnosticCategory.Error, "Declarations_with_definite_assignment_assertions_must_also_have_type_annotations_1264", "Declarations with definite assignment assertions must also have type annotations."),
        A_rest_element_cannot_follow_another_rest_element: diag(1265, ts.DiagnosticCategory.Error, "A_rest_element_cannot_follow_another_rest_element_1265", "A rest element cannot follow another rest element."),
        An_optional_element_cannot_follow_a_rest_element: diag(1266, ts.DiagnosticCategory.Error, "An_optional_element_cannot_follow_a_rest_element_1266", "An optional element cannot follow a rest element."),
        Property_0_cannot_have_an_initializer_because_it_is_marked_abstract: diag(1267, ts.DiagnosticCategory.Error, "Property_0_cannot_have_an_initializer_because_it_is_marked_abstract_1267", "Property '{0}' cannot have an initializer because it is marked abstract."),
        An_index_signature_parameter_type_must_be_string_number_symbol_or_a_template_literal_type: diag(1268, ts.DiagnosticCategory.Error, "An_index_signature_parameter_type_must_be_string_number_symbol_or_a_template_literal_type_1268", "An index signature parameter type must be 'string', 'number', 'symbol', or a template literal type."),
        Cannot_use_export_import_on_a_type_or_type_only_namespace_when_the_isolatedModules_flag_is_provided: diag(1269, ts.DiagnosticCategory.Error, "Cannot_use_export_import_on_a_type_or_type_only_namespace_when_the_isolatedModules_flag_is_provided_1269", "Cannot use 'export import' on a type or type-only namespace when the '--isolatedModules' flag is provided."),
        Decorator_function_return_type_0_is_not_assignable_to_type_1: diag(1270, ts.DiagnosticCategory.Error, "Decorator_function_return_type_0_is_not_assignable_to_type_1_1270", "Decorator function return type '{0}' is not assignable to type '{1}'."),
        Decorator_function_return_type_is_0_but_is_expected_to_be_void_or_any: diag(1271, ts.DiagnosticCategory.Error, "Decorator_function_return_type_is_0_but_is_expected_to_be_void_or_any_1271", "Decorator function return type is '{0}' but is expected to be 'void' or 'any'."),
        A_type_referenced_in_a_decorated_signature_must_be_imported_with_import_type_or_a_namespace_import_when_isolatedModules_and_emitDecoratorMetadata_are_enabled: diag(1272, ts.DiagnosticCategory.Error, "A_type_referenced_in_a_decorated_signature_must_be_imported_with_import_type_or_a_namespace_import_w_1272", "A type referenced in a decorated signature must be imported with 'import type' or a namespace import when 'isolatedModules' and 'emitDecoratorMetadata' are enabled."),
        _0_modifier_cannot_appear_on_a_type_parameter: diag(1273, ts.DiagnosticCategory.Error, "_0_modifier_cannot_appear_on_a_type_parameter_1273", "'{0}' modifier cannot appear on a type parameter"),
        _0_modifier_can_only_appear_on_a_type_parameter_of_a_class_interface_or_type_alias: diag(1274, ts.DiagnosticCategory.Error, "_0_modifier_can_only_appear_on_a_type_parameter_of_a_class_interface_or_type_alias_1274", "'{0}' modifier can only appear on a type parameter of a class, interface or type alias"),
        with_statements_are_not_allowed_in_an_async_function_block: diag(1300, ts.DiagnosticCategory.Error, "with_statements_are_not_allowed_in_an_async_function_block_1300", "'with' statements are not allowed in an async function block."),
        await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules: diag(1308, ts.DiagnosticCategory.Error, "await_expressions_are_only_allowed_within_async_functions_and_at_the_top_levels_of_modules_1308", "'await' expressions are only allowed within async functions and at the top levels of modules."),
        The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level: diag(1309, ts.DiagnosticCategory.Error, "The_current_file_is_a_CommonJS_module_and_cannot_use_await_at_the_top_level_1309", "The current file is a CommonJS module and cannot use 'await' at the top level."),
        Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_part_of_a_destructuring_pattern: diag(1312, ts.DiagnosticCategory.Error, "Did_you_mean_to_use_a_Colon_An_can_only_follow_a_property_name_when_the_containing_object_literal_is_1312", "Did you mean to use a ':'? An '=' can only follow a property name when the containing object literal is part of a destructuring pattern."),
        The_body_of_an_if_statement_cannot_be_the_empty_statement: diag(1313, ts.DiagnosticCategory.Error, "The_body_of_an_if_statement_cannot_be_the_empty_statement_1313", "The body of an 'if' statement cannot be the empty statement."),
        Global_module_exports_may_only_appear_in_module_files: diag(1314, ts.DiagnosticCategory.Error, "Global_module_exports_may_only_appear_in_module_files_1314", "Global module exports may only appear in module files."),
        Global_module_exports_may_only_appear_in_declaration_files: diag(1315, ts.DiagnosticCategory.Error, "Global_module_exports_may_only_appear_in_declaration_files_1315", "Global module exports may only appear in declaration files."),
        Global_module_exports_may_only_appear_at_top_level: diag(1316, ts.DiagnosticCategory.Error, "Global_module_exports_may_only_appear_at_top_level_1316", "Global module exports may only appear at top level."),
        A_parameter_property_cannot_be_declared_using_a_rest_parameter: diag(1317, ts.DiagnosticCategory.Error, "A_parameter_property_cannot_be_declared_using_a_rest_parameter_1317", "A parameter property cannot be declared using a rest parameter."),
        An_abstract_accessor_cannot_have_an_implementation: diag(1318, ts.DiagnosticCategory.Error, "An_abstract_accessor_cannot_have_an_implementation_1318", "An abstract accessor cannot have an implementation."),
        A_default_export_can_only_be_used_in_an_ECMAScript_style_module: diag(1319, ts.DiagnosticCategory.Error, "A_default_export_can_only_be_used_in_an_ECMAScript_style_module_1319", "A default export can only be used in an ECMAScript-style module."),
        Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: diag(1320, ts.DiagnosticCategory.Error, "Type_of_await_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member_1320", "Type of 'await' operand must either be a valid promise or must not contain a callable 'then' member."),
        Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: diag(1321, ts.DiagnosticCategory.Error, "Type_of_yield_operand_in_an_async_generator_must_either_be_a_valid_promise_or_must_not_contain_a_cal_1321", "Type of 'yield' operand in an async generator must either be a valid promise or must not contain a callable 'then' member."),
        Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_contain_a_callable_then_member: diag(1322, ts.DiagnosticCategory.Error, "Type_of_iterated_elements_of_a_yield_Asterisk_operand_must_either_be_a_valid_promise_or_must_not_con_1322", "Type of iterated elements of a 'yield*' operand must either be a valid promise or must not contain a callable 'then' member."),
        Dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_es2022_esnext_commonjs_amd_system_umd_node16_or_nodenext: diag(1323, ts.DiagnosticCategory.Error, "Dynamic_imports_are_only_supported_when_the_module_flag_is_set_to_es2020_es2022_esnext_commonjs_amd__1323", "Dynamic imports are only supported when the '--module' flag is set to 'es2020', 'es2022', 'esnext', 'commonjs', 'amd', 'system', 'umd', 'node16', or 'nodenext'."),
        Dynamic_imports_only_support_a_second_argument_when_the_module_option_is_set_to_esnext_node16_or_nodenext: diag(1324, ts.DiagnosticCategory.Error, "Dynamic_imports_only_support_a_second_argument_when_the_module_option_is_set_to_esnext_node16_or_nod_1324", "Dynamic imports only support a second argument when the '--module' option is set to 'esnext', 'node16', or 'nodenext'."),
        Argument_of_dynamic_import_cannot_be_spread_element: diag(1325, ts.DiagnosticCategory.Error, "Argument_of_dynamic_import_cannot_be_spread_element_1325", "Argument of dynamic import cannot be spread element."),
        This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot_have_type_arguments: diag(1326, ts.DiagnosticCategory.Error, "This_use_of_import_is_invalid_import_calls_can_be_written_but_they_must_have_parentheses_and_cannot__1326", "This use of 'import' is invalid. 'import()' calls can be written, but they must have parentheses and cannot have type arguments."),
        String_literal_with_double_quotes_expected: diag(1327, ts.DiagnosticCategory.Error, "String_literal_with_double_quotes_expected_1327", "String literal with double quotes expected."),
        Property_value_can_only_be_string_literal_numeric_literal_true_false_null_object_literal_or_array_literal: diag(1328, ts.DiagnosticCategory.Error, "Property_value_can_only_be_string_literal_numeric_literal_true_false_null_object_literal_or_array_li_1328", "Property value can only be string literal, numeric literal, 'true', 'false', 'null', object literal or array literal."),
        _0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write_0: diag(1329, ts.DiagnosticCategory.Error, "_0_accepts_too_few_arguments_to_be_used_as_a_decorator_here_Did_you_mean_to_call_it_first_and_write__1329", "'{0}' accepts too few arguments to be used as a decorator here. Did you mean to call it first and write '@{0}()'?"),
        A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly: diag(1330, ts.DiagnosticCategory.Error, "A_property_of_an_interface_or_type_literal_whose_type_is_a_unique_symbol_type_must_be_readonly_1330", "A property of an interface or type literal whose type is a 'unique symbol' type must be 'readonly'."),
        A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly: diag(1331, ts.DiagnosticCategory.Error, "A_property_of_a_class_whose_type_is_a_unique_symbol_type_must_be_both_static_and_readonly_1331", "A property of a class whose type is a 'unique symbol' type must be both 'static' and 'readonly'."),
        A_variable_whose_type_is_a_unique_symbol_type_must_be_const: diag(1332, ts.DiagnosticCategory.Error, "A_variable_whose_type_is_a_unique_symbol_type_must_be_const_1332", "A variable whose type is a 'unique symbol' type must be 'const'."),
        unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name: diag(1333, ts.DiagnosticCategory.Error, "unique_symbol_types_may_not_be_used_on_a_variable_declaration_with_a_binding_name_1333", "'unique symbol' types may not be used on a variable declaration with a binding name."),
        unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement: diag(1334, ts.DiagnosticCategory.Error, "unique_symbol_types_are_only_allowed_on_variables_in_a_variable_statement_1334", "'unique symbol' types are only allowed on variables in a variable statement."),
        unique_symbol_types_are_not_allowed_here: diag(1335, ts.DiagnosticCategory.Error, "unique_symbol_types_are_not_allowed_here_1335", "'unique symbol' types are not allowed here."),
        An_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_Consider_using_a_mapped_object_type_instead: diag(1337, ts.DiagnosticCategory.Error, "An_index_signature_parameter_type_cannot_be_a_literal_type_or_generic_type_Consider_using_a_mapped_o_1337", "An index signature parameter type cannot be a literal type or generic type. Consider using a mapped object type instead."),
        infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type: diag(1338, ts.DiagnosticCategory.Error, "infer_declarations_are_only_permitted_in_the_extends_clause_of_a_conditional_type_1338", "'infer' declarations are only permitted in the 'extends' clause of a conditional type."),
        Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here: diag(1339, ts.DiagnosticCategory.Error, "Module_0_does_not_refer_to_a_value_but_is_used_as_a_value_here_1339", "Module '{0}' does not refer to a value, but is used as a value here."),
        Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0: diag(1340, ts.DiagnosticCategory.Error, "Module_0_does_not_refer_to_a_type_but_is_used_as_a_type_here_Did_you_mean_typeof_import_0_1340", "Module '{0}' does not refer to a type, but is used as a type here. Did you mean 'typeof import('{0}')'?"),
        Class_constructor_may_not_be_an_accessor: diag(1341, ts.DiagnosticCategory.Error, "Class_constructor_may_not_be_an_accessor_1341", "Class constructor may not be an accessor."),
        Type_arguments_cannot_be_used_here: diag(1342, ts.DiagnosticCategory.Error, "Type_arguments_cannot_be_used_here_1342", "Type arguments cannot be used here."),
        The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_es2020_es2022_esnext_system_node16_or_nodenext: diag(1343, ts.DiagnosticCategory.Error, "The_import_meta_meta_property_is_only_allowed_when_the_module_option_is_es2020_es2022_esnext_system__1343", "The 'import.meta' meta-property is only allowed when the '--module' option is 'es2020', 'es2022', 'esnext', 'system', 'node16', or 'nodenext'."),
        A_label_is_not_allowed_here: diag(1344, ts.DiagnosticCategory.Error, "A_label_is_not_allowed_here_1344", "'A label is not allowed here."),
        An_expression_of_type_void_cannot_be_tested_for_truthiness: diag(1345, ts.DiagnosticCategory.Error, "An_expression_of_type_void_cannot_be_tested_for_truthiness_1345", "An expression of type 'void' cannot be tested for truthiness."),
        This_parameter_is_not_allowed_with_use_strict_directive: diag(1346, ts.DiagnosticCategory.Error, "This_parameter_is_not_allowed_with_use_strict_directive_1346", "This parameter is not allowed with 'use strict' directive."),
        use_strict_directive_cannot_be_used_with_non_simple_parameter_list: diag(1347, ts.DiagnosticCategory.Error, "use_strict_directive_cannot_be_used_with_non_simple_parameter_list_1347", "'use strict' directive cannot be used with non-simple parameter list."),
        Non_simple_parameter_declared_here: diag(1348, ts.DiagnosticCategory.Error, "Non_simple_parameter_declared_here_1348", "Non-simple parameter declared here."),
        use_strict_directive_used_here: diag(1349, ts.DiagnosticCategory.Error, "use_strict_directive_used_here_1349", "'use strict' directive used here."),
        Print_the_final_configuration_instead_of_building: diag(1350, ts.DiagnosticCategory.Message, "Print_the_final_configuration_instead_of_building_1350", "Print the final configuration instead of building."),
        An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal: diag(1351, ts.DiagnosticCategory.Error, "An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal_1351", "An identifier or keyword cannot immediately follow a numeric literal."),
        A_bigint_literal_cannot_use_exponential_notation: diag(1352, ts.DiagnosticCategory.Error, "A_bigint_literal_cannot_use_exponential_notation_1352", "A bigint literal cannot use exponential notation."),
        A_bigint_literal_must_be_an_integer: diag(1353, ts.DiagnosticCategory.Error, "A_bigint_literal_must_be_an_integer_1353", "A bigint literal must be an integer."),
        readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types: diag(1354, ts.DiagnosticCategory.Error, "readonly_type_modifier_is_only_permitted_on_array_and_tuple_literal_types_1354", "'readonly' type modifier is only permitted on array and tuple literal types."),
        A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array_or_object_literals: diag(1355, ts.DiagnosticCategory.Error, "A_const_assertions_can_only_be_applied_to_references_to_enum_members_or_string_number_boolean_array__1355", "A 'const' assertions can only be applied to references to enum members, or string, number, boolean, array, or object literals."),
        Did_you_mean_to_mark_this_function_as_async: diag(1356, ts.DiagnosticCategory.Error, "Did_you_mean_to_mark_this_function_as_async_1356", "Did you mean to mark this function as 'async'?"),
        An_enum_member_name_must_be_followed_by_a_or: diag(1357, ts.DiagnosticCategory.Error, "An_enum_member_name_must_be_followed_by_a_or_1357", "An enum member name must be followed by a ',', '=', or '}'."),
        Tagged_template_expressions_are_not_permitted_in_an_optional_chain: diag(1358, ts.DiagnosticCategory.Error, "Tagged_template_expressions_are_not_permitted_in_an_optional_chain_1358", "Tagged template expressions are not permitted in an optional chain."),
        Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here: diag(1359, ts.DiagnosticCategory.Error, "Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here_1359", "Identifier expected. '{0}' is a reserved word that cannot be used here."),
        Class_constructor_may_not_be_a_generator: diag(1360, ts.DiagnosticCategory.Error, "Class_constructor_may_not_be_a_generator_1360", "Class constructor may not be a generator."),
        _0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type: diag(1361, ts.DiagnosticCategory.Error, "_0_cannot_be_used_as_a_value_because_it_was_imported_using_import_type_1361", "'{0}' cannot be used as a value because it was imported using 'import type'."),
        _0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type: diag(1362, ts.DiagnosticCategory.Error, "_0_cannot_be_used_as_a_value_because_it_was_exported_using_export_type_1362", "'{0}' cannot be used as a value because it was exported using 'export type'."),
        A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both: diag(1363, ts.DiagnosticCategory.Error, "A_type_only_import_can_specify_a_default_import_or_named_bindings_but_not_both_1363", "A type-only import can specify a default import or named bindings, but not both."),
        Convert_to_type_only_export: diag(1364, ts.DiagnosticCategory.Message, "Convert_to_type_only_export_1364", "Convert to type-only export"),
        Convert_all_re_exported_types_to_type_only_exports: diag(1365, ts.DiagnosticCategory.Message, "Convert_all_re_exported_types_to_type_only_exports_1365", "Convert all re-exported types to type-only exports"),
        Split_into_two_separate_import_declarations: diag(1366, ts.DiagnosticCategory.Message, "Split_into_two_separate_import_declarations_1366", "Split into two separate import declarations"),
        Split_all_invalid_type_only_imports: diag(1367, ts.DiagnosticCategory.Message, "Split_all_invalid_type_only_imports_1367", "Split all invalid type-only imports"),
        Did_you_mean_0: diag(1369, ts.DiagnosticCategory.Message, "Did_you_mean_0_1369", "Did you mean '{0}'?"),
        This_import_is_never_used_as_a_value_and_must_use_import_type_because_importsNotUsedAsValues_is_set_to_error: diag(1371, ts.DiagnosticCategory.Error, "This_import_is_never_used_as_a_value_and_must_use_import_type_because_importsNotUsedAsValues_is_set__1371", "This import is never used as a value and must use 'import type' because 'importsNotUsedAsValues' is set to 'error'."),
        Convert_to_type_only_import: diag(1373, ts.DiagnosticCategory.Message, "Convert_to_type_only_import_1373", "Convert to type-only import"),
        Convert_all_imports_not_used_as_a_value_to_type_only_imports: diag(1374, ts.DiagnosticCategory.Message, "Convert_all_imports_not_used_as_a_value_to_type_only_imports_1374", "Convert all imports not used as a value to type-only imports"),
        await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module: diag(1375, ts.DiagnosticCategory.Error, "await_expressions_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_fi_1375", "'await' expressions are only allowed at the top level of a file when that file is a module, but this file has no imports or exports. Consider adding an empty 'export {}' to make this file a module."),
        _0_was_imported_here: diag(1376, ts.DiagnosticCategory.Message, "_0_was_imported_here_1376", "'{0}' was imported here."),
        _0_was_exported_here: diag(1377, ts.DiagnosticCategory.Message, "_0_was_exported_here_1377", "'{0}' was exported here."),
        Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_or_nodenext_and_the_target_option_is_set_to_es2017_or_higher: diag(1378, ts.DiagnosticCategory.Error, "Top_level_await_expressions_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_n_1378", "Top-level 'await' expressions are only allowed when the 'module' option is set to 'es2022', 'esnext', 'system', 'node16', or 'nodenext', and the 'target' option is set to 'es2017' or higher."),
        An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type: diag(1379, ts.DiagnosticCategory.Error, "An_import_alias_cannot_reference_a_declaration_that_was_exported_using_export_type_1379", "An import alias cannot reference a declaration that was exported using 'export type'."),
        An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type: diag(1380, ts.DiagnosticCategory.Error, "An_import_alias_cannot_reference_a_declaration_that_was_imported_using_import_type_1380", "An import alias cannot reference a declaration that was imported using 'import type'."),
        Unexpected_token_Did_you_mean_or_rbrace: diag(1381, ts.DiagnosticCategory.Error, "Unexpected_token_Did_you_mean_or_rbrace_1381", "Unexpected token. Did you mean `{'}'}` or `&rbrace;`?"),
        Unexpected_token_Did_you_mean_or_gt: diag(1382, ts.DiagnosticCategory.Error, "Unexpected_token_Did_you_mean_or_gt_1382", "Unexpected token. Did you mean `{'>'}` or `&gt;`?"),
        Only_named_exports_may_use_export_type: diag(1383, ts.DiagnosticCategory.Error, "Only_named_exports_may_use_export_type_1383", "Only named exports may use 'export type'."),
        Function_type_notation_must_be_parenthesized_when_used_in_a_union_type: diag(1385, ts.DiagnosticCategory.Error, "Function_type_notation_must_be_parenthesized_when_used_in_a_union_type_1385", "Function type notation must be parenthesized when used in a union type."),
        Constructor_type_notation_must_be_parenthesized_when_used_in_a_union_type: diag(1386, ts.DiagnosticCategory.Error, "Constructor_type_notation_must_be_parenthesized_when_used_in_a_union_type_1386", "Constructor type notation must be parenthesized when used in a union type."),
        Function_type_notation_must_be_parenthesized_when_used_in_an_intersection_type: diag(1387, ts.DiagnosticCategory.Error, "Function_type_notation_must_be_parenthesized_when_used_in_an_intersection_type_1387", "Function type notation must be parenthesized when used in an intersection type."),
        Constructor_type_notation_must_be_parenthesized_when_used_in_an_intersection_type: diag(1388, ts.DiagnosticCategory.Error, "Constructor_type_notation_must_be_parenthesized_when_used_in_an_intersection_type_1388", "Constructor type notation must be parenthesized when used in an intersection type."),
        _0_is_not_allowed_as_a_variable_declaration_name: diag(1389, ts.DiagnosticCategory.Error, "_0_is_not_allowed_as_a_variable_declaration_name_1389", "'{0}' is not allowed as a variable declaration name."),
        _0_is_not_allowed_as_a_parameter_name: diag(1390, ts.DiagnosticCategory.Error, "_0_is_not_allowed_as_a_parameter_name_1390", "'{0}' is not allowed as a parameter name."),
        An_import_alias_cannot_use_import_type: diag(1392, ts.DiagnosticCategory.Error, "An_import_alias_cannot_use_import_type_1392", "An import alias cannot use 'import type'"),
        Imported_via_0_from_file_1: diag(1393, ts.DiagnosticCategory.Message, "Imported_via_0_from_file_1_1393", "Imported via {0} from file '{1}'"),
        Imported_via_0_from_file_1_with_packageId_2: diag(1394, ts.DiagnosticCategory.Message, "Imported_via_0_from_file_1_with_packageId_2_1394", "Imported via {0} from file '{1}' with packageId '{2}'"),
        Imported_via_0_from_file_1_to_import_importHelpers_as_specified_in_compilerOptions: diag(1395, ts.DiagnosticCategory.Message, "Imported_via_0_from_file_1_to_import_importHelpers_as_specified_in_compilerOptions_1395", "Imported via {0} from file '{1}' to import 'importHelpers' as specified in compilerOptions"),
        Imported_via_0_from_file_1_with_packageId_2_to_import_importHelpers_as_specified_in_compilerOptions: diag(1396, ts.DiagnosticCategory.Message, "Imported_via_0_from_file_1_with_packageId_2_to_import_importHelpers_as_specified_in_compilerOptions_1396", "Imported via {0} from file '{1}' with packageId '{2}' to import 'importHelpers' as specified in compilerOptions"),
        Imported_via_0_from_file_1_to_import_jsx_and_jsxs_factory_functions: diag(1397, ts.DiagnosticCategory.Message, "Imported_via_0_from_file_1_to_import_jsx_and_jsxs_factory_functions_1397", "Imported via {0} from file '{1}' to import 'jsx' and 'jsxs' factory functions"),
        Imported_via_0_from_file_1_with_packageId_2_to_import_jsx_and_jsxs_factory_functions: diag(1398, ts.DiagnosticCategory.Message, "Imported_via_0_from_file_1_with_packageId_2_to_import_jsx_and_jsxs_factory_functions_1398", "Imported via {0} from file '{1}' with packageId '{2}' to import 'jsx' and 'jsxs' factory functions"),
        File_is_included_via_import_here: diag(1399, ts.DiagnosticCategory.Message, "File_is_included_via_import_here_1399", "File is included via import here."),
        Referenced_via_0_from_file_1: diag(1400, ts.DiagnosticCategory.Message, "Referenced_via_0_from_file_1_1400", "Referenced via '{0}' from file '{1}'"),
        File_is_included_via_reference_here: diag(1401, ts.DiagnosticCategory.Message, "File_is_included_via_reference_here_1401", "File is included via reference here."),
        Type_library_referenced_via_0_from_file_1: diag(1402, ts.DiagnosticCategory.Message, "Type_library_referenced_via_0_from_file_1_1402", "Type library referenced via '{0}' from file '{1}'"),
        Type_library_referenced_via_0_from_file_1_with_packageId_2: diag(1403, ts.DiagnosticCategory.Message, "Type_library_referenced_via_0_from_file_1_with_packageId_2_1403", "Type library referenced via '{0}' from file '{1}' with packageId '{2}'"),
        File_is_included_via_type_library_reference_here: diag(1404, ts.DiagnosticCategory.Message, "File_is_included_via_type_library_reference_here_1404", "File is included via type library reference here."),
        Library_referenced_via_0_from_file_1: diag(1405, ts.DiagnosticCategory.Message, "Library_referenced_via_0_from_file_1_1405", "Library referenced via '{0}' from file '{1}'"),
        File_is_included_via_library_reference_here: diag(1406, ts.DiagnosticCategory.Message, "File_is_included_via_library_reference_here_1406", "File is included via library reference here."),
        Matched_by_include_pattern_0_in_1: diag(1407, ts.DiagnosticCategory.Message, "Matched_by_include_pattern_0_in_1_1407", "Matched by include pattern '{0}' in '{1}'"),
        File_is_matched_by_include_pattern_specified_here: diag(1408, ts.DiagnosticCategory.Message, "File_is_matched_by_include_pattern_specified_here_1408", "File is matched by include pattern specified here."),
        Part_of_files_list_in_tsconfig_json: diag(1409, ts.DiagnosticCategory.Message, "Part_of_files_list_in_tsconfig_json_1409", "Part of 'files' list in tsconfig.json"),
        File_is_matched_by_files_list_specified_here: diag(1410, ts.DiagnosticCategory.Message, "File_is_matched_by_files_list_specified_here_1410", "File is matched by 'files' list specified here."),
        Output_from_referenced_project_0_included_because_1_specified: diag(1411, ts.DiagnosticCategory.Message, "Output_from_referenced_project_0_included_because_1_specified_1411", "Output from referenced project '{0}' included because '{1}' specified"),
        Output_from_referenced_project_0_included_because_module_is_specified_as_none: diag(1412, ts.DiagnosticCategory.Message, "Output_from_referenced_project_0_included_because_module_is_specified_as_none_1412", "Output from referenced project '{0}' included because '--module' is specified as 'none'"),
        File_is_output_from_referenced_project_specified_here: diag(1413, ts.DiagnosticCategory.Message, "File_is_output_from_referenced_project_specified_here_1413", "File is output from referenced project specified here."),
        Source_from_referenced_project_0_included_because_1_specified: diag(1414, ts.DiagnosticCategory.Message, "Source_from_referenced_project_0_included_because_1_specified_1414", "Source from referenced project '{0}' included because '{1}' specified"),
        Source_from_referenced_project_0_included_because_module_is_specified_as_none: diag(1415, ts.DiagnosticCategory.Message, "Source_from_referenced_project_0_included_because_module_is_specified_as_none_1415", "Source from referenced project '{0}' included because '--module' is specified as 'none'"),
        File_is_source_from_referenced_project_specified_here: diag(1416, ts.DiagnosticCategory.Message, "File_is_source_from_referenced_project_specified_here_1416", "File is source from referenced project specified here."),
        Entry_point_of_type_library_0_specified_in_compilerOptions: diag(1417, ts.DiagnosticCategory.Message, "Entry_point_of_type_library_0_specified_in_compilerOptions_1417", "Entry point of type library '{0}' specified in compilerOptions"),
        Entry_point_of_type_library_0_specified_in_compilerOptions_with_packageId_1: diag(1418, ts.DiagnosticCategory.Message, "Entry_point_of_type_library_0_specified_in_compilerOptions_with_packageId_1_1418", "Entry point of type library '{0}' specified in compilerOptions with packageId '{1}'"),
        File_is_entry_point_of_type_library_specified_here: diag(1419, ts.DiagnosticCategory.Message, "File_is_entry_point_of_type_library_specified_here_1419", "File is entry point of type library specified here."),
        Entry_point_for_implicit_type_library_0: diag(1420, ts.DiagnosticCategory.Message, "Entry_point_for_implicit_type_library_0_1420", "Entry point for implicit type library '{0}'"),
        Entry_point_for_implicit_type_library_0_with_packageId_1: diag(1421, ts.DiagnosticCategory.Message, "Entry_point_for_implicit_type_library_0_with_packageId_1_1421", "Entry point for implicit type library '{0}' with packageId '{1}'"),
        Library_0_specified_in_compilerOptions: diag(1422, ts.DiagnosticCategory.Message, "Library_0_specified_in_compilerOptions_1422", "Library '{0}' specified in compilerOptions"),
        File_is_library_specified_here: diag(1423, ts.DiagnosticCategory.Message, "File_is_library_specified_here_1423", "File is library specified here."),
        Default_library: diag(1424, ts.DiagnosticCategory.Message, "Default_library_1424", "Default library"),
        Default_library_for_target_0: diag(1425, ts.DiagnosticCategory.Message, "Default_library_for_target_0_1425", "Default library for target '{0}'"),
        File_is_default_library_for_target_specified_here: diag(1426, ts.DiagnosticCategory.Message, "File_is_default_library_for_target_specified_here_1426", "File is default library for target specified here."),
        Root_file_specified_for_compilation: diag(1427, ts.DiagnosticCategory.Message, "Root_file_specified_for_compilation_1427", "Root file specified for compilation"),
        File_is_output_of_project_reference_source_0: diag(1428, ts.DiagnosticCategory.Message, "File_is_output_of_project_reference_source_0_1428", "File is output of project reference source '{0}'"),
        File_redirects_to_file_0: diag(1429, ts.DiagnosticCategory.Message, "File_redirects_to_file_0_1429", "File redirects to file '{0}'"),
        The_file_is_in_the_program_because_Colon: diag(1430, ts.DiagnosticCategory.Message, "The_file_is_in_the_program_because_Colon_1430", "The file is in the program because:"),
        for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_has_no_imports_or_exports_Consider_adding_an_empty_export_to_make_this_file_a_module: diag(1431, ts.DiagnosticCategory.Error, "for_await_loops_are_only_allowed_at_the_top_level_of_a_file_when_that_file_is_a_module_but_this_file_1431", "'for await' loops are only allowed at the top level of a file when that file is a module, but this file has no imports or exports. Consider adding an empty 'export {}' to make this file a module."),
        Top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_node16_or_nodenext_and_the_target_option_is_set_to_es2017_or_higher: diag(1432, ts.DiagnosticCategory.Error, "Top_level_for_await_loops_are_only_allowed_when_the_module_option_is_set_to_es2022_esnext_system_nod_1432", "Top-level 'for await' loops are only allowed when the 'module' option is set to 'es2022', 'esnext', 'system', 'node16', or 'nodenext', and the 'target' option is set to 'es2017' or higher."),
        Decorators_may_not_be_applied_to_this_parameters: diag(1433, ts.DiagnosticCategory.Error, "Decorators_may_not_be_applied_to_this_parameters_1433", "Decorators may not be applied to 'this' parameters."),
        Unexpected_keyword_or_identifier: diag(1434, ts.DiagnosticCategory.Error, "Unexpected_keyword_or_identifier_1434", "Unexpected keyword or identifier."),
        Unknown_keyword_or_identifier_Did_you_mean_0: diag(1435, ts.DiagnosticCategory.Error, "Unknown_keyword_or_identifier_Did_you_mean_0_1435", "Unknown keyword or identifier. Did you mean '{0}'?"),
        Decorators_must_precede_the_name_and_all_keywords_of_property_declarations: diag(1436, ts.DiagnosticCategory.Error, "Decorators_must_precede_the_name_and_all_keywords_of_property_declarations_1436", "Decorators must precede the name and all keywords of property declarations."),
        Namespace_must_be_given_a_name: diag(1437, ts.DiagnosticCategory.Error, "Namespace_must_be_given_a_name_1437", "Namespace must be given a name."),
        Interface_must_be_given_a_name: diag(1438, ts.DiagnosticCategory.Error, "Interface_must_be_given_a_name_1438", "Interface must be given a name."),
        Type_alias_must_be_given_a_name: diag(1439, ts.DiagnosticCategory.Error, "Type_alias_must_be_given_a_name_1439", "Type alias must be given a name."),
        Variable_declaration_not_allowed_at_this_location: diag(1440, ts.DiagnosticCategory.Error, "Variable_declaration_not_allowed_at_this_location_1440", "Variable declaration not allowed at this location."),
        Cannot_start_a_function_call_in_a_type_annotation: diag(1441, ts.DiagnosticCategory.Error, "Cannot_start_a_function_call_in_a_type_annotation_1441", "Cannot start a function call in a type annotation."),
        Expected_for_property_initializer: diag(1442, ts.DiagnosticCategory.Error, "Expected_for_property_initializer_1442", "Expected '=' for property initializer."),
        Module_declaration_names_may_only_use_or_quoted_strings: diag(1443, ts.DiagnosticCategory.Error, "Module_declaration_names_may_only_use_or_quoted_strings_1443", "Module declaration names may only use ' or \" quoted strings."),
        _0_is_a_type_and_must_be_imported_using_a_type_only_import_when_preserveValueImports_and_isolatedModules_are_both_enabled: diag(1444, ts.DiagnosticCategory.Error, "_0_is_a_type_and_must_be_imported_using_a_type_only_import_when_preserveValueImports_and_isolatedMod_1444", "'{0}' is a type and must be imported using a type-only import when 'preserveValueImports' and 'isolatedModules' are both enabled."),
        _0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_preserveValueImports_and_isolatedModules_are_both_enabled: diag(1446, ts.DiagnosticCategory.Error, "_0_resolves_to_a_type_only_declaration_and_must_be_imported_using_a_type_only_import_when_preserveVa_1446", "'{0}' resolves to a type-only declaration and must be imported using a type-only import when 'preserveValueImports' and 'isolatedModules' are both enabled."),
        _0_resolves_to_a_type_only_declaration_and_must_be_re_exported_using_a_type_only_re_export_when_isolatedModules_is_enabled: diag(1448, ts.DiagnosticCategory.Error, "_0_resolves_to_a_type_only_declaration_and_must_be_re_exported_using_a_type_only_re_export_when_isol_1448", "'{0}' resolves to a type-only declaration and must be re-exported using a type-only re-export when 'isolatedModules' is enabled."),
        Preserve_unused_imported_values_in_the_JavaScript_output_that_would_otherwise_be_removed: diag(1449, ts.DiagnosticCategory.Message, "Preserve_unused_imported_values_in_the_JavaScript_output_that_would_otherwise_be_removed_1449", "Preserve unused imported values in the JavaScript output that would otherwise be removed."),
        Dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_assertion_as_arguments: diag(1450, ts.DiagnosticCategory.Message, "Dynamic_imports_can_only_accept_a_module_specifier_and_an_optional_assertion_as_arguments_1450", "Dynamic imports can only accept a module specifier and an optional assertion as arguments"),
        Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member_declaration_property_access_or_on_the_left_hand_side_of_an_in_expression: diag(1451, ts.DiagnosticCategory.Error, "Private_identifiers_are_only_allowed_in_class_bodies_and_may_only_be_used_as_part_of_a_class_member__1451", "Private identifiers are only allowed in class bodies and may only be used as part of a class member declaration, property access, or on the left-hand-side of an 'in' expression"),
        resolution_mode_assertions_are_only_supported_when_moduleResolution_is_node16_or_nodenext: diag(1452, ts.DiagnosticCategory.Error, "resolution_mode_assertions_are_only_supported_when_moduleResolution_is_node16_or_nodenext_1452", "'resolution-mode' assertions are only supported when `moduleResolution` is `node16` or `nodenext`."),
        resolution_mode_should_be_either_require_or_import: diag(1453, ts.DiagnosticCategory.Error, "resolution_mode_should_be_either_require_or_import_1453", "`resolution-mode` should be either `require` or `import`."),
        resolution_mode_can_only_be_set_for_type_only_imports: diag(1454, ts.DiagnosticCategory.Error, "resolution_mode_can_only_be_set_for_type_only_imports_1454", "`resolution-mode` can only be set for type-only imports."),
        resolution_mode_is_the_only_valid_key_for_type_import_assertions: diag(1455, ts.DiagnosticCategory.Error, "resolution_mode_is_the_only_valid_key_for_type_import_assertions_1455", "`resolution-mode` is the only valid key for type import assertions."),
        Type_import_assertions_should_have_exactly_one_key_resolution_mode_with_value_import_or_require: diag(1456, ts.DiagnosticCategory.Error, "Type_import_assertions_should_have_exactly_one_key_resolution_mode_with_value_import_or_require_1456", "Type import assertions should have exactly one key - `resolution-mode` - with value `import` or `require`."),
        Matched_by_default_include_pattern_Asterisk_Asterisk_Slash_Asterisk: diag(1457, ts.DiagnosticCategory.Message, "Matched_by_default_include_pattern_Asterisk_Asterisk_Slash_Asterisk_1457", "Matched by default include pattern '**/*'"),
        File_is_ECMAScript_module_because_0_has_field_type_with_value_module: diag(1458, ts.DiagnosticCategory.Message, "File_is_ECMAScript_module_because_0_has_field_type_with_value_module_1458", "File is ECMAScript module because '{0}' has field \"type\" with value \"module\""),
        File_is_CommonJS_module_because_0_has_field_type_whose_value_is_not_module: diag(1459, ts.DiagnosticCategory.Message, "File_is_CommonJS_module_because_0_has_field_type_whose_value_is_not_module_1459", "File is CommonJS module because '{0}' has field \"type\" whose value is not \"module\""),
        File_is_CommonJS_module_because_0_does_not_have_field_type: diag(1460, ts.DiagnosticCategory.Message, "File_is_CommonJS_module_because_0_does_not_have_field_type_1460", "File is CommonJS module because '{0}' does not have field \"type\""),
        File_is_CommonJS_module_because_package_json_was_not_found: diag(1461, ts.DiagnosticCategory.Message, "File_is_CommonJS_module_because_package_json_was_not_found_1461", "File is CommonJS module because 'package.json' was not found"),
        The_import_meta_meta_property_is_not_allowed_in_files_which_will_build_into_CommonJS_output: diag(1470, ts.DiagnosticCategory.Error, "The_import_meta_meta_property_is_not_allowed_in_files_which_will_build_into_CommonJS_output_1470", "The 'import.meta' meta-property is not allowed in files which will build into CommonJS output."),
        Module_0_cannot_be_imported_using_this_construct_The_specifier_only_resolves_to_an_ES_module_which_cannot_be_imported_with_require_Use_an_ECMAScript_import_instead: diag(1471, ts.DiagnosticCategory.Error, "Module_0_cannot_be_imported_using_this_construct_The_specifier_only_resolves_to_an_ES_module_which_c_1471", "Module '{0}' cannot be imported using this construct. The specifier only resolves to an ES module, which cannot be imported with 'require'. Use an ECMAScript import instead."),
        catch_or_finally_expected: diag(1472, ts.DiagnosticCategory.Error, "catch_or_finally_expected_1472", "'catch' or 'finally' expected."),
        An_import_declaration_can_only_be_used_at_the_top_level_of_a_module: diag(1473, ts.DiagnosticCategory.Error, "An_import_declaration_can_only_be_used_at_the_top_level_of_a_module_1473", "An import declaration can only be used at the top level of a module."),
        An_export_declaration_can_only_be_used_at_the_top_level_of_a_module: diag(1474, ts.DiagnosticCategory.Error, "An_export_declaration_can_only_be_used_at_the_top_level_of_a_module_1474", "An export declaration can only be used at the top level of a module."),
        Control_what_method_is_used_to_detect_module_format_JS_files: diag(1475, ts.DiagnosticCategory.Message, "Control_what_method_is_used_to_detect_module_format_JS_files_1475", "Control what method is used to detect module-format JS files."),
        auto_Colon_Treat_files_with_imports_exports_import_meta_jsx_with_jsx_Colon_react_jsx_or_esm_format_with_module_Colon_node16_as_modules: diag(1476, ts.DiagnosticCategory.Message, "auto_Colon_Treat_files_with_imports_exports_import_meta_jsx_with_jsx_Colon_react_jsx_or_esm_format_w_1476", "\"auto\": Treat files with imports, exports, import.meta, jsx (with jsx: react-jsx), or esm format (with module: node16+) as modules."),
        An_instantiation_expression_cannot_be_followed_by_a_property_access: diag(1477, ts.DiagnosticCategory.Error, "An_instantiation_expression_cannot_be_followed_by_a_property_access_1477", "An instantiation expression cannot be followed by a property access."),
        Identifier_or_string_literal_expected: diag(1478, ts.DiagnosticCategory.Error, "Identifier_or_string_literal_expected_1478", "Identifier or string literal expected."),
        The_current_file_is_a_CommonJS_module_whose_imports_will_produce_require_calls_however_the_referenced_file_is_an_ECMAScript_module_and_cannot_be_imported_with_require_Consider_writing_a_dynamic_import_0_call_instead: diag(1479, ts.DiagnosticCategory.Error, "The_current_file_is_a_CommonJS_module_whose_imports_will_produce_require_calls_however_the_reference_1479", "The current file is a CommonJS module whose imports will produce 'require' calls; however, the referenced file is an ECMAScript module and cannot be imported with 'require'. Consider writing a dynamic 'import(\"{0}\")' call instead."),
        To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_create_a_local_package_json_file_with_type_Colon_module: diag(1480, ts.DiagnosticCategory.Message, "To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_create_a_local_packag_1480", "To convert this file to an ECMAScript module, change its file extension to '{0}' or create a local package.json file with `{ \"type\": \"module\" }`."),
        To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_add_the_field_type_Colon_module_to_1: diag(1481, ts.DiagnosticCategory.Message, "To_convert_this_file_to_an_ECMAScript_module_change_its_file_extension_to_0_or_add_the_field_type_Co_1481", "To convert this file to an ECMAScript module, change its file extension to '{0}', or add the field `\"type\": \"module\"` to '{1}'."),
        To_convert_this_file_to_an_ECMAScript_module_add_the_field_type_Colon_module_to_0: diag(1482, ts.DiagnosticCategory.Message, "To_convert_this_file_to_an_ECMAScript_module_add_the_field_type_Colon_module_to_0_1482", "To convert this file to an ECMAScript module, add the field `\"type\": \"module\"` to '{0}'."),
        To_convert_this_file_to_an_ECMAScript_module_create_a_local_package_json_file_with_type_Colon_module: diag(1483, ts.DiagnosticCategory.Message, "To_convert_this_file_to_an_ECMAScript_module_create_a_local_package_json_file_with_type_Colon_module_1483", "To convert this file to an ECMAScript module, create a local package.json file with `{ \"type\": \"module\" }`."),
        The_types_of_0_are_incompatible_between_these_types: diag(2200, ts.DiagnosticCategory.Error, "The_types_of_0_are_incompatible_between_these_types_2200", "The types of '{0}' are incompatible between these types."),
        The_types_returned_by_0_are_incompatible_between_these_types: diag(2201, ts.DiagnosticCategory.Error, "The_types_returned_by_0_are_incompatible_between_these_types_2201", "The types returned by '{0}' are incompatible between these types."),
        Call_signature_return_types_0_and_1_are_incompatible: diag(2202, ts.DiagnosticCategory.Error, "Call_signature_return_types_0_and_1_are_incompatible_2202", "Call signature return types '{0}' and '{1}' are incompatible.", /*reportsUnnecessary*/ undefined, /*elidedInCompatabilityPyramid*/ true),
        Construct_signature_return_types_0_and_1_are_incompatible: diag(2203, ts.DiagnosticCategory.Error, "Construct_signature_return_types_0_and_1_are_incompatible_2203", "Construct signature return types '{0}' and '{1}' are incompatible.", /*reportsUnnecessary*/ undefined, /*elidedInCompatabilityPyramid*/ true),
        Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1: diag(2204, ts.DiagnosticCategory.Error, "Call_signatures_with_no_arguments_have_incompatible_return_types_0_and_1_2204", "Call signatures with no arguments have incompatible return types '{0}' and '{1}'.", /*reportsUnnecessary*/ undefined, /*elidedInCompatabilityPyramid*/ true),
        Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1: diag(2205, ts.DiagnosticCategory.Error, "Construct_signatures_with_no_arguments_have_incompatible_return_types_0_and_1_2205", "Construct signatures with no arguments have incompatible return types '{0}' and '{1}'.", /*reportsUnnecessary*/ undefined, /*elidedInCompatabilityPyramid*/ true),
        The_type_modifier_cannot_be_used_on_a_named_import_when_import_type_is_used_on_its_import_statement: diag(2206, ts.DiagnosticCategory.Error, "The_type_modifier_cannot_be_used_on_a_named_import_when_import_type_is_used_on_its_import_statement_2206", "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement."),
        The_type_modifier_cannot_be_used_on_a_named_export_when_export_type_is_used_on_its_export_statement: diag(2207, ts.DiagnosticCategory.Error, "The_type_modifier_cannot_be_used_on_a_named_export_when_export_type_is_used_on_its_export_statement_2207", "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement."),
        This_type_parameter_might_need_an_extends_0_constraint: diag(2208, ts.DiagnosticCategory.Error, "This_type_parameter_might_need_an_extends_0_constraint_2208", "This type parameter might need an `extends {0}` constraint."),
        The_project_root_is_ambiguous_but_is_required_to_resolve_export_map_entry_0_in_file_1_Supply_the_rootDir_compiler_option_to_disambiguate: diag(2209, ts.DiagnosticCategory.Error, "The_project_root_is_ambiguous_but_is_required_to_resolve_export_map_entry_0_in_file_1_Supply_the_roo_2209", "The project root is ambiguous, but is required to resolve export map entry '{0}' in file '{1}'. Supply the `rootDir` compiler option to disambiguate."),
        The_project_root_is_ambiguous_but_is_required_to_resolve_import_map_entry_0_in_file_1_Supply_the_rootDir_compiler_option_to_disambiguate: diag(2210, ts.DiagnosticCategory.Error, "The_project_root_is_ambiguous_but_is_required_to_resolve_import_map_entry_0_in_file_1_Supply_the_roo_2210", "The project root is ambiguous, but is required to resolve import map entry '{0}' in file '{1}'. Supply the `rootDir` compiler option to disambiguate."),
        Add_extends_constraint: diag(2211, ts.DiagnosticCategory.Message, "Add_extends_constraint_2211", "Add `extends` constraint."),
        Add_extends_constraint_to_all_type_parameters: diag(2212, ts.DiagnosticCategory.Message, "Add_extends_constraint_to_all_type_parameters_2212", "Add `extends` constraint to all type parameters"),
        Duplicate_identifier_0: diag(2300, ts.DiagnosticCategory.Error, "Duplicate_identifier_0_2300", "Duplicate identifier '{0}'."),
        Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor: diag(2301, ts.DiagnosticCategory.Error, "Initializer_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor_2301", "Initializer of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor."),
        Static_members_cannot_reference_class_type_parameters: diag(2302, ts.DiagnosticCategory.Error, "Static_members_cannot_reference_class_type_parameters_2302", "Static members cannot reference class type parameters."),
        Circular_definition_of_import_alias_0: diag(2303, ts.DiagnosticCategory.Error, "Circular_definition_of_import_alias_0_2303", "Circular definition of import alias '{0}'."),
        Cannot_find_name_0: diag(2304, ts.DiagnosticCategory.Error, "Cannot_find_name_0_2304", "Cannot find name '{0}'."),
        Module_0_has_no_exported_member_1: diag(2305, ts.DiagnosticCategory.Error, "Module_0_has_no_exported_member_1_2305", "Module '{0}' has no exported member '{1}'."),
        File_0_is_not_a_module: diag(2306, ts.DiagnosticCategory.Error, "File_0_is_not_a_module_2306", "File '{0}' is not a module."),
        Cannot_find_module_0_or_its_corresponding_type_declarations: diag(2307, ts.DiagnosticCategory.Error, "Cannot_find_module_0_or_its_corresponding_type_declarations_2307", "Cannot find module '{0}' or its corresponding type declarations."),
        Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambiguity: diag(2308, ts.DiagnosticCategory.Error, "Module_0_has_already_exported_a_member_named_1_Consider_explicitly_re_exporting_to_resolve_the_ambig_2308", "Module {0} has already exported a member named '{1}'. Consider explicitly re-exporting to resolve the ambiguity."),
        An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements: diag(2309, ts.DiagnosticCategory.Error, "An_export_assignment_cannot_be_used_in_a_module_with_other_exported_elements_2309", "An export assignment cannot be used in a module with other exported elements."),
        Type_0_recursively_references_itself_as_a_base_type: diag(2310, ts.DiagnosticCategory.Error, "Type_0_recursively_references_itself_as_a_base_type_2310", "Type '{0}' recursively references itself as a base type."),
        Cannot_find_name_0_Did_you_mean_to_write_this_in_an_async_function: diag(2311, ts.DiagnosticCategory.Error, "Cannot_find_name_0_Did_you_mean_to_write_this_in_an_async_function_2311", "Cannot find name '{0}'. Did you mean to write this in an async function?"),
        An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_members: diag(2312, ts.DiagnosticCategory.Error, "An_interface_can_only_extend_an_object_type_or_intersection_of_object_types_with_statically_known_me_2312", "An interface can only extend an object type or intersection of object types with statically known members."),
        Type_parameter_0_has_a_circular_constraint: diag(2313, ts.DiagnosticCategory.Error, "Type_parameter_0_has_a_circular_constraint_2313", "Type parameter '{0}' has a circular constraint."),
        Generic_type_0_requires_1_type_argument_s: diag(2314, ts.DiagnosticCategory.Error, "Generic_type_0_requires_1_type_argument_s_2314", "Generic type '{0}' requires {1} type argument(s)."),
        Type_0_is_not_generic: diag(2315, ts.DiagnosticCategory.Error, "Type_0_is_not_generic_2315", "Type '{0}' is not generic."),
        Global_type_0_must_be_a_class_or_interface_type: diag(2316, ts.DiagnosticCategory.Error, "Global_type_0_must_be_a_class_or_interface_type_2316", "Global type '{0}' must be a class or interface type."),
        Global_type_0_must_have_1_type_parameter_s: diag(2317, ts.DiagnosticCategory.Error, "Global_type_0_must_have_1_type_parameter_s_2317", "Global type '{0}' must have {1} type parameter(s)."),
        Cannot_find_global_type_0: diag(2318, ts.DiagnosticCategory.Error, "Cannot_find_global_type_0_2318", "Cannot find global type '{0}'."),
        Named_property_0_of_types_1_and_2_are_not_identical: diag(2319, ts.DiagnosticCategory.Error, "Named_property_0_of_types_1_and_2_are_not_identical_2319", "Named property '{0}' of types '{1}' and '{2}' are not identical."),
        Interface_0_cannot_simultaneously_extend_types_1_and_2: diag(2320, ts.DiagnosticCategory.Error, "Interface_0_cannot_simultaneously_extend_types_1_and_2_2320", "Interface '{0}' cannot simultaneously extend types '{1}' and '{2}'."),
        Excessive_stack_depth_comparing_types_0_and_1: diag(2321, ts.DiagnosticCategory.Error, "Excessive_stack_depth_comparing_types_0_and_1_2321", "Excessive stack depth comparing types '{0}' and '{1}'."),
        Type_0_is_not_assignable_to_type_1: diag(2322, ts.DiagnosticCategory.Error, "Type_0_is_not_assignable_to_type_1_2322", "Type '{0}' is not assignable to type '{1}'."),
        Cannot_redeclare_exported_variable_0: diag(2323, ts.DiagnosticCategory.Error, "Cannot_redeclare_exported_variable_0_2323", "Cannot redeclare exported variable '{0}'."),
        Property_0_is_missing_in_type_1: diag(2324, ts.DiagnosticCategory.Error, "Property_0_is_missing_in_type_1_2324", "Property '{0}' is missing in type '{1}'."),
        Property_0_is_private_in_type_1_but_not_in_type_2: diag(2325, ts.DiagnosticCategory.Error, "Property_0_is_private_in_type_1_but_not_in_type_2_2325", "Property '{0}' is private in type '{1}' but not in type '{2}'."),
        Types_of_property_0_are_incompatible: diag(2326, ts.DiagnosticCategory.Error, "Types_of_property_0_are_incompatible_2326", "Types of property '{0}' are incompatible."),
        Property_0_is_optional_in_type_1_but_required_in_type_2: diag(2327, ts.DiagnosticCategory.Error, "Property_0_is_optional_in_type_1_but_required_in_type_2_2327", "Property '{0}' is optional in type '{1}' but required in type '{2}'."),
        Types_of_parameters_0_and_1_are_incompatible: diag(2328, ts.DiagnosticCategory.Error, "Types_of_parameters_0_and_1_are_incompatible_2328", "Types of parameters '{0}' and '{1}' are incompatible."),
        Index_signature_for_type_0_is_missing_in_type_1: diag(2329, ts.DiagnosticCategory.Error, "Index_signature_for_type_0_is_missing_in_type_1_2329", "Index signature for type '{0}' is missing in type '{1}'."),
        _0_and_1_index_signatures_are_incompatible: diag(2330, ts.DiagnosticCategory.Error, "_0_and_1_index_signatures_are_incompatible_2330", "'{0}' and '{1}' index signatures are incompatible."),
        this_cannot_be_referenced_in_a_module_or_namespace_body: diag(2331, ts.DiagnosticCategory.Error, "this_cannot_be_referenced_in_a_module_or_namespace_body_2331", "'this' cannot be referenced in a module or namespace body."),
        this_cannot_be_referenced_in_current_location: diag(2332, ts.DiagnosticCategory.Error, "this_cannot_be_referenced_in_current_location_2332", "'this' cannot be referenced in current location."),
        this_cannot_be_referenced_in_constructor_arguments: diag(2333, ts.DiagnosticCategory.Error, "this_cannot_be_referenced_in_constructor_arguments_2333", "'this' cannot be referenced in constructor arguments."),
        this_cannot_be_referenced_in_a_static_property_initializer: diag(2334, ts.DiagnosticCategory.Error, "this_cannot_be_referenced_in_a_static_property_initializer_2334", "'this' cannot be referenced in a static property initializer."),
        super_can_only_be_referenced_in_a_derived_class: diag(2335, ts.DiagnosticCategory.Error, "super_can_only_be_referenced_in_a_derived_class_2335", "'super' can only be referenced in a derived class."),
        super_cannot_be_referenced_in_constructor_arguments: diag(2336, ts.DiagnosticCategory.Error, "super_cannot_be_referenced_in_constructor_arguments_2336", "'super' cannot be referenced in constructor arguments."),
        Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors: diag(2337, ts.DiagnosticCategory.Error, "Super_calls_are_not_permitted_outside_constructors_or_in_nested_functions_inside_constructors_2337", "Super calls are not permitted outside constructors or in nested functions inside constructors."),
        super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_derived_class: diag(2338, ts.DiagnosticCategory.Error, "super_property_access_is_permitted_only_in_a_constructor_member_function_or_member_accessor_of_a_der_2338", "'super' property access is permitted only in a constructor, member function, or member accessor of a derived class."),
        Property_0_does_not_exist_on_type_1: diag(2339, ts.DiagnosticCategory.Error, "Property_0_does_not_exist_on_type_1_2339", "Property '{0}' does not exist on type '{1}'."),
        Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword: diag(2340, ts.DiagnosticCategory.Error, "Only_public_and_protected_methods_of_the_base_class_are_accessible_via_the_super_keyword_2340", "Only public and protected methods of the base class are accessible via the 'super' keyword."),
        Property_0_is_private_and_only_accessible_within_class_1: diag(2341, ts.DiagnosticCategory.Error, "Property_0_is_private_and_only_accessible_within_class_1_2341", "Property '{0}' is private and only accessible within class '{1}'."),
        This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_version_of_0: diag(2343, ts.DiagnosticCategory.Error, "This_syntax_requires_an_imported_helper_named_1_which_does_not_exist_in_0_Consider_upgrading_your_ve_2343", "This syntax requires an imported helper named '{1}' which does not exist in '{0}'. Consider upgrading your version of '{0}'."),
        Type_0_does_not_satisfy_the_constraint_1: diag(2344, ts.DiagnosticCategory.Error, "Type_0_does_not_satisfy_the_constraint_1_2344", "Type '{0}' does not satisfy the constraint '{1}'."),
        Argument_of_type_0_is_not_assignable_to_parameter_of_type_1: diag(2345, ts.DiagnosticCategory.Error, "Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_2345", "Argument of type '{0}' is not assignable to parameter of type '{1}'."),
        Call_target_does_not_contain_any_signatures: diag(2346, ts.DiagnosticCategory.Error, "Call_target_does_not_contain_any_signatures_2346", "Call target does not contain any signatures."),
        Untyped_function_calls_may_not_accept_type_arguments: diag(2347, ts.DiagnosticCategory.Error, "Untyped_function_calls_may_not_accept_type_arguments_2347", "Untyped function calls may not accept type arguments."),
        Value_of_type_0_is_not_callable_Did_you_mean_to_include_new: diag(2348, ts.DiagnosticCategory.Error, "Value_of_type_0_is_not_callable_Did_you_mean_to_include_new_2348", "Value of type '{0}' is not callable. Did you mean to include 'new'?"),
        This_expression_is_not_callable: diag(2349, ts.DiagnosticCategory.Error, "This_expression_is_not_callable_2349", "This expression is not callable."),
        Only_a_void_function_can_be_called_with_the_new_keyword: diag(2350, ts.DiagnosticCategory.Error, "Only_a_void_function_can_be_called_with_the_new_keyword_2350", "Only a void function can be called with the 'new' keyword."),
        This_expression_is_not_constructable: diag(2351, ts.DiagnosticCategory.Error, "This_expression_is_not_constructable_2351", "This expression is not constructable."),
        Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the_other_If_this_was_intentional_convert_the_expression_to_unknown_first: diag(2352, ts.DiagnosticCategory.Error, "Conversion_of_type_0_to_type_1_may_be_a_mistake_because_neither_type_sufficiently_overlaps_with_the__2352", "Conversion of type '{0}' to type '{1}' may be a mistake because neither type sufficiently overlaps with the other. If this was intentional, convert the expression to 'unknown' first."),
        Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1: diag(2353, ts.DiagnosticCategory.Error, "Object_literal_may_only_specify_known_properties_and_0_does_not_exist_in_type_1_2353", "Object literal may only specify known properties, and '{0}' does not exist in type '{1}'."),
        This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found: diag(2354, ts.DiagnosticCategory.Error, "This_syntax_requires_an_imported_helper_but_module_0_cannot_be_found_2354", "This syntax requires an imported helper but module '{0}' cannot be found."),
        A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value: diag(2355, ts.DiagnosticCategory.Error, "A_function_whose_declared_type_is_neither_void_nor_any_must_return_a_value_2355", "A function whose declared type is neither 'void' nor 'any' must return a value."),
        An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type: diag(2356, ts.DiagnosticCategory.Error, "An_arithmetic_operand_must_be_of_type_any_number_bigint_or_an_enum_type_2356", "An arithmetic operand must be of type 'any', 'number', 'bigint' or an enum type."),
        The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access: diag(2357, ts.DiagnosticCategory.Error, "The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_or_a_property_access_2357", "The operand of an increment or decrement operator must be a variable or a property access."),
        The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: diag(2358, ts.DiagnosticCategory.Error, "The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_paramete_2358", "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter."),
        The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_Function_interface_type: diag(2359, ts.DiagnosticCategory.Error, "The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_of_a_type_assignable_to_the_F_2359", "The right-hand side of an 'instanceof' expression must be of type 'any' or of a type assignable to the 'Function' interface type."),
        The_left_hand_side_of_an_in_expression_must_be_a_private_identifier_or_of_type_any_string_number_or_symbol: diag(2360, ts.DiagnosticCategory.Error, "The_left_hand_side_of_an_in_expression_must_be_a_private_identifier_or_of_type_any_string_number_or__2360", "The left-hand side of an 'in' expression must be a private identifier or of type 'any', 'string', 'number', or 'symbol'."),
        The_right_hand_side_of_an_in_expression_must_not_be_a_primitive: diag(2361, ts.DiagnosticCategory.Error, "The_right_hand_side_of_an_in_expression_must_not_be_a_primitive_2361", "The right-hand side of an 'in' expression must not be a primitive."),
        The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type: diag(2362, ts.DiagnosticCategory.Error, "The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type_2362", "The left-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type."),
        The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type: diag(2363, ts.DiagnosticCategory.Error, "The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_bigint_or_an_enum_type_2363", "The right-hand side of an arithmetic operation must be of type 'any', 'number', 'bigint' or an enum type."),
        The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access: diag(2364, ts.DiagnosticCategory.Error, "The_left_hand_side_of_an_assignment_expression_must_be_a_variable_or_a_property_access_2364", "The left-hand side of an assignment expression must be a variable or a property access."),
        Operator_0_cannot_be_applied_to_types_1_and_2: diag(2365, ts.DiagnosticCategory.Error, "Operator_0_cannot_be_applied_to_types_1_and_2_2365", "Operator '{0}' cannot be applied to types '{1}' and '{2}'."),
        Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined: diag(2366, ts.DiagnosticCategory.Error, "Function_lacks_ending_return_statement_and_return_type_does_not_include_undefined_2366", "Function lacks ending return statement and return type does not include 'undefined'."),
        This_condition_will_always_return_0_since_the_types_1_and_2_have_no_overlap: diag(2367, ts.DiagnosticCategory.Error, "This_condition_will_always_return_0_since_the_types_1_and_2_have_no_overlap_2367", "This condition will always return '{0}' since the types '{1}' and '{2}' have no overlap."),
        Type_parameter_name_cannot_be_0: diag(2368, ts.DiagnosticCategory.Error, "Type_parameter_name_cannot_be_0_2368", "Type parameter name cannot be '{0}'."),
        A_parameter_property_is_only_allowed_in_a_constructor_implementation: diag(2369, ts.DiagnosticCategory.Error, "A_parameter_property_is_only_allowed_in_a_constructor_implementation_2369", "A parameter property is only allowed in a constructor implementation."),
        A_rest_parameter_must_be_of_an_array_type: diag(2370, ts.DiagnosticCategory.Error, "A_rest_parameter_must_be_of_an_array_type_2370", "A rest parameter must be of an array type."),
        A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation: diag(2371, ts.DiagnosticCategory.Error, "A_parameter_initializer_is_only_allowed_in_a_function_or_constructor_implementation_2371", "A parameter initializer is only allowed in a function or constructor implementation."),
        Parameter_0_cannot_reference_itself: diag(2372, ts.DiagnosticCategory.Error, "Parameter_0_cannot_reference_itself_2372", "Parameter '{0}' cannot reference itself."),
        Parameter_0_cannot_reference_identifier_1_declared_after_it: diag(2373, ts.DiagnosticCategory.Error, "Parameter_0_cannot_reference_identifier_1_declared_after_it_2373", "Parameter '{0}' cannot reference identifier '{1}' declared after it."),
        Duplicate_index_signature_for_type_0: diag(2374, ts.DiagnosticCategory.Error, "Duplicate_index_signature_for_type_0_2374", "Duplicate index signature for type '{0}'."),
        Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties: diag(2375, ts.DiagnosticCategory.Error, "Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefi_2375", "Type '{0}' is not assignable to type '{1}' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the types of the target's properties."),
        A_super_call_must_be_the_first_statement_in_the_constructor_to_refer_to_super_or_this_when_a_derived_class_contains_initialized_properties_parameter_properties_or_private_identifiers: diag(2376, ts.DiagnosticCategory.Error, "A_super_call_must_be_the_first_statement_in_the_constructor_to_refer_to_super_or_this_when_a_derived_2376", "A 'super' call must be the first statement in the constructor to refer to 'super' or 'this' when a derived class contains initialized properties, parameter properties, or private identifiers."),
        Constructors_for_derived_classes_must_contain_a_super_call: diag(2377, ts.DiagnosticCategory.Error, "Constructors_for_derived_classes_must_contain_a_super_call_2377", "Constructors for derived classes must contain a 'super' call."),
        A_get_accessor_must_return_a_value: diag(2378, ts.DiagnosticCategory.Error, "A_get_accessor_must_return_a_value_2378", "A 'get' accessor must return a value."),
        Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_types_of_the_target_s_properties: diag(2379, ts.DiagnosticCategory.Error, "Argument_of_type_0_is_not_assignable_to_parameter_of_type_1_with_exactOptionalPropertyTypes_Colon_tr_2379", "Argument of type '{0}' is not assignable to parameter of type '{1}' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the types of the target's properties."),
        The_return_type_of_a_get_accessor_must_be_assignable_to_its_set_accessor_type: diag(2380, ts.DiagnosticCategory.Error, "The_return_type_of_a_get_accessor_must_be_assignable_to_its_set_accessor_type_2380", "The return type of a 'get' accessor must be assignable to its 'set' accessor type"),
        Overload_signatures_must_all_be_exported_or_non_exported: diag(2383, ts.DiagnosticCategory.Error, "Overload_signatures_must_all_be_exported_or_non_exported_2383", "Overload signatures must all be exported or non-exported."),
        Overload_signatures_must_all_be_ambient_or_non_ambient: diag(2384, ts.DiagnosticCategory.Error, "Overload_signatures_must_all_be_ambient_or_non_ambient_2384", "Overload signatures must all be ambient or non-ambient."),
        Overload_signatures_must_all_be_public_private_or_protected: diag(2385, ts.DiagnosticCategory.Error, "Overload_signatures_must_all_be_public_private_or_protected_2385", "Overload signatures must all be public, private or protected."),
        Overload_signatures_must_all_be_optional_or_required: diag(2386, ts.DiagnosticCategory.Error, "Overload_signatures_must_all_be_optional_or_required_2386", "Overload signatures must all be optional or required."),
        Function_overload_must_be_static: diag(2387, ts.DiagnosticCategory.Error, "Function_overload_must_be_static_2387", "Function overload must be static."),
        Function_overload_must_not_be_static: diag(2388, ts.DiagnosticCategory.Error, "Function_overload_must_not_be_static_2388", "Function overload must not be static."),
        Function_implementation_name_must_be_0: diag(2389, ts.DiagnosticCategory.Error, "Function_implementation_name_must_be_0_2389", "Function implementation name must be '{0}'."),
        Constructor_implementation_is_missing: diag(2390, ts.DiagnosticCategory.Error, "Constructor_implementation_is_missing_2390", "Constructor implementation is missing."),
        Function_implementation_is_missing_or_not_immediately_following_the_declaration: diag(2391, ts.DiagnosticCategory.Error, "Function_implementation_is_missing_or_not_immediately_following_the_declaration_2391", "Function implementation is missing or not immediately following the declaration."),
        Multiple_constructor_implementations_are_not_allowed: diag(2392, ts.DiagnosticCategory.Error, "Multiple_constructor_implementations_are_not_allowed_2392", "Multiple constructor implementations are not allowed."),
        Duplicate_function_implementation: diag(2393, ts.DiagnosticCategory.Error, "Duplicate_function_implementation_2393", "Duplicate function implementation."),
        This_overload_signature_is_not_compatible_with_its_implementation_signature: diag(2394, ts.DiagnosticCategory.Error, "This_overload_signature_is_not_compatible_with_its_implementation_signature_2394", "This overload signature is not compatible with its implementation signature."),
        Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local: diag(2395, ts.DiagnosticCategory.Error, "Individual_declarations_in_merged_declaration_0_must_be_all_exported_or_all_local_2395", "Individual declarations in merged declaration '{0}' must be all exported or all local."),
        Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters: diag(2396, ts.DiagnosticCategory.Error, "Duplicate_identifier_arguments_Compiler_uses_arguments_to_initialize_rest_parameters_2396", "Duplicate identifier 'arguments'. Compiler uses 'arguments' to initialize rest parameters."),
        Declaration_name_conflicts_with_built_in_global_identifier_0: diag(2397, ts.DiagnosticCategory.Error, "Declaration_name_conflicts_with_built_in_global_identifier_0_2397", "Declaration name conflicts with built-in global identifier '{0}'."),
        constructor_cannot_be_used_as_a_parameter_property_name: diag(2398, ts.DiagnosticCategory.Error, "constructor_cannot_be_used_as_a_parameter_property_name_2398", "'constructor' cannot be used as a parameter property name."),
        Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference: diag(2399, ts.DiagnosticCategory.Error, "Duplicate_identifier_this_Compiler_uses_variable_declaration_this_to_capture_this_reference_2399", "Duplicate identifier '_this'. Compiler uses variable declaration '_this' to capture 'this' reference."),
        Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference: diag(2400, ts.DiagnosticCategory.Error, "Expression_resolves_to_variable_declaration_this_that_compiler_uses_to_capture_this_reference_2400", "Expression resolves to variable declaration '_this' that compiler uses to capture 'this' reference."),
        A_super_call_must_be_a_root_level_statement_within_a_constructor_of_a_derived_class_that_contains_initialized_properties_parameter_properties_or_private_identifiers: diag(2401, ts.DiagnosticCategory.Error, "A_super_call_must_be_a_root_level_statement_within_a_constructor_of_a_derived_class_that_contains_in_2401", "A 'super' call must be a root-level statement within a constructor of a derived class that contains initialized properties, parameter properties, or private identifiers."),
        Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference: diag(2402, ts.DiagnosticCategory.Error, "Expression_resolves_to_super_that_compiler_uses_to_capture_base_class_reference_2402", "Expression resolves to '_super' that compiler uses to capture base class reference."),
        Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2: diag(2403, ts.DiagnosticCategory.Error, "Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_t_2403", "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'."),
        The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation: diag(2404, ts.DiagnosticCategory.Error, "The_left_hand_side_of_a_for_in_statement_cannot_use_a_type_annotation_2404", "The left-hand side of a 'for...in' statement cannot use a type annotation."),
        The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any: diag(2405, ts.DiagnosticCategory.Error, "The_left_hand_side_of_a_for_in_statement_must_be_of_type_string_or_any_2405", "The left-hand side of a 'for...in' statement must be of type 'string' or 'any'."),
        The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access: diag(2406, ts.DiagnosticCategory.Error, "The_left_hand_side_of_a_for_in_statement_must_be_a_variable_or_a_property_access_2406", "The left-hand side of a 'for...in' statement must be a variable or a property access."),
        The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_here_has_type_0: diag(2407, ts.DiagnosticCategory.Error, "The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter_but_2407", "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter, but here has type '{0}'."),
        Setters_cannot_return_a_value: diag(2408, ts.DiagnosticCategory.Error, "Setters_cannot_return_a_value_2408", "Setters cannot return a value."),
        Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class: diag(2409, ts.DiagnosticCategory.Error, "Return_type_of_constructor_signature_must_be_assignable_to_the_instance_type_of_the_class_2409", "Return type of constructor signature must be assignable to the instance type of the class."),
        The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any: diag(2410, ts.DiagnosticCategory.Error, "The_with_statement_is_not_supported_All_symbols_in_a_with_block_will_have_type_any_2410", "The 'with' statement is not supported. All symbols in a 'with' block will have type 'any'."),
        Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefined_to_the_type_of_the_target: diag(2412, ts.DiagnosticCategory.Error, "Type_0_is_not_assignable_to_type_1_with_exactOptionalPropertyTypes_Colon_true_Consider_adding_undefi_2412", "Type '{0}' is not assignable to type '{1}' with 'exactOptionalPropertyTypes: true'. Consider adding 'undefined' to the type of the target."),
        Property_0_of_type_1_is_not_assignable_to_2_index_type_3: diag(2411, ts.DiagnosticCategory.Error, "Property_0_of_type_1_is_not_assignable_to_2_index_type_3_2411", "Property '{0}' of type '{1}' is not assignable to '{2}' index type '{3}'."),
        _0_index_type_1_is_not_assignable_to_2_index_type_3: diag(2413, ts.DiagnosticCategory.Error, "_0_index_type_1_is_not_assignable_to_2_index_type_3_2413", "'{0}' index type '{1}' is not assignable to '{2}' index type '{3}'."),
        Class_name_cannot_be_0: diag(2414, ts.DiagnosticCategory.Error, "Class_name_cannot_be_0_2414", "Class name cannot be '{0}'."),
        Class_0_incorrectly_extends_base_class_1: diag(2415, ts.DiagnosticCategory.Error, "Class_0_incorrectly_extends_base_class_1_2415", "Class '{0}' incorrectly extends base class '{1}'."),
        Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2: diag(2416, ts.DiagnosticCategory.Error, "Property_0_in_type_1_is_not_assignable_to_the_same_property_in_base_type_2_2416", "Property '{0}' in type '{1}' is not assignable to the same property in base type '{2}'."),
        Class_static_side_0_incorrectly_extends_base_class_static_side_1: diag(2417, ts.DiagnosticCategory.Error, "Class_static_side_0_incorrectly_extends_base_class_static_side_1_2417", "Class static side '{0}' incorrectly extends base class static side '{1}'."),
        Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1: diag(2418, ts.DiagnosticCategory.Error, "Type_of_computed_property_s_value_is_0_which_is_not_assignable_to_type_1_2418", "Type of computed property's value is '{0}', which is not assignable to type '{1}'."),
        Types_of_construct_signatures_are_incompatible: diag(2419, ts.DiagnosticCategory.Error, "Types_of_construct_signatures_are_incompatible_2419", "Types of construct signatures are incompatible."),
        Class_0_incorrectly_implements_interface_1: diag(2420, ts.DiagnosticCategory.Error, "Class_0_incorrectly_implements_interface_1_2420", "Class '{0}' incorrectly implements interface '{1}'."),
        A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_members: diag(2422, ts.DiagnosticCategory.Error, "A_class_can_only_implement_an_object_type_or_intersection_of_object_types_with_statically_known_memb_2422", "A class can only implement an object type or intersection of object types with statically known members."),
        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor: diag(2423, ts.DiagnosticCategory.Error, "Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_access_2423", "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor."),
        Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function: diag(2425, ts.DiagnosticCategory.Error, "Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_functi_2425", "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function."),
        Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function: diag(2426, ts.DiagnosticCategory.Error, "Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_functi_2426", "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function."),
        Interface_name_cannot_be_0: diag(2427, ts.DiagnosticCategory.Error, "Interface_name_cannot_be_0_2427", "Interface name cannot be '{0}'."),
        All_declarations_of_0_must_have_identical_type_parameters: diag(2428, ts.DiagnosticCategory.Error, "All_declarations_of_0_must_have_identical_type_parameters_2428", "All declarations of '{0}' must have identical type parameters."),
        Interface_0_incorrectly_extends_interface_1: diag(2430, ts.DiagnosticCategory.Error, "Interface_0_incorrectly_extends_interface_1_2430", "Interface '{0}' incorrectly extends interface '{1}'."),
        Enum_name_cannot_be_0: diag(2431, ts.DiagnosticCategory.Error, "Enum_name_cannot_be_0_2431", "Enum name cannot be '{0}'."),
        In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enum_element: diag(2432, ts.DiagnosticCategory.Error, "In_an_enum_with_multiple_declarations_only_one_declaration_can_omit_an_initializer_for_its_first_enu_2432", "In an enum with multiple declarations, only one declaration can omit an initializer for its first enum element."),
        A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merged: diag(2433, ts.DiagnosticCategory.Error, "A_namespace_declaration_cannot_be_in_a_different_file_from_a_class_or_function_with_which_it_is_merg_2433", "A namespace declaration cannot be in a different file from a class or function with which it is merged."),
        A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged: diag(2434, ts.DiagnosticCategory.Error, "A_namespace_declaration_cannot_be_located_prior_to_a_class_or_function_with_which_it_is_merged_2434", "A namespace declaration cannot be located prior to a class or function with which it is merged."),
        Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces: diag(2435, ts.DiagnosticCategory.Error, "Ambient_modules_cannot_be_nested_in_other_modules_or_namespaces_2435", "Ambient modules cannot be nested in other modules or namespaces."),
        Ambient_module_declaration_cannot_specify_relative_module_name: diag(2436, ts.DiagnosticCategory.Error, "Ambient_module_declaration_cannot_specify_relative_module_name_2436", "Ambient module declaration cannot specify relative module name."),
        Module_0_is_hidden_by_a_local_declaration_with_the_same_name: diag(2437, ts.DiagnosticCategory.Error, "Module_0_is_hidden_by_a_local_declaration_with_the_same_name_2437", "Module '{0}' is hidden by a local declaration with the same name."),
        Import_name_cannot_be_0: diag(2438, ts.DiagnosticCategory.Error, "Import_name_cannot_be_0_2438", "Import name cannot be '{0}'."),
        Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relative_module_name: diag(2439, ts.DiagnosticCategory.Error, "Import_or_export_declaration_in_an_ambient_module_declaration_cannot_reference_module_through_relati_2439", "Import or export declaration in an ambient module declaration cannot reference module through relative module name."),
        Import_declaration_conflicts_with_local_declaration_of_0: diag(2440, ts.DiagnosticCategory.Error, "Import_declaration_conflicts_with_local_declaration_of_0_2440", "Import declaration conflicts with local declaration of '{0}'."),
        Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module: diag(2441, ts.DiagnosticCategory.Error, "Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_2441", "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module."),
        Types_have_separate_declarations_of_a_private_property_0: diag(2442, ts.DiagnosticCategory.Error, "Types_have_separate_declarations_of_a_private_property_0_2442", "Types have separate declarations of a private property '{0}'."),
        Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2: diag(2443, ts.DiagnosticCategory.Error, "Property_0_is_protected_but_type_1_is_not_a_class_derived_from_2_2443", "Property '{0}' is protected but type '{1}' is not a class derived from '{2}'."),
        Property_0_is_protected_in_type_1_but_public_in_type_2: diag(2444, ts.DiagnosticCategory.Error, "Property_0_is_protected_in_type_1_but_public_in_type_2_2444", "Property '{0}' is protected in type '{1}' but public in type '{2}'."),
        Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses: diag(2445, ts.DiagnosticCategory.Error, "Property_0_is_protected_and_only_accessible_within_class_1_and_its_subclasses_2445", "Property '{0}' is protected and only accessible within class '{1}' and its subclasses."),
        Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_This_is_an_instance_of_class_2: diag(2446, ts.DiagnosticCategory.Error, "Property_0_is_protected_and_only_accessible_through_an_instance_of_class_1_This_is_an_instance_of_cl_2446", "Property '{0}' is protected and only accessible through an instance of class '{1}'. This is an instance of class '{2}'."),
        The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead: diag(2447, ts.DiagnosticCategory.Error, "The_0_operator_is_not_allowed_for_boolean_types_Consider_using_1_instead_2447", "The '{0}' operator is not allowed for boolean types. Consider using '{1}' instead."),
        Block_scoped_variable_0_used_before_its_declaration: diag(2448, ts.DiagnosticCategory.Error, "Block_scoped_variable_0_used_before_its_declaration_2448", "Block-scoped variable '{0}' used before its declaration."),
        Class_0_used_before_its_declaration: diag(2449, ts.DiagnosticCategory.Error, "Class_0_used_before_its_declaration_2449", "Class '{0}' used before its declaration."),
        Enum_0_used_before_its_declaration: diag(2450, ts.DiagnosticCategory.Error, "Enum_0_used_before_its_declaration_2450", "Enum '{0}' used before its declaration."),
        Cannot_redeclare_block_scoped_variable_0: diag(2451, ts.DiagnosticCategory.Error, "Cannot_redeclare_block_scoped_variable_0_2451", "Cannot redeclare block-scoped variable '{0}'."),
        An_enum_member_cannot_have_a_numeric_name: diag(2452, ts.DiagnosticCategory.Error, "An_enum_member_cannot_have_a_numeric_name_2452", "An enum member cannot have a numeric name."),
        Variable_0_is_used_before_being_assigned: diag(2454, ts.DiagnosticCategory.Error, "Variable_0_is_used_before_being_assigned_2454", "Variable '{0}' is used before being assigned."),
        Type_alias_0_circularly_references_itself: diag(2456, ts.DiagnosticCategory.Error, "Type_alias_0_circularly_references_itself_2456", "Type alias '{0}' circularly references itself."),
        Type_alias_name_cannot_be_0: diag(2457, ts.DiagnosticCategory.Error, "Type_alias_name_cannot_be_0_2457", "Type alias name cannot be '{0}'."),
        An_AMD_module_cannot_have_multiple_name_assignments: diag(2458, ts.DiagnosticCategory.Error, "An_AMD_module_cannot_have_multiple_name_assignments_2458", "An AMD module cannot have multiple name assignments."),
        Module_0_declares_1_locally_but_it_is_not_exported: diag(2459, ts.DiagnosticCategory.Error, "Module_0_declares_1_locally_but_it_is_not_exported_2459", "Module '{0}' declares '{1}' locally, but it is not exported."),
        Module_0_declares_1_locally_but_it_is_exported_as_2: diag(2460, ts.DiagnosticCategory.Error, "Module_0_declares_1_locally_but_it_is_exported_as_2_2460", "Module '{0}' declares '{1}' locally, but it is exported as '{2}'."),
        Type_0_is_not_an_array_type: diag(2461, ts.DiagnosticCategory.Error, "Type_0_is_not_an_array_type_2461", "Type '{0}' is not an array type."),
        A_rest_element_must_be_last_in_a_destructuring_pattern: diag(2462, ts.DiagnosticCategory.Error, "A_rest_element_must_be_last_in_a_destructuring_pattern_2462", "A rest element must be last in a destructuring pattern."),
        A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature: diag(2463, ts.DiagnosticCategory.Error, "A_binding_pattern_parameter_cannot_be_optional_in_an_implementation_signature_2463", "A binding pattern parameter cannot be optional in an implementation signature."),
        A_computed_property_name_must_be_of_type_string_number_symbol_or_any: diag(2464, ts.DiagnosticCategory.Error, "A_computed_property_name_must_be_of_type_string_number_symbol_or_any_2464", "A computed property name must be of type 'string', 'number', 'symbol', or 'any'."),
        this_cannot_be_referenced_in_a_computed_property_name: diag(2465, ts.DiagnosticCategory.Error, "this_cannot_be_referenced_in_a_computed_property_name_2465", "'this' cannot be referenced in a computed property name."),
        super_cannot_be_referenced_in_a_computed_property_name: diag(2466, ts.DiagnosticCategory.Error, "super_cannot_be_referenced_in_a_computed_property_name_2466", "'super' cannot be referenced in a computed property name."),
        A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type: diag(2467, ts.DiagnosticCategory.Error, "A_computed_property_name_cannot_reference_a_type_parameter_from_its_containing_type_2467", "A computed property name cannot reference a type parameter from its containing type."),
        Cannot_find_global_value_0: diag(2468, ts.DiagnosticCategory.Error, "Cannot_find_global_value_0_2468", "Cannot find global value '{0}'."),
        The_0_operator_cannot_be_applied_to_type_symbol: diag(2469, ts.DiagnosticCategory.Error, "The_0_operator_cannot_be_applied_to_type_symbol_2469", "The '{0}' operator cannot be applied to type 'symbol'."),
        Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher: diag(2472, ts.DiagnosticCategory.Error, "Spread_operator_in_new_expressions_is_only_available_when_targeting_ECMAScript_5_and_higher_2472", "Spread operator in 'new' expressions is only available when targeting ECMAScript 5 and higher."),
        Enum_declarations_must_all_be_const_or_non_const: diag(2473, ts.DiagnosticCategory.Error, "Enum_declarations_must_all_be_const_or_non_const_2473", "Enum declarations must all be const or non-const."),
        const_enum_member_initializers_can_only_contain_literal_values_and_other_computed_enum_values: diag(2474, ts.DiagnosticCategory.Error, "const_enum_member_initializers_can_only_contain_literal_values_and_other_computed_enum_values_2474", "const enum member initializers can only contain literal values and other computed enum values."),
        const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_import_declaration_or_export_assignment_or_type_query: diag(2475, ts.DiagnosticCategory.Error, "const_enums_can_only_be_used_in_property_or_index_access_expressions_or_the_right_hand_side_of_an_im_2475", "'const' enums can only be used in property or index access expressions or the right hand side of an import declaration or export assignment or type query."),
        A_const_enum_member_can_only_be_accessed_using_a_string_literal: diag(2476, ts.DiagnosticCategory.Error, "A_const_enum_member_can_only_be_accessed_using_a_string_literal_2476", "A const enum member can only be accessed using a string literal."),
        const_enum_member_initializer_was_evaluated_to_a_non_finite_value: diag(2477, ts.DiagnosticCategory.Error, "const_enum_member_initializer_was_evaluated_to_a_non_finite_value_2477", "'const' enum member initializer was evaluated to a non-finite value."),
        const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN: diag(2478, ts.DiagnosticCategory.Error, "const_enum_member_initializer_was_evaluated_to_disallowed_value_NaN_2478", "'const' enum member initializer was evaluated to disallowed value 'NaN'."),
        let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations: diag(2480, ts.DiagnosticCategory.Error, "let_is_not_allowed_to_be_used_as_a_name_in_let_or_const_declarations_2480", "'let' is not allowed to be used as a name in 'let' or 'const' declarations."),
        Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1: diag(2481, ts.DiagnosticCategory.Error, "Cannot_initialize_outer_scoped_variable_0_in_the_same_scope_as_block_scoped_declaration_1_2481", "Cannot initialize outer scoped variable '{0}' in the same scope as block scoped declaration '{1}'."),
        The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation: diag(2483, ts.DiagnosticCategory.Error, "The_left_hand_side_of_a_for_of_statement_cannot_use_a_type_annotation_2483", "The left-hand side of a 'for...of' statement cannot use a type annotation."),
        Export_declaration_conflicts_with_exported_declaration_of_0: diag(2484, ts.DiagnosticCategory.Error, "Export_declaration_conflicts_with_exported_declaration_of_0_2484", "Export declaration conflicts with exported declaration of '{0}'."),
        The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access: diag(2487, ts.DiagnosticCategory.Error, "The_left_hand_side_of_a_for_of_statement_must_be_a_variable_or_a_property_access_2487", "The left-hand side of a 'for...of' statement must be a variable or a property access."),
        Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator: diag(2488, ts.DiagnosticCategory.Error, "Type_0_must_have_a_Symbol_iterator_method_that_returns_an_iterator_2488", "Type '{0}' must have a '[Symbol.iterator]()' method that returns an iterator."),
        An_iterator_must_have_a_next_method: diag(2489, ts.DiagnosticCategory.Error, "An_iterator_must_have_a_next_method_2489", "An iterator must have a 'next()' method."),
        The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property: diag(2490, ts.DiagnosticCategory.Error, "The_type_returned_by_the_0_method_of_an_iterator_must_have_a_value_property_2490", "The type returned by the '{0}()' method of an iterator must have a 'value' property."),
        The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern: diag(2491, ts.DiagnosticCategory.Error, "The_left_hand_side_of_a_for_in_statement_cannot_be_a_destructuring_pattern_2491", "The left-hand side of a 'for...in' statement cannot be a destructuring pattern."),
        Cannot_redeclare_identifier_0_in_catch_clause: diag(2492, ts.DiagnosticCategory.Error, "Cannot_redeclare_identifier_0_in_catch_clause_2492", "Cannot redeclare identifier '{0}' in catch clause."),
        Tuple_type_0_of_length_1_has_no_element_at_index_2: diag(2493, ts.DiagnosticCategory.Error, "Tuple_type_0_of_length_1_has_no_element_at_index_2_2493", "Tuple type '{0}' of length '{1}' has no element at index '{2}'."),
        Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher: diag(2494, ts.DiagnosticCategory.Error, "Using_a_string_in_a_for_of_statement_is_only_supported_in_ECMAScript_5_and_higher_2494", "Using a string in a 'for...of' statement is only supported in ECMAScript 5 and higher."),
        Type_0_is_not_an_array_type_or_a_string_type: diag(2495, ts.DiagnosticCategory.Error, "Type_0_is_not_an_array_type_or_a_string_type_2495", "Type '{0}' is not an array type or a string type."),
        The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES3_and_ES5_Consider_using_a_standard_function_expression: diag(2496, ts.DiagnosticCategory.Error, "The_arguments_object_cannot_be_referenced_in_an_arrow_function_in_ES3_and_ES5_Consider_using_a_stand_2496", "The 'arguments' object cannot be referenced in an arrow function in ES3 and ES5. Consider using a standard function expression."),
        This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_referencing_its_default_export: diag(2497, ts.DiagnosticCategory.Error, "This_module_can_only_be_referenced_with_ECMAScript_imports_Slashexports_by_turning_on_the_0_flag_and_2497", "This module can only be referenced with ECMAScript imports/exports by turning on the '{0}' flag and referencing its default export."),
        Module_0_uses_export_and_cannot_be_used_with_export_Asterisk: diag(2498, ts.DiagnosticCategory.Error, "Module_0_uses_export_and_cannot_be_used_with_export_Asterisk_2498", "Module '{0}' uses 'export =' and cannot be used with 'export *'."),
        An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments: diag(2499, ts.DiagnosticCategory.Error, "An_interface_can_only_extend_an_identifier_Slashqualified_name_with_optional_type_arguments_2499", "An interface can only extend an identifier/qualified-name with optional type arguments."),
        A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments: diag(2500, ts.DiagnosticCategory.Error, "A_class_can_only_implement_an_identifier_Slashqualified_name_with_optional_type_arguments_2500", "A class can only implement an identifier/qualified-name with optional type arguments."),
        A_rest_element_cannot_contain_a_binding_pattern: diag(2501, ts.DiagnosticCategory.Error, "A_rest_element_cannot_contain_a_binding_pattern_2501", "A rest element cannot contain a binding pattern."),
        _0_is_referenced_directly_or_indirectly_in_its_own_type_annotation: diag(2502, ts.DiagnosticCategory.Error, "_0_is_referenced_directly_or_indirectly_in_its_own_type_annotation_2502", "'{0}' is referenced directly or indirectly in its own type annotation."),
        Cannot_find_namespace_0: diag(2503, ts.DiagnosticCategory.Error, "Cannot_find_namespace_0_2503", "Cannot find namespace '{0}'."),
        Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator: diag(2504, ts.DiagnosticCategory.Error, "Type_0_must_have_a_Symbol_asyncIterator_method_that_returns_an_async_iterator_2504", "Type '{0}' must have a '[Symbol.asyncIterator]()' method that returns an async iterator."),
        A_generator_cannot_have_a_void_type_annotation: diag(2505, ts.DiagnosticCategory.Error, "A_generator_cannot_have_a_void_type_annotation_2505", "A generator cannot have a 'void' type annotation."),
        _0_is_referenced_directly_or_indirectly_in_its_own_base_expression: diag(2506, ts.DiagnosticCategory.Error, "_0_is_referenced_directly_or_indirectly_in_its_own_base_expression_2506", "'{0}' is referenced directly or indirectly in its own base expression."),
        Type_0_is_not_a_constructor_function_type: diag(2507, ts.DiagnosticCategory.Error, "Type_0_is_not_a_constructor_function_type_2507", "Type '{0}' is not a constructor function type."),
        No_base_constructor_has_the_specified_number_of_type_arguments: diag(2508, ts.DiagnosticCategory.Error, "No_base_constructor_has_the_specified_number_of_type_arguments_2508", "No base constructor has the specified number of type arguments."),
        Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_known_members: diag(2509, ts.DiagnosticCategory.Error, "Base_constructor_return_type_0_is_not_an_object_type_or_intersection_of_object_types_with_statically_2509", "Base constructor return type '{0}' is not an object type or intersection of object types with statically known members."),
        Base_constructors_must_all_have_the_same_return_type: diag(2510, ts.DiagnosticCategory.Error, "Base_constructors_must_all_have_the_same_return_type_2510", "Base constructors must all have the same return type."),
        Cannot_create_an_instance_of_an_abstract_class: diag(2511, ts.DiagnosticCategory.Error, "Cannot_create_an_instance_of_an_abstract_class_2511", "Cannot create an instance of an abstract class."),
        Overload_signatures_must_all_be_abstract_or_non_abstract: diag(2512, ts.DiagnosticCategory.Error, "Overload_signatures_must_all_be_abstract_or_non_abstract_2512", "Overload signatures must all be abstract or non-abstract."),
        Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression: diag(2513, ts.DiagnosticCategory.Error, "Abstract_method_0_in_class_1_cannot_be_accessed_via_super_expression_2513", "Abstract method '{0}' in class '{1}' cannot be accessed via super expression."),
        A_tuple_type_cannot_be_indexed_with_a_negative_value: diag(2514, ts.DiagnosticCategory.Error, "A_tuple_type_cannot_be_indexed_with_a_negative_value_2514", "A tuple type cannot be indexed with a negative value."),
        Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2: diag(2515, ts.DiagnosticCategory.Error, "Non_abstract_class_0_does_not_implement_inherited_abstract_member_1_from_class_2_2515", "Non-abstract class '{0}' does not implement inherited abstract member '{1}' from class '{2}'."),
        All_declarations_of_an_abstract_method_must_be_consecutive: diag(2516, ts.DiagnosticCategory.Error, "All_declarations_of_an_abstract_method_must_be_consecutive_2516", "All declarations of an abstract method must be consecutive."),
        Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type: diag(2517, ts.DiagnosticCategory.Error, "Cannot_assign_an_abstract_constructor_type_to_a_non_abstract_constructor_type_2517", "Cannot assign an abstract constructor type to a non-abstract constructor type."),
        A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard: diag(2518, ts.DiagnosticCategory.Error, "A_this_based_type_guard_is_not_compatible_with_a_parameter_based_type_guard_2518", "A 'this'-based type guard is not compatible with a parameter-based type guard."),
        An_async_iterator_must_have_a_next_method: diag(2519, ts.DiagnosticCategory.Error, "An_async_iterator_must_have_a_next_method_2519", "An async iterator must have a 'next()' method."),
        Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions: diag(2520, ts.DiagnosticCategory.Error, "Duplicate_identifier_0_Compiler_uses_declaration_1_to_support_async_functions_2520", "Duplicate identifier '{0}'. Compiler uses declaration '{1}' to support async functions."),
        The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES3_and_ES5_Consider_using_a_standard_function_or_method: diag(2522, ts.DiagnosticCategory.Error, "The_arguments_object_cannot_be_referenced_in_an_async_function_or_method_in_ES3_and_ES5_Consider_usi_2522", "The 'arguments' object cannot be referenced in an async function or method in ES3 and ES5. Consider using a standard function or method."),
        yield_expressions_cannot_be_used_in_a_parameter_initializer: diag(2523, ts.DiagnosticCategory.Error, "yield_expressions_cannot_be_used_in_a_parameter_initializer_2523", "'yield' expressions cannot be used in a parameter initializer."),
        await_expressions_cannot_be_used_in_a_parameter_initializer: diag(2524, ts.DiagnosticCategory.Error, "await_expressions_cannot_be_used_in_a_parameter_initializer_2524", "'await' expressions cannot be used in a parameter initializer."),
        Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value: diag(2525, ts.DiagnosticCategory.Error, "Initializer_provides_no_value_for_this_binding_element_and_the_binding_element_has_no_default_value_2525", "Initializer provides no value for this binding element and the binding element has no default value."),
        A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface: diag(2526, ts.DiagnosticCategory.Error, "A_this_type_is_available_only_in_a_non_static_member_of_a_class_or_interface_2526", "A 'this' type is available only in a non-static member of a class or interface."),
        The_inferred_type_of_0_references_an_inaccessible_1_type_A_type_annotation_is_necessary: diag(2527, ts.DiagnosticCategory.Error, "The_inferred_type_of_0_references_an_inaccessible_1_type_A_type_annotation_is_necessary_2527", "The inferred type of '{0}' references an inaccessible '{1}' type. A type annotation is necessary."),
        A_module_cannot_have_multiple_default_exports: diag(2528, ts.DiagnosticCategory.Error, "A_module_cannot_have_multiple_default_exports_2528", "A module cannot have multiple default exports."),
        Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_functions: diag(2529, ts.DiagnosticCategory.Error, "Duplicate_identifier_0_Compiler_reserves_name_1_in_top_level_scope_of_a_module_containing_async_func_2529", "Duplicate identifier '{0}'. Compiler reserves name '{1}' in top level scope of a module containing async functions."),
        Property_0_is_incompatible_with_index_signature: diag(2530, ts.DiagnosticCategory.Error, "Property_0_is_incompatible_with_index_signature_2530", "Property '{0}' is incompatible with index signature."),
        Object_is_possibly_null: diag(2531, ts.DiagnosticCategory.Error, "Object_is_possibly_null_2531", "Object is possibly 'null'."),
        Object_is_possibly_undefined: diag(2532, ts.DiagnosticCategory.Error, "Object_is_possibly_undefined_2532", "Object is possibly 'undefined'."),
        Object_is_possibly_null_or_undefined: diag(2533, ts.DiagnosticCategory.Error, "Object_is_possibly_null_or_undefined_2533", "Object is possibly 'null' or 'undefined'."),
        A_function_returning_never_cannot_have_a_reachable_end_point: diag(2534, ts.DiagnosticCategory.Error, "A_function_returning_never_cannot_have_a_reachable_end_point_2534", "A function returning 'never' cannot have a reachable end point."),
        Enum_type_0_has_members_with_initializers_that_are_not_literals: diag(2535, ts.DiagnosticCategory.Error, "Enum_type_0_has_members_with_initializers_that_are_not_literals_2535", "Enum type '{0}' has members with initializers that are not literals."),
        Type_0_cannot_be_used_to_index_type_1: diag(2536, ts.DiagnosticCategory.Error, "Type_0_cannot_be_used_to_index_type_1_2536", "Type '{0}' cannot be used to index type '{1}'."),
        Type_0_has_no_matching_index_signature_for_type_1: diag(2537, ts.DiagnosticCategory.Error, "Type_0_has_no_matching_index_signature_for_type_1_2537", "Type '{0}' has no matching index signature for type '{1}'."),
        Type_0_cannot_be_used_as_an_index_type: diag(2538, ts.DiagnosticCategory.Error, "Type_0_cannot_be_used_as_an_index_type_2538", "Type '{0}' cannot be used as an index type."),
        Cannot_assign_to_0_because_it_is_not_a_variable: diag(2539, ts.DiagnosticCategory.Error, "Cannot_assign_to_0_because_it_is_not_a_variable_2539", "Cannot assign to '{0}' because it is not a variable."),
        Cannot_assign_to_0_because_it_is_a_read_only_property: diag(2540, ts.DiagnosticCategory.Error, "Cannot_assign_to_0_because_it_is_a_read_only_property_2540", "Cannot assign to '{0}' because it is a read-only property."),
        Index_signature_in_type_0_only_permits_reading: diag(2542, ts.DiagnosticCategory.Error, "Index_signature_in_type_0_only_permits_reading_2542", "Index signature in type '{0}' only permits reading."),
        Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_meta_property_reference: diag(2543, ts.DiagnosticCategory.Error, "Duplicate_identifier_newTarget_Compiler_uses_variable_declaration_newTarget_to_capture_new_target_me_2543", "Duplicate identifier '_newTarget'. Compiler uses variable declaration '_newTarget' to capture 'new.target' meta-property reference."),
        Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta_property_reference: diag(2544, ts.DiagnosticCategory.Error, "Expression_resolves_to_variable_declaration_newTarget_that_compiler_uses_to_capture_new_target_meta__2544", "Expression resolves to variable declaration '_newTarget' that compiler uses to capture 'new.target' meta-property reference."),
        A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any: diag(2545, ts.DiagnosticCategory.Error, "A_mixin_class_must_have_a_constructor_with_a_single_rest_parameter_of_type_any_2545", "A mixin class must have a constructor with a single rest parameter of type 'any[]'."),
        The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_property: diag(2547, ts.DiagnosticCategory.Error, "The_type_returned_by_the_0_method_of_an_async_iterator_must_be_a_promise_for_a_type_with_a_value_pro_2547", "The type returned by the '{0}()' method of an async iterator must be a promise for a type with a 'value' property."),
        Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator: diag(2548, ts.DiagnosticCategory.Error, "Type_0_is_not_an_array_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator_2548", "Type '{0}' is not an array type or does not have a '[Symbol.iterator]()' method that returns an iterator."),
        Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns_an_iterator: diag(2549, ts.DiagnosticCategory.Error, "Type_0_is_not_an_array_type_or_a_string_type_or_does_not_have_a_Symbol_iterator_method_that_returns__2549", "Type '{0}' is not an array type or a string type or does not have a '[Symbol.iterator]()' method that returns an iterator."),
        Property_0_does_not_exist_on_type_1_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2_or_later: diag(2550, ts.DiagnosticCategory.Error, "Property_0_does_not_exist_on_type_1_Do_you_need_to_change_your_target_library_Try_changing_the_lib_c_2550", "Property '{0}' does not exist on type '{1}'. Do you need to change your target library? Try changing the 'lib' compiler option to '{2}' or later."),
        Property_0_does_not_exist_on_type_1_Did_you_mean_2: diag(2551, ts.DiagnosticCategory.Error, "Property_0_does_not_exist_on_type_1_Did_you_mean_2_2551", "Property '{0}' does not exist on type '{1}'. Did you mean '{2}'?"),
        Cannot_find_name_0_Did_you_mean_1: diag(2552, ts.DiagnosticCategory.Error, "Cannot_find_name_0_Did_you_mean_1_2552", "Cannot find name '{0}'. Did you mean '{1}'?"),
        Computed_values_are_not_permitted_in_an_enum_with_string_valued_members: diag(2553, ts.DiagnosticCategory.Error, "Computed_values_are_not_permitted_in_an_enum_with_string_valued_members_2553", "Computed values are not permitted in an enum with string valued members."),
        Expected_0_arguments_but_got_1: diag(2554, ts.DiagnosticCategory.Error, "Expected_0_arguments_but_got_1_2554", "Expected {0} arguments, but got {1}."),
        Expected_at_least_0_arguments_but_got_1: diag(2555, ts.DiagnosticCategory.Error, "Expected_at_least_0_arguments_but_got_1_2555", "Expected at least {0} arguments, but got {1}."),
        A_spread_argument_must_either_have_a_tuple_type_or_be_passed_to_a_rest_parameter: diag(2556, ts.DiagnosticCategory.Error, "A_spread_argument_must_either_have_a_tuple_type_or_be_passed_to_a_rest_parameter_2556", "A spread argument must either have a tuple type or be passed to a rest parameter."),
        Expected_0_type_arguments_but_got_1: diag(2558, ts.DiagnosticCategory.Error, "Expected_0_type_arguments_but_got_1_2558", "Expected {0} type arguments, but got {1}."),
        Type_0_has_no_properties_in_common_with_type_1: diag(2559, ts.DiagnosticCategory.Error, "Type_0_has_no_properties_in_common_with_type_1_2559", "Type '{0}' has no properties in common with type '{1}'."),
        Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it: diag(2560, ts.DiagnosticCategory.Error, "Value_of_type_0_has_no_properties_in_common_with_type_1_Did_you_mean_to_call_it_2560", "Value of type '{0}' has no properties in common with type '{1}'. Did you mean to call it?"),
        Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_write_2: diag(2561, ts.DiagnosticCategory.Error, "Object_literal_may_only_specify_known_properties_but_0_does_not_exist_in_type_1_Did_you_mean_to_writ_2561", "Object literal may only specify known properties, but '{0}' does not exist in type '{1}'. Did you mean to write '{2}'?"),
        Base_class_expressions_cannot_reference_class_type_parameters: diag(2562, ts.DiagnosticCategory.Error, "Base_class_expressions_cannot_reference_class_type_parameters_2562", "Base class expressions cannot reference class type parameters."),
        The_containing_function_or_module_body_is_too_large_for_control_flow_analysis: diag(2563, ts.DiagnosticCategory.Error, "The_containing_function_or_module_body_is_too_large_for_control_flow_analysis_2563", "The containing function or module body is too large for control flow analysis."),
        Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor: diag(2564, ts.DiagnosticCategory.Error, "Property_0_has_no_initializer_and_is_not_definitely_assigned_in_the_constructor_2564", "Property '{0}' has no initializer and is not definitely assigned in the constructor."),
        Property_0_is_used_before_being_assigned: diag(2565, ts.DiagnosticCategory.Error, "Property_0_is_used_before_being_assigned_2565", "Property '{0}' is used before being assigned."),
        A_rest_element_cannot_have_a_property_name: diag(2566, ts.DiagnosticCategory.Error, "A_rest_element_cannot_have_a_property_name_2566", "A rest element cannot have a property name."),
        Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations: diag(2567, ts.DiagnosticCategory.Error, "Enum_declarations_can_only_merge_with_namespace_or_other_enum_declarations_2567", "Enum declarations can only merge with namespace or other enum declarations."),
        Property_0_may_not_exist_on_type_1_Did_you_mean_2: diag(2568, ts.DiagnosticCategory.Error, "Property_0_may_not_exist_on_type_1_Did_you_mean_2_2568", "Property '{0}' may not exist on type '{1}'. Did you mean '{2}'?"),
        Could_not_find_name_0_Did_you_mean_1: diag(2570, ts.DiagnosticCategory.Error, "Could_not_find_name_0_Did_you_mean_1_2570", "Could not find name '{0}'. Did you mean '{1}'?"),
        Object_is_of_type_unknown: diag(2571, ts.DiagnosticCategory.Error, "Object_is_of_type_unknown_2571", "Object is of type 'unknown'."),
        A_rest_element_type_must_be_an_array_type: diag(2574, ts.DiagnosticCategory.Error, "A_rest_element_type_must_be_an_array_type_2574", "A rest element type must be an array type."),
        No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments: diag(2575, ts.DiagnosticCategory.Error, "No_overload_expects_0_arguments_but_overloads_do_exist_that_expect_either_1_or_2_arguments_2575", "No overload expects {0} arguments, but overloads do exist that expect either {1} or {2} arguments."),
        Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead: diag(2576, ts.DiagnosticCategory.Error, "Property_0_does_not_exist_on_type_1_Did_you_mean_to_access_the_static_member_2_instead_2576", "Property '{0}' does not exist on type '{1}'. Did you mean to access the static member '{2}' instead?"),
        Return_type_annotation_circularly_references_itself: diag(2577, ts.DiagnosticCategory.Error, "Return_type_annotation_circularly_references_itself_2577", "Return type annotation circularly references itself."),
        Unused_ts_expect_error_directive: diag(2578, ts.DiagnosticCategory.Error, "Unused_ts_expect_error_directive_2578", "Unused '@ts-expect-error' directive."),
        Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode: diag(2580, ts.DiagnosticCategory.Error, "Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashno_2580", "Cannot find name '{0}'. Do you need to install type definitions for node? Try `npm i --save-dev @types/node`."),
        Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery: diag(2581, ts.DiagnosticCategory.Error, "Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slash_2581", "Cannot find name '{0}'. Do you need to install type definitions for jQuery? Try `npm i --save-dev @types/jquery`."),
        Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha: diag(2582, ts.DiagnosticCategory.Error, "Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_type_2582", "Cannot find name '{0}'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha`."),
        Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_1_or_later: diag(2583, ts.DiagnosticCategory.Error, "Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2583", "Cannot find name '{0}'. Do you need to change your target library? Try changing the 'lib' compiler option to '{1}' or later."),
        Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_include_dom: diag(2584, ts.DiagnosticCategory.Error, "Cannot_find_name_0_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_2584", "Cannot find name '{0}'. Do you need to change your target library? Try changing the 'lib' compiler option to include 'dom'."),
        _0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_Try_changing_the_lib_compiler_option_to_es2015_or_later: diag(2585, ts.DiagnosticCategory.Error, "_0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Do_you_need_to_change_your_target_library_2585", "'{0}' only refers to a type, but is being used as a value here. Do you need to change your target library? Try changing the 'lib' compiler option to es2015 or later."),
        Cannot_assign_to_0_because_it_is_a_constant: diag(2588, ts.DiagnosticCategory.Error, "Cannot_assign_to_0_because_it_is_a_constant_2588", "Cannot assign to '{0}' because it is a constant."),
        Type_instantiation_is_excessively_deep_and_possibly_infinite: diag(2589, ts.DiagnosticCategory.Error, "Type_instantiation_is_excessively_deep_and_possibly_infinite_2589", "Type instantiation is excessively deep and possibly infinite."),
        Expression_produces_a_union_type_that_is_too_complex_to_represent: diag(2590, ts.DiagnosticCategory.Error, "Expression_produces_a_union_type_that_is_too_complex_to_represent_2590", "Expression produces a union type that is too complex to represent."),
        Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashnode_and_then_add_node_to_the_types_field_in_your_tsconfig: diag(2591, ts.DiagnosticCategory.Error, "Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_node_Try_npm_i_save_dev_types_Slashno_2591", "Cannot find name '{0}'. Do you need to install type definitions for node? Try `npm i --save-dev @types/node` and then add 'node' to the types field in your tsconfig."),
        Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slashjquery_and_then_add_jquery_to_the_types_field_in_your_tsconfig: diag(2592, ts.DiagnosticCategory.Error, "Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_jQuery_Try_npm_i_save_dev_types_Slash_2592", "Cannot find name '{0}'. Do you need to install type definitions for jQuery? Try `npm i --save-dev @types/jquery` and then add 'jquery' to the types field in your tsconfig."),
        Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_types_Slashjest_or_npm_i_save_dev_types_Slashmocha_and_then_add_jest_or_mocha_to_the_types_field_in_your_tsconfig: diag(2593, ts.DiagnosticCategory.Error, "Cannot_find_name_0_Do_you_need_to_install_type_definitions_for_a_test_runner_Try_npm_i_save_dev_type_2593", "Cannot find name '{0}'. Do you need to install type definitions for a test runner? Try `npm i --save-dev @types/jest` or `npm i --save-dev @types/mocha` and then add 'jest' or 'mocha' to the types field in your tsconfig."),
        This_module_is_declared_with_export_and_can_only_be_used_with_a_default_import_when_using_the_0_flag: diag(2594, ts.DiagnosticCategory.Error, "This_module_is_declared_with_export_and_can_only_be_used_with_a_default_import_when_using_the_0_flag_2594", "This module is declared with 'export =', and can only be used with a default import when using the '{0}' flag."),
        _0_can_only_be_imported_by_using_a_default_import: diag(2595, ts.DiagnosticCategory.Error, "_0_can_only_be_imported_by_using_a_default_import_2595", "'{0}' can only be imported by using a default import."),
        _0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import: diag(2596, ts.DiagnosticCategory.Error, "_0_can_only_be_imported_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import_2596", "'{0}' can only be imported by turning on the 'esModuleInterop' flag and using a default import."),
        _0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import: diag(2597, ts.DiagnosticCategory.Error, "_0_can_only_be_imported_by_using_a_require_call_or_by_using_a_default_import_2597", "'{0}' can only be imported by using a 'require' call or by using a default import."),
        _0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import: diag(2598, ts.DiagnosticCategory.Error, "_0_can_only_be_imported_by_using_a_require_call_or_by_turning_on_the_esModuleInterop_flag_and_using__2598", "'{0}' can only be imported by using a 'require' call or by turning on the 'esModuleInterop' flag and using a default import."),
        JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist: diag(2602, ts.DiagnosticCategory.Error, "JSX_element_implicitly_has_type_any_because_the_global_type_JSX_Element_does_not_exist_2602", "JSX element implicitly has type 'any' because the global type 'JSX.Element' does not exist."),
        Property_0_in_type_1_is_not_assignable_to_type_2: diag(2603, ts.DiagnosticCategory.Error, "Property_0_in_type_1_is_not_assignable_to_type_2_2603", "Property '{0}' in type '{1}' is not assignable to type '{2}'."),
        JSX_element_type_0_does_not_have_any_construct_or_call_signatures: diag(2604, ts.DiagnosticCategory.Error, "JSX_element_type_0_does_not_have_any_construct_or_call_signatures_2604", "JSX element type '{0}' does not have any construct or call signatures."),
        Property_0_of_JSX_spread_attribute_is_not_assignable_to_target_property: diag(2606, ts.DiagnosticCategory.Error, "Property_0_of_JSX_spread_attribute_is_not_assignable_to_target_property_2606", "Property '{0}' of JSX spread attribute is not assignable to target property."),
        JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property: diag(2607, ts.DiagnosticCategory.Error, "JSX_element_class_does_not_support_attributes_because_it_does_not_have_a_0_property_2607", "JSX element class does not support attributes because it does not have a '{0}' property."),
        The_global_type_JSX_0_may_not_have_more_than_one_property: diag(2608, ts.DiagnosticCategory.Error, "The_global_type_JSX_0_may_not_have_more_than_one_property_2608", "The global type 'JSX.{0}' may not have more than one property."),
        JSX_spread_child_must_be_an_array_type: diag(2609, ts.DiagnosticCategory.Error, "JSX_spread_child_must_be_an_array_type_2609", "JSX spread child must be an array type."),
        _0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property: diag(2610, ts.DiagnosticCategory.Error, "_0_is_defined_as_an_accessor_in_class_1_but_is_overridden_here_in_2_as_an_instance_property_2610", "'{0}' is defined as an accessor in class '{1}', but is overridden here in '{2}' as an instance property."),
        _0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor: diag(2611, ts.DiagnosticCategory.Error, "_0_is_defined_as_a_property_in_class_1_but_is_overridden_here_in_2_as_an_accessor_2611", "'{0}' is defined as a property in class '{1}', but is overridden here in '{2}' as an accessor."),
        Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_add_a_declare_modifier_or_remove_the_redundant_declaration: diag(2612, ts.DiagnosticCategory.Error, "Property_0_will_overwrite_the_base_property_in_1_If_this_is_intentional_add_an_initializer_Otherwise_2612", "Property '{0}' will overwrite the base property in '{1}'. If this is intentional, add an initializer. Otherwise, add a 'declare' modifier or remove the redundant declaration."),
        Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead: diag(2613, ts.DiagnosticCategory.Error, "Module_0_has_no_default_export_Did_you_mean_to_use_import_1_from_0_instead_2613", "Module '{0}' has no default export. Did you mean to use 'import { {1} } from {0}' instead?"),
        Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead: diag(2614, ts.DiagnosticCategory.Error, "Module_0_has_no_exported_member_1_Did_you_mean_to_use_import_1_from_0_instead_2614", "Module '{0}' has no exported member '{1}'. Did you mean to use 'import {1} from {0}' instead?"),
        Type_of_property_0_circularly_references_itself_in_mapped_type_1: diag(2615, ts.DiagnosticCategory.Error, "Type_of_property_0_circularly_references_itself_in_mapped_type_1_2615", "Type of property '{0}' circularly references itself in mapped type '{1}'."),
        _0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import: diag(2616, ts.DiagnosticCategory.Error, "_0_can_only_be_imported_by_using_import_1_require_2_or_a_default_import_2616", "'{0}' can only be imported by using 'import {1} = require({2})' or a default import."),
        _0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_using_a_default_import: diag(2617, ts.DiagnosticCategory.Error, "_0_can_only_be_imported_by_using_import_1_require_2_or_by_turning_on_the_esModuleInterop_flag_and_us_2617", "'{0}' can only be imported by using 'import {1} = require({2})' or by turning on the 'esModuleInterop' flag and using a default import."),
        Source_has_0_element_s_but_target_requires_1: diag(2618, ts.DiagnosticCategory.Error, "Source_has_0_element_s_but_target_requires_1_2618", "Source has {0} element(s) but target requires {1}."),
        Source_has_0_element_s_but_target_allows_only_1: diag(2619, ts.DiagnosticCategory.Error, "Source_has_0_element_s_but_target_allows_only_1_2619", "Source has {0} element(s) but target allows only {1}."),
        Target_requires_0_element_s_but_source_may_have_fewer: diag(2620, ts.DiagnosticCategory.Error, "Target_requires_0_element_s_but_source_may_have_fewer_2620", "Target requires {0} element(s) but source may have fewer."),
        Target_allows_only_0_element_s_but_source_may_have_more: diag(2621, ts.DiagnosticCategory.Error, "Target_allows_only_0_element_s_but_source_may_have_more_2621", "Target allows only {0} element(s) but source may have more."),
        Source_provides_no_match_for_required_element_at_position_0_in_target: diag(2623, ts.DiagnosticCategory.Error, "Source_provides_no_match_for_required_element_at_position_0_in_target_2623", "Source provides no match for required element at position {0} in target."),
        Source_provides_no_match_for_variadic_element_at_position_0_in_target: diag(2624, ts.DiagnosticCategory.Error, "Source_provides_no_match_for_variadic_element_at_position_0_in_target_2624", "Source provides no match for variadic element at position {0} in target."),
        Variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target: diag(2625, ts.DiagnosticCategory.Error, "Variadic_element_at_position_0_in_source_does_not_match_element_at_position_1_in_target_2625", "Variadic element at position {0} in source does not match element at position {1} in target."),
        Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target: diag(2626, ts.DiagnosticCategory.Error, "Type_at_position_0_in_source_is_not_compatible_with_type_at_position_1_in_target_2626", "Type at position {0} in source is not compatible with type at position {1} in target."),
        Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target: diag(2627, ts.DiagnosticCategory.Error, "Type_at_positions_0_through_1_in_source_is_not_compatible_with_type_at_position_2_in_target_2627", "Type at positions {0} through {1} in source is not compatible with type at position {2} in target."),
        Cannot_assign_to_0_because_it_is_an_enum: diag(2628, ts.DiagnosticCategory.Error, "Cannot_assign_to_0_because_it_is_an_enum_2628", "Cannot assign to '{0}' because it is an enum."),
        Cannot_assign_to_0_because_it_is_a_class: diag(2629, ts.DiagnosticCategory.Error, "Cannot_assign_to_0_because_it_is_a_class_2629", "Cannot assign to '{0}' because it is a class."),
        Cannot_assign_to_0_because_it_is_a_function: diag(2630, ts.DiagnosticCategory.Error, "Cannot_assign_to_0_because_it_is_a_function_2630", "Cannot assign to '{0}' because it is a function."),
        Cannot_assign_to_0_because_it_is_a_namespace: diag(2631, ts.DiagnosticCategory.Error, "Cannot_assign_to_0_because_it_is_a_namespace_2631", "Cannot assign to '{0}' because it is a namespace."),
        Cannot_assign_to_0_because_it_is_an_import: diag(2632, ts.DiagnosticCategory.Error, "Cannot_assign_to_0_because_it_is_an_import_2632", "Cannot assign to '{0}' because it is an import."),
        JSX_property_access_expressions_cannot_include_JSX_namespace_names: diag(2633, ts.DiagnosticCategory.Error, "JSX_property_access_expressions_cannot_include_JSX_namespace_names_2633", "JSX property access expressions cannot include JSX namespace names"),
        _0_index_signatures_are_incompatible: diag(2634, ts.DiagnosticCategory.Error, "_0_index_signatures_are_incompatible_2634", "'{0}' index signatures are incompatible."),
        Type_0_has_no_signatures_for_which_the_type_argument_list_is_applicable: diag(2635, ts.DiagnosticCategory.Error, "Type_0_has_no_signatures_for_which_the_type_argument_list_is_applicable_2635", "Type '{0}' has no signatures for which the type argument list is applicable."),
        Type_0_is_not_assignable_to_type_1_as_implied_by_variance_annotation: diag(2636, ts.DiagnosticCategory.Error, "Type_0_is_not_assignable_to_type_1_as_implied_by_variance_annotation_2636", "Type '{0}' is not assignable to type '{1}' as implied by variance annotation."),
        Variance_annotations_are_only_supported_in_type_aliases_for_object_function_constructor_and_mapped_types: diag(2637, ts.DiagnosticCategory.Error, "Variance_annotations_are_only_supported_in_type_aliases_for_object_function_constructor_and_mapped_t_2637", "Variance annotations are only supported in type aliases for object, function, constructor, and mapped types."),
        Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity: diag(2649, ts.DiagnosticCategory.Error, "Cannot_augment_module_0_with_value_exports_because_it_resolves_to_a_non_module_entity_2649", "Cannot augment module '{0}' with value exports because it resolves to a non-module entity."),
        A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_members_defined_in_other_enums: diag(2651, ts.DiagnosticCategory.Error, "A_member_initializer_in_a_enum_declaration_cannot_reference_members_declared_after_it_including_memb_2651", "A member initializer in a enum declaration cannot reference members declared after it, including members defined in other enums."),
        Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_default_0_declaration_instead: diag(2652, ts.DiagnosticCategory.Error, "Merged_declaration_0_cannot_include_a_default_export_declaration_Consider_adding_a_separate_export_d_2652", "Merged declaration '{0}' cannot include a default export declaration. Consider adding a separate 'export default {0}' declaration instead."),
        Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1: diag(2653, ts.DiagnosticCategory.Error, "Non_abstract_class_expression_does_not_implement_inherited_abstract_member_0_from_class_1_2653", "Non-abstract class expression does not implement inherited abstract member '{0}' from class '{1}'."),
        JSX_expressions_must_have_one_parent_element: diag(2657, ts.DiagnosticCategory.Error, "JSX_expressions_must_have_one_parent_element_2657", "JSX expressions must have one parent element."),
        Type_0_provides_no_match_for_the_signature_1: diag(2658, ts.DiagnosticCategory.Error, "Type_0_provides_no_match_for_the_signature_1_2658", "Type '{0}' provides no match for the signature '{1}'."),
        super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_higher: diag(2659, ts.DiagnosticCategory.Error, "super_is_only_allowed_in_members_of_object_literal_expressions_when_option_target_is_ES2015_or_highe_2659", "'super' is only allowed in members of object literal expressions when option 'target' is 'ES2015' or higher."),
        super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions: diag(2660, ts.DiagnosticCategory.Error, "super_can_only_be_referenced_in_members_of_derived_classes_or_object_literal_expressions_2660", "'super' can only be referenced in members of derived classes or object literal expressions."),
        Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module: diag(2661, ts.DiagnosticCategory.Error, "Cannot_export_0_Only_local_declarations_can_be_exported_from_a_module_2661", "Cannot export '{0}'. Only local declarations can be exported from a module."),
        Cannot_find_name_0_Did_you_mean_the_static_member_1_0: diag(2662, ts.DiagnosticCategory.Error, "Cannot_find_name_0_Did_you_mean_the_static_member_1_0_2662", "Cannot find name '{0}'. Did you mean the static member '{1}.{0}'?"),
        Cannot_find_name_0_Did_you_mean_the_instance_member_this_0: diag(2663, ts.DiagnosticCategory.Error, "Cannot_find_name_0_Did_you_mean_the_instance_member_this_0_2663", "Cannot find name '{0}'. Did you mean the instance member 'this.{0}'?"),
        Invalid_module_name_in_augmentation_module_0_cannot_be_found: diag(2664, ts.DiagnosticCategory.Error, "Invalid_module_name_in_augmentation_module_0_cannot_be_found_2664", "Invalid module name in augmentation, module '{0}' cannot be found."),
        Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augmented: diag(2665, ts.DiagnosticCategory.Error, "Invalid_module_name_in_augmentation_Module_0_resolves_to_an_untyped_module_at_1_which_cannot_be_augm_2665", "Invalid module name in augmentation. Module '{0}' resolves to an untyped module at '{1}', which cannot be augmented."),
        Exports_and_export_assignments_are_not_permitted_in_module_augmentations: diag(2666, ts.DiagnosticCategory.Error, "Exports_and_export_assignments_are_not_permitted_in_module_augmentations_2666", "Exports and export assignments are not permitted in module augmentations."),
        Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_module: diag(2667, ts.DiagnosticCategory.Error, "Imports_are_not_permitted_in_module_augmentations_Consider_moving_them_to_the_enclosing_external_mod_2667", "Imports are not permitted in module augmentations. Consider moving them to the enclosing external module."),
        export_modifier_cannot_be_applied_to_ambient_modules_and_module_augmentations_since_they_are_always_visible: diag(2668, ts.DiagnosticCategory.Error, "export_modifier_cannot_be_applied_to_ambient_modules_and_module_augmentations_since_they_are_always__2668", "'export' modifier cannot be applied to ambient modules and module augmentations since they are always visible."),
        Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_declarations: diag(2669, ts.DiagnosticCategory.Error, "Augmentations_for_the_global_scope_can_only_be_directly_nested_in_external_modules_or_ambient_module_2669", "Augmentations for the global scope can only be directly nested in external modules or ambient module declarations."),
        Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambient_context: diag(2670, ts.DiagnosticCategory.Error, "Augmentations_for_the_global_scope_should_have_declare_modifier_unless_they_appear_in_already_ambien_2670", "Augmentations for the global scope should have 'declare' modifier unless they appear in already ambient context."),
        Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity: diag(2671, ts.DiagnosticCategory.Error, "Cannot_augment_module_0_because_it_resolves_to_a_non_module_entity_2671", "Cannot augment module '{0}' because it resolves to a non-module entity."),
        Cannot_assign_a_0_constructor_type_to_a_1_constructor_type: diag(2672, ts.DiagnosticCategory.Error, "Cannot_assign_a_0_constructor_type_to_a_1_constructor_type_2672", "Cannot assign a '{0}' constructor type to a '{1}' constructor type."),
        Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration: diag(2673, ts.DiagnosticCategory.Error, "Constructor_of_class_0_is_private_and_only_accessible_within_the_class_declaration_2673", "Constructor of class '{0}' is private and only accessible within the class declaration."),
        Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration: diag(2674, ts.DiagnosticCategory.Error, "Constructor_of_class_0_is_protected_and_only_accessible_within_the_class_declaration_2674", "Constructor of class '{0}' is protected and only accessible within the class declaration."),
        Cannot_extend_a_class_0_Class_constructor_is_marked_as_private: diag(2675, ts.DiagnosticCategory.Error, "Cannot_extend_a_class_0_Class_constructor_is_marked_as_private_2675", "Cannot extend a class '{0}'. Class constructor is marked as private."),
        Accessors_must_both_be_abstract_or_non_abstract: diag(2676, ts.DiagnosticCategory.Error, "Accessors_must_both_be_abstract_or_non_abstract_2676", "Accessors must both be abstract or non-abstract."),
        A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type: diag(2677, ts.DiagnosticCategory.Error, "A_type_predicate_s_type_must_be_assignable_to_its_parameter_s_type_2677", "A type predicate's type must be assignable to its parameter's type."),
        Type_0_is_not_comparable_to_type_1: diag(2678, ts.DiagnosticCategory.Error, "Type_0_is_not_comparable_to_type_1_2678", "Type '{0}' is not comparable to type '{1}'."),
        A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void: diag(2679, ts.DiagnosticCategory.Error, "A_function_that_is_called_with_the_new_keyword_cannot_have_a_this_type_that_is_void_2679", "A function that is called with the 'new' keyword cannot have a 'this' type that is 'void'."),
        A_0_parameter_must_be_the_first_parameter: diag(2680, ts.DiagnosticCategory.Error, "A_0_parameter_must_be_the_first_parameter_2680", "A '{0}' parameter must be the first parameter."),
        A_constructor_cannot_have_a_this_parameter: diag(2681, ts.DiagnosticCategory.Error, "A_constructor_cannot_have_a_this_parameter_2681", "A constructor cannot have a 'this' parameter."),
        this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation: diag(2683, ts.DiagnosticCategory.Error, "this_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_2683", "'this' implicitly has type 'any' because it does not have a type annotation."),
        The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1: diag(2684, ts.DiagnosticCategory.Error, "The_this_context_of_type_0_is_not_assignable_to_method_s_this_of_type_1_2684", "The 'this' context of type '{0}' is not assignable to method's 'this' of type '{1}'."),
        The_this_types_of_each_signature_are_incompatible: diag(2685, ts.DiagnosticCategory.Error, "The_this_types_of_each_signature_are_incompatible_2685", "The 'this' types of each signature are incompatible."),
        _0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead: diag(2686, ts.DiagnosticCategory.Error, "_0_refers_to_a_UMD_global_but_the_current_file_is_a_module_Consider_adding_an_import_instead_2686", "'{0}' refers to a UMD global, but the current file is a module. Consider adding an import instead."),
        All_declarations_of_0_must_have_identical_modifiers: diag(2687, ts.DiagnosticCategory.Error, "All_declarations_of_0_must_have_identical_modifiers_2687", "All declarations of '{0}' must have identical modifiers."),
        Cannot_find_type_definition_file_for_0: diag(2688, ts.DiagnosticCategory.Error, "Cannot_find_type_definition_file_for_0_2688", "Cannot find type definition file for '{0}'."),
        Cannot_extend_an_interface_0_Did_you_mean_implements: diag(2689, ts.DiagnosticCategory.Error, "Cannot_extend_an_interface_0_Did_you_mean_implements_2689", "Cannot extend an interface '{0}'. Did you mean 'implements'?"),
        _0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0: diag(2690, ts.DiagnosticCategory.Error, "_0_only_refers_to_a_type_but_is_being_used_as_a_value_here_Did_you_mean_to_use_1_in_0_2690", "'{0}' only refers to a type, but is being used as a value here. Did you mean to use '{1} in {0}'?"),
        An_import_path_cannot_end_with_a_0_extension_Consider_importing_1_instead: diag(2691, ts.DiagnosticCategory.Error, "An_import_path_cannot_end_with_a_0_extension_Consider_importing_1_instead_2691", "An import path cannot end with a '{0}' extension. Consider importing '{1}' instead."),
        _0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible: diag(2692, ts.DiagnosticCategory.Error, "_0_is_a_primitive_but_1_is_a_wrapper_object_Prefer_using_0_when_possible_2692", "'{0}' is a primitive, but '{1}' is a wrapper object. Prefer using '{0}' when possible."),
        _0_only_refers_to_a_type_but_is_being_used_as_a_value_here: diag(2693, ts.DiagnosticCategory.Error, "_0_only_refers_to_a_type_but_is_being_used_as_a_value_here_2693", "'{0}' only refers to a type, but is being used as a value here."),
        Namespace_0_has_no_exported_member_1: diag(2694, ts.DiagnosticCategory.Error, "Namespace_0_has_no_exported_member_1_2694", "Namespace '{0}' has no exported member '{1}'."),
        Left_side_of_comma_operator_is_unused_and_has_no_side_effects: diag(2695, ts.DiagnosticCategory.Error, "Left_side_of_comma_operator_is_unused_and_has_no_side_effects_2695", "Left side of comma operator is unused and has no side effects.", /*reportsUnnecessary*/ true),
        The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead: diag(2696, ts.DiagnosticCategory.Error, "The_Object_type_is_assignable_to_very_few_other_types_Did_you_mean_to_use_the_any_type_instead_2696", "The 'Object' type is assignable to very few other types. Did you mean to use the 'any' type instead?"),
        An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option: diag(2697, ts.DiagnosticCategory.Error, "An_async_function_or_method_must_return_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_in_2697", "An async function or method must return a 'Promise'. Make sure you have a declaration for 'Promise' or include 'ES2015' in your '--lib' option."),
        Spread_types_may_only_be_created_from_object_types: diag(2698, ts.DiagnosticCategory.Error, "Spread_types_may_only_be_created_from_object_types_2698", "Spread types may only be created from object types."),
        Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1: diag(2699, ts.DiagnosticCategory.Error, "Static_property_0_conflicts_with_built_in_property_Function_0_of_constructor_function_1_2699", "Static property '{0}' conflicts with built-in property 'Function.{0}' of constructor function '{1}'."),
        Rest_types_may_only_be_created_from_object_types: diag(2700, ts.DiagnosticCategory.Error, "Rest_types_may_only_be_created_from_object_types_2700", "Rest types may only be created from object types."),
        The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access: diag(2701, ts.DiagnosticCategory.Error, "The_target_of_an_object_rest_assignment_must_be_a_variable_or_a_property_access_2701", "The target of an object rest assignment must be a variable or a property access."),
        _0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here: diag(2702, ts.DiagnosticCategory.Error, "_0_only_refers_to_a_type_but_is_being_used_as_a_namespace_here_2702", "'{0}' only refers to a type, but is being used as a namespace here."),
        The_operand_of_a_delete_operator_must_be_a_property_reference: diag(2703, ts.DiagnosticCategory.Error, "The_operand_of_a_delete_operator_must_be_a_property_reference_2703", "The operand of a 'delete' operator must be a property reference."),
        The_operand_of_a_delete_operator_cannot_be_a_read_only_property: diag(2704, ts.DiagnosticCategory.Error, "The_operand_of_a_delete_operator_cannot_be_a_read_only_property_2704", "The operand of a 'delete' operator cannot be a read-only property."),
        An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option: diag(2705, ts.DiagnosticCategory.Error, "An_async_function_or_method_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_de_2705", "An async function or method in ES5/ES3 requires the 'Promise' constructor.  Make sure you have a declaration for the 'Promise' constructor or include 'ES2015' in your '--lib' option."),
        Required_type_parameters_may_not_follow_optional_type_parameters: diag(2706, ts.DiagnosticCategory.Error, "Required_type_parameters_may_not_follow_optional_type_parameters_2706", "Required type parameters may not follow optional type parameters."),
        Generic_type_0_requires_between_1_and_2_type_arguments: diag(2707, ts.DiagnosticCategory.Error, "Generic_type_0_requires_between_1_and_2_type_arguments_2707", "Generic type '{0}' requires between {1} and {2} type arguments."),
        Cannot_use_namespace_0_as_a_value: diag(2708, ts.DiagnosticCategory.Error, "Cannot_use_namespace_0_as_a_value_2708", "Cannot use namespace '{0}' as a value."),
        Cannot_use_namespace_0_as_a_type: diag(2709, ts.DiagnosticCategory.Error, "Cannot_use_namespace_0_as_a_type_2709", "Cannot use namespace '{0}' as a type."),
        _0_are_specified_twice_The_attribute_named_0_will_be_overwritten: diag(2710, ts.DiagnosticCategory.Error, "_0_are_specified_twice_The_attribute_named_0_will_be_overwritten_2710", "'{0}' are specified twice. The attribute named '{0}' will be overwritten."),
        A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES2015_in_your_lib_option: diag(2711, ts.DiagnosticCategory.Error, "A_dynamic_import_call_returns_a_Promise_Make_sure_you_have_a_declaration_for_Promise_or_include_ES20_2711", "A dynamic import call returns a 'Promise'. Make sure you have a declaration for 'Promise' or include 'ES2015' in your '--lib' option."),
        A_dynamic_import_call_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declaration_for_the_Promise_constructor_or_include_ES2015_in_your_lib_option: diag(2712, ts.DiagnosticCategory.Error, "A_dynamic_import_call_in_ES5_SlashES3_requires_the_Promise_constructor_Make_sure_you_have_a_declarat_2712", "A dynamic import call in ES5/ES3 requires the 'Promise' constructor.  Make sure you have a declaration for the 'Promise' constructor or include 'ES2015' in your '--lib' option."),
        Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_property_1_in_0_with_0_1: diag(2713, ts.DiagnosticCategory.Error, "Cannot_access_0_1_because_0_is_a_type_but_not_a_namespace_Did_you_mean_to_retrieve_the_type_of_the_p_2713", "Cannot access '{0}.{1}' because '{0}' is a type, but not a namespace. Did you mean to retrieve the type of the property '{1}' in '{0}' with '{0}[\"{1}\"]'?"),
        The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context: diag(2714, ts.DiagnosticCategory.Error, "The_expression_of_an_export_assignment_must_be_an_identifier_or_qualified_name_in_an_ambient_context_2714", "The expression of an export assignment must be an identifier or qualified name in an ambient context."),
        Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor: diag(2715, ts.DiagnosticCategory.Error, "Abstract_property_0_in_class_1_cannot_be_accessed_in_the_constructor_2715", "Abstract property '{0}' in class '{1}' cannot be accessed in the constructor."),
        Type_parameter_0_has_a_circular_default: diag(2716, ts.DiagnosticCategory.Error, "Type_parameter_0_has_a_circular_default_2716", "Type parameter '{0}' has a circular default."),
        Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_type_2: diag(2717, ts.DiagnosticCategory.Error, "Subsequent_property_declarations_must_have_the_same_type_Property_0_must_be_of_type_1_but_here_has_t_2717", "Subsequent property declarations must have the same type.  Property '{0}' must be of type '{1}', but here has type '{2}'."),
        Duplicate_property_0: diag(2718, ts.DiagnosticCategory.Error, "Duplicate_property_0_2718", "Duplicate property '{0}'."),
        Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated: diag(2719, ts.DiagnosticCategory.Error, "Type_0_is_not_assignable_to_type_1_Two_different_types_with_this_name_exist_but_they_are_unrelated_2719", "Type '{0}' is not assignable to type '{1}'. Two different types with this name exist, but they are unrelated."),
        Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclass: diag(2720, ts.DiagnosticCategory.Error, "Class_0_incorrectly_implements_class_1_Did_you_mean_to_extend_1_and_inherit_its_members_as_a_subclas_2720", "Class '{0}' incorrectly implements class '{1}'. Did you mean to extend '{1}' and inherit its members as a subclass?"),
        Cannot_invoke_an_object_which_is_possibly_null: diag(2721, ts.DiagnosticCategory.Error, "Cannot_invoke_an_object_which_is_possibly_null_2721", "Cannot invoke an object which is possibly 'null'."),
        Cannot_invoke_an_object_which_is_possibly_undefined: diag(2722, ts.DiagnosticCategory.Error, "Cannot_invoke_an_object_which_is_possibly_undefined_2722", "Cannot invoke an object which is possibly 'undefined'."),
        Cannot_invoke_an_object_which_is_possibly_null_or_undefined: diag(2723, ts.DiagnosticCategory.Error, "Cannot_invoke_an_object_which_is_possibly_null_or_undefined_2723", "Cannot invoke an object which is possibly 'null' or 'undefined'."),
        _0_has_no_exported_member_named_1_Did_you_mean_2: diag(2724, ts.DiagnosticCategory.Error, "_0_has_no_exported_member_named_1_Did_you_mean_2_2724", "'{0}' has no exported member named '{1}'. Did you mean '{2}'?"),
        Class_name_cannot_be_Object_when_targeting_ES5_with_module_0: diag(2725, ts.DiagnosticCategory.Error, "Class_name_cannot_be_Object_when_targeting_ES5_with_module_0_2725", "Class name cannot be 'Object' when targeting ES5 with module {0}."),
        Cannot_find_lib_definition_for_0: diag(2726, ts.DiagnosticCategory.Error, "Cannot_find_lib_definition_for_0_2726", "Cannot find lib definition for '{0}'."),
        Cannot_find_lib_definition_for_0_Did_you_mean_1: diag(2727, ts.DiagnosticCategory.Error, "Cannot_find_lib_definition_for_0_Did_you_mean_1_2727", "Cannot find lib definition for '{0}'. Did you mean '{1}'?"),
        _0_is_declared_here: diag(2728, ts.DiagnosticCategory.Message, "_0_is_declared_here_2728", "'{0}' is declared here."),
        Property_0_is_used_before_its_initialization: diag(2729, ts.DiagnosticCategory.Error, "Property_0_is_used_before_its_initialization_2729", "Property '{0}' is used before its initialization."),
        An_arrow_function_cannot_have_a_this_parameter: diag(2730, ts.DiagnosticCategory.Error, "An_arrow_function_cannot_have_a_this_parameter_2730", "An arrow function cannot have a 'this' parameter."),
        Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_in_String: diag(2731, ts.DiagnosticCategory.Error, "Implicit_conversion_of_a_symbol_to_a_string_will_fail_at_runtime_Consider_wrapping_this_expression_i_2731", "Implicit conversion of a 'symbol' to a 'string' will fail at runtime. Consider wrapping this expression in 'String(...)'."),
        Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension: diag(2732, ts.DiagnosticCategory.Error, "Cannot_find_module_0_Consider_using_resolveJsonModule_to_import_module_with_json_extension_2732", "Cannot find module '{0}'. Consider using '--resolveJsonModule' to import module with '.json' extension."),
        Property_0_was_also_declared_here: diag(2733, ts.DiagnosticCategory.Error, "Property_0_was_also_declared_here_2733", "Property '{0}' was also declared here."),
        Are_you_missing_a_semicolon: diag(2734, ts.DiagnosticCategory.Error, "Are_you_missing_a_semicolon_2734", "Are you missing a semicolon?"),
        Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1: diag(2735, ts.DiagnosticCategory.Error, "Did_you_mean_for_0_to_be_constrained_to_type_new_args_Colon_any_1_2735", "Did you mean for '{0}' to be constrained to type 'new (...args: any[]) => {1}'?"),
        Operator_0_cannot_be_applied_to_type_1: diag(2736, ts.DiagnosticCategory.Error, "Operator_0_cannot_be_applied_to_type_1_2736", "Operator '{0}' cannot be applied to type '{1}'."),
        BigInt_literals_are_not_available_when_targeting_lower_than_ES2020: diag(2737, ts.DiagnosticCategory.Error, "BigInt_literals_are_not_available_when_targeting_lower_than_ES2020_2737", "BigInt literals are not available when targeting lower than ES2020."),
        An_outer_value_of_this_is_shadowed_by_this_container: diag(2738, ts.DiagnosticCategory.Message, "An_outer_value_of_this_is_shadowed_by_this_container_2738", "An outer value of 'this' is shadowed by this container."),
        Type_0_is_missing_the_following_properties_from_type_1_Colon_2: diag(2739, ts.DiagnosticCategory.Error, "Type_0_is_missing_the_following_properties_from_type_1_Colon_2_2739", "Type '{0}' is missing the following properties from type '{1}': {2}"),
        Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more: diag(2740, ts.DiagnosticCategory.Error, "Type_0_is_missing_the_following_properties_from_type_1_Colon_2_and_3_more_2740", "Type '{0}' is missing the following properties from type '{1}': {2}, and {3} more."),
        Property_0_is_missing_in_type_1_but_required_in_type_2: diag(2741, ts.DiagnosticCategory.Error, "Property_0_is_missing_in_type_1_but_required_in_type_2_2741", "Property '{0}' is missing in type '{1}' but required in type '{2}'."),
        The_inferred_type_of_0_cannot_be_named_without_a_reference_to_1_This_is_likely_not_portable_A_type_annotation_is_necessary: diag(2742, ts.DiagnosticCategory.Error, "The_inferred_type_of_0_cannot_be_named_without_a_reference_to_1_This_is_likely_not_portable_A_type_a_2742", "The inferred type of '{0}' cannot be named without a reference to '{1}'. This is likely not portable. A type annotation is necessary."),
        No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments: diag(2743, ts.DiagnosticCategory.Error, "No_overload_expects_0_type_arguments_but_overloads_do_exist_that_expect_either_1_or_2_type_arguments_2743", "No overload expects {0} type arguments, but overloads do exist that expect either {1} or {2} type arguments."),
        Type_parameter_defaults_can_only_reference_previously_declared_type_parameters: diag(2744, ts.DiagnosticCategory.Error, "Type_parameter_defaults_can_only_reference_previously_declared_type_parameters_2744", "Type parameter defaults can only reference previously declared type parameters."),
        This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_provided: diag(2745, ts.DiagnosticCategory.Error, "This_JSX_tag_s_0_prop_expects_type_1_which_requires_multiple_children_but_only_a_single_child_was_pr_2745", "This JSX tag's '{0}' prop expects type '{1}' which requires multiple children, but only a single child was provided."),
        This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided: diag(2746, ts.DiagnosticCategory.Error, "This_JSX_tag_s_0_prop_expects_a_single_child_of_type_1_but_multiple_children_were_provided_2746", "This JSX tag's '{0}' prop expects a single child of type '{1}', but multiple children were provided."),
        _0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_type_of_1_is_2: diag(2747, ts.DiagnosticCategory.Error, "_0_components_don_t_accept_text_as_child_elements_Text_in_JSX_has_the_type_string_but_the_expected_t_2747", "'{0}' components don't accept text as child elements. Text in JSX has the type 'string', but the expected type of '{1}' is '{2}'."),
        Cannot_access_ambient_const_enums_when_the_isolatedModules_flag_is_provided: diag(2748, ts.DiagnosticCategory.Error, "Cannot_access_ambient_const_enums_when_the_isolatedModules_flag_is_provided_2748", "Cannot access ambient const enums when the '--isolatedModules' flag is provided."),
        _0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0: diag(2749, ts.DiagnosticCategory.Error, "_0_refers_to_a_value_but_is_being_used_as_a_type_here_Did_you_mean_typeof_0_2749", "'{0}' refers to a value, but is being used as a type here. Did you mean 'typeof {0}'?"),
        The_implementation_signature_is_declared_here: diag(2750, ts.DiagnosticCategory.Error, "The_implementation_signature_is_declared_here_2750", "The implementation signature is declared here."),
        Circularity_originates_in_type_at_this_location: diag(2751, ts.DiagnosticCategory.Error, "Circularity_originates_in_type_at_this_location_2751", "Circularity originates in type at this location."),
        The_first_export_default_is_here: diag(2752, ts.DiagnosticCategory.Error, "The_first_export_default_is_here_2752", "The first export default is here."),
        Another_export_default_is_here: diag(2753, ts.DiagnosticCategory.Error, "Another_export_default_is_here_2753", "Another export default is here."),
        super_may_not_use_type_arguments: diag(2754, ts.DiagnosticCategory.Error, "super_may_not_use_type_arguments_2754", "'super' may not use type arguments."),
        No_constituent_of_type_0_is_callable: diag(2755, ts.DiagnosticCategory.Error, "No_constituent_of_type_0_is_callable_2755", "No constituent of type '{0}' is callable."),
        Not_all_constituents_of_type_0_are_callable: diag(2756, ts.DiagnosticCategory.Error, "Not_all_constituents_of_type_0_are_callable_2756", "Not all constituents of type '{0}' are callable."),
        Type_0_has_no_call_signatures: diag(2757, ts.DiagnosticCategory.Error, "Type_0_has_no_call_signatures_2757", "Type '{0}' has no call signatures."),
        Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_other: diag(2758, ts.DiagnosticCategory.Error, "Each_member_of_the_union_type_0_has_signatures_but_none_of_those_signatures_are_compatible_with_each_2758", "Each member of the union type '{0}' has signatures, but none of those signatures are compatible with each other."),
        No_constituent_of_type_0_is_constructable: diag(2759, ts.DiagnosticCategory.Error, "No_constituent_of_type_0_is_constructable_2759", "No constituent of type '{0}' is constructable."),
        Not_all_constituents_of_type_0_are_constructable: diag(2760, ts.DiagnosticCategory.Error, "Not_all_constituents_of_type_0_are_constructable_2760", "Not all constituents of type '{0}' are constructable."),
        Type_0_has_no_construct_signatures: diag(2761, ts.DiagnosticCategory.Error, "Type_0_has_no_construct_signatures_2761", "Type '{0}' has no construct signatures."),
        Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_with_each_other: diag(2762, ts.DiagnosticCategory.Error, "Each_member_of_the_union_type_0_has_construct_signatures_but_none_of_those_signatures_are_compatible_2762", "Each member of the union type '{0}' has construct signatures, but none of those signatures are compatible with each other."),
        Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_send_0: diag(2763, ts.DiagnosticCategory.Error, "Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_for_of_will_always_s_2763", "Cannot iterate value because the 'next' method of its iterator expects type '{1}', but for-of will always send '{0}'."),
        Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_always_send_0: diag(2764, ts.DiagnosticCategory.Error, "Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_spread_will_al_2764", "Cannot iterate value because the 'next' method of its iterator expects type '{1}', but array spread will always send '{0}'."),
        Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring_will_always_send_0: diag(2765, ts.DiagnosticCategory.Error, "Cannot_iterate_value_because_the_next_method_of_its_iterator_expects_type_1_but_array_destructuring__2765", "Cannot iterate value because the 'next' method of its iterator expects type '{1}', but array destructuring will always send '{0}'."),
        Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_containing_generator_will_always_send_0: diag(2766, ts.DiagnosticCategory.Error, "Cannot_delegate_iteration_to_value_because_the_next_method_of_its_iterator_expects_type_1_but_the_co_2766", "Cannot delegate iteration to value because the 'next' method of its iterator expects type '{1}', but the containing generator will always send '{0}'."),
        The_0_property_of_an_iterator_must_be_a_method: diag(2767, ts.DiagnosticCategory.Error, "The_0_property_of_an_iterator_must_be_a_method_2767", "The '{0}' property of an iterator must be a method."),
        The_0_property_of_an_async_iterator_must_be_a_method: diag(2768, ts.DiagnosticCategory.Error, "The_0_property_of_an_async_iterator_must_be_a_method_2768", "The '{0}' property of an async iterator must be a method."),
        No_overload_matches_this_call: diag(2769, ts.DiagnosticCategory.Error, "No_overload_matches_this_call_2769", "No overload matches this call."),
        The_last_overload_gave_the_following_error: diag(2770, ts.DiagnosticCategory.Error, "The_last_overload_gave_the_following_error_2770", "The last overload gave the following error."),
        The_last_overload_is_declared_here: diag(2771, ts.DiagnosticCategory.Error, "The_last_overload_is_declared_here_2771", "The last overload is declared here."),
        Overload_0_of_1_2_gave_the_following_error: diag(2772, ts.DiagnosticCategory.Error, "Overload_0_of_1_2_gave_the_following_error_2772", "Overload {0} of {1}, '{2}', gave the following error."),
        Did_you_forget_to_use_await: diag(2773, ts.DiagnosticCategory.Error, "Did_you_forget_to_use_await_2773", "Did you forget to use 'await'?"),
        This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_instead: diag(2774, ts.DiagnosticCategory.Error, "This_condition_will_always_return_true_since_this_function_is_always_defined_Did_you_mean_to_call_it_2774", "This condition will always return true since this function is always defined. Did you mean to call it instead?"),
        Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation: diag(2775, ts.DiagnosticCategory.Error, "Assertions_require_every_name_in_the_call_target_to_be_declared_with_an_explicit_type_annotation_2775", "Assertions require every name in the call target to be declared with an explicit type annotation."),
        Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name: diag(2776, ts.DiagnosticCategory.Error, "Assertions_require_the_call_target_to_be_an_identifier_or_qualified_name_2776", "Assertions require the call target to be an identifier or qualified name."),
        The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access: diag(2777, ts.DiagnosticCategory.Error, "The_operand_of_an_increment_or_decrement_operator_may_not_be_an_optional_property_access_2777", "The operand of an increment or decrement operator may not be an optional property access."),
        The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access: diag(2778, ts.DiagnosticCategory.Error, "The_target_of_an_object_rest_assignment_may_not_be_an_optional_property_access_2778", "The target of an object rest assignment may not be an optional property access."),
        The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access: diag(2779, ts.DiagnosticCategory.Error, "The_left_hand_side_of_an_assignment_expression_may_not_be_an_optional_property_access_2779", "The left-hand side of an assignment expression may not be an optional property access."),
        The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access: diag(2780, ts.DiagnosticCategory.Error, "The_left_hand_side_of_a_for_in_statement_may_not_be_an_optional_property_access_2780", "The left-hand side of a 'for...in' statement may not be an optional property access."),
        The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access: diag(2781, ts.DiagnosticCategory.Error, "The_left_hand_side_of_a_for_of_statement_may_not_be_an_optional_property_access_2781", "The left-hand side of a 'for...of' statement may not be an optional property access."),
        _0_needs_an_explicit_type_annotation: diag(2782, ts.DiagnosticCategory.Message, "_0_needs_an_explicit_type_annotation_2782", "'{0}' needs an explicit type annotation."),
        _0_is_specified_more_than_once_so_this_usage_will_be_overwritten: diag(2783, ts.DiagnosticCategory.Error, "_0_is_specified_more_than_once_so_this_usage_will_be_overwritten_2783", "'{0}' is specified more than once, so this usage will be overwritten."),
        get_and_set_accessors_cannot_declare_this_parameters: diag(2784, ts.DiagnosticCategory.Error, "get_and_set_accessors_cannot_declare_this_parameters_2784", "'get' and 'set' accessors cannot declare 'this' parameters."),
        This_spread_always_overwrites_this_property: diag(2785, ts.DiagnosticCategory.Error, "This_spread_always_overwrites_this_property_2785", "This spread always overwrites this property."),
        _0_cannot_be_used_as_a_JSX_component: diag(2786, ts.DiagnosticCategory.Error, "_0_cannot_be_used_as_a_JSX_component_2786", "'{0}' cannot be used as a JSX component."),
        Its_return_type_0_is_not_a_valid_JSX_element: diag(2787, ts.DiagnosticCategory.Error, "Its_return_type_0_is_not_a_valid_JSX_element_2787", "Its return type '{0}' is not a valid JSX element."),
        Its_instance_type_0_is_not_a_valid_JSX_element: diag(2788, ts.DiagnosticCategory.Error, "Its_instance_type_0_is_not_a_valid_JSX_element_2788", "Its instance type '{0}' is not a valid JSX element."),
        Its_element_type_0_is_not_a_valid_JSX_element: diag(2789, ts.DiagnosticCategory.Error, "Its_element_type_0_is_not_a_valid_JSX_element_2789", "Its element type '{0}' is not a valid JSX element."),
        The_operand_of_a_delete_operator_must_be_optional: diag(2790, ts.DiagnosticCategory.Error, "The_operand_of_a_delete_operator_must_be_optional_2790", "The operand of a 'delete' operator must be optional."),
        Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_later: diag(2791, ts.DiagnosticCategory.Error, "Exponentiation_cannot_be_performed_on_bigint_values_unless_the_target_option_is_set_to_es2016_or_lat_2791", "Exponentiation cannot be performed on 'bigint' values unless the 'target' option is set to 'es2016' or later."),
        Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_node_or_to_add_aliases_to_the_paths_option: diag(2792, ts.DiagnosticCategory.Error, "Cannot_find_module_0_Did_you_mean_to_set_the_moduleResolution_option_to_node_or_to_add_aliases_to_th_2792", "Cannot find module '{0}'. Did you mean to set the 'moduleResolution' option to 'node', or to add aliases to the 'paths' option?"),
        The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_are_not_externally_visible: diag(2793, ts.DiagnosticCategory.Error, "The_call_would_have_succeeded_against_this_implementation_but_implementation_signatures_of_overloads_2793", "The call would have succeeded against this implementation, but implementation signatures of overloads are not externally visible."),
        Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise: diag(2794, ts.DiagnosticCategory.Error, "Expected_0_arguments_but_got_1_Did_you_forget_to_include_void_in_your_type_argument_to_Promise_2794", "Expected {0} arguments, but got {1}. Did you forget to include 'void' in your type argument to 'Promise'?"),
        The_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types: diag(2795, ts.DiagnosticCategory.Error, "The_intrinsic_keyword_can_only_be_used_to_declare_compiler_provided_intrinsic_types_2795", "The 'intrinsic' keyword can only be used to declare compiler provided intrinsic types."),
        It_is_likely_that_you_are_missing_a_comma_to_separate_these_two_template_expressions_They_form_a_tagged_template_expression_which_cannot_be_invoked: diag(2796, ts.DiagnosticCategory.Error, "It_is_likely_that_you_are_missing_a_comma_to_separate_these_two_template_expressions_They_form_a_tag_2796", "It is likely that you are missing a comma to separate these two template expressions. They form a tagged template expression which cannot be invoked."),
        A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_be_declared_abstract: diag(2797, ts.DiagnosticCategory.Error, "A_mixin_class_that_extends_from_a_type_variable_containing_an_abstract_construct_signature_must_also_2797", "A mixin class that extends from a type variable containing an abstract construct signature must also be declared 'abstract'."),
        The_declaration_was_marked_as_deprecated_here: diag(2798, ts.DiagnosticCategory.Error, "The_declaration_was_marked_as_deprecated_here_2798", "The declaration was marked as deprecated here."),
        Type_produces_a_tuple_type_that_is_too_large_to_represent: diag(2799, ts.DiagnosticCategory.Error, "Type_produces_a_tuple_type_that_is_too_large_to_represent_2799", "Type produces a tuple type that is too large to represent."),
        Expression_produces_a_tuple_type_that_is_too_large_to_represent: diag(2800, ts.DiagnosticCategory.Error, "Expression_produces_a_tuple_type_that_is_too_large_to_represent_2800", "Expression produces a tuple type that is too large to represent."),
        This_condition_will_always_return_true_since_this_0_is_always_defined: diag(2801, ts.DiagnosticCategory.Error, "This_condition_will_always_return_true_since_this_0_is_always_defined_2801", "This condition will always return true since this '{0}' is always defined."),
        Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es2015_or_higher: diag(2802, ts.DiagnosticCategory.Error, "Type_0_can_only_be_iterated_through_when_using_the_downlevelIteration_flag_or_with_a_target_of_es201_2802", "Type '{0}' can only be iterated through when using the '--downlevelIteration' flag or with a '--target' of 'es2015' or higher."),
        Cannot_assign_to_private_method_0_Private_methods_are_not_writable: diag(2803, ts.DiagnosticCategory.Error, "Cannot_assign_to_private_method_0_Private_methods_are_not_writable_2803", "Cannot assign to private method '{0}'. Private methods are not writable."),
        Duplicate_identifier_0_Static_and_instance_elements_cannot_share_the_same_private_name: diag(2804, ts.DiagnosticCategory.Error, "Duplicate_identifier_0_Static_and_instance_elements_cannot_share_the_same_private_name_2804", "Duplicate identifier '{0}'. Static and instance elements cannot share the same private name."),
        Private_accessor_was_defined_without_a_getter: diag(2806, ts.DiagnosticCategory.Error, "Private_accessor_was_defined_without_a_getter_2806", "Private accessor was defined without a getter."),
        This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_one_in_0_Consider_upgrading_your_version_of_0: diag(2807, ts.DiagnosticCategory.Error, "This_syntax_requires_an_imported_helper_named_1_with_2_parameters_which_is_not_compatible_with_the_o_2807", "This syntax requires an imported helper named '{1}' with {2} parameters, which is not compatible with the one in '{0}'. Consider upgrading your version of '{0}'."),
        A_get_accessor_must_be_at_least_as_accessible_as_the_setter: diag(2808, ts.DiagnosticCategory.Error, "A_get_accessor_must_be_at_least_as_accessible_as_the_setter_2808", "A get accessor must be at least as accessible as the setter"),
        Declaration_or_statement_expected_This_follows_a_block_of_statements_so_if_you_intended_to_write_a_destructuring_assignment_you_might_need_to_wrap_the_the_whole_assignment_in_parentheses: diag(2809, ts.DiagnosticCategory.Error, "Declaration_or_statement_expected_This_follows_a_block_of_statements_so_if_you_intended_to_write_a_d_2809", "Declaration or statement expected. This '=' follows a block of statements, so if you intended to write a destructuring assignment, you might need to wrap the the whole assignment in parentheses."),
        Expected_1_argument_but_got_0_new_Promise_needs_a_JSDoc_hint_to_produce_a_resolve_that_can_be_called_without_arguments: diag(2810, ts.DiagnosticCategory.Error, "Expected_1_argument_but_got_0_new_Promise_needs_a_JSDoc_hint_to_produce_a_resolve_that_can_be_called_2810", "Expected 1 argument, but got 0. 'new Promise()' needs a JSDoc hint to produce a 'resolve' that can be called without arguments."),
        Initializer_for_property_0: diag(2811, ts.DiagnosticCategory.Error, "Initializer_for_property_0_2811", "Initializer for property '{0}'"),
        Property_0_does_not_exist_on_type_1_Try_changing_the_lib_compiler_option_to_include_dom: diag(2812, ts.DiagnosticCategory.Error, "Property_0_does_not_exist_on_type_1_Try_changing_the_lib_compiler_option_to_include_dom_2812", "Property '{0}' does not exist on type '{1}'. Try changing the 'lib' compiler option to include 'dom'."),
        Class_declaration_cannot_implement_overload_list_for_0: diag(2813, ts.DiagnosticCategory.Error, "Class_declaration_cannot_implement_overload_list_for_0_2813", "Class declaration cannot implement overload list for '{0}'."),
        Function_with_bodies_can_only_merge_with_classes_that_are_ambient: diag(2814, ts.DiagnosticCategory.Error, "Function_with_bodies_can_only_merge_with_classes_that_are_ambient_2814", "Function with bodies can only merge with classes that are ambient."),
        arguments_cannot_be_referenced_in_property_initializers: diag(2815, ts.DiagnosticCategory.Error, "arguments_cannot_be_referenced_in_property_initializers_2815", "'arguments' cannot be referenced in property initializers."),
        Cannot_use_this_in_a_static_property_initializer_of_a_decorated_class: diag(2816, ts.DiagnosticCategory.Error, "Cannot_use_this_in_a_static_property_initializer_of_a_decorated_class_2816", "Cannot use 'this' in a static property initializer of a decorated class."),
        Property_0_has_no_initializer_and_is_not_definitely_assigned_in_a_class_static_block: diag(2817, ts.DiagnosticCategory.Error, "Property_0_has_no_initializer_and_is_not_definitely_assigned_in_a_class_static_block_2817", "Property '{0}' has no initializer and is not definitely assigned in a class static block."),
        Duplicate_identifier_0_Compiler_reserves_name_1_when_emitting_super_references_in_static_initializers: diag(2818, ts.DiagnosticCategory.Error, "Duplicate_identifier_0_Compiler_reserves_name_1_when_emitting_super_references_in_static_initializer_2818", "Duplicate identifier '{0}'. Compiler reserves name '{1}' when emitting 'super' references in static initializers."),
        Namespace_name_cannot_be_0: diag(2819, ts.DiagnosticCategory.Error, "Namespace_name_cannot_be_0_2819", "Namespace name cannot be '{0}'."),
        Type_0_is_not_assignable_to_type_1_Did_you_mean_2: diag(2820, ts.DiagnosticCategory.Error, "Type_0_is_not_assignable_to_type_1_Did_you_mean_2_2820", "Type '{0}' is not assignable to type '{1}'. Did you mean '{2}'?"),
        Import_assertions_are_only_supported_when_the_module_option_is_set_to_esnext_or_nodenext: diag(2821, ts.DiagnosticCategory.Error, "Import_assertions_are_only_supported_when_the_module_option_is_set_to_esnext_or_nodenext_2821", "Import assertions are only supported when the '--module' option is set to 'esnext' or 'nodenext'."),
        Import_assertions_cannot_be_used_with_type_only_imports_or_exports: diag(2822, ts.DiagnosticCategory.Error, "Import_assertions_cannot_be_used_with_type_only_imports_or_exports_2822", "Import assertions cannot be used with type-only imports or exports."),
        Cannot_find_namespace_0_Did_you_mean_1: diag(2833, ts.DiagnosticCategory.Error, "Cannot_find_namespace_0_Did_you_mean_1_2833", "Cannot find namespace '{0}'. Did you mean '{1}'?"),
        Relative_import_paths_need_explicit_file_extensions_in_EcmaScript_imports_when_moduleResolution_is_node16_or_nodenext_Consider_adding_an_extension_to_the_import_path: diag(2834, ts.DiagnosticCategory.Error, "Relative_import_paths_need_explicit_file_extensions_in_EcmaScript_imports_when_moduleResolution_is_n_2834", "Relative import paths need explicit file extensions in EcmaScript imports when '--moduleResolution' is 'node16' or 'nodenext'. Consider adding an extension to the import path."),
        Relative_import_paths_need_explicit_file_extensions_in_EcmaScript_imports_when_moduleResolution_is_node16_or_nodenext_Did_you_mean_0: diag(2835, ts.DiagnosticCategory.Error, "Relative_import_paths_need_explicit_file_extensions_in_EcmaScript_imports_when_moduleResolution_is_n_2835", "Relative import paths need explicit file extensions in EcmaScript imports when '--moduleResolution' is 'node16' or 'nodenext'. Did you mean '{0}'?"),
        Import_assertions_are_not_allowed_on_statements_that_transpile_to_commonjs_require_calls: diag(2836, ts.DiagnosticCategory.Error, "Import_assertions_are_not_allowed_on_statements_that_transpile_to_commonjs_require_calls_2836", "Import assertions are not allowed on statements that transpile to commonjs 'require' calls."),
        Import_assertion_values_must_be_string_literal_expressions: diag(2837, ts.DiagnosticCategory.Error, "Import_assertion_values_must_be_string_literal_expressions_2837", "Import assertion values must be string literal expressions."),
        All_declarations_of_0_must_have_identical_constraints: diag(2838, ts.DiagnosticCategory.Error, "All_declarations_of_0_must_have_identical_constraints_2838", "All declarations of '{0}' must have identical constraints."),
        This_condition_will_always_return_0_since_JavaScript_compares_objects_by_reference_not_value: diag(2839, ts.DiagnosticCategory.Error, "This_condition_will_always_return_0_since_JavaScript_compares_objects_by_reference_not_value_2839", "This condition will always return '{0}' since JavaScript compares objects by reference, not value."),
        An_interface_cannot_extend_a_primitive_type_like_0_an_interface_can_only_extend_named_types_and_classes: diag(2840, ts.DiagnosticCategory.Error, "An_interface_cannot_extend_a_primitive_type_like_0_an_interface_can_only_extend_named_types_and_clas_2840", "An interface cannot extend a primitive type like '{0}'; an interface can only extend named types and classes"),
        The_type_of_this_expression_cannot_be_named_without_a_resolution_mode_assertion_which_is_an_unstable_feature_Use_nightly_TypeScript_to_silence_this_error_Try_updating_with_npm_install_D_typescript_next: diag(2841, ts.DiagnosticCategory.Error, "The_type_of_this_expression_cannot_be_named_without_a_resolution_mode_assertion_which_is_an_unstable_2841", "The type of this expression cannot be named without a 'resolution-mode' assertion, which is an unstable feature. Use nightly TypeScript to silence this error. Try updating with 'npm install -D typescript@next'."),
        _0_is_an_unused_renaming_of_1_Did_you_intend_to_use_it_as_a_type_annotation: diag(2842, ts.DiagnosticCategory.Error, "_0_is_an_unused_renaming_of_1_Did_you_intend_to_use_it_as_a_type_annotation_2842", "'{0}' is an unused renaming of '{1}'. Did you intend to use it as a type annotation?"),
        We_can_only_write_a_type_for_0_by_adding_a_type_for_the_entire_parameter_here: diag(2843, ts.DiagnosticCategory.Error, "We_can_only_write_a_type_for_0_by_adding_a_type_for_the_entire_parameter_here_2843", "We can only write a type for '{0}' by adding a type for the entire parameter here."),
        Type_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor: diag(2844, ts.DiagnosticCategory.Error, "Type_of_instance_member_variable_0_cannot_reference_identifier_1_declared_in_the_constructor_2844", "Type of instance member variable '{0}' cannot reference identifier '{1}' declared in the constructor."),
        Import_declaration_0_is_using_private_name_1: diag(4000, ts.DiagnosticCategory.Error, "Import_declaration_0_is_using_private_name_1_4000", "Import declaration '{0}' is using private name '{1}'."),
        Type_parameter_0_of_exported_class_has_or_is_using_private_name_1: diag(4002, ts.DiagnosticCategory.Error, "Type_parameter_0_of_exported_class_has_or_is_using_private_name_1_4002", "Type parameter '{0}' of exported class has or is using private name '{1}'."),
        Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1: diag(4004, ts.DiagnosticCategory.Error, "Type_parameter_0_of_exported_interface_has_or_is_using_private_name_1_4004", "Type parameter '{0}' of exported interface has or is using private name '{1}'."),
        Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1: diag(4006, ts.DiagnosticCategory.Error, "Type_parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1_4006", "Type parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'."),
        Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1: diag(4008, ts.DiagnosticCategory.Error, "Type_parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1_4008", "Type parameter '{0}' of call signature from exported interface has or is using private name '{1}'."),
        Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1: diag(4010, ts.DiagnosticCategory.Error, "Type_parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1_4010", "Type parameter '{0}' of public static method from exported class has or is using private name '{1}'."),
        Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1: diag(4012, ts.DiagnosticCategory.Error, "Type_parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1_4012", "Type parameter '{0}' of public method from exported class has or is using private name '{1}'."),
        Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1: diag(4014, ts.DiagnosticCategory.Error, "Type_parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1_4014", "Type parameter '{0}' of method from exported interface has or is using private name '{1}'."),
        Type_parameter_0_of_exported_function_has_or_is_using_private_name_1: diag(4016, ts.DiagnosticCategory.Error, "Type_parameter_0_of_exported_function_has_or_is_using_private_name_1_4016", "Type parameter '{0}' of exported function has or is using private name '{1}'."),
        Implements_clause_of_exported_class_0_has_or_is_using_private_name_1: diag(4019, ts.DiagnosticCategory.Error, "Implements_clause_of_exported_class_0_has_or_is_using_private_name_1_4019", "Implements clause of exported class '{0}' has or is using private name '{1}'."),
        extends_clause_of_exported_class_0_has_or_is_using_private_name_1: diag(4020, ts.DiagnosticCategory.Error, "extends_clause_of_exported_class_0_has_or_is_using_private_name_1_4020", "'extends' clause of exported class '{0}' has or is using private name '{1}'."),
        extends_clause_of_exported_class_has_or_is_using_private_name_0: diag(4021, ts.DiagnosticCategory.Error, "extends_clause_of_exported_class_has_or_is_using_private_name_0_4021", "'extends' clause of exported class has or is using private name '{0}'."),
        extends_clause_of_exported_interface_0_has_or_is_using_private_name_1: diag(4022, ts.DiagnosticCategory.Error, "extends_clause_of_exported_interface_0_has_or_is_using_private_name_1_4022", "'extends' clause of exported interface '{0}' has or is using private name '{1}'."),
        Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4023, ts.DiagnosticCategory.Error, "Exported_variable_0_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4023", "Exported variable '{0}' has or is using name '{1}' from external module {2} but cannot be named."),
        Exported_variable_0_has_or_is_using_name_1_from_private_module_2: diag(4024, ts.DiagnosticCategory.Error, "Exported_variable_0_has_or_is_using_name_1_from_private_module_2_4024", "Exported variable '{0}' has or is using name '{1}' from private module '{2}'."),
        Exported_variable_0_has_or_is_using_private_name_1: diag(4025, ts.DiagnosticCategory.Error, "Exported_variable_0_has_or_is_using_private_name_1_4025", "Exported variable '{0}' has or is using private name '{1}'."),
        Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4026, ts.DiagnosticCategory.Error, "Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot__4026", "Public static property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named."),
        Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4027, ts.DiagnosticCategory.Error, "Public_static_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4027", "Public static property '{0}' of exported class has or is using name '{1}' from private module '{2}'."),
        Public_static_property_0_of_exported_class_has_or_is_using_private_name_1: diag(4028, ts.DiagnosticCategory.Error, "Public_static_property_0_of_exported_class_has_or_is_using_private_name_1_4028", "Public static property '{0}' of exported class has or is using private name '{1}'."),
        Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4029, ts.DiagnosticCategory.Error, "Public_property_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_name_4029", "Public property '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named."),
        Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4030, ts.DiagnosticCategory.Error, "Public_property_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4030", "Public property '{0}' of exported class has or is using name '{1}' from private module '{2}'."),
        Public_property_0_of_exported_class_has_or_is_using_private_name_1: diag(4031, ts.DiagnosticCategory.Error, "Public_property_0_of_exported_class_has_or_is_using_private_name_1_4031", "Public property '{0}' of exported class has or is using private name '{1}'."),
        Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2: diag(4032, ts.DiagnosticCategory.Error, "Property_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2_4032", "Property '{0}' of exported interface has or is using name '{1}' from private module '{2}'."),
        Property_0_of_exported_interface_has_or_is_using_private_name_1: diag(4033, ts.DiagnosticCategory.Error, "Property_0_of_exported_interface_has_or_is_using_private_name_1_4033", "Property '{0}' of exported interface has or is using private name '{1}'."),
        Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4034, ts.DiagnosticCategory.Error, "Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_name_1_from_private_mod_4034", "Parameter type of public static setter '{0}' from exported class has or is using name '{1}' from private module '{2}'."),
        Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_private_name_1: diag(4035, ts.DiagnosticCategory.Error, "Parameter_type_of_public_static_setter_0_from_exported_class_has_or_is_using_private_name_1_4035", "Parameter type of public static setter '{0}' from exported class has or is using private name '{1}'."),
        Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4036, ts.DiagnosticCategory.Error, "Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2_4036", "Parameter type of public setter '{0}' from exported class has or is using name '{1}' from private module '{2}'."),
        Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_private_name_1: diag(4037, ts.DiagnosticCategory.Error, "Parameter_type_of_public_setter_0_from_exported_class_has_or_is_using_private_name_1_4037", "Parameter type of public setter '{0}' from exported class has or is using private name '{1}'."),
        Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4038, ts.DiagnosticCategory.Error, "Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_external_modul_4038", "Return type of public static getter '{0}' from exported class has or is using name '{1}' from external module {2} but cannot be named."),
        Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4039, ts.DiagnosticCategory.Error, "Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_4039", "Return type of public static getter '{0}' from exported class has or is using name '{1}' from private module '{2}'."),
        Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_private_name_1: diag(4040, ts.DiagnosticCategory.Error, "Return_type_of_public_static_getter_0_from_exported_class_has_or_is_using_private_name_1_4040", "Return type of public static getter '{0}' from exported class has or is using private name '{1}'."),
        Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4041, ts.DiagnosticCategory.Error, "Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_4041", "Return type of public getter '{0}' from exported class has or is using name '{1}' from external module {2} but cannot be named."),
        Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4042, ts.DiagnosticCategory.Error, "Return_type_of_public_getter_0_from_exported_class_has_or_is_using_name_1_from_private_module_2_4042", "Return type of public getter '{0}' from exported class has or is using name '{1}' from private module '{2}'."),
        Return_type_of_public_getter_0_from_exported_class_has_or_is_using_private_name_1: diag(4043, ts.DiagnosticCategory.Error, "Return_type_of_public_getter_0_from_exported_class_has_or_is_using_private_name_1_4043", "Return type of public getter '{0}' from exported class has or is using private name '{1}'."),
        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: diag(4044, ts.DiagnosticCategory.Error, "Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_name_0_from_private_mod_4044", "Return type of constructor signature from exported interface has or is using name '{0}' from private module '{1}'."),
        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0: diag(4045, ts.DiagnosticCategory.Error, "Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_0_4045", "Return type of constructor signature from exported interface has or is using private name '{0}'."),
        Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: diag(4046, ts.DiagnosticCategory.Error, "Return_type_of_call_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4046", "Return type of call signature from exported interface has or is using name '{0}' from private module '{1}'."),
        Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0: diag(4047, ts.DiagnosticCategory.Error, "Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_name_0_4047", "Return type of call signature from exported interface has or is using private name '{0}'."),
        Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1: diag(4048, ts.DiagnosticCategory.Error, "Return_type_of_index_signature_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4048", "Return type of index signature from exported interface has or is using name '{0}' from private module '{1}'."),
        Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0: diag(4049, ts.DiagnosticCategory.Error, "Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_name_0_4049", "Return type of index signature from exported interface has or is using private name '{0}'."),
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: diag(4050, ts.DiagnosticCategory.Error, "Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_external_module__4050", "Return type of public static method from exported class has or is using name '{0}' from external module {1} but cannot be named."),
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1: diag(4051, ts.DiagnosticCategory.Error, "Return_type_of_public_static_method_from_exported_class_has_or_is_using_name_0_from_private_module_1_4051", "Return type of public static method from exported class has or is using name '{0}' from private module '{1}'."),
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0: diag(4052, ts.DiagnosticCategory.Error, "Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_name_0_4052", "Return type of public static method from exported class has or is using private name '{0}'."),
        Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: diag(4053, ts.DiagnosticCategory.Error, "Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_external_module_1_but_c_4053", "Return type of public method from exported class has or is using name '{0}' from external module {1} but cannot be named."),
        Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1: diag(4054, ts.DiagnosticCategory.Error, "Return_type_of_public_method_from_exported_class_has_or_is_using_name_0_from_private_module_1_4054", "Return type of public method from exported class has or is using name '{0}' from private module '{1}'."),
        Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0: diag(4055, ts.DiagnosticCategory.Error, "Return_type_of_public_method_from_exported_class_has_or_is_using_private_name_0_4055", "Return type of public method from exported class has or is using private name '{0}'."),
        Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1: diag(4056, ts.DiagnosticCategory.Error, "Return_type_of_method_from_exported_interface_has_or_is_using_name_0_from_private_module_1_4056", "Return type of method from exported interface has or is using name '{0}' from private module '{1}'."),
        Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0: diag(4057, ts.DiagnosticCategory.Error, "Return_type_of_method_from_exported_interface_has_or_is_using_private_name_0_4057", "Return type of method from exported interface has or is using private name '{0}'."),
        Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named: diag(4058, ts.DiagnosticCategory.Error, "Return_type_of_exported_function_has_or_is_using_name_0_from_external_module_1_but_cannot_be_named_4058", "Return type of exported function has or is using name '{0}' from external module {1} but cannot be named."),
        Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1: diag(4059, ts.DiagnosticCategory.Error, "Return_type_of_exported_function_has_or_is_using_name_0_from_private_module_1_4059", "Return type of exported function has or is using name '{0}' from private module '{1}'."),
        Return_type_of_exported_function_has_or_is_using_private_name_0: diag(4060, ts.DiagnosticCategory.Error, "Return_type_of_exported_function_has_or_is_using_private_name_0_4060", "Return type of exported function has or is using private name '{0}'."),
        Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4061, ts.DiagnosticCategory.Error, "Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_can_4061", "Parameter '{0}' of constructor from exported class has or is using name '{1}' from external module {2} but cannot be named."),
        Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4062, ts.DiagnosticCategory.Error, "Parameter_0_of_constructor_from_exported_class_has_or_is_using_name_1_from_private_module_2_4062", "Parameter '{0}' of constructor from exported class has or is using name '{1}' from private module '{2}'."),
        Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1: diag(4063, ts.DiagnosticCategory.Error, "Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_name_1_4063", "Parameter '{0}' of constructor from exported class has or is using private name '{1}'."),
        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: diag(4064, ts.DiagnosticCategory.Error, "Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_name_1_from_private_mod_4064", "Parameter '{0}' of constructor signature from exported interface has or is using name '{1}' from private module '{2}'."),
        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1: diag(4065, ts.DiagnosticCategory.Error, "Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_name_1_4065", "Parameter '{0}' of constructor signature from exported interface has or is using private name '{1}'."),
        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: diag(4066, ts.DiagnosticCategory.Error, "Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4066", "Parameter '{0}' of call signature from exported interface has or is using name '{1}' from private module '{2}'."),
        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1: diag(4067, ts.DiagnosticCategory.Error, "Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_name_1_4067", "Parameter '{0}' of call signature from exported interface has or is using private name '{1}'."),
        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4068, ts.DiagnosticCategory.Error, "Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_external_module__4068", "Parameter '{0}' of public static method from exported class has or is using name '{1}' from external module {2} but cannot be named."),
        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4069, ts.DiagnosticCategory.Error, "Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_name_1_from_private_module_2_4069", "Parameter '{0}' of public static method from exported class has or is using name '{1}' from private module '{2}'."),
        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1: diag(4070, ts.DiagnosticCategory.Error, "Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_name_1_4070", "Parameter '{0}' of public static method from exported class has or is using private name '{1}'."),
        Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4071, ts.DiagnosticCategory.Error, "Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_external_module_2_but_c_4071", "Parameter '{0}' of public method from exported class has or is using name '{1}' from external module {2} but cannot be named."),
        Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4072, ts.DiagnosticCategory.Error, "Parameter_0_of_public_method_from_exported_class_has_or_is_using_name_1_from_private_module_2_4072", "Parameter '{0}' of public method from exported class has or is using name '{1}' from private module '{2}'."),
        Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1: diag(4073, ts.DiagnosticCategory.Error, "Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_name_1_4073", "Parameter '{0}' of public method from exported class has or is using private name '{1}'."),
        Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2: diag(4074, ts.DiagnosticCategory.Error, "Parameter_0_of_method_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4074", "Parameter '{0}' of method from exported interface has or is using name '{1}' from private module '{2}'."),
        Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1: diag(4075, ts.DiagnosticCategory.Error, "Parameter_0_of_method_from_exported_interface_has_or_is_using_private_name_1_4075", "Parameter '{0}' of method from exported interface has or is using private name '{1}'."),
        Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4076, ts.DiagnosticCategory.Error, "Parameter_0_of_exported_function_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4076", "Parameter '{0}' of exported function has or is using name '{1}' from external module {2} but cannot be named."),
        Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2: diag(4077, ts.DiagnosticCategory.Error, "Parameter_0_of_exported_function_has_or_is_using_name_1_from_private_module_2_4077", "Parameter '{0}' of exported function has or is using name '{1}' from private module '{2}'."),
        Parameter_0_of_exported_function_has_or_is_using_private_name_1: diag(4078, ts.DiagnosticCategory.Error, "Parameter_0_of_exported_function_has_or_is_using_private_name_1_4078", "Parameter '{0}' of exported function has or is using private name '{1}'."),
        Exported_type_alias_0_has_or_is_using_private_name_1: diag(4081, ts.DiagnosticCategory.Error, "Exported_type_alias_0_has_or_is_using_private_name_1_4081", "Exported type alias '{0}' has or is using private name '{1}'."),
        Default_export_of_the_module_has_or_is_using_private_name_0: diag(4082, ts.DiagnosticCategory.Error, "Default_export_of_the_module_has_or_is_using_private_name_0_4082", "Default export of the module has or is using private name '{0}'."),
        Type_parameter_0_of_exported_type_alias_has_or_is_using_private_name_1: diag(4083, ts.DiagnosticCategory.Error, "Type_parameter_0_of_exported_type_alias_has_or_is_using_private_name_1_4083", "Type parameter '{0}' of exported type alias has or is using private name '{1}'."),
        Exported_type_alias_0_has_or_is_using_private_name_1_from_module_2: diag(4084, ts.DiagnosticCategory.Error, "Exported_type_alias_0_has_or_is_using_private_name_1_from_module_2_4084", "Exported type alias '{0}' has or is using private name '{1}' from module {2}."),
        Conflicting_definitions_for_0_found_at_1_and_2_Consider_installing_a_specific_version_of_this_library_to_resolve_the_conflict: diag(4090, ts.DiagnosticCategory.Error, "Conflicting_definitions_for_0_found_at_1_and_2_Consider_installing_a_specific_version_of_this_librar_4090", "Conflicting definitions for '{0}' found at '{1}' and '{2}'. Consider installing a specific version of this library to resolve the conflict."),
        Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2: diag(4091, ts.DiagnosticCategory.Error, "Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_name_1_from_private_module_2_4091", "Parameter '{0}' of index signature from exported interface has or is using name '{1}' from private module '{2}'."),
        Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_private_name_1: diag(4092, ts.DiagnosticCategory.Error, "Parameter_0_of_index_signature_from_exported_interface_has_or_is_using_private_name_1_4092", "Parameter '{0}' of index signature from exported interface has or is using private name '{1}'."),
        Property_0_of_exported_class_expression_may_not_be_private_or_protected: diag(4094, ts.DiagnosticCategory.Error, "Property_0_of_exported_class_expression_may_not_be_private_or_protected_4094", "Property '{0}' of exported class expression may not be private or protected."),
        Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4095, ts.DiagnosticCategory.Error, "Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_4095", "Public static method '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named."),
        Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4096, ts.DiagnosticCategory.Error, "Public_static_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4096", "Public static method '{0}' of exported class has or is using name '{1}' from private module '{2}'."),
        Public_static_method_0_of_exported_class_has_or_is_using_private_name_1: diag(4097, ts.DiagnosticCategory.Error, "Public_static_method_0_of_exported_class_has_or_is_using_private_name_1_4097", "Public static method '{0}' of exported class has or is using private name '{1}'."),
        Public_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4098, ts.DiagnosticCategory.Error, "Public_method_0_of_exported_class_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4098", "Public method '{0}' of exported class has or is using name '{1}' from external module {2} but cannot be named."),
        Public_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2: diag(4099, ts.DiagnosticCategory.Error, "Public_method_0_of_exported_class_has_or_is_using_name_1_from_private_module_2_4099", "Public method '{0}' of exported class has or is using name '{1}' from private module '{2}'."),
        Public_method_0_of_exported_class_has_or_is_using_private_name_1: diag(4100, ts.DiagnosticCategory.Error, "Public_method_0_of_exported_class_has_or_is_using_private_name_1_4100", "Public method '{0}' of exported class has or is using private name '{1}'."),
        Method_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2: diag(4101, ts.DiagnosticCategory.Error, "Method_0_of_exported_interface_has_or_is_using_name_1_from_private_module_2_4101", "Method '{0}' of exported interface has or is using name '{1}' from private module '{2}'."),
        Method_0_of_exported_interface_has_or_is_using_private_name_1: diag(4102, ts.DiagnosticCategory.Error, "Method_0_of_exported_interface_has_or_is_using_private_name_1_4102", "Method '{0}' of exported interface has or is using private name '{1}'."),
        Type_parameter_0_of_exported_mapped_object_type_is_using_private_name_1: diag(4103, ts.DiagnosticCategory.Error, "Type_parameter_0_of_exported_mapped_object_type_is_using_private_name_1_4103", "Type parameter '{0}' of exported mapped object type is using private name '{1}'."),
        The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1: diag(4104, ts.DiagnosticCategory.Error, "The_type_0_is_readonly_and_cannot_be_assigned_to_the_mutable_type_1_4104", "The type '{0}' is 'readonly' and cannot be assigned to the mutable type '{1}'."),
        Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter: diag(4105, ts.DiagnosticCategory.Error, "Private_or_protected_member_0_cannot_be_accessed_on_a_type_parameter_4105", "Private or protected member '{0}' cannot be accessed on a type parameter."),
        Parameter_0_of_accessor_has_or_is_using_private_name_1: diag(4106, ts.DiagnosticCategory.Error, "Parameter_0_of_accessor_has_or_is_using_private_name_1_4106", "Parameter '{0}' of accessor has or is using private name '{1}'."),
        Parameter_0_of_accessor_has_or_is_using_name_1_from_private_module_2: diag(4107, ts.DiagnosticCategory.Error, "Parameter_0_of_accessor_has_or_is_using_name_1_from_private_module_2_4107", "Parameter '{0}' of accessor has or is using name '{1}' from private module '{2}'."),
        Parameter_0_of_accessor_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named: diag(4108, ts.DiagnosticCategory.Error, "Parameter_0_of_accessor_has_or_is_using_name_1_from_external_module_2_but_cannot_be_named_4108", "Parameter '{0}' of accessor has or is using name '{1}' from external module '{2}' but cannot be named."),
        Type_arguments_for_0_circularly_reference_themselves: diag(4109, ts.DiagnosticCategory.Error, "Type_arguments_for_0_circularly_reference_themselves_4109", "Type arguments for '{0}' circularly reference themselves."),
        Tuple_type_arguments_circularly_reference_themselves: diag(4110, ts.DiagnosticCategory.Error, "Tuple_type_arguments_circularly_reference_themselves_4110", "Tuple type arguments circularly reference themselves."),
        Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0: diag(4111, ts.DiagnosticCategory.Error, "Property_0_comes_from_an_index_signature_so_it_must_be_accessed_with_0_4111", "Property '{0}' comes from an index signature, so it must be accessed with ['{0}']."),
        This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another_class: diag(4112, ts.DiagnosticCategory.Error, "This_member_cannot_have_an_override_modifier_because_its_containing_class_0_does_not_extend_another__4112", "This member cannot have an 'override' modifier because its containing class '{0}' does not extend another class."),
        This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0: diag(4113, ts.DiagnosticCategory.Error, "This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_4113", "This member cannot have an 'override' modifier because it is not declared in the base class '{0}'."),
        This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0: diag(4114, ts.DiagnosticCategory.Error, "This_member_must_have_an_override_modifier_because_it_overrides_a_member_in_the_base_class_0_4114", "This member must have an 'override' modifier because it overrides a member in the base class '{0}'."),
        This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0: diag(4115, ts.DiagnosticCategory.Error, "This_parameter_property_must_have_an_override_modifier_because_it_overrides_a_member_in_base_class_0_4115", "This parameter property must have an 'override' modifier because it overrides a member in base class '{0}'."),
        This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared_in_the_base_class_0: diag(4116, ts.DiagnosticCategory.Error, "This_member_must_have_an_override_modifier_because_it_overrides_an_abstract_method_that_is_declared__4116", "This member must have an 'override' modifier because it overrides an abstract method that is declared in the base class '{0}'."),
        This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1: diag(4117, ts.DiagnosticCategory.Error, "This_member_cannot_have_an_override_modifier_because_it_is_not_declared_in_the_base_class_0_Did_you__4117", "This member cannot have an 'override' modifier because it is not declared in the base class '{0}'. Did you mean '{1}'?"),
        The_type_of_this_node_cannot_be_serialized_because_its_property_0_cannot_be_serialized: diag(4118, ts.DiagnosticCategory.Error, "The_type_of_this_node_cannot_be_serialized_because_its_property_0_cannot_be_serialized_4118", "The type of this node cannot be serialized because its property '{0}' cannot be serialized."),
        This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0: diag(4119, ts.DiagnosticCategory.Error, "This_member_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_4119", "This member must have a JSDoc comment with an '@override' tag because it overrides a member in the base class '{0}'."),
        This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_in_the_base_class_0: diag(4120, ts.DiagnosticCategory.Error, "This_parameter_property_must_have_a_JSDoc_comment_with_an_override_tag_because_it_overrides_a_member_4120", "This parameter property must have a JSDoc comment with an '@override' tag because it overrides a member in the base class '{0}'."),
        This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_extend_another_class: diag(4121, ts.DiagnosticCategory.Error, "This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_its_containing_class_0_does_not_4121", "This member cannot have a JSDoc comment with an '@override' tag because its containing class '{0}' does not extend another class."),
        This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0: diag(4122, ts.DiagnosticCategory.Error, "This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base__4122", "This member cannot have a JSDoc comment with an '@override' tag because it is not declared in the base class '{0}'."),
        This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base_class_0_Did_you_mean_1: diag(4123, ts.DiagnosticCategory.Error, "This_member_cannot_have_a_JSDoc_comment_with_an_override_tag_because_it_is_not_declared_in_the_base__4123", "This member cannot have a JSDoc comment with an 'override' tag because it is not declared in the base class '{0}'. Did you mean '{1}'?"),
        Compiler_option_0_of_value_1_is_unstable_Use_nightly_TypeScript_to_silence_this_error_Try_updating_with_npm_install_D_typescript_next: diag(4124, ts.DiagnosticCategory.Error, "Compiler_option_0_of_value_1_is_unstable_Use_nightly_TypeScript_to_silence_this_error_Try_updating_w_4124", "Compiler option '{0}' of value '{1}' is unstable. Use nightly TypeScript to silence this error. Try updating with 'npm install -D typescript@next'."),
        resolution_mode_assertions_are_unstable_Use_nightly_TypeScript_to_silence_this_error_Try_updating_with_npm_install_D_typescript_next: diag(4125, ts.DiagnosticCategory.Error, "resolution_mode_assertions_are_unstable_Use_nightly_TypeScript_to_silence_this_error_Try_updating_wi_4125", "'resolution-mode' assertions are unstable. Use nightly TypeScript to silence this error. Try updating with 'npm install -D typescript@next'."),
        The_current_host_does_not_support_the_0_option: diag(5001, ts.DiagnosticCategory.Error, "The_current_host_does_not_support_the_0_option_5001", "The current host does not support the '{0}' option."),
        Cannot_find_the_common_subdirectory_path_for_the_input_files: diag(5009, ts.DiagnosticCategory.Error, "Cannot_find_the_common_subdirectory_path_for_the_input_files_5009", "Cannot find the common subdirectory path for the input files."),
        File_specification_cannot_end_in_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0: diag(5010, ts.DiagnosticCategory.Error, "File_specification_cannot_end_in_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0_5010", "File specification cannot end in a recursive directory wildcard ('**'): '{0}'."),
        Cannot_read_file_0_Colon_1: diag(5012, ts.DiagnosticCategory.Error, "Cannot_read_file_0_Colon_1_5012", "Cannot read file '{0}': {1}."),
        Failed_to_parse_file_0_Colon_1: diag(5014, ts.DiagnosticCategory.Error, "Failed_to_parse_file_0_Colon_1_5014", "Failed to parse file '{0}': {1}."),
        Unknown_compiler_option_0: diag(5023, ts.DiagnosticCategory.Error, "Unknown_compiler_option_0_5023", "Unknown compiler option '{0}'."),
        Compiler_option_0_requires_a_value_of_type_1: diag(5024, ts.DiagnosticCategory.Error, "Compiler_option_0_requires_a_value_of_type_1_5024", "Compiler option '{0}' requires a value of type {1}."),
        Unknown_compiler_option_0_Did_you_mean_1: diag(5025, ts.DiagnosticCategory.Error, "Unknown_compiler_option_0_Did_you_mean_1_5025", "Unknown compiler option '{0}'. Did you mean '{1}'?"),
        Could_not_write_file_0_Colon_1: diag(5033, ts.DiagnosticCategory.Error, "Could_not_write_file_0_Colon_1_5033", "Could not write file '{0}': {1}."),
        Option_project_cannot_be_mixed_with_source_files_on_a_command_line: diag(5042, ts.DiagnosticCategory.Error, "Option_project_cannot_be_mixed_with_source_files_on_a_command_line_5042", "Option 'project' cannot be mixed with source files on a command line."),
        Option_isolatedModules_can_only_be_used_when_either_option_module_is_provided_or_option_target_is_ES2015_or_higher: diag(5047, ts.DiagnosticCategory.Error, "Option_isolatedModules_can_only_be_used_when_either_option_module_is_provided_or_option_target_is_ES_5047", "Option 'isolatedModules' can only be used when either option '--module' is provided or option 'target' is 'ES2015' or higher."),
        Option_0_cannot_be_specified_when_option_target_is_ES3: diag(5048, ts.DiagnosticCategory.Error, "Option_0_cannot_be_specified_when_option_target_is_ES3_5048", "Option '{0}' cannot be specified when option 'target' is 'ES3'."),
        Option_0_can_only_be_used_when_either_option_inlineSourceMap_or_option_sourceMap_is_provided: diag(5051, ts.DiagnosticCategory.Error, "Option_0_can_only_be_used_when_either_option_inlineSourceMap_or_option_sourceMap_is_provided_5051", "Option '{0} can only be used when either option '--inlineSourceMap' or option '--sourceMap' is provided."),
        Option_0_cannot_be_specified_without_specifying_option_1: diag(5052, ts.DiagnosticCategory.Error, "Option_0_cannot_be_specified_without_specifying_option_1_5052", "Option '{0}' cannot be specified without specifying option '{1}'."),
        Option_0_cannot_be_specified_with_option_1: diag(5053, ts.DiagnosticCategory.Error, "Option_0_cannot_be_specified_with_option_1_5053", "Option '{0}' cannot be specified with option '{1}'."),
        A_tsconfig_json_file_is_already_defined_at_Colon_0: diag(5054, ts.DiagnosticCategory.Error, "A_tsconfig_json_file_is_already_defined_at_Colon_0_5054", "A 'tsconfig.json' file is already defined at: '{0}'."),
        Cannot_write_file_0_because_it_would_overwrite_input_file: diag(5055, ts.DiagnosticCategory.Error, "Cannot_write_file_0_because_it_would_overwrite_input_file_5055", "Cannot write file '{0}' because it would overwrite input file."),
        Cannot_write_file_0_because_it_would_be_overwritten_by_multiple_input_files: diag(5056, ts.DiagnosticCategory.Error, "Cannot_write_file_0_because_it_would_be_overwritten_by_multiple_input_files_5056", "Cannot write file '{0}' because it would be overwritten by multiple input files."),
        Cannot_find_a_tsconfig_json_file_at_the_specified_directory_Colon_0: diag(5057, ts.DiagnosticCategory.Error, "Cannot_find_a_tsconfig_json_file_at_the_specified_directory_Colon_0_5057", "Cannot find a tsconfig.json file at the specified directory: '{0}'."),
        The_specified_path_does_not_exist_Colon_0: diag(5058, ts.DiagnosticCategory.Error, "The_specified_path_does_not_exist_Colon_0_5058", "The specified path does not exist: '{0}'."),
        Invalid_value_for_reactNamespace_0_is_not_a_valid_identifier: diag(5059, ts.DiagnosticCategory.Error, "Invalid_value_for_reactNamespace_0_is_not_a_valid_identifier_5059", "Invalid value for '--reactNamespace'. '{0}' is not a valid identifier."),
        Pattern_0_can_have_at_most_one_Asterisk_character: diag(5061, ts.DiagnosticCategory.Error, "Pattern_0_can_have_at_most_one_Asterisk_character_5061", "Pattern '{0}' can have at most one '*' character."),
        Substitution_0_in_pattern_1_can_have_at_most_one_Asterisk_character: diag(5062, ts.DiagnosticCategory.Error, "Substitution_0_in_pattern_1_can_have_at_most_one_Asterisk_character_5062", "Substitution '{0}' in pattern '{1}' can have at most one '*' character."),
        Substitutions_for_pattern_0_should_be_an_array: diag(5063, ts.DiagnosticCategory.Error, "Substitutions_for_pattern_0_should_be_an_array_5063", "Substitutions for pattern '{0}' should be an array."),
        Substitution_0_for_pattern_1_has_incorrect_type_expected_string_got_2: diag(5064, ts.DiagnosticCategory.Error, "Substitution_0_for_pattern_1_has_incorrect_type_expected_string_got_2_5064", "Substitution '{0}' for pattern '{1}' has incorrect type, expected 'string', got '{2}'."),
        File_specification_cannot_contain_a_parent_directory_that_appears_after_a_recursive_directory_wildcard_Asterisk_Asterisk_Colon_0: diag(5065, ts.DiagnosticCategory.Error, "File_specification_cannot_contain_a_parent_directory_that_appears_after_a_recursive_directory_wildca_5065", "File specification cannot contain a parent directory ('..') that appears after a recursive directory wildcard ('**'): '{0}'."),
        Substitutions_for_pattern_0_shouldn_t_be_an_empty_array: diag(5066, ts.DiagnosticCategory.Error, "Substitutions_for_pattern_0_shouldn_t_be_an_empty_array_5066", "Substitutions for pattern '{0}' shouldn't be an empty array."),
        Invalid_value_for_jsxFactory_0_is_not_a_valid_identifier_or_qualified_name: diag(5067, ts.DiagnosticCategory.Error, "Invalid_value_for_jsxFactory_0_is_not_a_valid_identifier_or_qualified_name_5067", "Invalid value for 'jsxFactory'. '{0}' is not a valid identifier or qualified-name."),
        Adding_a_tsconfig_json_file_will_help_organize_projects_that_contain_both_TypeScript_and_JavaScript_files_Learn_more_at_https_Colon_Slash_Slashaka_ms_Slashtsconfig: diag(5068, ts.DiagnosticCategory.Error, "Adding_a_tsconfig_json_file_will_help_organize_projects_that_contain_both_TypeScript_and_JavaScript__5068", "Adding a tsconfig.json file will help organize projects that contain both TypeScript and JavaScript files. Learn more at https://aka.ms/tsconfig."),
        Option_0_cannot_be_specified_without_specifying_option_1_or_option_2: diag(5069, ts.DiagnosticCategory.Error, "Option_0_cannot_be_specified_without_specifying_option_1_or_option_2_5069", "Option '{0}' cannot be specified without specifying option '{1}' or option '{2}'."),
        Option_resolveJsonModule_cannot_be_specified_without_node_module_resolution_strategy: diag(5070, ts.DiagnosticCategory.Error, "Option_resolveJsonModule_cannot_be_specified_without_node_module_resolution_strategy_5070", "Option '--resolveJsonModule' cannot be specified without 'node' module resolution strategy."),
        Option_resolveJsonModule_can_only_be_specified_when_module_code_generation_is_commonjs_amd_es2015_or_esNext: diag(5071, ts.DiagnosticCategory.Error, "Option_resolveJsonModule_can_only_be_specified_when_module_code_generation_is_commonjs_amd_es2015_or_5071", "Option '--resolveJsonModule' can only be specified when module code generation is 'commonjs', 'amd', 'es2015' or 'esNext'."),
        Unknown_build_option_0: diag(5072, ts.DiagnosticCategory.Error, "Unknown_build_option_0_5072", "Unknown build option '{0}'."),
        Build_option_0_requires_a_value_of_type_1: diag(5073, ts.DiagnosticCategory.Error, "Build_option_0_requires_a_value_of_type_1_5073", "Build option '{0}' requires a value of type {1}."),
        Option_incremental_can_only_be_specified_using_tsconfig_emitting_to_single_file_or_when_option_tsBuildInfoFile_is_specified: diag(5074, ts.DiagnosticCategory.Error, "Option_incremental_can_only_be_specified_using_tsconfig_emitting_to_single_file_or_when_option_tsBui_5074", "Option '--incremental' can only be specified using tsconfig, emitting to single file or when option '--tsBuildInfoFile' is specified."),
        _0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_constraint_2: diag(5075, ts.DiagnosticCategory.Error, "_0_is_assignable_to_the_constraint_of_type_1_but_1_could_be_instantiated_with_a_different_subtype_of_5075", "'{0}' is assignable to the constraint of type '{1}', but '{1}' could be instantiated with a different subtype of constraint '{2}'."),
        _0_and_1_operations_cannot_be_mixed_without_parentheses: diag(5076, ts.DiagnosticCategory.Error, "_0_and_1_operations_cannot_be_mixed_without_parentheses_5076", "'{0}' and '{1}' operations cannot be mixed without parentheses."),
        Unknown_build_option_0_Did_you_mean_1: diag(5077, ts.DiagnosticCategory.Error, "Unknown_build_option_0_Did_you_mean_1_5077", "Unknown build option '{0}'. Did you mean '{1}'?"),
        Unknown_watch_option_0: diag(5078, ts.DiagnosticCategory.Error, "Unknown_watch_option_0_5078", "Unknown watch option '{0}'."),
        Unknown_watch_option_0_Did_you_mean_1: diag(5079, ts.DiagnosticCategory.Error, "Unknown_watch_option_0_Did_you_mean_1_5079", "Unknown watch option '{0}'. Did you mean '{1}'?"),
        Watch_option_0_requires_a_value_of_type_1: diag(5080, ts.DiagnosticCategory.Error, "Watch_option_0_requires_a_value_of_type_1_5080", "Watch option '{0}' requires a value of type {1}."),
        Cannot_find_a_tsconfig_json_file_at_the_current_directory_Colon_0: diag(5081, ts.DiagnosticCategory.Error, "Cannot_find_a_tsconfig_json_file_at_the_current_directory_Colon_0_5081", "Cannot find a tsconfig.json file at the current directory: {0}."),
        _0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1: diag(5082, ts.DiagnosticCategory.Error, "_0_could_be_instantiated_with_an_arbitrary_type_which_could_be_unrelated_to_1_5082", "'{0}' could be instantiated with an arbitrary type which could be unrelated to '{1}'."),
        Cannot_read_file_0: diag(5083, ts.DiagnosticCategory.Error, "Cannot_read_file_0_5083", "Cannot read file '{0}'."),
        Tuple_members_must_all_have_names_or_all_not_have_names: diag(5084, ts.DiagnosticCategory.Error, "Tuple_members_must_all_have_names_or_all_not_have_names_5084", "Tuple members must all have names or all not have names."),
        A_tuple_member_cannot_be_both_optional_and_rest: diag(5085, ts.DiagnosticCategory.Error, "A_tuple_member_cannot_be_both_optional_and_rest_5085", "A tuple member cannot be both optional and rest."),
        A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_colon_rather_than_after_the_type: diag(5086, ts.DiagnosticCategory.Error, "A_labeled_tuple_element_is_declared_as_optional_with_a_question_mark_after_the_name_and_before_the_c_5086", "A labeled tuple element is declared as optional with a question mark after the name and before the colon, rather than after the type."),
        A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type: diag(5087, ts.DiagnosticCategory.Error, "A_labeled_tuple_element_is_declared_as_rest_with_a_before_the_name_rather_than_before_the_type_5087", "A labeled tuple element is declared as rest with a '...' before the name, rather than before the type."),
        The_inferred_type_of_0_references_a_type_with_a_cyclic_structure_which_cannot_be_trivially_serialized_A_type_annotation_is_necessary: diag(5088, ts.DiagnosticCategory.Error, "The_inferred_type_of_0_references_a_type_with_a_cyclic_structure_which_cannot_be_trivially_serialize_5088", "The inferred type of '{0}' references a type with a cyclic structure which cannot be trivially serialized. A type annotation is necessary."),
        Option_0_cannot_be_specified_when_option_jsx_is_1: diag(5089, ts.DiagnosticCategory.Error, "Option_0_cannot_be_specified_when_option_jsx_is_1_5089", "Option '{0}' cannot be specified when option 'jsx' is '{1}'."),
        Non_relative_paths_are_not_allowed_when_baseUrl_is_not_set_Did_you_forget_a_leading_Slash: diag(5090, ts.DiagnosticCategory.Error, "Non_relative_paths_are_not_allowed_when_baseUrl_is_not_set_Did_you_forget_a_leading_Slash_5090", "Non-relative paths are not allowed when 'baseUrl' is not set. Did you forget a leading './'?"),
        Option_preserveConstEnums_cannot_be_disabled_when_isolatedModules_is_enabled: diag(5091, ts.DiagnosticCategory.Error, "Option_preserveConstEnums_cannot_be_disabled_when_isolatedModules_is_enabled_5091", "Option 'preserveConstEnums' cannot be disabled when 'isolatedModules' is enabled."),
        The_root_value_of_a_0_file_must_be_an_object: diag(5092, ts.DiagnosticCategory.Error, "The_root_value_of_a_0_file_must_be_an_object_5092", "The root value of a '{0}' file must be an object."),
        Compiler_option_0_may_only_be_used_with_build: diag(5093, ts.DiagnosticCategory.Error, "Compiler_option_0_may_only_be_used_with_build_5093", "Compiler option '--{0}' may only be used with '--build'."),
        Compiler_option_0_may_not_be_used_with_build: diag(5094, ts.DiagnosticCategory.Error, "Compiler_option_0_may_not_be_used_with_build_5094", "Compiler option '--{0}' may not be used with '--build'."),
        Option_preserveValueImports_can_only_be_used_when_module_is_set_to_es2015_or_later: diag(5095, ts.DiagnosticCategory.Error, "Option_preserveValueImports_can_only_be_used_when_module_is_set_to_es2015_or_later_5095", "Option 'preserveValueImports' can only be used when 'module' is set to 'es2015' or later."),
        Generates_a_sourcemap_for_each_corresponding_d_ts_file: diag(6000, ts.DiagnosticCategory.Message, "Generates_a_sourcemap_for_each_corresponding_d_ts_file_6000", "Generates a sourcemap for each corresponding '.d.ts' file."),
        Concatenate_and_emit_output_to_single_file: diag(6001, ts.DiagnosticCategory.Message, "Concatenate_and_emit_output_to_single_file_6001", "Concatenate and emit output to single file."),
        Generates_corresponding_d_ts_file: diag(6002, ts.DiagnosticCategory.Message, "Generates_corresponding_d_ts_file_6002", "Generates corresponding '.d.ts' file."),
        Specify_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations: diag(6004, ts.DiagnosticCategory.Message, "Specify_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations_6004", "Specify the location where debugger should locate TypeScript files instead of source locations."),
        Watch_input_files: diag(6005, ts.DiagnosticCategory.Message, "Watch_input_files_6005", "Watch input files."),
        Redirect_output_structure_to_the_directory: diag(6006, ts.DiagnosticCategory.Message, "Redirect_output_structure_to_the_directory_6006", "Redirect output structure to the directory."),
        Do_not_erase_const_enum_declarations_in_generated_code: diag(6007, ts.DiagnosticCategory.Message, "Do_not_erase_const_enum_declarations_in_generated_code_6007", "Do not erase const enum declarations in generated code."),
        Do_not_emit_outputs_if_any_errors_were_reported: diag(6008, ts.DiagnosticCategory.Message, "Do_not_emit_outputs_if_any_errors_were_reported_6008", "Do not emit outputs if any errors were reported."),
        Do_not_emit_comments_to_output: diag(6009, ts.DiagnosticCategory.Message, "Do_not_emit_comments_to_output_6009", "Do not emit comments to output."),
        Do_not_emit_outputs: diag(6010, ts.DiagnosticCategory.Message, "Do_not_emit_outputs_6010", "Do not emit outputs."),
        Allow_default_imports_from_modules_with_no_default_export_This_does_not_affect_code_emit_just_typechecking: diag(6011, ts.DiagnosticCategory.Message, "Allow_default_imports_from_modules_with_no_default_export_This_does_not_affect_code_emit_just_typech_6011", "Allow default imports from modules with no default export. This does not affect code emit, just typechecking."),
        Skip_type_checking_of_declaration_files: diag(6012, ts.DiagnosticCategory.Message, "Skip_type_checking_of_declaration_files_6012", "Skip type checking of declaration files."),
        Do_not_resolve_the_real_path_of_symlinks: diag(6013, ts.DiagnosticCategory.Message, "Do_not_resolve_the_real_path_of_symlinks_6013", "Do not resolve the real path of symlinks."),
        Only_emit_d_ts_declaration_files: diag(6014, ts.DiagnosticCategory.Message, "Only_emit_d_ts_declaration_files_6014", "Only emit '.d.ts' declaration files."),
        Specify_ECMAScript_target_version: diag(6015, ts.DiagnosticCategory.Message, "Specify_ECMAScript_target_version_6015", "Specify ECMAScript target version."),
        Specify_module_code_generation: diag(6016, ts.DiagnosticCategory.Message, "Specify_module_code_generation_6016", "Specify module code generation."),
        Print_this_message: diag(6017, ts.DiagnosticCategory.Message, "Print_this_message_6017", "Print this message."),
        Print_the_compiler_s_version: diag(6019, ts.DiagnosticCategory.Message, "Print_the_compiler_s_version_6019", "Print the compiler's version."),
        Compile_the_project_given_the_path_to_its_configuration_file_or_to_a_folder_with_a_tsconfig_json: diag(6020, ts.DiagnosticCategory.Message, "Compile_the_project_given_the_path_to_its_configuration_file_or_to_a_folder_with_a_tsconfig_json_6020", "Compile the project given the path to its configuration file, or to a folder with a 'tsconfig.json'."),
        Syntax_Colon_0: diag(6023, ts.DiagnosticCategory.Message, "Syntax_Colon_0_6023", "Syntax: {0}"),
        options: diag(6024, ts.DiagnosticCategory.Message, "options_6024", "options"),
        file: diag(6025, ts.DiagnosticCategory.Message, "file_6025", "file"),
        Examples_Colon_0: diag(6026, ts.DiagnosticCategory.Message, "Examples_Colon_0_6026", "Examples: {0}"),
        Options_Colon: diag(6027, ts.DiagnosticCategory.Message, "Options_Colon_6027", "Options:"),
        Version_0: diag(6029, ts.DiagnosticCategory.Message, "Version_0_6029", "Version {0}"),
        Insert_command_line_options_and_files_from_a_file: diag(6030, ts.DiagnosticCategory.Message, "Insert_command_line_options_and_files_from_a_file_6030", "Insert command line options and files from a file."),
        Starting_compilation_in_watch_mode: diag(6031, ts.DiagnosticCategory.Message, "Starting_compilation_in_watch_mode_6031", "Starting compilation in watch mode..."),
        File_change_detected_Starting_incremental_compilation: diag(6032, ts.DiagnosticCategory.Message, "File_change_detected_Starting_incremental_compilation_6032", "File change detected. Starting incremental compilation..."),
        KIND: diag(6034, ts.DiagnosticCategory.Message, "KIND_6034", "KIND"),
        FILE: diag(6035, ts.DiagnosticCategory.Message, "FILE_6035", "FILE"),
        VERSION: diag(6036, ts.DiagnosticCategory.Message, "VERSION_6036", "VERSION"),
        LOCATION: diag(6037, ts.DiagnosticCategory.Message, "LOCATION_6037", "LOCATION"),
        DIRECTORY: diag(6038, ts.DiagnosticCategory.Message, "DIRECTORY_6038", "DIRECTORY"),
        STRATEGY: diag(6039, ts.DiagnosticCategory.Message, "STRATEGY_6039", "STRATEGY"),
        FILE_OR_DIRECTORY: diag(6040, ts.DiagnosticCategory.Message, "FILE_OR_DIRECTORY_6040", "FILE OR DIRECTORY"),
        Errors_Files: diag(6041, ts.DiagnosticCategory.Message, "Errors_Files_6041", "Errors  Files"),
        Generates_corresponding_map_file: diag(6043, ts.DiagnosticCategory.Message, "Generates_corresponding_map_file_6043", "Generates corresponding '.map' file."),
        Compiler_option_0_expects_an_argument: diag(6044, ts.DiagnosticCategory.Error, "Compiler_option_0_expects_an_argument_6044", "Compiler option '{0}' expects an argument."),
        Unterminated_quoted_string_in_response_file_0: diag(6045, ts.DiagnosticCategory.Error, "Unterminated_quoted_string_in_response_file_0_6045", "Unterminated quoted string in response file '{0}'."),
        Argument_for_0_option_must_be_Colon_1: diag(6046, ts.DiagnosticCategory.Error, "Argument_for_0_option_must_be_Colon_1_6046", "Argument for '{0}' option must be: {1}."),
        Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1: diag(6048, ts.DiagnosticCategory.Error, "Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1_6048", "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'."),
        Unable_to_open_file_0: diag(6050, ts.DiagnosticCategory.Error, "Unable_to_open_file_0_6050", "Unable to open file '{0}'."),
        Corrupted_locale_file_0: diag(6051, ts.DiagnosticCategory.Error, "Corrupted_locale_file_0_6051", "Corrupted locale file {0}."),
        Raise_error_on_expressions_and_declarations_with_an_implied_any_type: diag(6052, ts.DiagnosticCategory.Message, "Raise_error_on_expressions_and_declarations_with_an_implied_any_type_6052", "Raise error on expressions and declarations with an implied 'any' type."),
        File_0_not_found: diag(6053, ts.DiagnosticCategory.Error, "File_0_not_found_6053", "File '{0}' not found."),
        File_0_has_an_unsupported_extension_The_only_supported_extensions_are_1: diag(6054, ts.DiagnosticCategory.Error, "File_0_has_an_unsupported_extension_The_only_supported_extensions_are_1_6054", "File '{0}' has an unsupported extension. The only supported extensions are {1}."),
        Suppress_noImplicitAny_errors_for_indexing_objects_lacking_index_signatures: diag(6055, ts.DiagnosticCategory.Message, "Suppress_noImplicitAny_errors_for_indexing_objects_lacking_index_signatures_6055", "Suppress noImplicitAny errors for indexing objects lacking index signatures."),
        Do_not_emit_declarations_for_code_that_has_an_internal_annotation: diag(6056, ts.DiagnosticCategory.Message, "Do_not_emit_declarations_for_code_that_has_an_internal_annotation_6056", "Do not emit declarations for code that has an '@internal' annotation."),
        Specify_the_root_directory_of_input_files_Use_to_control_the_output_directory_structure_with_outDir: diag(6058, ts.DiagnosticCategory.Message, "Specify_the_root_directory_of_input_files_Use_to_control_the_output_directory_structure_with_outDir_6058", "Specify the root directory of input files. Use to control the output directory structure with --outDir."),
        File_0_is_not_under_rootDir_1_rootDir_is_expected_to_contain_all_source_files: diag(6059, ts.DiagnosticCategory.Error, "File_0_is_not_under_rootDir_1_rootDir_is_expected_to_contain_all_source_files_6059", "File '{0}' is not under 'rootDir' '{1}'. 'rootDir' is expected to contain all source files."),
        Specify_the_end_of_line_sequence_to_be_used_when_emitting_files_Colon_CRLF_dos_or_LF_unix: diag(6060, ts.DiagnosticCategory.Message, "Specify_the_end_of_line_sequence_to_be_used_when_emitting_files_Colon_CRLF_dos_or_LF_unix_6060", "Specify the end of line sequence to be used when emitting files: 'CRLF' (dos) or 'LF' (unix)."),
        NEWLINE: diag(6061, ts.DiagnosticCategory.Message, "NEWLINE_6061", "NEWLINE"),
        Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_null_on_command_line: diag(6064, ts.DiagnosticCategory.Error, "Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_null_on_command_line_6064", "Option '{0}' can only be specified in 'tsconfig.json' file or set to 'null' on command line."),
        Enables_experimental_support_for_ES7_decorators: diag(6065, ts.DiagnosticCategory.Message, "Enables_experimental_support_for_ES7_decorators_6065", "Enables experimental support for ES7 decorators."),
        Enables_experimental_support_for_emitting_type_metadata_for_decorators: diag(6066, ts.DiagnosticCategory.Message, "Enables_experimental_support_for_emitting_type_metadata_for_decorators_6066", "Enables experimental support for emitting type metadata for decorators."),
        Specify_module_resolution_strategy_Colon_node_Node_js_or_classic_TypeScript_pre_1_6: diag(6069, ts.DiagnosticCategory.Message, "Specify_module_resolution_strategy_Colon_node_Node_js_or_classic_TypeScript_pre_1_6_6069", "Specify module resolution strategy: 'node' (Node.js) or 'classic' (TypeScript pre-1.6)."),
        Initializes_a_TypeScript_project_and_creates_a_tsconfig_json_file: diag(6070, ts.DiagnosticCategory.Message, "Initializes_a_TypeScript_project_and_creates_a_tsconfig_json_file_6070", "Initializes a TypeScript project and creates a tsconfig.json file."),
        Successfully_created_a_tsconfig_json_file: diag(6071, ts.DiagnosticCategory.Message, "Successfully_created_a_tsconfig_json_file_6071", "Successfully created a tsconfig.json file."),
        Suppress_excess_property_checks_for_object_literals: diag(6072, ts.DiagnosticCategory.Message, "Suppress_excess_property_checks_for_object_literals_6072", "Suppress excess property checks for object literals."),
        Stylize_errors_and_messages_using_color_and_context_experimental: diag(6073, ts.DiagnosticCategory.Message, "Stylize_errors_and_messages_using_color_and_context_experimental_6073", "Stylize errors and messages using color and context (experimental)."),
        Do_not_report_errors_on_unused_labels: diag(6074, ts.DiagnosticCategory.Message, "Do_not_report_errors_on_unused_labels_6074", "Do not report errors on unused labels."),
        Report_error_when_not_all_code_paths_in_function_return_a_value: diag(6075, ts.DiagnosticCategory.Message, "Report_error_when_not_all_code_paths_in_function_return_a_value_6075", "Report error when not all code paths in function return a value."),
        Report_errors_for_fallthrough_cases_in_switch_statement: diag(6076, ts.DiagnosticCategory.Message, "Report_errors_for_fallthrough_cases_in_switch_statement_6076", "Report errors for fallthrough cases in switch statement."),
        Do_not_report_errors_on_unreachable_code: diag(6077, ts.DiagnosticCategory.Message, "Do_not_report_errors_on_unreachable_code_6077", "Do not report errors on unreachable code."),
        Disallow_inconsistently_cased_references_to_the_same_file: diag(6078, ts.DiagnosticCategory.Message, "Disallow_inconsistently_cased_references_to_the_same_file_6078", "Disallow inconsistently-cased references to the same file."),
        Specify_library_files_to_be_included_in_the_compilation: diag(6079, ts.DiagnosticCategory.Message, "Specify_library_files_to_be_included_in_the_compilation_6079", "Specify library files to be included in the compilation."),
        Specify_JSX_code_generation: diag(6080, ts.DiagnosticCategory.Message, "Specify_JSX_code_generation_6080", "Specify JSX code generation."),
        File_0_has_an_unsupported_extension_so_skipping_it: diag(6081, ts.DiagnosticCategory.Message, "File_0_has_an_unsupported_extension_so_skipping_it_6081", "File '{0}' has an unsupported extension, so skipping it."),
        Only_amd_and_system_modules_are_supported_alongside_0: diag(6082, ts.DiagnosticCategory.Error, "Only_amd_and_system_modules_are_supported_alongside_0_6082", "Only 'amd' and 'system' modules are supported alongside --{0}."),
        Base_directory_to_resolve_non_absolute_module_names: diag(6083, ts.DiagnosticCategory.Message, "Base_directory_to_resolve_non_absolute_module_names_6083", "Base directory to resolve non-absolute module names."),
        Deprecated_Use_jsxFactory_instead_Specify_the_object_invoked_for_createElement_when_targeting_react_JSX_emit: diag(6084, ts.DiagnosticCategory.Message, "Deprecated_Use_jsxFactory_instead_Specify_the_object_invoked_for_createElement_when_targeting_react__6084", "[Deprecated] Use '--jsxFactory' instead. Specify the object invoked for createElement when targeting 'react' JSX emit"),
        Enable_tracing_of_the_name_resolution_process: diag(6085, ts.DiagnosticCategory.Message, "Enable_tracing_of_the_name_resolution_process_6085", "Enable tracing of the name resolution process."),
        Resolving_module_0_from_1: diag(6086, ts.DiagnosticCategory.Message, "Resolving_module_0_from_1_6086", "======== Resolving module '{0}' from '{1}'. ========"),
        Explicitly_specified_module_resolution_kind_Colon_0: diag(6087, ts.DiagnosticCategory.Message, "Explicitly_specified_module_resolution_kind_Colon_0_6087", "Explicitly specified module resolution kind: '{0}'."),
        Module_resolution_kind_is_not_specified_using_0: diag(6088, ts.DiagnosticCategory.Message, "Module_resolution_kind_is_not_specified_using_0_6088", "Module resolution kind is not specified, using '{0}'."),
        Module_name_0_was_successfully_resolved_to_1: diag(6089, ts.DiagnosticCategory.Message, "Module_name_0_was_successfully_resolved_to_1_6089", "======== Module name '{0}' was successfully resolved to '{1}'. ========"),
        Module_name_0_was_not_resolved: diag(6090, ts.DiagnosticCategory.Message, "Module_name_0_was_not_resolved_6090", "======== Module name '{0}' was not resolved. ========"),
        paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0: diag(6091, ts.DiagnosticCategory.Message, "paths_option_is_specified_looking_for_a_pattern_to_match_module_name_0_6091", "'paths' option is specified, looking for a pattern to match module name '{0}'."),
        Module_name_0_matched_pattern_1: diag(6092, ts.DiagnosticCategory.Message, "Module_name_0_matched_pattern_1_6092", "Module name '{0}', matched pattern '{1}'."),
        Trying_substitution_0_candidate_module_location_Colon_1: diag(6093, ts.DiagnosticCategory.Message, "Trying_substitution_0_candidate_module_location_Colon_1_6093", "Trying substitution '{0}', candidate module location: '{1}'."),
        Resolving_module_name_0_relative_to_base_url_1_2: diag(6094, ts.DiagnosticCategory.Message, "Resolving_module_name_0_relative_to_base_url_1_2_6094", "Resolving module name '{0}' relative to base url '{1}' - '{2}'."),
        Loading_module_as_file_Slash_folder_candidate_module_location_0_target_file_type_1: diag(6095, ts.DiagnosticCategory.Message, "Loading_module_as_file_Slash_folder_candidate_module_location_0_target_file_type_1_6095", "Loading module as file / folder, candidate module location '{0}', target file type '{1}'."),
        File_0_does_not_exist: diag(6096, ts.DiagnosticCategory.Message, "File_0_does_not_exist_6096", "File '{0}' does not exist."),
        File_0_exist_use_it_as_a_name_resolution_result: diag(6097, ts.DiagnosticCategory.Message, "File_0_exist_use_it_as_a_name_resolution_result_6097", "File '{0}' exist - use it as a name resolution result."),
        Loading_module_0_from_node_modules_folder_target_file_type_1: diag(6098, ts.DiagnosticCategory.Message, "Loading_module_0_from_node_modules_folder_target_file_type_1_6098", "Loading module '{0}' from 'node_modules' folder, target file type '{1}'."),
        Found_package_json_at_0: diag(6099, ts.DiagnosticCategory.Message, "Found_package_json_at_0_6099", "Found 'package.json' at '{0}'."),
        package_json_does_not_have_a_0_field: diag(6100, ts.DiagnosticCategory.Message, "package_json_does_not_have_a_0_field_6100", "'package.json' does not have a '{0}' field."),
        package_json_has_0_field_1_that_references_2: diag(6101, ts.DiagnosticCategory.Message, "package_json_has_0_field_1_that_references_2_6101", "'package.json' has '{0}' field '{1}' that references '{2}'."),
        Allow_javascript_files_to_be_compiled: diag(6102, ts.DiagnosticCategory.Message, "Allow_javascript_files_to_be_compiled_6102", "Allow javascript files to be compiled."),
        Checking_if_0_is_the_longest_matching_prefix_for_1_2: diag(6104, ts.DiagnosticCategory.Message, "Checking_if_0_is_the_longest_matching_prefix_for_1_2_6104", "Checking if '{0}' is the longest matching prefix for '{1}' - '{2}'."),
        Expected_type_of_0_field_in_package_json_to_be_1_got_2: diag(6105, ts.DiagnosticCategory.Message, "Expected_type_of_0_field_in_package_json_to_be_1_got_2_6105", "Expected type of '{0}' field in 'package.json' to be '{1}', got '{2}'."),
        baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1: diag(6106, ts.DiagnosticCategory.Message, "baseUrl_option_is_set_to_0_using_this_value_to_resolve_non_relative_module_name_1_6106", "'baseUrl' option is set to '{0}', using this value to resolve non-relative module name '{1}'."),
        rootDirs_option_is_set_using_it_to_resolve_relative_module_name_0: diag(6107, ts.DiagnosticCategory.Message, "rootDirs_option_is_set_using_it_to_resolve_relative_module_name_0_6107", "'rootDirs' option is set, using it to resolve relative module name '{0}'."),
        Longest_matching_prefix_for_0_is_1: diag(6108, ts.DiagnosticCategory.Message, "Longest_matching_prefix_for_0_is_1_6108", "Longest matching prefix for '{0}' is '{1}'."),
        Loading_0_from_the_root_dir_1_candidate_location_2: diag(6109, ts.DiagnosticCategory.Message, "Loading_0_from_the_root_dir_1_candidate_location_2_6109", "Loading '{0}' from the root dir '{1}', candidate location '{2}'."),
        Trying_other_entries_in_rootDirs: diag(6110, ts.DiagnosticCategory.Message, "Trying_other_entries_in_rootDirs_6110", "Trying other entries in 'rootDirs'."),
        Module_resolution_using_rootDirs_has_failed: diag(6111, ts.DiagnosticCategory.Message, "Module_resolution_using_rootDirs_has_failed_6111", "Module resolution using 'rootDirs' has failed."),
        Do_not_emit_use_strict_directives_in_module_output: diag(6112, ts.DiagnosticCategory.Message, "Do_not_emit_use_strict_directives_in_module_output_6112", "Do not emit 'use strict' directives in module output."),
        Enable_strict_null_checks: diag(6113, ts.DiagnosticCategory.Message, "Enable_strict_null_checks_6113", "Enable strict null checks."),
        Unknown_option_excludes_Did_you_mean_exclude: diag(6114, ts.DiagnosticCategory.Error, "Unknown_option_excludes_Did_you_mean_exclude_6114", "Unknown option 'excludes'. Did you mean 'exclude'?"),
        Raise_error_on_this_expressions_with_an_implied_any_type: diag(6115, ts.DiagnosticCategory.Message, "Raise_error_on_this_expressions_with_an_implied_any_type_6115", "Raise error on 'this' expressions with an implied 'any' type."),
        Resolving_type_reference_directive_0_containing_file_1_root_directory_2: diag(6116, ts.DiagnosticCategory.Message, "Resolving_type_reference_directive_0_containing_file_1_root_directory_2_6116", "======== Resolving type reference directive '{0}', containing file '{1}', root directory '{2}'. ========"),
        Type_reference_directive_0_was_successfully_resolved_to_1_primary_Colon_2: diag(6119, ts.DiagnosticCategory.Message, "Type_reference_directive_0_was_successfully_resolved_to_1_primary_Colon_2_6119", "======== Type reference directive '{0}' was successfully resolved to '{1}', primary: {2}. ========"),
        Type_reference_directive_0_was_not_resolved: diag(6120, ts.DiagnosticCategory.Message, "Type_reference_directive_0_was_not_resolved_6120", "======== Type reference directive '{0}' was not resolved. ========"),
        Resolving_with_primary_search_path_0: diag(6121, ts.DiagnosticCategory.Message, "Resolving_with_primary_search_path_0_6121", "Resolving with primary search path '{0}'."),
        Root_directory_cannot_be_determined_skipping_primary_search_paths: diag(6122, ts.DiagnosticCategory.Message, "Root_directory_cannot_be_determined_skipping_primary_search_paths_6122", "Root directory cannot be determined, skipping primary search paths."),
        Resolving_type_reference_directive_0_containing_file_1_root_directory_not_set: diag(6123, ts.DiagnosticCategory.Message, "Resolving_type_reference_directive_0_containing_file_1_root_directory_not_set_6123", "======== Resolving type reference directive '{0}', containing file '{1}', root directory not set. ========"),
        Type_declaration_files_to_be_included_in_compilation: diag(6124, ts.DiagnosticCategory.Message, "Type_declaration_files_to_be_included_in_compilation_6124", "Type declaration files to be included in compilation."),
        Looking_up_in_node_modules_folder_initial_location_0: diag(6125, ts.DiagnosticCategory.Message, "Looking_up_in_node_modules_folder_initial_location_0_6125", "Looking up in 'node_modules' folder, initial location '{0}'."),
        Containing_file_is_not_specified_and_root_directory_cannot_be_determined_skipping_lookup_in_node_modules_folder: diag(6126, ts.DiagnosticCategory.Message, "Containing_file_is_not_specified_and_root_directory_cannot_be_determined_skipping_lookup_in_node_mod_6126", "Containing file is not specified and root directory cannot be determined, skipping lookup in 'node_modules' folder."),
        Resolving_type_reference_directive_0_containing_file_not_set_root_directory_1: diag(6127, ts.DiagnosticCategory.Message, "Resolving_type_reference_directive_0_containing_file_not_set_root_directory_1_6127", "======== Resolving type reference directive '{0}', containing file not set, root directory '{1}'. ========"),
        Resolving_type_reference_directive_0_containing_file_not_set_root_directory_not_set: diag(6128, ts.DiagnosticCategory.Message, "Resolving_type_reference_directive_0_containing_file_not_set_root_directory_not_set_6128", "======== Resolving type reference directive '{0}', containing file not set, root directory not set. ========"),
        Resolving_real_path_for_0_result_1: diag(6130, ts.DiagnosticCategory.Message, "Resolving_real_path_for_0_result_1_6130", "Resolving real path for '{0}', result '{1}'."),
        Cannot_compile_modules_using_option_0_unless_the_module_flag_is_amd_or_system: diag(6131, ts.DiagnosticCategory.Error, "Cannot_compile_modules_using_option_0_unless_the_module_flag_is_amd_or_system_6131", "Cannot compile modules using option '{0}' unless the '--module' flag is 'amd' or 'system'."),
        File_name_0_has_a_1_extension_stripping_it: diag(6132, ts.DiagnosticCategory.Message, "File_name_0_has_a_1_extension_stripping_it_6132", "File name '{0}' has a '{1}' extension - stripping it."),
        _0_is_declared_but_its_value_is_never_read: diag(6133, ts.DiagnosticCategory.Error, "_0_is_declared_but_its_value_is_never_read_6133", "'{0}' is declared but its value is never read.", /*reportsUnnecessary*/ true),
        Report_errors_on_unused_locals: diag(6134, ts.DiagnosticCategory.Message, "Report_errors_on_unused_locals_6134", "Report errors on unused locals."),
        Report_errors_on_unused_parameters: diag(6135, ts.DiagnosticCategory.Message, "Report_errors_on_unused_parameters_6135", "Report errors on unused parameters."),
        The_maximum_dependency_depth_to_search_under_node_modules_and_load_JavaScript_files: diag(6136, ts.DiagnosticCategory.Message, "The_maximum_dependency_depth_to_search_under_node_modules_and_load_JavaScript_files_6136", "The maximum dependency depth to search under node_modules and load JavaScript files."),
        Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1: diag(6137, ts.DiagnosticCategory.Error, "Cannot_import_type_declaration_files_Consider_importing_0_instead_of_1_6137", "Cannot import type declaration files. Consider importing '{0}' instead of '{1}'."),
        Property_0_is_declared_but_its_value_is_never_read: diag(6138, ts.DiagnosticCategory.Error, "Property_0_is_declared_but_its_value_is_never_read_6138", "Property '{0}' is declared but its value is never read.", /*reportsUnnecessary*/ true),
        Import_emit_helpers_from_tslib: diag(6139, ts.DiagnosticCategory.Message, "Import_emit_helpers_from_tslib_6139", "Import emit helpers from 'tslib'."),
        Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using_cache_location_2: diag(6140, ts.DiagnosticCategory.Error, "Auto_discovery_for_typings_is_enabled_in_project_0_Running_extra_resolution_pass_for_module_1_using__6140", "Auto discovery for typings is enabled in project '{0}'. Running extra resolution pass for module '{1}' using cache location '{2}'."),
        Parse_in_strict_mode_and_emit_use_strict_for_each_source_file: diag(6141, ts.DiagnosticCategory.Message, "Parse_in_strict_mode_and_emit_use_strict_for_each_source_file_6141", "Parse in strict mode and emit \"use strict\" for each source file."),
        Module_0_was_resolved_to_1_but_jsx_is_not_set: diag(6142, ts.DiagnosticCategory.Error, "Module_0_was_resolved_to_1_but_jsx_is_not_set_6142", "Module '{0}' was resolved to '{1}', but '--jsx' is not set."),
        Module_0_was_resolved_as_locally_declared_ambient_module_in_file_1: diag(6144, ts.DiagnosticCategory.Message, "Module_0_was_resolved_as_locally_declared_ambient_module_in_file_1_6144", "Module '{0}' was resolved as locally declared ambient module in file '{1}'."),
        Module_0_was_resolved_as_ambient_module_declared_in_1_since_this_file_was_not_modified: diag(6145, ts.DiagnosticCategory.Message, "Module_0_was_resolved_as_ambient_module_declared_in_1_since_this_file_was_not_modified_6145", "Module '{0}' was resolved as ambient module declared in '{1}' since this file was not modified."),
        Specify_the_JSX_factory_function_to_use_when_targeting_react_JSX_emit_e_g_React_createElement_or_h: diag(6146, ts.DiagnosticCategory.Message, "Specify_the_JSX_factory_function_to_use_when_targeting_react_JSX_emit_e_g_React_createElement_or_h_6146", "Specify the JSX factory function to use when targeting 'react' JSX emit, e.g. 'React.createElement' or 'h'."),
        Resolution_for_module_0_was_found_in_cache_from_location_1: diag(6147, ts.DiagnosticCategory.Message, "Resolution_for_module_0_was_found_in_cache_from_location_1_6147", "Resolution for module '{0}' was found in cache from location '{1}'."),
        Directory_0_does_not_exist_skipping_all_lookups_in_it: diag(6148, ts.DiagnosticCategory.Message, "Directory_0_does_not_exist_skipping_all_lookups_in_it_6148", "Directory '{0}' does not exist, skipping all lookups in it."),
        Show_diagnostic_information: diag(6149, ts.DiagnosticCategory.Message, "Show_diagnostic_information_6149", "Show diagnostic information."),
        Show_verbose_diagnostic_information: diag(6150, ts.DiagnosticCategory.Message, "Show_verbose_diagnostic_information_6150", "Show verbose diagnostic information."),
        Emit_a_single_file_with_source_maps_instead_of_having_a_separate_file: diag(6151, ts.DiagnosticCategory.Message, "Emit_a_single_file_with_source_maps_instead_of_having_a_separate_file_6151", "Emit a single file with source maps instead of having a separate file."),
        Emit_the_source_alongside_the_sourcemaps_within_a_single_file_requires_inlineSourceMap_or_sourceMap_to_be_set: diag(6152, ts.DiagnosticCategory.Message, "Emit_the_source_alongside_the_sourcemaps_within_a_single_file_requires_inlineSourceMap_or_sourceMap__6152", "Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set."),
        Transpile_each_file_as_a_separate_module_similar_to_ts_transpileModule: diag(6153, ts.DiagnosticCategory.Message, "Transpile_each_file_as_a_separate_module_similar_to_ts_transpileModule_6153", "Transpile each file as a separate module (similar to 'ts.transpileModule')."),
        Print_names_of_generated_files_part_of_the_compilation: diag(6154, ts.DiagnosticCategory.Message, "Print_names_of_generated_files_part_of_the_compilation_6154", "Print names of generated files part of the compilation."),
        Print_names_of_files_part_of_the_compilation: diag(6155, ts.DiagnosticCategory.Message, "Print_names_of_files_part_of_the_compilation_6155", "Print names of files part of the compilation."),
        The_locale_used_when_displaying_messages_to_the_user_e_g_en_us: diag(6156, ts.DiagnosticCategory.Message, "The_locale_used_when_displaying_messages_to_the_user_e_g_en_us_6156", "The locale used when displaying messages to the user (e.g. 'en-us')"),
        Do_not_generate_custom_helper_functions_like_extends_in_compiled_output: diag(6157, ts.DiagnosticCategory.Message, "Do_not_generate_custom_helper_functions_like_extends_in_compiled_output_6157", "Do not generate custom helper functions like '__extends' in compiled output."),
        Do_not_include_the_default_library_file_lib_d_ts: diag(6158, ts.DiagnosticCategory.Message, "Do_not_include_the_default_library_file_lib_d_ts_6158", "Do not include the default library file (lib.d.ts)."),
        Do_not_add_triple_slash_references_or_imported_modules_to_the_list_of_compiled_files: diag(6159, ts.DiagnosticCategory.Message, "Do_not_add_triple_slash_references_or_imported_modules_to_the_list_of_compiled_files_6159", "Do not add triple-slash references or imported modules to the list of compiled files."),
        Deprecated_Use_skipLibCheck_instead_Skip_type_checking_of_default_library_declaration_files: diag(6160, ts.DiagnosticCategory.Message, "Deprecated_Use_skipLibCheck_instead_Skip_type_checking_of_default_library_declaration_files_6160", "[Deprecated] Use '--skipLibCheck' instead. Skip type checking of default library declaration files."),
        List_of_folders_to_include_type_definitions_from: diag(6161, ts.DiagnosticCategory.Message, "List_of_folders_to_include_type_definitions_from_6161", "List of folders to include type definitions from."),
        Disable_size_limitations_on_JavaScript_projects: diag(6162, ts.DiagnosticCategory.Message, "Disable_size_limitations_on_JavaScript_projects_6162", "Disable size limitations on JavaScript projects."),
        The_character_set_of_the_input_files: diag(6163, ts.DiagnosticCategory.Message, "The_character_set_of_the_input_files_6163", "The character set of the input files."),
        Do_not_truncate_error_messages: diag(6165, ts.DiagnosticCategory.Message, "Do_not_truncate_error_messages_6165", "Do not truncate error messages."),
        Output_directory_for_generated_declaration_files: diag(6166, ts.DiagnosticCategory.Message, "Output_directory_for_generated_declaration_files_6166", "Output directory for generated declaration files."),
        A_series_of_entries_which_re_map_imports_to_lookup_locations_relative_to_the_baseUrl: diag(6167, ts.DiagnosticCategory.Message, "A_series_of_entries_which_re_map_imports_to_lookup_locations_relative_to_the_baseUrl_6167", "A series of entries which re-map imports to lookup locations relative to the 'baseUrl'."),
        List_of_root_folders_whose_combined_content_represents_the_structure_of_the_project_at_runtime: diag(6168, ts.DiagnosticCategory.Message, "List_of_root_folders_whose_combined_content_represents_the_structure_of_the_project_at_runtime_6168", "List of root folders whose combined content represents the structure of the project at runtime."),
        Show_all_compiler_options: diag(6169, ts.DiagnosticCategory.Message, "Show_all_compiler_options_6169", "Show all compiler options."),
        Deprecated_Use_outFile_instead_Concatenate_and_emit_output_to_single_file: diag(6170, ts.DiagnosticCategory.Message, "Deprecated_Use_outFile_instead_Concatenate_and_emit_output_to_single_file_6170", "[Deprecated] Use '--outFile' instead. Concatenate and emit output to single file"),
        Command_line_Options: diag(6171, ts.DiagnosticCategory.Message, "Command_line_Options_6171", "Command-line Options"),
        Provide_full_support_for_iterables_in_for_of_spread_and_destructuring_when_targeting_ES5_or_ES3: diag(6179, ts.DiagnosticCategory.Message, "Provide_full_support_for_iterables_in_for_of_spread_and_destructuring_when_targeting_ES5_or_ES3_6179", "Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'."),
        Enable_all_strict_type_checking_options: diag(6180, ts.DiagnosticCategory.Message, "Enable_all_strict_type_checking_options_6180", "Enable all strict type-checking options."),
        Scoped_package_detected_looking_in_0: diag(6182, ts.DiagnosticCategory.Message, "Scoped_package_detected_looking_in_0_6182", "Scoped package detected, looking in '{0}'"),
        Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2: diag(6183, ts.DiagnosticCategory.Message, "Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2_6183", "Reusing resolution of module '{0}' from '{1}' of old program, it was successfully resolved to '{2}'."),
        Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package_ID_3: diag(6184, ts.DiagnosticCategory.Message, "Reusing_resolution_of_module_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package__6184", "Reusing resolution of module '{0}' from '{1}' of old program, it was successfully resolved to '{2}' with Package ID '{3}'."),
        Enable_strict_checking_of_function_types: diag(6186, ts.DiagnosticCategory.Message, "Enable_strict_checking_of_function_types_6186", "Enable strict checking of function types."),
        Enable_strict_checking_of_property_initialization_in_classes: diag(6187, ts.DiagnosticCategory.Message, "Enable_strict_checking_of_property_initialization_in_classes_6187", "Enable strict checking of property initialization in classes."),
        Numeric_separators_are_not_allowed_here: diag(6188, ts.DiagnosticCategory.Error, "Numeric_separators_are_not_allowed_here_6188", "Numeric separators are not allowed here."),
        Multiple_consecutive_numeric_separators_are_not_permitted: diag(6189, ts.DiagnosticCategory.Error, "Multiple_consecutive_numeric_separators_are_not_permitted_6189", "Multiple consecutive numeric separators are not permitted."),
        Whether_to_keep_outdated_console_output_in_watch_mode_instead_of_clearing_the_screen: diag(6191, ts.DiagnosticCategory.Message, "Whether_to_keep_outdated_console_output_in_watch_mode_instead_of_clearing_the_screen_6191", "Whether to keep outdated console output in watch mode instead of clearing the screen."),
        All_imports_in_import_declaration_are_unused: diag(6192, ts.DiagnosticCategory.Error, "All_imports_in_import_declaration_are_unused_6192", "All imports in import declaration are unused.", /*reportsUnnecessary*/ true),
        Found_1_error_Watching_for_file_changes: diag(6193, ts.DiagnosticCategory.Message, "Found_1_error_Watching_for_file_changes_6193", "Found 1 error. Watching for file changes."),
        Found_0_errors_Watching_for_file_changes: diag(6194, ts.DiagnosticCategory.Message, "Found_0_errors_Watching_for_file_changes_6194", "Found {0} errors. Watching for file changes."),
        Resolve_keyof_to_string_valued_property_names_only_no_numbers_or_symbols: diag(6195, ts.DiagnosticCategory.Message, "Resolve_keyof_to_string_valued_property_names_only_no_numbers_or_symbols_6195", "Resolve 'keyof' to string valued property names only (no numbers or symbols)."),
        _0_is_declared_but_never_used: diag(6196, ts.DiagnosticCategory.Error, "_0_is_declared_but_never_used_6196", "'{0}' is declared but never used.", /*reportsUnnecessary*/ true),
        Include_modules_imported_with_json_extension: diag(6197, ts.DiagnosticCategory.Message, "Include_modules_imported_with_json_extension_6197", "Include modules imported with '.json' extension"),
        All_destructured_elements_are_unused: diag(6198, ts.DiagnosticCategory.Error, "All_destructured_elements_are_unused_6198", "All destructured elements are unused.", /*reportsUnnecessary*/ true),
        All_variables_are_unused: diag(6199, ts.DiagnosticCategory.Error, "All_variables_are_unused_6199", "All variables are unused.", /*reportsUnnecessary*/ true),
        Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0: diag(6200, ts.DiagnosticCategory.Error, "Definitions_of_the_following_identifiers_conflict_with_those_in_another_file_Colon_0_6200", "Definitions of the following identifiers conflict with those in another file: {0}"),
        Conflicts_are_in_this_file: diag(6201, ts.DiagnosticCategory.Message, "Conflicts_are_in_this_file_6201", "Conflicts are in this file."),
        Project_references_may_not_form_a_circular_graph_Cycle_detected_Colon_0: diag(6202, ts.DiagnosticCategory.Error, "Project_references_may_not_form_a_circular_graph_Cycle_detected_Colon_0_6202", "Project references may not form a circular graph. Cycle detected: {0}"),
        _0_was_also_declared_here: diag(6203, ts.DiagnosticCategory.Message, "_0_was_also_declared_here_6203", "'{0}' was also declared here."),
        and_here: diag(6204, ts.DiagnosticCategory.Message, "and_here_6204", "and here."),
        All_type_parameters_are_unused: diag(6205, ts.DiagnosticCategory.Error, "All_type_parameters_are_unused_6205", "All type parameters are unused."),
        package_json_has_a_typesVersions_field_with_version_specific_path_mappings: diag(6206, ts.DiagnosticCategory.Message, "package_json_has_a_typesVersions_field_with_version_specific_path_mappings_6206", "'package.json' has a 'typesVersions' field with version-specific path mappings."),
        package_json_does_not_have_a_typesVersions_entry_that_matches_version_0: diag(6207, ts.DiagnosticCategory.Message, "package_json_does_not_have_a_typesVersions_entry_that_matches_version_0_6207", "'package.json' does not have a 'typesVersions' entry that matches version '{0}'."),
        package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_match_module_name_2: diag(6208, ts.DiagnosticCategory.Message, "package_json_has_a_typesVersions_entry_0_that_matches_compiler_version_1_looking_for_a_pattern_to_ma_6208", "'package.json' has a 'typesVersions' entry '{0}' that matches compiler version '{1}', looking for a pattern to match module name '{2}'."),
        package_json_has_a_typesVersions_entry_0_that_is_not_a_valid_semver_range: diag(6209, ts.DiagnosticCategory.Message, "package_json_has_a_typesVersions_entry_0_that_is_not_a_valid_semver_range_6209", "'package.json' has a 'typesVersions' entry '{0}' that is not a valid semver range."),
        An_argument_for_0_was_not_provided: diag(6210, ts.DiagnosticCategory.Message, "An_argument_for_0_was_not_provided_6210", "An argument for '{0}' was not provided."),
        An_argument_matching_this_binding_pattern_was_not_provided: diag(6211, ts.DiagnosticCategory.Message, "An_argument_matching_this_binding_pattern_was_not_provided_6211", "An argument matching this binding pattern was not provided."),
        Did_you_mean_to_call_this_expression: diag(6212, ts.DiagnosticCategory.Message, "Did_you_mean_to_call_this_expression_6212", "Did you mean to call this expression?"),
        Did_you_mean_to_use_new_with_this_expression: diag(6213, ts.DiagnosticCategory.Message, "Did_you_mean_to_use_new_with_this_expression_6213", "Did you mean to use 'new' with this expression?"),
        Enable_strict_bind_call_and_apply_methods_on_functions: diag(6214, ts.DiagnosticCategory.Message, "Enable_strict_bind_call_and_apply_methods_on_functions_6214", "Enable strict 'bind', 'call', and 'apply' methods on functions."),
        Using_compiler_options_of_project_reference_redirect_0: diag(6215, ts.DiagnosticCategory.Message, "Using_compiler_options_of_project_reference_redirect_0_6215", "Using compiler options of project reference redirect '{0}'."),
        Found_1_error: diag(6216, ts.DiagnosticCategory.Message, "Found_1_error_6216", "Found 1 error."),
        Found_0_errors: diag(6217, ts.DiagnosticCategory.Message, "Found_0_errors_6217", "Found {0} errors."),
        Module_name_0_was_successfully_resolved_to_1_with_Package_ID_2: diag(6218, ts.DiagnosticCategory.Message, "Module_name_0_was_successfully_resolved_to_1_with_Package_ID_2_6218", "======== Module name '{0}' was successfully resolved to '{1}' with Package ID '{2}'. ========"),
        Type_reference_directive_0_was_successfully_resolved_to_1_with_Package_ID_2_primary_Colon_3: diag(6219, ts.DiagnosticCategory.Message, "Type_reference_directive_0_was_successfully_resolved_to_1_with_Package_ID_2_primary_Colon_3_6219", "======== Type reference directive '{0}' was successfully resolved to '{1}' with Package ID '{2}', primary: {3}. ========"),
        package_json_had_a_falsy_0_field: diag(6220, ts.DiagnosticCategory.Message, "package_json_had_a_falsy_0_field_6220", "'package.json' had a falsy '{0}' field."),
        Disable_use_of_source_files_instead_of_declaration_files_from_referenced_projects: diag(6221, ts.DiagnosticCategory.Message, "Disable_use_of_source_files_instead_of_declaration_files_from_referenced_projects_6221", "Disable use of source files instead of declaration files from referenced projects."),
        Emit_class_fields_with_Define_instead_of_Set: diag(6222, ts.DiagnosticCategory.Message, "Emit_class_fields_with_Define_instead_of_Set_6222", "Emit class fields with Define instead of Set."),
        Generates_a_CPU_profile: diag(6223, ts.DiagnosticCategory.Message, "Generates_a_CPU_profile_6223", "Generates a CPU profile."),
        Disable_solution_searching_for_this_project: diag(6224, ts.DiagnosticCategory.Message, "Disable_solution_searching_for_this_project_6224", "Disable solution searching for this project."),
        Specify_strategy_for_watching_file_Colon_FixedPollingInterval_default_PriorityPollingInterval_DynamicPriorityPolling_FixedChunkSizePolling_UseFsEvents_UseFsEventsOnParentDirectory: diag(6225, ts.DiagnosticCategory.Message, "Specify_strategy_for_watching_file_Colon_FixedPollingInterval_default_PriorityPollingInterval_Dynami_6225", "Specify strategy for watching file: 'FixedPollingInterval' (default), 'PriorityPollingInterval', 'DynamicPriorityPolling', 'FixedChunkSizePolling', 'UseFsEvents', 'UseFsEventsOnParentDirectory'."),
        Specify_strategy_for_watching_directory_on_platforms_that_don_t_support_recursive_watching_natively_Colon_UseFsEvents_default_FixedPollingInterval_DynamicPriorityPolling_FixedChunkSizePolling: diag(6226, ts.DiagnosticCategory.Message, "Specify_strategy_for_watching_directory_on_platforms_that_don_t_support_recursive_watching_natively__6226", "Specify strategy for watching directory on platforms that don't support recursive watching natively: 'UseFsEvents' (default), 'FixedPollingInterval', 'DynamicPriorityPolling', 'FixedChunkSizePolling'."),
        Specify_strategy_for_creating_a_polling_watch_when_it_fails_to_create_using_file_system_events_Colon_FixedInterval_default_PriorityInterval_DynamicPriority_FixedChunkSize: diag(6227, ts.DiagnosticCategory.Message, "Specify_strategy_for_creating_a_polling_watch_when_it_fails_to_create_using_file_system_events_Colon_6227", "Specify strategy for creating a polling watch when it fails to create using file system events: 'FixedInterval' (default), 'PriorityInterval', 'DynamicPriority', 'FixedChunkSize'."),
        Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3: diag(6229, ts.DiagnosticCategory.Error, "Tag_0_expects_at_least_1_arguments_but_the_JSX_factory_2_provides_at_most_3_6229", "Tag '{0}' expects at least '{1}' arguments, but the JSX factory '{2}' provides at most '{3}'."),
        Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_false_or_null_on_command_line: diag(6230, ts.DiagnosticCategory.Error, "Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_false_or_null_on_command_line_6230", "Option '{0}' can only be specified in 'tsconfig.json' file or set to 'false' or 'null' on command line."),
        Could_not_resolve_the_path_0_with_the_extensions_Colon_1: diag(6231, ts.DiagnosticCategory.Error, "Could_not_resolve_the_path_0_with_the_extensions_Colon_1_6231", "Could not resolve the path '{0}' with the extensions: {1}."),
        Declaration_augments_declaration_in_another_file_This_cannot_be_serialized: diag(6232, ts.DiagnosticCategory.Error, "Declaration_augments_declaration_in_another_file_This_cannot_be_serialized_6232", "Declaration augments declaration in another file. This cannot be serialized."),
        This_is_the_declaration_being_augmented_Consider_moving_the_augmenting_declaration_into_the_same_file: diag(6233, ts.DiagnosticCategory.Error, "This_is_the_declaration_being_augmented_Consider_moving_the_augmenting_declaration_into_the_same_fil_6233", "This is the declaration being augmented. Consider moving the augmenting declaration into the same file."),
        This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without: diag(6234, ts.DiagnosticCategory.Error, "This_expression_is_not_callable_because_it_is_a_get_accessor_Did_you_mean_to_use_it_without_6234", "This expression is not callable because it is a 'get' accessor. Did you mean to use it without '()'?"),
        Disable_loading_referenced_projects: diag(6235, ts.DiagnosticCategory.Message, "Disable_loading_referenced_projects_6235", "Disable loading referenced projects."),
        Arguments_for_the_rest_parameter_0_were_not_provided: diag(6236, ts.DiagnosticCategory.Error, "Arguments_for_the_rest_parameter_0_were_not_provided_6236", "Arguments for the rest parameter '{0}' were not provided."),
        Generates_an_event_trace_and_a_list_of_types: diag(6237, ts.DiagnosticCategory.Message, "Generates_an_event_trace_and_a_list_of_types_6237", "Generates an event trace and a list of types."),
        Specify_the_module_specifier_to_be_used_to_import_the_jsx_and_jsxs_factory_functions_from_eg_react: diag(6238, ts.DiagnosticCategory.Error, "Specify_the_module_specifier_to_be_used_to_import_the_jsx_and_jsxs_factory_functions_from_eg_react_6238", "Specify the module specifier to be used to import the 'jsx' and 'jsxs' factory functions from. eg, react"),
        File_0_exists_according_to_earlier_cached_lookups: diag(6239, ts.DiagnosticCategory.Message, "File_0_exists_according_to_earlier_cached_lookups_6239", "File '{0}' exists according to earlier cached lookups."),
        File_0_does_not_exist_according_to_earlier_cached_lookups: diag(6240, ts.DiagnosticCategory.Message, "File_0_does_not_exist_according_to_earlier_cached_lookups_6240", "File '{0}' does not exist according to earlier cached lookups."),
        Resolution_for_type_reference_directive_0_was_found_in_cache_from_location_1: diag(6241, ts.DiagnosticCategory.Message, "Resolution_for_type_reference_directive_0_was_found_in_cache_from_location_1_6241", "Resolution for type reference directive '{0}' was found in cache from location '{1}'."),
        Resolving_type_reference_directive_0_containing_file_1: diag(6242, ts.DiagnosticCategory.Message, "Resolving_type_reference_directive_0_containing_file_1_6242", "======== Resolving type reference directive '{0}', containing file '{1}'. ========"),
        Interpret_optional_property_types_as_written_rather_than_adding_undefined: diag(6243, ts.DiagnosticCategory.Message, "Interpret_optional_property_types_as_written_rather_than_adding_undefined_6243", "Interpret optional property types as written, rather than adding 'undefined'."),
        Modules: diag(6244, ts.DiagnosticCategory.Message, "Modules_6244", "Modules"),
        File_Management: diag(6245, ts.DiagnosticCategory.Message, "File_Management_6245", "File Management"),
        Emit: diag(6246, ts.DiagnosticCategory.Message, "Emit_6246", "Emit"),
        JavaScript_Support: diag(6247, ts.DiagnosticCategory.Message, "JavaScript_Support_6247", "JavaScript Support"),
        Type_Checking: diag(6248, ts.DiagnosticCategory.Message, "Type_Checking_6248", "Type Checking"),
        Editor_Support: diag(6249, ts.DiagnosticCategory.Message, "Editor_Support_6249", "Editor Support"),
        Watch_and_Build_Modes: diag(6250, ts.DiagnosticCategory.Message, "Watch_and_Build_Modes_6250", "Watch and Build Modes"),
        Compiler_Diagnostics: diag(6251, ts.DiagnosticCategory.Message, "Compiler_Diagnostics_6251", "Compiler Diagnostics"),
        Interop_Constraints: diag(6252, ts.DiagnosticCategory.Message, "Interop_Constraints_6252", "Interop Constraints"),
        Backwards_Compatibility: diag(6253, ts.DiagnosticCategory.Message, "Backwards_Compatibility_6253", "Backwards Compatibility"),
        Language_and_Environment: diag(6254, ts.DiagnosticCategory.Message, "Language_and_Environment_6254", "Language and Environment"),
        Projects: diag(6255, ts.DiagnosticCategory.Message, "Projects_6255", "Projects"),
        Output_Formatting: diag(6256, ts.DiagnosticCategory.Message, "Output_Formatting_6256", "Output Formatting"),
        Completeness: diag(6257, ts.DiagnosticCategory.Message, "Completeness_6257", "Completeness"),
        _0_should_be_set_inside_the_compilerOptions_object_of_the_config_json_file: diag(6258, ts.DiagnosticCategory.Error, "_0_should_be_set_inside_the_compilerOptions_object_of_the_config_json_file_6258", "'{0}' should be set inside the 'compilerOptions' object of the config json file"),
        Found_1_error_in_1: diag(6259, ts.DiagnosticCategory.Message, "Found_1_error_in_1_6259", "Found 1 error in {1}"),
        Found_0_errors_in_the_same_file_starting_at_Colon_1: diag(6260, ts.DiagnosticCategory.Message, "Found_0_errors_in_the_same_file_starting_at_Colon_1_6260", "Found {0} errors in the same file, starting at: {1}"),
        Found_0_errors_in_1_files: diag(6261, ts.DiagnosticCategory.Message, "Found_0_errors_in_1_files_6261", "Found {0} errors in {1} files."),
        Directory_0_has_no_containing_package_json_scope_Imports_will_not_resolve: diag(6270, ts.DiagnosticCategory.Message, "Directory_0_has_no_containing_package_json_scope_Imports_will_not_resolve_6270", "Directory '{0}' has no containing package.json scope. Imports will not resolve."),
        Import_specifier_0_does_not_exist_in_package_json_scope_at_path_1: diag(6271, ts.DiagnosticCategory.Message, "Import_specifier_0_does_not_exist_in_package_json_scope_at_path_1_6271", "Import specifier '{0}' does not exist in package.json scope at path '{1}'."),
        Invalid_import_specifier_0_has_no_possible_resolutions: diag(6272, ts.DiagnosticCategory.Message, "Invalid_import_specifier_0_has_no_possible_resolutions_6272", "Invalid import specifier '{0}' has no possible resolutions."),
        package_json_scope_0_has_no_imports_defined: diag(6273, ts.DiagnosticCategory.Message, "package_json_scope_0_has_no_imports_defined_6273", "package.json scope '{0}' has no imports defined."),
        package_json_scope_0_explicitly_maps_specifier_1_to_null: diag(6274, ts.DiagnosticCategory.Message, "package_json_scope_0_explicitly_maps_specifier_1_to_null_6274", "package.json scope '{0}' explicitly maps specifier '{1}' to null."),
        package_json_scope_0_has_invalid_type_for_target_of_specifier_1: diag(6275, ts.DiagnosticCategory.Message, "package_json_scope_0_has_invalid_type_for_target_of_specifier_1_6275", "package.json scope '{0}' has invalid type for target of specifier '{1}'"),
        Export_specifier_0_does_not_exist_in_package_json_scope_at_path_1: diag(6276, ts.DiagnosticCategory.Message, "Export_specifier_0_does_not_exist_in_package_json_scope_at_path_1_6276", "Export specifier '{0}' does not exist in package.json scope at path '{1}'."),
        Enable_project_compilation: diag(6302, ts.DiagnosticCategory.Message, "Enable_project_compilation_6302", "Enable project compilation"),
        Composite_projects_may_not_disable_declaration_emit: diag(6304, ts.DiagnosticCategory.Error, "Composite_projects_may_not_disable_declaration_emit_6304", "Composite projects may not disable declaration emit."),
        Output_file_0_has_not_been_built_from_source_file_1: diag(6305, ts.DiagnosticCategory.Error, "Output_file_0_has_not_been_built_from_source_file_1_6305", "Output file '{0}' has not been built from source file '{1}'."),
        Referenced_project_0_must_have_setting_composite_Colon_true: diag(6306, ts.DiagnosticCategory.Error, "Referenced_project_0_must_have_setting_composite_Colon_true_6306", "Referenced project '{0}' must have setting \"composite\": true."),
        File_0_is_not_listed_within_the_file_list_of_project_1_Projects_must_list_all_files_or_use_an_include_pattern: diag(6307, ts.DiagnosticCategory.Error, "File_0_is_not_listed_within_the_file_list_of_project_1_Projects_must_list_all_files_or_use_an_includ_6307", "File '{0}' is not listed within the file list of project '{1}'. Projects must list all files or use an 'include' pattern."),
        Cannot_prepend_project_0_because_it_does_not_have_outFile_set: diag(6308, ts.DiagnosticCategory.Error, "Cannot_prepend_project_0_because_it_does_not_have_outFile_set_6308", "Cannot prepend project '{0}' because it does not have 'outFile' set"),
        Output_file_0_from_project_1_does_not_exist: diag(6309, ts.DiagnosticCategory.Error, "Output_file_0_from_project_1_does_not_exist_6309", "Output file '{0}' from project '{1}' does not exist"),
        Referenced_project_0_may_not_disable_emit: diag(6310, ts.DiagnosticCategory.Error, "Referenced_project_0_may_not_disable_emit_6310", "Referenced project '{0}' may not disable emit."),
        Project_0_is_out_of_date_because_output_1_is_older_than_input_2: diag(6350, ts.DiagnosticCategory.Message, "Project_0_is_out_of_date_because_output_1_is_older_than_input_2_6350", "Project '{0}' is out of date because output '{1}' is older than input '{2}'"),
        Project_0_is_up_to_date_because_newest_input_1_is_older_than_output_2: diag(6351, ts.DiagnosticCategory.Message, "Project_0_is_up_to_date_because_newest_input_1_is_older_than_output_2_6351", "Project '{0}' is up to date because newest input '{1}' is older than output '{2}'"),
        Project_0_is_out_of_date_because_output_file_1_does_not_exist: diag(6352, ts.DiagnosticCategory.Message, "Project_0_is_out_of_date_because_output_file_1_does_not_exist_6352", "Project '{0}' is out of date because output file '{1}' does not exist"),
        Project_0_is_out_of_date_because_its_dependency_1_is_out_of_date: diag(6353, ts.DiagnosticCategory.Message, "Project_0_is_out_of_date_because_its_dependency_1_is_out_of_date_6353", "Project '{0}' is out of date because its dependency '{1}' is out of date"),
        Project_0_is_up_to_date_with_d_ts_files_from_its_dependencies: diag(6354, ts.DiagnosticCategory.Message, "Project_0_is_up_to_date_with_d_ts_files_from_its_dependencies_6354", "Project '{0}' is up to date with .d.ts files from its dependencies"),
        Projects_in_this_build_Colon_0: diag(6355, ts.DiagnosticCategory.Message, "Projects_in_this_build_Colon_0_6355", "Projects in this build: {0}"),
        A_non_dry_build_would_delete_the_following_files_Colon_0: diag(6356, ts.DiagnosticCategory.Message, "A_non_dry_build_would_delete_the_following_files_Colon_0_6356", "A non-dry build would delete the following files: {0}"),
        A_non_dry_build_would_build_project_0: diag(6357, ts.DiagnosticCategory.Message, "A_non_dry_build_would_build_project_0_6357", "A non-dry build would build project '{0}'"),
        Building_project_0: diag(6358, ts.DiagnosticCategory.Message, "Building_project_0_6358", "Building project '{0}'..."),
        Updating_output_timestamps_of_project_0: diag(6359, ts.DiagnosticCategory.Message, "Updating_output_timestamps_of_project_0_6359", "Updating output timestamps of project '{0}'..."),
        Project_0_is_up_to_date: diag(6361, ts.DiagnosticCategory.Message, "Project_0_is_up_to_date_6361", "Project '{0}' is up to date"),
        Skipping_build_of_project_0_because_its_dependency_1_has_errors: diag(6362, ts.DiagnosticCategory.Message, "Skipping_build_of_project_0_because_its_dependency_1_has_errors_6362", "Skipping build of project '{0}' because its dependency '{1}' has errors"),
        Project_0_can_t_be_built_because_its_dependency_1_has_errors: diag(6363, ts.DiagnosticCategory.Message, "Project_0_can_t_be_built_because_its_dependency_1_has_errors_6363", "Project '{0}' can't be built because its dependency '{1}' has errors"),
        Build_one_or_more_projects_and_their_dependencies_if_out_of_date: diag(6364, ts.DiagnosticCategory.Message, "Build_one_or_more_projects_and_their_dependencies_if_out_of_date_6364", "Build one or more projects and their dependencies, if out of date"),
        Delete_the_outputs_of_all_projects: diag(6365, ts.DiagnosticCategory.Message, "Delete_the_outputs_of_all_projects_6365", "Delete the outputs of all projects."),
        Show_what_would_be_built_or_deleted_if_specified_with_clean: diag(6367, ts.DiagnosticCategory.Message, "Show_what_would_be_built_or_deleted_if_specified_with_clean_6367", "Show what would be built (or deleted, if specified with '--clean')"),
        Option_build_must_be_the_first_command_line_argument: diag(6369, ts.DiagnosticCategory.Error, "Option_build_must_be_the_first_command_line_argument_6369", "Option '--build' must be the first command line argument."),
        Options_0_and_1_cannot_be_combined: diag(6370, ts.DiagnosticCategory.Error, "Options_0_and_1_cannot_be_combined_6370", "Options '{0}' and '{1}' cannot be combined."),
        Updating_unchanged_output_timestamps_of_project_0: diag(6371, ts.DiagnosticCategory.Message, "Updating_unchanged_output_timestamps_of_project_0_6371", "Updating unchanged output timestamps of project '{0}'..."),
        Project_0_is_out_of_date_because_output_of_its_dependency_1_has_changed: diag(6372, ts.DiagnosticCategory.Message, "Project_0_is_out_of_date_because_output_of_its_dependency_1_has_changed_6372", "Project '{0}' is out of date because output of its dependency '{1}' has changed"),
        Updating_output_of_project_0: diag(6373, ts.DiagnosticCategory.Message, "Updating_output_of_project_0_6373", "Updating output of project '{0}'..."),
        A_non_dry_build_would_update_timestamps_for_output_of_project_0: diag(6374, ts.DiagnosticCategory.Message, "A_non_dry_build_would_update_timestamps_for_output_of_project_0_6374", "A non-dry build would update timestamps for output of project '{0}'"),
        A_non_dry_build_would_update_output_of_project_0: diag(6375, ts.DiagnosticCategory.Message, "A_non_dry_build_would_update_output_of_project_0_6375", "A non-dry build would update output of project '{0}'"),
        Cannot_update_output_of_project_0_because_there_was_error_reading_file_1: diag(6376, ts.DiagnosticCategory.Message, "Cannot_update_output_of_project_0_because_there_was_error_reading_file_1_6376", "Cannot update output of project '{0}' because there was error reading file '{1}'"),
        Cannot_write_file_0_because_it_will_overwrite_tsbuildinfo_file_generated_by_referenced_project_1: diag(6377, ts.DiagnosticCategory.Error, "Cannot_write_file_0_because_it_will_overwrite_tsbuildinfo_file_generated_by_referenced_project_1_6377", "Cannot write file '{0}' because it will overwrite '.tsbuildinfo' file generated by referenced project '{1}'"),
        Composite_projects_may_not_disable_incremental_compilation: diag(6379, ts.DiagnosticCategory.Error, "Composite_projects_may_not_disable_incremental_compilation_6379", "Composite projects may not disable incremental compilation."),
        Specify_file_to_store_incremental_compilation_information: diag(6380, ts.DiagnosticCategory.Message, "Specify_file_to_store_incremental_compilation_information_6380", "Specify file to store incremental compilation information"),
        Project_0_is_out_of_date_because_output_for_it_was_generated_with_version_1_that_differs_with_current_version_2: diag(6381, ts.DiagnosticCategory.Message, "Project_0_is_out_of_date_because_output_for_it_was_generated_with_version_1_that_differs_with_curren_6381", "Project '{0}' is out of date because output for it was generated with version '{1}' that differs with current version '{2}'"),
        Skipping_build_of_project_0_because_its_dependency_1_was_not_built: diag(6382, ts.DiagnosticCategory.Message, "Skipping_build_of_project_0_because_its_dependency_1_was_not_built_6382", "Skipping build of project '{0}' because its dependency '{1}' was not built"),
        Project_0_can_t_be_built_because_its_dependency_1_was_not_built: diag(6383, ts.DiagnosticCategory.Message, "Project_0_can_t_be_built_because_its_dependency_1_was_not_built_6383", "Project '{0}' can't be built because its dependency '{1}' was not built"),
        Have_recompiles_in_incremental_and_watch_assume_that_changes_within_a_file_will_only_affect_files_directly_depending_on_it: diag(6384, ts.DiagnosticCategory.Message, "Have_recompiles_in_incremental_and_watch_assume_that_changes_within_a_file_will_only_affect_files_di_6384", "Have recompiles in '--incremental' and '--watch' assume that changes within a file will only affect files directly depending on it."),
        _0_is_deprecated: diag(6385, ts.DiagnosticCategory.Suggestion, "_0_is_deprecated_6385", "'{0}' is deprecated.", /*reportsUnnecessary*/ undefined, /*elidedInCompatabilityPyramid*/ undefined, /*reportsDeprecated*/ true),
        Performance_timings_for_diagnostics_or_extendedDiagnostics_are_not_available_in_this_session_A_native_implementation_of_the_Web_Performance_API_could_not_be_found: diag(6386, ts.DiagnosticCategory.Message, "Performance_timings_for_diagnostics_or_extendedDiagnostics_are_not_available_in_this_session_A_nativ_6386", "Performance timings for '--diagnostics' or '--extendedDiagnostics' are not available in this session. A native implementation of the Web Performance API could not be found."),
        The_signature_0_of_1_is_deprecated: diag(6387, ts.DiagnosticCategory.Suggestion, "The_signature_0_of_1_is_deprecated_6387", "The signature '{0}' of '{1}' is deprecated.", /*reportsUnnecessary*/ undefined, /*elidedInCompatabilityPyramid*/ undefined, /*reportsDeprecated*/ true),
        Project_0_is_being_forcibly_rebuilt: diag(6388, ts.DiagnosticCategory.Message, "Project_0_is_being_forcibly_rebuilt_6388", "Project '{0}' is being forcibly rebuilt"),
        Reusing_resolution_of_module_0_from_1_of_old_program_it_was_not_resolved: diag(6389, ts.DiagnosticCategory.Message, "Reusing_resolution_of_module_0_from_1_of_old_program_it_was_not_resolved_6389", "Reusing resolution of module '{0}' from '{1}' of old program, it was not resolved."),
        Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved_to_2: diag(6390, ts.DiagnosticCategory.Message, "Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved__6390", "Reusing resolution of type reference directive '{0}' from '{1}' of old program, it was successfully resolved to '{2}'."),
        Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved_to_2_with_Package_ID_3: diag(6391, ts.DiagnosticCategory.Message, "Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_successfully_resolved__6391", "Reusing resolution of type reference directive '{0}' from '{1}' of old program, it was successfully resolved to '{2}' with Package ID '{3}'."),
        Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_not_resolved: diag(6392, ts.DiagnosticCategory.Message, "Reusing_resolution_of_type_reference_directive_0_from_1_of_old_program_it_was_not_resolved_6392", "Reusing resolution of type reference directive '{0}' from '{1}' of old program, it was not resolved."),
        Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3: diag(6393, ts.DiagnosticCategory.Message, "Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_6393", "Reusing resolution of module '{0}' from '{1}' found in cache from location '{2}', it was successfully resolved to '{3}'."),
        Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3_with_Package_ID_4: diag(6394, ts.DiagnosticCategory.Message, "Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_6394", "Reusing resolution of module '{0}' from '{1}' found in cache from location '{2}', it was successfully resolved to '{3}' with Package ID '{4}'."),
        Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_not_resolved: diag(6395, ts.DiagnosticCategory.Message, "Reusing_resolution_of_module_0_from_1_found_in_cache_from_location_2_it_was_not_resolved_6395", "Reusing resolution of module '{0}' from '{1}' found in cache from location '{2}', it was not resolved."),
        Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3: diag(6396, ts.DiagnosticCategory.Message, "Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_succes_6396", "Reusing resolution of type reference directive '{0}' from '{1}' found in cache from location '{2}', it was successfully resolved to '{3}'."),
        Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_successfully_resolved_to_3_with_Package_ID_4: diag(6397, ts.DiagnosticCategory.Message, "Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_succes_6397", "Reusing resolution of type reference directive '{0}' from '{1}' found in cache from location '{2}', it was successfully resolved to '{3}' with Package ID '{4}'."),
        Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_not_resolved: diag(6398, ts.DiagnosticCategory.Message, "Reusing_resolution_of_type_reference_directive_0_from_1_found_in_cache_from_location_2_it_was_not_re_6398", "Reusing resolution of type reference directive '{0}' from '{1}' found in cache from location '{2}', it was not resolved."),
        Project_0_is_out_of_date_because_buildinfo_file_1_indicates_that_some_of_the_changes_were_not_emitted: diag(6399, ts.DiagnosticCategory.Message, "Project_0_is_out_of_date_because_buildinfo_file_1_indicates_that_some_of_the_changes_were_not_emitte_6399", "Project '{0}' is out of date because buildinfo file '{1}' indicates that some of the changes were not emitted"),
        Project_0_is_up_to_date_but_needs_to_update_timestamps_of_output_files_that_are_older_than_input_files: diag(6400, ts.DiagnosticCategory.Message, "Project_0_is_up_to_date_but_needs_to_update_timestamps_of_output_files_that_are_older_than_input_fil_6400", "Project '{0}' is up to date but needs to update timestamps of output files that are older than input files"),
        The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1: diag(6500, ts.DiagnosticCategory.Message, "The_expected_type_comes_from_property_0_which_is_declared_here_on_type_1_6500", "The expected type comes from property '{0}' which is declared here on type '{1}'"),
        The_expected_type_comes_from_this_index_signature: diag(6501, ts.DiagnosticCategory.Message, "The_expected_type_comes_from_this_index_signature_6501", "The expected type comes from this index signature."),
        The_expected_type_comes_from_the_return_type_of_this_signature: diag(6502, ts.DiagnosticCategory.Message, "The_expected_type_comes_from_the_return_type_of_this_signature_6502", "The expected type comes from the return type of this signature."),
        Print_names_of_files_that_are_part_of_the_compilation_and_then_stop_processing: diag(6503, ts.DiagnosticCategory.Message, "Print_names_of_files_that_are_part_of_the_compilation_and_then_stop_processing_6503", "Print names of files that are part of the compilation and then stop processing."),
        File_0_is_a_JavaScript_file_Did_you_mean_to_enable_the_allowJs_option: diag(6504, ts.DiagnosticCategory.Error, "File_0_is_a_JavaScript_file_Did_you_mean_to_enable_the_allowJs_option_6504", "File '{0}' is a JavaScript file. Did you mean to enable the 'allowJs' option?"),
        Print_names_of_files_and_the_reason_they_are_part_of_the_compilation: diag(6505, ts.DiagnosticCategory.Message, "Print_names_of_files_and_the_reason_they_are_part_of_the_compilation_6505", "Print names of files and the reason they are part of the compilation."),
        Consider_adding_a_declare_modifier_to_this_class: diag(6506, ts.DiagnosticCategory.Message, "Consider_adding_a_declare_modifier_to_this_class_6506", "Consider adding a 'declare' modifier to this class."),
        Allow_JavaScript_files_to_be_a_part_of_your_program_Use_the_checkJS_option_to_get_errors_from_these_files: diag(6600, ts.DiagnosticCategory.Message, "Allow_JavaScript_files_to_be_a_part_of_your_program_Use_the_checkJS_option_to_get_errors_from_these__6600", "Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files."),
        Allow_import_x_from_y_when_a_module_doesn_t_have_a_default_export: diag(6601, ts.DiagnosticCategory.Message, "Allow_import_x_from_y_when_a_module_doesn_t_have_a_default_export_6601", "Allow 'import x from y' when a module doesn't have a default export."),
        Allow_accessing_UMD_globals_from_modules: diag(6602, ts.DiagnosticCategory.Message, "Allow_accessing_UMD_globals_from_modules_6602", "Allow accessing UMD globals from modules."),
        Disable_error_reporting_for_unreachable_code: diag(6603, ts.DiagnosticCategory.Message, "Disable_error_reporting_for_unreachable_code_6603", "Disable error reporting for unreachable code."),
        Disable_error_reporting_for_unused_labels: diag(6604, ts.DiagnosticCategory.Message, "Disable_error_reporting_for_unused_labels_6604", "Disable error reporting for unused labels."),
        Ensure_use_strict_is_always_emitted: diag(6605, ts.DiagnosticCategory.Message, "Ensure_use_strict_is_always_emitted_6605", "Ensure 'use strict' is always emitted."),
        Have_recompiles_in_projects_that_use_incremental_and_watch_mode_assume_that_changes_within_a_file_will_only_affect_files_directly_depending_on_it: diag(6606, ts.DiagnosticCategory.Message, "Have_recompiles_in_projects_that_use_incremental_and_watch_mode_assume_that_changes_within_a_file_wi_6606", "Have recompiles in projects that use 'incremental' and 'watch' mode assume that changes within a file will only affect files directly depending on it."),
        Specify_the_base_directory_to_resolve_non_relative_module_names: diag(6607, ts.DiagnosticCategory.Message, "Specify_the_base_directory_to_resolve_non_relative_module_names_6607", "Specify the base directory to resolve non-relative module names."),
        No_longer_supported_In_early_versions_manually_set_the_text_encoding_for_reading_files: diag(6608, ts.DiagnosticCategory.Message, "No_longer_supported_In_early_versions_manually_set_the_text_encoding_for_reading_files_6608", "No longer supported. In early versions, manually set the text encoding for reading files."),
        Enable_error_reporting_in_type_checked_JavaScript_files: diag(6609, ts.DiagnosticCategory.Message, "Enable_error_reporting_in_type_checked_JavaScript_files_6609", "Enable error reporting in type-checked JavaScript files."),
        Enable_constraints_that_allow_a_TypeScript_project_to_be_used_with_project_references: diag(6611, ts.DiagnosticCategory.Message, "Enable_constraints_that_allow_a_TypeScript_project_to_be_used_with_project_references_6611", "Enable constraints that allow a TypeScript project to be used with project references."),
        Generate_d_ts_files_from_TypeScript_and_JavaScript_files_in_your_project: diag(6612, ts.DiagnosticCategory.Message, "Generate_d_ts_files_from_TypeScript_and_JavaScript_files_in_your_project_6612", "Generate .d.ts files from TypeScript and JavaScript files in your project."),
        Specify_the_output_directory_for_generated_declaration_files: diag(6613, ts.DiagnosticCategory.Message, "Specify_the_output_directory_for_generated_declaration_files_6613", "Specify the output directory for generated declaration files."),
        Create_sourcemaps_for_d_ts_files: diag(6614, ts.DiagnosticCategory.Message, "Create_sourcemaps_for_d_ts_files_6614", "Create sourcemaps for d.ts files."),
        Output_compiler_performance_information_after_building: diag(6615, ts.DiagnosticCategory.Message, "Output_compiler_performance_information_after_building_6615", "Output compiler performance information after building."),
        Disables_inference_for_type_acquisition_by_looking_at_filenames_in_a_project: diag(6616, ts.DiagnosticCategory.Message, "Disables_inference_for_type_acquisition_by_looking_at_filenames_in_a_project_6616", "Disables inference for type acquisition by looking at filenames in a project."),
        Reduce_the_number_of_projects_loaded_automatically_by_TypeScript: diag(6617, ts.DiagnosticCategory.Message, "Reduce_the_number_of_projects_loaded_automatically_by_TypeScript_6617", "Reduce the number of projects loaded automatically by TypeScript."),
        Remove_the_20mb_cap_on_total_source_code_size_for_JavaScript_files_in_the_TypeScript_language_server: diag(6618, ts.DiagnosticCategory.Message, "Remove_the_20mb_cap_on_total_source_code_size_for_JavaScript_files_in_the_TypeScript_language_server_6618", "Remove the 20mb cap on total source code size for JavaScript files in the TypeScript language server."),
        Opt_a_project_out_of_multi_project_reference_checking_when_editing: diag(6619, ts.DiagnosticCategory.Message, "Opt_a_project_out_of_multi_project_reference_checking_when_editing_6619", "Opt a project out of multi-project reference checking when editing."),
        Disable_preferring_source_files_instead_of_declaration_files_when_referencing_composite_projects: diag(6620, ts.DiagnosticCategory.Message, "Disable_preferring_source_files_instead_of_declaration_files_when_referencing_composite_projects_6620", "Disable preferring source files instead of declaration files when referencing composite projects."),
        Emit_more_compliant_but_verbose_and_less_performant_JavaScript_for_iteration: diag(6621, ts.DiagnosticCategory.Message, "Emit_more_compliant_but_verbose_and_less_performant_JavaScript_for_iteration_6621", "Emit more compliant, but verbose and less performant JavaScript for iteration."),
        Emit_a_UTF_8_Byte_Order_Mark_BOM_in_the_beginning_of_output_files: diag(6622, ts.DiagnosticCategory.Message, "Emit_a_UTF_8_Byte_Order_Mark_BOM_in_the_beginning_of_output_files_6622", "Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files."),
        Only_output_d_ts_files_and_not_JavaScript_files: diag(6623, ts.DiagnosticCategory.Message, "Only_output_d_ts_files_and_not_JavaScript_files_6623", "Only output d.ts files and not JavaScript files."),
        Emit_design_type_metadata_for_decorated_declarations_in_source_files: diag(6624, ts.DiagnosticCategory.Message, "Emit_design_type_metadata_for_decorated_declarations_in_source_files_6624", "Emit design-type metadata for decorated declarations in source files."),
        Disable_the_type_acquisition_for_JavaScript_projects: diag(6625, ts.DiagnosticCategory.Message, "Disable_the_type_acquisition_for_JavaScript_projects_6625", "Disable the type acquisition for JavaScript projects"),
        Emit_additional_JavaScript_to_ease_support_for_importing_CommonJS_modules_This_enables_allowSyntheticDefaultImports_for_type_compatibility: diag(6626, ts.DiagnosticCategory.Message, "Emit_additional_JavaScript_to_ease_support_for_importing_CommonJS_modules_This_enables_allowSyntheti_6626", "Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility."),
        Filters_results_from_the_include_option: diag(6627, ts.DiagnosticCategory.Message, "Filters_results_from_the_include_option_6627", "Filters results from the `include` option."),
        Remove_a_list_of_directories_from_the_watch_process: diag(6628, ts.DiagnosticCategory.Message, "Remove_a_list_of_directories_from_the_watch_process_6628", "Remove a list of directories from the watch process."),
        Remove_a_list_of_files_from_the_watch_mode_s_processing: diag(6629, ts.DiagnosticCategory.Message, "Remove_a_list_of_files_from_the_watch_mode_s_processing_6629", "Remove a list of files from the watch mode's processing."),
        Enable_experimental_support_for_TC39_stage_2_draft_decorators: diag(6630, ts.DiagnosticCategory.Message, "Enable_experimental_support_for_TC39_stage_2_draft_decorators_6630", "Enable experimental support for TC39 stage 2 draft decorators."),
        Print_files_read_during_the_compilation_including_why_it_was_included: diag(6631, ts.DiagnosticCategory.Message, "Print_files_read_during_the_compilation_including_why_it_was_included_6631", "Print files read during the compilation including why it was included."),
        Output_more_detailed_compiler_performance_information_after_building: diag(6632, ts.DiagnosticCategory.Message, "Output_more_detailed_compiler_performance_information_after_building_6632", "Output more detailed compiler performance information after building."),
        Specify_one_or_more_path_or_node_module_references_to_base_configuration_files_from_which_settings_are_inherited: diag(6633, ts.DiagnosticCategory.Message, "Specify_one_or_more_path_or_node_module_references_to_base_configuration_files_from_which_settings_a_6633", "Specify one or more path or node module references to base configuration files from which settings are inherited."),
        Specify_what_approach_the_watcher_should_use_if_the_system_runs_out_of_native_file_watchers: diag(6634, ts.DiagnosticCategory.Message, "Specify_what_approach_the_watcher_should_use_if_the_system_runs_out_of_native_file_watchers_6634", "Specify what approach the watcher should use if the system runs out of native file watchers."),
        Include_a_list_of_files_This_does_not_support_glob_patterns_as_opposed_to_include: diag(6635, ts.DiagnosticCategory.Message, "Include_a_list_of_files_This_does_not_support_glob_patterns_as_opposed_to_include_6635", "Include a list of files. This does not support glob patterns, as opposed to `include`."),
        Build_all_projects_including_those_that_appear_to_be_up_to_date: diag(6636, ts.DiagnosticCategory.Message, "Build_all_projects_including_those_that_appear_to_be_up_to_date_6636", "Build all projects, including those that appear to be up to date."),
        Ensure_that_casing_is_correct_in_imports: diag(6637, ts.DiagnosticCategory.Message, "Ensure_that_casing_is_correct_in_imports_6637", "Ensure that casing is correct in imports."),
        Emit_a_v8_CPU_profile_of_the_compiler_run_for_debugging: diag(6638, ts.DiagnosticCategory.Message, "Emit_a_v8_CPU_profile_of_the_compiler_run_for_debugging_6638", "Emit a v8 CPU profile of the compiler run for debugging."),
        Allow_importing_helper_functions_from_tslib_once_per_project_instead_of_including_them_per_file: diag(6639, ts.DiagnosticCategory.Message, "Allow_importing_helper_functions_from_tslib_once_per_project_instead_of_including_them_per_file_6639", "Allow importing helper functions from tslib once per project, instead of including them per-file."),
        Specify_a_list_of_glob_patterns_that_match_files_to_be_included_in_compilation: diag(6641, ts.DiagnosticCategory.Message, "Specify_a_list_of_glob_patterns_that_match_files_to_be_included_in_compilation_6641", "Specify a list of glob patterns that match files to be included in compilation."),
        Save_tsbuildinfo_files_to_allow_for_incremental_compilation_of_projects: diag(6642, ts.DiagnosticCategory.Message, "Save_tsbuildinfo_files_to_allow_for_incremental_compilation_of_projects_6642", "Save .tsbuildinfo files to allow for incremental compilation of projects."),
        Include_sourcemap_files_inside_the_emitted_JavaScript: diag(6643, ts.DiagnosticCategory.Message, "Include_sourcemap_files_inside_the_emitted_JavaScript_6643", "Include sourcemap files inside the emitted JavaScript."),
        Include_source_code_in_the_sourcemaps_inside_the_emitted_JavaScript: diag(6644, ts.DiagnosticCategory.Message, "Include_source_code_in_the_sourcemaps_inside_the_emitted_JavaScript_6644", "Include source code in the sourcemaps inside the emitted JavaScript."),
        Ensure_that_each_file_can_be_safely_transpiled_without_relying_on_other_imports: diag(6645, ts.DiagnosticCategory.Message, "Ensure_that_each_file_can_be_safely_transpiled_without_relying_on_other_imports_6645", "Ensure that each file can be safely transpiled without relying on other imports."),
        Specify_what_JSX_code_is_generated: diag(6646, ts.DiagnosticCategory.Message, "Specify_what_JSX_code_is_generated_6646", "Specify what JSX code is generated."),
        Specify_the_JSX_factory_function_used_when_targeting_React_JSX_emit_e_g_React_createElement_or_h: diag(6647, ts.DiagnosticCategory.Message, "Specify_the_JSX_factory_function_used_when_targeting_React_JSX_emit_e_g_React_createElement_or_h_6647", "Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'."),
        Specify_the_JSX_Fragment_reference_used_for_fragments_when_targeting_React_JSX_emit_e_g_React_Fragment_or_Fragment: diag(6648, ts.DiagnosticCategory.Message, "Specify_the_JSX_Fragment_reference_used_for_fragments_when_targeting_React_JSX_emit_e_g_React_Fragme_6648", "Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'."),
        Specify_module_specifier_used_to_import_the_JSX_factory_functions_when_using_jsx_Colon_react_jsx_Asterisk: diag(6649, ts.DiagnosticCategory.Message, "Specify_module_specifier_used_to_import_the_JSX_factory_functions_when_using_jsx_Colon_react_jsx_Ast_6649", "Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'."),
        Make_keyof_only_return_strings_instead_of_string_numbers_or_symbols_Legacy_option: diag(6650, ts.DiagnosticCategory.Message, "Make_keyof_only_return_strings_instead_of_string_numbers_or_symbols_Legacy_option_6650", "Make keyof only return strings instead of string, numbers or symbols. Legacy option."),
        Specify_a_set_of_bundled_library_declaration_files_that_describe_the_target_runtime_environment: diag(6651, ts.DiagnosticCategory.Message, "Specify_a_set_of_bundled_library_declaration_files_that_describe_the_target_runtime_environment_6651", "Specify a set of bundled library declaration files that describe the target runtime environment."),
        Print_the_names_of_emitted_files_after_a_compilation: diag(6652, ts.DiagnosticCategory.Message, "Print_the_names_of_emitted_files_after_a_compilation_6652", "Print the names of emitted files after a compilation."),
        Print_all_of_the_files_read_during_the_compilation: diag(6653, ts.DiagnosticCategory.Message, "Print_all_of_the_files_read_during_the_compilation_6653", "Print all of the files read during the compilation."),
        Set_the_language_of_the_messaging_from_TypeScript_This_does_not_affect_emit: diag(6654, ts.DiagnosticCategory.Message, "Set_the_language_of_the_messaging_from_TypeScript_This_does_not_affect_emit_6654", "Set the language of the messaging from TypeScript. This does not affect emit."),
        Specify_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations: diag(6655, ts.DiagnosticCategory.Message, "Specify_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations_6655", "Specify the location where debugger should locate map files instead of generated locations."),
        Specify_the_maximum_folder_depth_used_for_checking_JavaScript_files_from_node_modules_Only_applicable_with_allowJs: diag(6656, ts.DiagnosticCategory.Message, "Specify_the_maximum_folder_depth_used_for_checking_JavaScript_files_from_node_modules_Only_applicabl_6656", "Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'."),
        Specify_what_module_code_is_generated: diag(6657, ts.DiagnosticCategory.Message, "Specify_what_module_code_is_generated_6657", "Specify what module code is generated."),
        Specify_how_TypeScript_looks_up_a_file_from_a_given_module_specifier: diag(6658, ts.DiagnosticCategory.Message, "Specify_how_TypeScript_looks_up_a_file_from_a_given_module_specifier_6658", "Specify how TypeScript looks up a file from a given module specifier."),
        Set_the_newline_character_for_emitting_files: diag(6659, ts.DiagnosticCategory.Message, "Set_the_newline_character_for_emitting_files_6659", "Set the newline character for emitting files."),
        Disable_emitting_files_from_a_compilation: diag(6660, ts.DiagnosticCategory.Message, "Disable_emitting_files_from_a_compilation_6660", "Disable emitting files from a compilation."),
        Disable_generating_custom_helper_functions_like_extends_in_compiled_output: diag(6661, ts.DiagnosticCategory.Message, "Disable_generating_custom_helper_functions_like_extends_in_compiled_output_6661", "Disable generating custom helper functions like '__extends' in compiled output."),
        Disable_emitting_files_if_any_type_checking_errors_are_reported: diag(6662, ts.DiagnosticCategory.Message, "Disable_emitting_files_if_any_type_checking_errors_are_reported_6662", "Disable emitting files if any type checking errors are reported."),
        Disable_truncating_types_in_error_messages: diag(6663, ts.DiagnosticCategory.Message, "Disable_truncating_types_in_error_messages_6663", "Disable truncating types in error messages."),
        Enable_error_reporting_for_fallthrough_cases_in_switch_statements: diag(6664, ts.DiagnosticCategory.Message, "Enable_error_reporting_for_fallthrough_cases_in_switch_statements_6664", "Enable error reporting for fallthrough cases in switch statements."),
        Enable_error_reporting_for_expressions_and_declarations_with_an_implied_any_type: diag(6665, ts.DiagnosticCategory.Message, "Enable_error_reporting_for_expressions_and_declarations_with_an_implied_any_type_6665", "Enable error reporting for expressions and declarations with an implied 'any' type."),
        Ensure_overriding_members_in_derived_classes_are_marked_with_an_override_modifier: diag(6666, ts.DiagnosticCategory.Message, "Ensure_overriding_members_in_derived_classes_are_marked_with_an_override_modifier_6666", "Ensure overriding members in derived classes are marked with an override modifier."),
        Enable_error_reporting_for_codepaths_that_do_not_explicitly_return_in_a_function: diag(6667, ts.DiagnosticCategory.Message, "Enable_error_reporting_for_codepaths_that_do_not_explicitly_return_in_a_function_6667", "Enable error reporting for codepaths that do not explicitly return in a function."),
        Enable_error_reporting_when_this_is_given_the_type_any: diag(6668, ts.DiagnosticCategory.Message, "Enable_error_reporting_when_this_is_given_the_type_any_6668", "Enable error reporting when 'this' is given the type 'any'."),
        Disable_adding_use_strict_directives_in_emitted_JavaScript_files: diag(6669, ts.DiagnosticCategory.Message, "Disable_adding_use_strict_directives_in_emitted_JavaScript_files_6669", "Disable adding 'use strict' directives in emitted JavaScript files."),
        Disable_including_any_library_files_including_the_default_lib_d_ts: diag(6670, ts.DiagnosticCategory.Message, "Disable_including_any_library_files_including_the_default_lib_d_ts_6670", "Disable including any library files, including the default lib.d.ts."),
        Enforces_using_indexed_accessors_for_keys_declared_using_an_indexed_type: diag(6671, ts.DiagnosticCategory.Message, "Enforces_using_indexed_accessors_for_keys_declared_using_an_indexed_type_6671", "Enforces using indexed accessors for keys declared using an indexed type."),
        Disallow_import_s_require_s_or_reference_s_from_expanding_the_number_of_files_TypeScript_should_add_to_a_project: diag(6672, ts.DiagnosticCategory.Message, "Disallow_import_s_require_s_or_reference_s_from_expanding_the_number_of_files_TypeScript_should_add__6672", "Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project."),
        Disable_strict_checking_of_generic_signatures_in_function_types: diag(6673, ts.DiagnosticCategory.Message, "Disable_strict_checking_of_generic_signatures_in_function_types_6673", "Disable strict checking of generic signatures in function types."),
        Add_undefined_to_a_type_when_accessed_using_an_index: diag(6674, ts.DiagnosticCategory.Message, "Add_undefined_to_a_type_when_accessed_using_an_index_6674", "Add 'undefined' to a type when accessed using an index."),
        Enable_error_reporting_when_local_variables_aren_t_read: diag(6675, ts.DiagnosticCategory.Message, "Enable_error_reporting_when_local_variables_aren_t_read_6675", "Enable error reporting when local variables aren't read."),
        Raise_an_error_when_a_function_parameter_isn_t_read: diag(6676, ts.DiagnosticCategory.Message, "Raise_an_error_when_a_function_parameter_isn_t_read_6676", "Raise an error when a function parameter isn't read."),
        Deprecated_setting_Use_outFile_instead: diag(6677, ts.DiagnosticCategory.Message, "Deprecated_setting_Use_outFile_instead_6677", "Deprecated setting. Use 'outFile' instead."),
        Specify_an_output_folder_for_all_emitted_files: diag(6678, ts.DiagnosticCategory.Message, "Specify_an_output_folder_for_all_emitted_files_6678", "Specify an output folder for all emitted files."),
        Specify_a_file_that_bundles_all_outputs_into_one_JavaScript_file_If_declaration_is_true_also_designates_a_file_that_bundles_all_d_ts_output: diag(6679, ts.DiagnosticCategory.Message, "Specify_a_file_that_bundles_all_outputs_into_one_JavaScript_file_If_declaration_is_true_also_designa_6679", "Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output."),
        Specify_a_set_of_entries_that_re_map_imports_to_additional_lookup_locations: diag(6680, ts.DiagnosticCategory.Message, "Specify_a_set_of_entries_that_re_map_imports_to_additional_lookup_locations_6680", "Specify a set of entries that re-map imports to additional lookup locations."),
        Specify_a_list_of_language_service_plugins_to_include: diag(6681, ts.DiagnosticCategory.Message, "Specify_a_list_of_language_service_plugins_to_include_6681", "Specify a list of language service plugins to include."),
        Disable_erasing_const_enum_declarations_in_generated_code: diag(6682, ts.DiagnosticCategory.Message, "Disable_erasing_const_enum_declarations_in_generated_code_6682", "Disable erasing 'const enum' declarations in generated code."),
        Disable_resolving_symlinks_to_their_realpath_This_correlates_to_the_same_flag_in_node: diag(6683, ts.DiagnosticCategory.Message, "Disable_resolving_symlinks_to_their_realpath_This_correlates_to_the_same_flag_in_node_6683", "Disable resolving symlinks to their realpath. This correlates to the same flag in node."),
        Disable_wiping_the_console_in_watch_mode: diag(6684, ts.DiagnosticCategory.Message, "Disable_wiping_the_console_in_watch_mode_6684", "Disable wiping the console in watch mode."),
        Enable_color_and_formatting_in_TypeScript_s_output_to_make_compiler_errors_easier_to_read: diag(6685, ts.DiagnosticCategory.Message, "Enable_color_and_formatting_in_TypeScript_s_output_to_make_compiler_errors_easier_to_read_6685", "Enable color and formatting in TypeScript's output to make compiler errors easier to read."),
        Specify_the_object_invoked_for_createElement_This_only_applies_when_targeting_react_JSX_emit: diag(6686, ts.DiagnosticCategory.Message, "Specify_the_object_invoked_for_createElement_This_only_applies_when_targeting_react_JSX_emit_6686", "Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit."),
        Specify_an_array_of_objects_that_specify_paths_for_projects_Used_in_project_references: diag(6687, ts.DiagnosticCategory.Message, "Specify_an_array_of_objects_that_specify_paths_for_projects_Used_in_project_references_6687", "Specify an array of objects that specify paths for projects. Used in project references."),
        Disable_emitting_comments: diag(6688, ts.DiagnosticCategory.Message, "Disable_emitting_comments_6688", "Disable emitting comments."),
        Enable_importing_json_files: diag(6689, ts.DiagnosticCategory.Message, "Enable_importing_json_files_6689", "Enable importing .json files."),
        Specify_the_root_folder_within_your_source_files: diag(6690, ts.DiagnosticCategory.Message, "Specify_the_root_folder_within_your_source_files_6690", "Specify the root folder within your source files."),
        Allow_multiple_folders_to_be_treated_as_one_when_resolving_modules: diag(6691, ts.DiagnosticCategory.Message, "Allow_multiple_folders_to_be_treated_as_one_when_resolving_modules_6691", "Allow multiple folders to be treated as one when resolving modules."),
        Skip_type_checking_d_ts_files_that_are_included_with_TypeScript: diag(6692, ts.DiagnosticCategory.Message, "Skip_type_checking_d_ts_files_that_are_included_with_TypeScript_6692", "Skip type checking .d.ts files that are included with TypeScript."),
        Skip_type_checking_all_d_ts_files: diag(6693, ts.DiagnosticCategory.Message, "Skip_type_checking_all_d_ts_files_6693", "Skip type checking all .d.ts files."),
        Create_source_map_files_for_emitted_JavaScript_files: diag(6694, ts.DiagnosticCategory.Message, "Create_source_map_files_for_emitted_JavaScript_files_6694", "Create source map files for emitted JavaScript files."),
        Specify_the_root_path_for_debuggers_to_find_the_reference_source_code: diag(6695, ts.DiagnosticCategory.Message, "Specify_the_root_path_for_debuggers_to_find_the_reference_source_code_6695", "Specify the root path for debuggers to find the reference source code."),
        Check_that_the_arguments_for_bind_call_and_apply_methods_match_the_original_function: diag(6697, ts.DiagnosticCategory.Message, "Check_that_the_arguments_for_bind_call_and_apply_methods_match_the_original_function_6697", "Check that the arguments for 'bind', 'call', and 'apply' methods match the original function."),
        When_assigning_functions_check_to_ensure_parameters_and_the_return_values_are_subtype_compatible: diag(6698, ts.DiagnosticCategory.Message, "When_assigning_functions_check_to_ensure_parameters_and_the_return_values_are_subtype_compatible_6698", "When assigning functions, check to ensure parameters and the return values are subtype-compatible."),
        When_type_checking_take_into_account_null_and_undefined: diag(6699, ts.DiagnosticCategory.Message, "When_type_checking_take_into_account_null_and_undefined_6699", "When type checking, take into account 'null' and 'undefined'."),
        Check_for_class_properties_that_are_declared_but_not_set_in_the_constructor: diag(6700, ts.DiagnosticCategory.Message, "Check_for_class_properties_that_are_declared_but_not_set_in_the_constructor_6700", "Check for class properties that are declared but not set in the constructor."),
        Disable_emitting_declarations_that_have_internal_in_their_JSDoc_comments: diag(6701, ts.DiagnosticCategory.Message, "Disable_emitting_declarations_that_have_internal_in_their_JSDoc_comments_6701", "Disable emitting declarations that have '@internal' in their JSDoc comments."),
        Disable_reporting_of_excess_property_errors_during_the_creation_of_object_literals: diag(6702, ts.DiagnosticCategory.Message, "Disable_reporting_of_excess_property_errors_during_the_creation_of_object_literals_6702", "Disable reporting of excess property errors during the creation of object literals."),
        Suppress_noImplicitAny_errors_when_indexing_objects_that_lack_index_signatures: diag(6703, ts.DiagnosticCategory.Message, "Suppress_noImplicitAny_errors_when_indexing_objects_that_lack_index_signatures_6703", "Suppress 'noImplicitAny' errors when indexing objects that lack index signatures."),
        Synchronously_call_callbacks_and_update_the_state_of_directory_watchers_on_platforms_that_don_t_support_recursive_watching_natively: diag(6704, ts.DiagnosticCategory.Message, "Synchronously_call_callbacks_and_update_the_state_of_directory_watchers_on_platforms_that_don_t_supp_6704", "Synchronously call callbacks and update the state of directory watchers on platforms that don`t support recursive watching natively."),
        Set_the_JavaScript_language_version_for_emitted_JavaScript_and_include_compatible_library_declarations: diag(6705, ts.DiagnosticCategory.Message, "Set_the_JavaScript_language_version_for_emitted_JavaScript_and_include_compatible_library_declaratio_6705", "Set the JavaScript language version for emitted JavaScript and include compatible library declarations."),
        Log_paths_used_during_the_moduleResolution_process: diag(6706, ts.DiagnosticCategory.Message, "Log_paths_used_during_the_moduleResolution_process_6706", "Log paths used during the 'moduleResolution' process."),
        Specify_the_path_to_tsbuildinfo_incremental_compilation_file: diag(6707, ts.DiagnosticCategory.Message, "Specify_the_path_to_tsbuildinfo_incremental_compilation_file_6707", "Specify the path to .tsbuildinfo incremental compilation file."),
        Specify_options_for_automatic_acquisition_of_declaration_files: diag(6709, ts.DiagnosticCategory.Message, "Specify_options_for_automatic_acquisition_of_declaration_files_6709", "Specify options for automatic acquisition of declaration files."),
        Specify_multiple_folders_that_act_like_Slashnode_modules_Slash_types: diag(6710, ts.DiagnosticCategory.Message, "Specify_multiple_folders_that_act_like_Slashnode_modules_Slash_types_6710", "Specify multiple folders that act like './node_modules/@types'."),
        Specify_type_package_names_to_be_included_without_being_referenced_in_a_source_file: diag(6711, ts.DiagnosticCategory.Message, "Specify_type_package_names_to_be_included_without_being_referenced_in_a_source_file_6711", "Specify type package names to be included without being referenced in a source file."),
        Emit_ECMAScript_standard_compliant_class_fields: diag(6712, ts.DiagnosticCategory.Message, "Emit_ECMAScript_standard_compliant_class_fields_6712", "Emit ECMAScript-standard-compliant class fields."),
        Enable_verbose_logging: diag(6713, ts.DiagnosticCategory.Message, "Enable_verbose_logging_6713", "Enable verbose logging."),
        Specify_how_directories_are_watched_on_systems_that_lack_recursive_file_watching_functionality: diag(6714, ts.DiagnosticCategory.Message, "Specify_how_directories_are_watched_on_systems_that_lack_recursive_file_watching_functionality_6714", "Specify how directories are watched on systems that lack recursive file-watching functionality."),
        Specify_how_the_TypeScript_watch_mode_works: diag(6715, ts.DiagnosticCategory.Message, "Specify_how_the_TypeScript_watch_mode_works_6715", "Specify how the TypeScript watch mode works."),
        Require_undeclared_properties_from_index_signatures_to_use_element_accesses: diag(6717, ts.DiagnosticCategory.Message, "Require_undeclared_properties_from_index_signatures_to_use_element_accesses_6717", "Require undeclared properties from index signatures to use element accesses."),
        Specify_emit_Slashchecking_behavior_for_imports_that_are_only_used_for_types: diag(6718, ts.DiagnosticCategory.Message, "Specify_emit_Slashchecking_behavior_for_imports_that_are_only_used_for_types_6718", "Specify emit/checking behavior for imports that are only used for types."),
        Default_catch_clause_variables_as_unknown_instead_of_any: diag(6803, ts.DiagnosticCategory.Message, "Default_catch_clause_variables_as_unknown_instead_of_any_6803", "Default catch clause variables as 'unknown' instead of 'any'."),
        one_of_Colon: diag(6900, ts.DiagnosticCategory.Message, "one_of_Colon_6900", "one of:"),
        one_or_more_Colon: diag(6901, ts.DiagnosticCategory.Message, "one_or_more_Colon_6901", "one or more:"),
        type_Colon: diag(6902, ts.DiagnosticCategory.Message, "type_Colon_6902", "type:"),
        default_Colon: diag(6903, ts.DiagnosticCategory.Message, "default_Colon_6903", "default:"),
        module_system_or_esModuleInterop: diag(6904, ts.DiagnosticCategory.Message, "module_system_or_esModuleInterop_6904", "module === \"system\" or esModuleInterop"),
        false_unless_strict_is_set: diag(6905, ts.DiagnosticCategory.Message, "false_unless_strict_is_set_6905", "`false`, unless `strict` is set"),
        false_unless_composite_is_set: diag(6906, ts.DiagnosticCategory.Message, "false_unless_composite_is_set_6906", "`false`, unless `composite` is set"),
        node_modules_bower_components_jspm_packages_plus_the_value_of_outDir_if_one_is_specified: diag(6907, ts.DiagnosticCategory.Message, "node_modules_bower_components_jspm_packages_plus_the_value_of_outDir_if_one_is_specified_6907", "`[\"node_modules\", \"bower_components\", \"jspm_packages\"]`, plus the value of `outDir` if one is specified."),
        if_files_is_specified_otherwise_Asterisk_Asterisk_Slash_Asterisk: diag(6908, ts.DiagnosticCategory.Message, "if_files_is_specified_otherwise_Asterisk_Asterisk_Slash_Asterisk_6908", "`[]` if `files` is specified, otherwise `[\"**/*\"]`"),
        true_if_composite_false_otherwise: diag(6909, ts.DiagnosticCategory.Message, "true_if_composite_false_otherwise_6909", "`true` if `composite`, `false` otherwise"),
        module_AMD_or_UMD_or_System_or_ES6_then_Classic_Otherwise_Node: diag(69010, ts.DiagnosticCategory.Message, "module_AMD_or_UMD_or_System_or_ES6_then_Classic_Otherwise_Node_69010", "module === `AMD` or `UMD` or `System` or `ES6`, then `Classic`, Otherwise `Node`"),
        Computed_from_the_list_of_input_files: diag(6911, ts.DiagnosticCategory.Message, "Computed_from_the_list_of_input_files_6911", "Computed from the list of input files"),
        Platform_specific: diag(6912, ts.DiagnosticCategory.Message, "Platform_specific_6912", "Platform specific"),
        You_can_learn_about_all_of_the_compiler_options_at_0: diag(6913, ts.DiagnosticCategory.Message, "You_can_learn_about_all_of_the_compiler_options_at_0_6913", "You can learn about all of the compiler options at {0}"),
        Including_watch_w_will_start_watching_the_current_project_for_the_file_changes_Once_set_you_can_config_watch_mode_with_Colon: diag(6914, ts.DiagnosticCategory.Message, "Including_watch_w_will_start_watching_the_current_project_for_the_file_changes_Once_set_you_can_conf_6914", "Including --watch, -w will start watching the current project for the file changes. Once set, you can config watch mode with:"),
        Using_build_b_will_make_tsc_behave_more_like_a_build_orchestrator_than_a_compiler_This_is_used_to_trigger_building_composite_projects_which_you_can_learn_more_about_at_0: diag(6915, ts.DiagnosticCategory.Message, "Using_build_b_will_make_tsc_behave_more_like_a_build_orchestrator_than_a_compiler_This_is_used_to_tr_6915", "Using --build, -b will make tsc behave more like a build orchestrator than a compiler. This is used to trigger building composite projects which you can learn more about at {0}"),
        COMMON_COMMANDS: diag(6916, ts.DiagnosticCategory.Message, "COMMON_COMMANDS_6916", "COMMON COMMANDS"),
        ALL_COMPILER_OPTIONS: diag(6917, ts.DiagnosticCategory.Message, "ALL_COMPILER_OPTIONS_6917", "ALL COMPILER OPTIONS"),
        WATCH_OPTIONS: diag(6918, ts.DiagnosticCategory.Message, "WATCH_OPTIONS_6918", "WATCH OPTIONS"),
        BUILD_OPTIONS: diag(6919, ts.DiagnosticCategory.Message, "BUILD_OPTIONS_6919", "BUILD OPTIONS"),
        COMMON_COMPILER_OPTIONS: diag(6920, ts.DiagnosticCategory.Message, "COMMON_COMPILER_OPTIONS_6920", "COMMON COMPILER OPTIONS"),
        COMMAND_LINE_FLAGS: diag(6921, ts.DiagnosticCategory.Message, "COMMAND_LINE_FLAGS_6921", "COMMAND LINE FLAGS"),
        tsc_Colon_The_TypeScript_Compiler: diag(6922, ts.DiagnosticCategory.Message, "tsc_Colon_The_TypeScript_Compiler_6922", "tsc: The TypeScript Compiler"),
        Compiles_the_current_project_tsconfig_json_in_the_working_directory: diag(6923, ts.DiagnosticCategory.Message, "Compiles_the_current_project_tsconfig_json_in_the_working_directory_6923", "Compiles the current project (tsconfig.json in the working directory.)"),
        Ignoring_tsconfig_json_compiles_the_specified_files_with_default_compiler_options: diag(6924, ts.DiagnosticCategory.Message, "Ignoring_tsconfig_json_compiles_the_specified_files_with_default_compiler_options_6924", "Ignoring tsconfig.json, compiles the specified files with default compiler options."),
        Build_a_composite_project_in_the_working_directory: diag(6925, ts.DiagnosticCategory.Message, "Build_a_composite_project_in_the_working_directory_6925", "Build a composite project in the working directory."),
        Creates_a_tsconfig_json_with_the_recommended_settings_in_the_working_directory: diag(6926, ts.DiagnosticCategory.Message, "Creates_a_tsconfig_json_with_the_recommended_settings_in_the_working_directory_6926", "Creates a tsconfig.json with the recommended settings in the working directory."),
        Compiles_the_TypeScript_project_located_at_the_specified_path: diag(6927, ts.DiagnosticCategory.Message, "Compiles_the_TypeScript_project_located_at_the_specified_path_6927", "Compiles the TypeScript project located at the specified path."),
        An_expanded_version_of_this_information_showing_all_possible_compiler_options: diag(6928, ts.DiagnosticCategory.Message, "An_expanded_version_of_this_information_showing_all_possible_compiler_options_6928", "An expanded version of this information, showing all possible compiler options"),
        Compiles_the_current_project_with_additional_settings: diag(6929, ts.DiagnosticCategory.Message, "Compiles_the_current_project_with_additional_settings_6929", "Compiles the current project, with additional settings."),
        true_for_ES2022_and_above_including_ESNext: diag(6930, ts.DiagnosticCategory.Message, "true_for_ES2022_and_above_including_ESNext_6930", "`true` for ES2022 and above, including ESNext."),
        List_of_file_name_suffixes_to_search_when_resolving_a_module: diag(6931, ts.DiagnosticCategory.Error, "List_of_file_name_suffixes_to_search_when_resolving_a_module_6931", "List of file name suffixes to search when resolving a module."),
        Variable_0_implicitly_has_an_1_type: diag(7005, ts.DiagnosticCategory.Error, "Variable_0_implicitly_has_an_1_type_7005", "Variable '{0}' implicitly has an '{1}' type."),
        Parameter_0_implicitly_has_an_1_type: diag(7006, ts.DiagnosticCategory.Error, "Parameter_0_implicitly_has_an_1_type_7006", "Parameter '{0}' implicitly has an '{1}' type."),
        Member_0_implicitly_has_an_1_type: diag(7008, ts.DiagnosticCategory.Error, "Member_0_implicitly_has_an_1_type_7008", "Member '{0}' implicitly has an '{1}' type."),
        new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type: diag(7009, ts.DiagnosticCategory.Error, "new_expression_whose_target_lacks_a_construct_signature_implicitly_has_an_any_type_7009", "'new' expression, whose target lacks a construct signature, implicitly has an 'any' type."),
        _0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type: diag(7010, ts.DiagnosticCategory.Error, "_0_which_lacks_return_type_annotation_implicitly_has_an_1_return_type_7010", "'{0}', which lacks return-type annotation, implicitly has an '{1}' return type."),
        Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type: diag(7011, ts.DiagnosticCategory.Error, "Function_expression_which_lacks_return_type_annotation_implicitly_has_an_0_return_type_7011", "Function expression, which lacks return-type annotation, implicitly has an '{0}' return type."),
        Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: diag(7013, ts.DiagnosticCategory.Error, "Construct_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type_7013", "Construct signature, which lacks return-type annotation, implicitly has an 'any' return type."),
        Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type: diag(7014, ts.DiagnosticCategory.Error, "Function_type_which_lacks_return_type_annotation_implicitly_has_an_0_return_type_7014", "Function type, which lacks return-type annotation, implicitly has an '{0}' return type."),
        Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number: diag(7015, ts.DiagnosticCategory.Error, "Element_implicitly_has_an_any_type_because_index_expression_is_not_of_type_number_7015", "Element implicitly has an 'any' type because index expression is not of type 'number'."),
        Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type: diag(7016, ts.DiagnosticCategory.Error, "Could_not_find_a_declaration_file_for_module_0_1_implicitly_has_an_any_type_7016", "Could not find a declaration file for module '{0}'. '{1}' implicitly has an 'any' type."),
        Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature: diag(7017, ts.DiagnosticCategory.Error, "Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_7017", "Element implicitly has an 'any' type because type '{0}' has no index signature."),
        Object_literal_s_property_0_implicitly_has_an_1_type: diag(7018, ts.DiagnosticCategory.Error, "Object_literal_s_property_0_implicitly_has_an_1_type_7018", "Object literal's property '{0}' implicitly has an '{1}' type."),
        Rest_parameter_0_implicitly_has_an_any_type: diag(7019, ts.DiagnosticCategory.Error, "Rest_parameter_0_implicitly_has_an_any_type_7019", "Rest parameter '{0}' implicitly has an 'any[]' type."),
        Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: diag(7020, ts.DiagnosticCategory.Error, "Call_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type_7020", "Call signature, which lacks return-type annotation, implicitly has an 'any' return type."),
        _0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or_indirectly_in_its_own_initializer: diag(7022, ts.DiagnosticCategory.Error, "_0_implicitly_has_type_any_because_it_does_not_have_a_type_annotation_and_is_referenced_directly_or__7022", "'{0}' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer."),
        _0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions: diag(7023, ts.DiagnosticCategory.Error, "_0_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_reference_7023", "'{0}' implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions."),
        Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_referenced_directly_or_indirectly_in_one_of_its_return_expressions: diag(7024, ts.DiagnosticCategory.Error, "Function_implicitly_has_return_type_any_because_it_does_not_have_a_return_type_annotation_and_is_ref_7024", "Function implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions."),
        Generator_implicitly_has_yield_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_return_type_annotation: diag(7025, ts.DiagnosticCategory.Error, "Generator_implicitly_has_yield_type_0_because_it_does_not_yield_any_values_Consider_supplying_a_retu_7025", "Generator implicitly has yield type '{0}' because it does not yield any values. Consider supplying a return type annotation."),
        JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists: diag(7026, ts.DiagnosticCategory.Error, "JSX_element_implicitly_has_type_any_because_no_interface_JSX_0_exists_7026", "JSX element implicitly has type 'any' because no interface 'JSX.{0}' exists."),
        Unreachable_code_detected: diag(7027, ts.DiagnosticCategory.Error, "Unreachable_code_detected_7027", "Unreachable code detected.", /*reportsUnnecessary*/ true),
        Unused_label: diag(7028, ts.DiagnosticCategory.Error, "Unused_label_7028", "Unused label.", /*reportsUnnecessary*/ true),
        Fallthrough_case_in_switch: diag(7029, ts.DiagnosticCategory.Error, "Fallthrough_case_in_switch_7029", "Fallthrough case in switch."),
        Not_all_code_paths_return_a_value: diag(7030, ts.DiagnosticCategory.Error, "Not_all_code_paths_return_a_value_7030", "Not all code paths return a value."),
        Binding_element_0_implicitly_has_an_1_type: diag(7031, ts.DiagnosticCategory.Error, "Binding_element_0_implicitly_has_an_1_type_7031", "Binding element '{0}' implicitly has an '{1}' type."),
        Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation: diag(7032, ts.DiagnosticCategory.Error, "Property_0_implicitly_has_type_any_because_its_set_accessor_lacks_a_parameter_type_annotation_7032", "Property '{0}' implicitly has type 'any', because its set accessor lacks a parameter type annotation."),
        Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation: diag(7033, ts.DiagnosticCategory.Error, "Property_0_implicitly_has_type_any_because_its_get_accessor_lacks_a_return_type_annotation_7033", "Property '{0}' implicitly has type 'any', because its get accessor lacks a return type annotation."),
        Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined: diag(7034, ts.DiagnosticCategory.Error, "Variable_0_implicitly_has_type_1_in_some_locations_where_its_type_cannot_be_determined_7034", "Variable '{0}' implicitly has type '{1}' in some locations where its type cannot be determined."),
        Try_npm_i_save_dev_types_Slash_1_if_it_exists_or_add_a_new_declaration_d_ts_file_containing_declare_module_0: diag(7035, ts.DiagnosticCategory.Error, "Try_npm_i_save_dev_types_Slash_1_if_it_exists_or_add_a_new_declaration_d_ts_file_containing_declare__7035", "Try `npm i --save-dev @types/{1}` if it exists or add a new declaration (.d.ts) file containing `declare module '{0}';`"),
        Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0: diag(7036, ts.DiagnosticCategory.Error, "Dynamic_import_s_specifier_must_be_of_type_string_but_here_has_type_0_7036", "Dynamic import's specifier must be of type 'string', but here has type '{0}'."),
        Enables_emit_interoperability_between_CommonJS_and_ES_Modules_via_creation_of_namespace_objects_for_all_imports_Implies_allowSyntheticDefaultImports: diag(7037, ts.DiagnosticCategory.Message, "Enables_emit_interoperability_between_CommonJS_and_ES_Modules_via_creation_of_namespace_objects_for__7037", "Enables emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'."),
        Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cause_a_failure_at_runtime_Consider_using_a_default_import_or_import_require_here_instead: diag(7038, ts.DiagnosticCategory.Message, "Type_originates_at_this_import_A_namespace_style_import_cannot_be_called_or_constructed_and_will_cau_7038", "Type originates at this import. A namespace-style import cannot be called or constructed, and will cause a failure at runtime. Consider using a default import or import require here instead."),
        Mapped_object_type_implicitly_has_an_any_template_type: diag(7039, ts.DiagnosticCategory.Error, "Mapped_object_type_implicitly_has_an_any_template_type_7039", "Mapped object type implicitly has an 'any' template type."),
        If_the_0_package_actually_exposes_this_module_consider_sending_a_pull_request_to_amend_https_Colon_Slash_Slashgithub_com_SlashDefinitelyTyped_SlashDefinitelyTyped_Slashtree_Slashmaster_Slashtypes_Slash_1: diag(7040, ts.DiagnosticCategory.Error, "If_the_0_package_actually_exposes_this_module_consider_sending_a_pull_request_to_amend_https_Colon_S_7040", "If the '{0}' package actually exposes this module, consider sending a pull request to amend 'https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/{1}'"),
        The_containing_arrow_function_captures_the_global_value_of_this: diag(7041, ts.DiagnosticCategory.Error, "The_containing_arrow_function_captures_the_global_value_of_this_7041", "The containing arrow function captures the global value of 'this'."),
        Module_0_was_resolved_to_1_but_resolveJsonModule_is_not_used: diag(7042, ts.DiagnosticCategory.Error, "Module_0_was_resolved_to_1_but_resolveJsonModule_is_not_used_7042", "Module '{0}' was resolved to '{1}', but '--resolveJsonModule' is not used."),
        Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage: diag(7043, ts.DiagnosticCategory.Suggestion, "Variable_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage_7043", "Variable '{0}' implicitly has an '{1}' type, but a better type may be inferred from usage."),
        Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage: diag(7044, ts.DiagnosticCategory.Suggestion, "Parameter_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage_7044", "Parameter '{0}' implicitly has an '{1}' type, but a better type may be inferred from usage."),
        Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage: diag(7045, ts.DiagnosticCategory.Suggestion, "Member_0_implicitly_has_an_1_type_but_a_better_type_may_be_inferred_from_usage_7045", "Member '{0}' implicitly has an '{1}' type, but a better type may be inferred from usage."),
        Variable_0_implicitly_has_type_1_in_some_locations_but_a_better_type_may_be_inferred_from_usage: diag(7046, ts.DiagnosticCategory.Suggestion, "Variable_0_implicitly_has_type_1_in_some_locations_but_a_better_type_may_be_inferred_from_usage_7046", "Variable '{0}' implicitly has type '{1}' in some locations, but a better type may be inferred from usage."),
        Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage: diag(7047, ts.DiagnosticCategory.Suggestion, "Rest_parameter_0_implicitly_has_an_any_type_but_a_better_type_may_be_inferred_from_usage_7047", "Rest parameter '{0}' implicitly has an 'any[]' type, but a better type may be inferred from usage."),
        Property_0_implicitly_has_type_any_but_a_better_type_for_its_get_accessor_may_be_inferred_from_usage: diag(7048, ts.DiagnosticCategory.Suggestion, "Property_0_implicitly_has_type_any_but_a_better_type_for_its_get_accessor_may_be_inferred_from_usage_7048", "Property '{0}' implicitly has type 'any', but a better type for its get accessor may be inferred from usage."),
        Property_0_implicitly_has_type_any_but_a_better_type_for_its_set_accessor_may_be_inferred_from_usage: diag(7049, ts.DiagnosticCategory.Suggestion, "Property_0_implicitly_has_type_any_but_a_better_type_for_its_set_accessor_may_be_inferred_from_usage_7049", "Property '{0}' implicitly has type 'any', but a better type for its set accessor may be inferred from usage."),
        _0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage: diag(7050, ts.DiagnosticCategory.Suggestion, "_0_implicitly_has_an_1_return_type_but_a_better_type_may_be_inferred_from_usage_7050", "'{0}' implicitly has an '{1}' return type, but a better type may be inferred from usage."),
        Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1: diag(7051, ts.DiagnosticCategory.Error, "Parameter_has_a_name_but_no_type_Did_you_mean_0_Colon_1_7051", "Parameter has a name but no type. Did you mean '{0}: {1}'?"),
        Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1: diag(7052, ts.DiagnosticCategory.Error, "Element_implicitly_has_an_any_type_because_type_0_has_no_index_signature_Did_you_mean_to_call_1_7052", "Element implicitly has an 'any' type because type '{0}' has no index signature. Did you mean to call '{1}'?"),
        Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1: diag(7053, ts.DiagnosticCategory.Error, "Element_implicitly_has_an_any_type_because_expression_of_type_0_can_t_be_used_to_index_type_1_7053", "Element implicitly has an 'any' type because expression of type '{0}' can't be used to index type '{1}'."),
        No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1: diag(7054, ts.DiagnosticCategory.Error, "No_index_signature_with_a_parameter_of_type_0_was_found_on_type_1_7054", "No index signature with a parameter of type '{0}' was found on type '{1}'."),
        _0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type: diag(7055, ts.DiagnosticCategory.Error, "_0_which_lacks_return_type_annotation_implicitly_has_an_1_yield_type_7055", "'{0}', which lacks return-type annotation, implicitly has an '{1}' yield type."),
        The_inferred_type_of_this_node_exceeds_the_maximum_length_the_compiler_will_serialize_An_explicit_type_annotation_is_needed: diag(7056, ts.DiagnosticCategory.Error, "The_inferred_type_of_this_node_exceeds_the_maximum_length_the_compiler_will_serialize_An_explicit_ty_7056", "The inferred type of this node exceeds the maximum length the compiler will serialize. An explicit type annotation is needed."),
        yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_type_annotation: diag(7057, ts.DiagnosticCategory.Error, "yield_expression_implicitly_results_in_an_any_type_because_its_containing_generator_lacks_a_return_t_7057", "'yield' expression implicitly results in an 'any' type because its containing generator lacks a return-type annotation."),
        If_the_0_package_actually_exposes_this_module_try_adding_a_new_declaration_d_ts_file_containing_declare_module_1: diag(7058, ts.DiagnosticCategory.Error, "If_the_0_package_actually_exposes_this_module_try_adding_a_new_declaration_d_ts_file_containing_decl_7058", "If the '{0}' package actually exposes this module, try adding a new declaration (.d.ts) file containing `declare module '{1}';`"),
        This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Use_an_as_expression_instead: diag(7059, ts.DiagnosticCategory.Error, "This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Use_an_as_expression_instead_7059", "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead."),
        This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Add_a_trailing_comma_or_explicit_constraint: diag(7060, ts.DiagnosticCategory.Error, "This_syntax_is_reserved_in_files_with_the_mts_or_cts_extension_Add_a_trailing_comma_or_explicit_cons_7060", "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma or explicit constraint."),
        A_mapped_type_may_not_declare_properties_or_methods: diag(7061, ts.DiagnosticCategory.Error, "A_mapped_type_may_not_declare_properties_or_methods_7061", "A mapped type may not declare properties or methods."),
        You_cannot_rename_this_element: diag(8000, ts.DiagnosticCategory.Error, "You_cannot_rename_this_element_8000", "You cannot rename this element."),
        You_cannot_rename_elements_that_are_defined_in_the_standard_TypeScript_library: diag(8001, ts.DiagnosticCategory.Error, "You_cannot_rename_elements_that_are_defined_in_the_standard_TypeScript_library_8001", "You cannot rename elements that are defined in the standard TypeScript library."),
        import_can_only_be_used_in_TypeScript_files: diag(8002, ts.DiagnosticCategory.Error, "import_can_only_be_used_in_TypeScript_files_8002", "'import ... =' can only be used in TypeScript files."),
        export_can_only_be_used_in_TypeScript_files: diag(8003, ts.DiagnosticCategory.Error, "export_can_only_be_used_in_TypeScript_files_8003", "'export =' can only be used in TypeScript files."),
        Type_parameter_declarations_can_only_be_used_in_TypeScript_files: diag(8004, ts.DiagnosticCategory.Error, "Type_parameter_declarations_can_only_be_used_in_TypeScript_files_8004", "Type parameter declarations can only be used in TypeScript files."),
        implements_clauses_can_only_be_used_in_TypeScript_files: diag(8005, ts.DiagnosticCategory.Error, "implements_clauses_can_only_be_used_in_TypeScript_files_8005", "'implements' clauses can only be used in TypeScript files."),
        _0_declarations_can_only_be_used_in_TypeScript_files: diag(8006, ts.DiagnosticCategory.Error, "_0_declarations_can_only_be_used_in_TypeScript_files_8006", "'{0}' declarations can only be used in TypeScript files."),
        Type_aliases_can_only_be_used_in_TypeScript_files: diag(8008, ts.DiagnosticCategory.Error, "Type_aliases_can_only_be_used_in_TypeScript_files_8008", "Type aliases can only be used in TypeScript files."),
        The_0_modifier_can_only_be_used_in_TypeScript_files: diag(8009, ts.DiagnosticCategory.Error, "The_0_modifier_can_only_be_used_in_TypeScript_files_8009", "The '{0}' modifier can only be used in TypeScript files."),
        Type_annotations_can_only_be_used_in_TypeScript_files: diag(8010, ts.DiagnosticCategory.Error, "Type_annotations_can_only_be_used_in_TypeScript_files_8010", "Type annotations can only be used in TypeScript files."),
        Type_arguments_can_only_be_used_in_TypeScript_files: diag(8011, ts.DiagnosticCategory.Error, "Type_arguments_can_only_be_used_in_TypeScript_files_8011", "Type arguments can only be used in TypeScript files."),
        Parameter_modifiers_can_only_be_used_in_TypeScript_files: diag(8012, ts.DiagnosticCategory.Error, "Parameter_modifiers_can_only_be_used_in_TypeScript_files_8012", "Parameter modifiers can only be used in TypeScript files."),
        Non_null_assertions_can_only_be_used_in_TypeScript_files: diag(8013, ts.DiagnosticCategory.Error, "Non_null_assertions_can_only_be_used_in_TypeScript_files_8013", "Non-null assertions can only be used in TypeScript files."),
        Type_assertion_expressions_can_only_be_used_in_TypeScript_files: diag(8016, ts.DiagnosticCategory.Error, "Type_assertion_expressions_can_only_be_used_in_TypeScript_files_8016", "Type assertion expressions can only be used in TypeScript files."),
        Octal_literal_types_must_use_ES2015_syntax_Use_the_syntax_0: diag(8017, ts.DiagnosticCategory.Error, "Octal_literal_types_must_use_ES2015_syntax_Use_the_syntax_0_8017", "Octal literal types must use ES2015 syntax. Use the syntax '{0}'."),
        Octal_literals_are_not_allowed_in_enums_members_initializer_Use_the_syntax_0: diag(8018, ts.DiagnosticCategory.Error, "Octal_literals_are_not_allowed_in_enums_members_initializer_Use_the_syntax_0_8018", "Octal literals are not allowed in enums members initializer. Use the syntax '{0}'."),
        Report_errors_in_js_files: diag(8019, ts.DiagnosticCategory.Message, "Report_errors_in_js_files_8019", "Report errors in .js files."),
        JSDoc_types_can_only_be_used_inside_documentation_comments: diag(8020, ts.DiagnosticCategory.Error, "JSDoc_types_can_only_be_used_inside_documentation_comments_8020", "JSDoc types can only be used inside documentation comments."),
        JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags: diag(8021, ts.DiagnosticCategory.Error, "JSDoc_typedef_tag_should_either_have_a_type_annotation_or_be_followed_by_property_or_member_tags_8021", "JSDoc '@typedef' tag should either have a type annotation or be followed by '@property' or '@member' tags."),
        JSDoc_0_is_not_attached_to_a_class: diag(8022, ts.DiagnosticCategory.Error, "JSDoc_0_is_not_attached_to_a_class_8022", "JSDoc '@{0}' is not attached to a class."),
        JSDoc_0_1_does_not_match_the_extends_2_clause: diag(8023, ts.DiagnosticCategory.Error, "JSDoc_0_1_does_not_match_the_extends_2_clause_8023", "JSDoc '@{0} {1}' does not match the 'extends {2}' clause."),
        JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name: diag(8024, ts.DiagnosticCategory.Error, "JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_8024", "JSDoc '@param' tag has name '{0}', but there is no parameter with that name."),
        Class_declarations_cannot_have_more_than_one_augments_or_extends_tag: diag(8025, ts.DiagnosticCategory.Error, "Class_declarations_cannot_have_more_than_one_augments_or_extends_tag_8025", "Class declarations cannot have more than one '@augments' or '@extends' tag."),
        Expected_0_type_arguments_provide_these_with_an_extends_tag: diag(8026, ts.DiagnosticCategory.Error, "Expected_0_type_arguments_provide_these_with_an_extends_tag_8026", "Expected {0} type arguments; provide these with an '@extends' tag."),
        Expected_0_1_type_arguments_provide_these_with_an_extends_tag: diag(8027, ts.DiagnosticCategory.Error, "Expected_0_1_type_arguments_provide_these_with_an_extends_tag_8027", "Expected {0}-{1} type arguments; provide these with an '@extends' tag."),
        JSDoc_may_only_appear_in_the_last_parameter_of_a_signature: diag(8028, ts.DiagnosticCategory.Error, "JSDoc_may_only_appear_in_the_last_parameter_of_a_signature_8028", "JSDoc '...' may only appear in the last parameter of a signature."),
        JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_had_an_array_type: diag(8029, ts.DiagnosticCategory.Error, "JSDoc_param_tag_has_name_0_but_there_is_no_parameter_with_that_name_It_would_match_arguments_if_it_h_8029", "JSDoc '@param' tag has name '{0}', but there is no parameter with that name. It would match 'arguments' if it had an array type."),
        The_type_of_a_function_declaration_must_match_the_function_s_signature: diag(8030, ts.DiagnosticCategory.Error, "The_type_of_a_function_declaration_must_match_the_function_s_signature_8030", "The type of a function declaration must match the function's signature."),
        You_cannot_rename_a_module_via_a_global_import: diag(8031, ts.DiagnosticCategory.Error, "You_cannot_rename_a_module_via_a_global_import_8031", "You cannot rename a module via a global import."),
        Qualified_name_0_is_not_allowed_without_a_leading_param_object_1: diag(8032, ts.DiagnosticCategory.Error, "Qualified_name_0_is_not_allowed_without_a_leading_param_object_1_8032", "Qualified name '{0}' is not allowed without a leading '@param {object} {1}'."),
        A_JSDoc_typedef_comment_may_not_contain_multiple_type_tags: diag(8033, ts.DiagnosticCategory.Error, "A_JSDoc_typedef_comment_may_not_contain_multiple_type_tags_8033", "A JSDoc '@typedef' comment may not contain multiple '@type' tags."),
        The_tag_was_first_specified_here: diag(8034, ts.DiagnosticCategory.Error, "The_tag_was_first_specified_here_8034", "The tag was first specified here."),
        You_cannot_rename_elements_that_are_defined_in_a_node_modules_folder: diag(8035, ts.DiagnosticCategory.Error, "You_cannot_rename_elements_that_are_defined_in_a_node_modules_folder_8035", "You cannot rename elements that are defined in a 'node_modules' folder."),
        You_cannot_rename_elements_that_are_defined_in_another_node_modules_folder: diag(8036, ts.DiagnosticCategory.Error, "You_cannot_rename_elements_that_are_defined_in_another_node_modules_folder_8036", "You cannot rename elements that are defined in another 'node_modules' folder."),
        Declaration_emit_for_this_file_requires_using_private_name_0_An_explicit_type_annotation_may_unblock_declaration_emit: diag(9005, ts.DiagnosticCategory.Error, "Declaration_emit_for_this_file_requires_using_private_name_0_An_explicit_type_annotation_may_unblock_9005", "Declaration emit for this file requires using private name '{0}'. An explicit type annotation may unblock declaration emit."),
        Declaration_emit_for_this_file_requires_using_private_name_0_from_module_1_An_explicit_type_annotation_may_unblock_declaration_emit: diag(9006, ts.DiagnosticCategory.Error, "Declaration_emit_for_this_file_requires_using_private_name_0_from_module_1_An_explicit_type_annotati_9006", "Declaration emit for this file requires using private name '{0}' from module '{1}'. An explicit type annotation may unblock declaration emit."),
        JSX_attributes_must_only_be_assigned_a_non_empty_expression: diag(17000, ts.DiagnosticCategory.Error, "JSX_attributes_must_only_be_assigned_a_non_empty_expression_17000", "JSX attributes must only be assigned a non-empty 'expression'."),
        JSX_elements_cannot_have_multiple_attributes_with_the_same_name: diag(17001, ts.DiagnosticCategory.Error, "JSX_elements_cannot_have_multiple_attributes_with_the_same_name_17001", "JSX elements cannot have multiple attributes with the same name."),
        Expected_corresponding_JSX_closing_tag_for_0: diag(17002, ts.DiagnosticCategory.Error, "Expected_corresponding_JSX_closing_tag_for_0_17002", "Expected corresponding JSX closing tag for '{0}'."),
        Cannot_use_JSX_unless_the_jsx_flag_is_provided: diag(17004, ts.DiagnosticCategory.Error, "Cannot_use_JSX_unless_the_jsx_flag_is_provided_17004", "Cannot use JSX unless the '--jsx' flag is provided."),
        A_constructor_cannot_contain_a_super_call_when_its_class_extends_null: diag(17005, ts.DiagnosticCategory.Error, "A_constructor_cannot_contain_a_super_call_when_its_class_extends_null_17005", "A constructor cannot contain a 'super' call when its class extends 'null'."),
        An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses: diag(17006, ts.DiagnosticCategory.Error, "An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_ex_17006", "An unary expression with the '{0}' operator is not allowed in the left-hand side of an exponentiation expression. Consider enclosing the expression in parentheses."),
        A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses: diag(17007, ts.DiagnosticCategory.Error, "A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Con_17007", "A type assertion expression is not allowed in the left-hand side of an exponentiation expression. Consider enclosing the expression in parentheses."),
        JSX_element_0_has_no_corresponding_closing_tag: diag(17008, ts.DiagnosticCategory.Error, "JSX_element_0_has_no_corresponding_closing_tag_17008", "JSX element '{0}' has no corresponding closing tag."),
        super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class: diag(17009, ts.DiagnosticCategory.Error, "super_must_be_called_before_accessing_this_in_the_constructor_of_a_derived_class_17009", "'super' must be called before accessing 'this' in the constructor of a derived class."),
        Unknown_type_acquisition_option_0: diag(17010, ts.DiagnosticCategory.Error, "Unknown_type_acquisition_option_0_17010", "Unknown type acquisition option '{0}'."),
        super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class: diag(17011, ts.DiagnosticCategory.Error, "super_must_be_called_before_accessing_a_property_of_super_in_the_constructor_of_a_derived_class_17011", "'super' must be called before accessing a property of 'super' in the constructor of a derived class."),
        _0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2: diag(17012, ts.DiagnosticCategory.Error, "_0_is_not_a_valid_meta_property_for_keyword_1_Did_you_mean_2_17012", "'{0}' is not a valid meta-property for keyword '{1}'. Did you mean '{2}'?"),
        Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constructor: diag(17013, ts.DiagnosticCategory.Error, "Meta_property_0_is_only_allowed_in_the_body_of_a_function_declaration_function_expression_or_constru_17013", "Meta-property '{0}' is only allowed in the body of a function declaration, function expression, or constructor."),
        JSX_fragment_has_no_corresponding_closing_tag: diag(17014, ts.DiagnosticCategory.Error, "JSX_fragment_has_no_corresponding_closing_tag_17014", "JSX fragment has no corresponding closing tag."),
        Expected_corresponding_closing_tag_for_JSX_fragment: diag(17015, ts.DiagnosticCategory.Error, "Expected_corresponding_closing_tag_for_JSX_fragment_17015", "Expected corresponding closing tag for JSX fragment."),
        The_jsxFragmentFactory_compiler_option_must_be_provided_to_use_JSX_fragments_with_the_jsxFactory_compiler_option: diag(17016, ts.DiagnosticCategory.Error, "The_jsxFragmentFactory_compiler_option_must_be_provided_to_use_JSX_fragments_with_the_jsxFactory_com_17016", "The 'jsxFragmentFactory' compiler option must be provided to use JSX fragments with the 'jsxFactory' compiler option."),
        An_jsxFrag_pragma_is_required_when_using_an_jsx_pragma_with_JSX_fragments: diag(17017, ts.DiagnosticCategory.Error, "An_jsxFrag_pragma_is_required_when_using_an_jsx_pragma_with_JSX_fragments_17017", "An @jsxFrag pragma is required when using an @jsx pragma with JSX fragments."),
        Unknown_type_acquisition_option_0_Did_you_mean_1: diag(17018, ts.DiagnosticCategory.Error, "Unknown_type_acquisition_option_0_Did_you_mean_1_17018", "Unknown type acquisition option '{0}'. Did you mean '{1}'?"),
        Circularity_detected_while_resolving_configuration_Colon_0: diag(18000, ts.DiagnosticCategory.Error, "Circularity_detected_while_resolving_configuration_Colon_0_18000", "Circularity detected while resolving configuration: {0}"),
        The_files_list_in_config_file_0_is_empty: diag(18002, ts.DiagnosticCategory.Error, "The_files_list_in_config_file_0_is_empty_18002", "The 'files' list in config file '{0}' is empty."),
        No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2: diag(18003, ts.DiagnosticCategory.Error, "No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2_18003", "No inputs were found in config file '{0}'. Specified 'include' paths were '{1}' and 'exclude' paths were '{2}'."),
        File_is_a_CommonJS_module_it_may_be_converted_to_an_ES_module: diag(80001, ts.DiagnosticCategory.Suggestion, "File_is_a_CommonJS_module_it_may_be_converted_to_an_ES_module_80001", "File is a CommonJS module; it may be converted to an ES module."),
        This_constructor_function_may_be_converted_to_a_class_declaration: diag(80002, ts.DiagnosticCategory.Suggestion, "This_constructor_function_may_be_converted_to_a_class_declaration_80002", "This constructor function may be converted to a class declaration."),
        Import_may_be_converted_to_a_default_import: diag(80003, ts.DiagnosticCategory.Suggestion, "Import_may_be_converted_to_a_default_import_80003", "Import may be converted to a default import."),
        JSDoc_types_may_be_moved_to_TypeScript_types: diag(80004, ts.DiagnosticCategory.Suggestion, "JSDoc_types_may_be_moved_to_TypeScript_types_80004", "JSDoc types may be moved to TypeScript types."),
        require_call_may_be_converted_to_an_import: diag(80005, ts.DiagnosticCategory.Suggestion, "require_call_may_be_converted_to_an_import_80005", "'require' call may be converted to an import."),
        This_may_be_converted_to_an_async_function: diag(80006, ts.DiagnosticCategory.Suggestion, "This_may_be_converted_to_an_async_function_80006", "This may be converted to an async function."),
        await_has_no_effect_on_the_type_of_this_expression: diag(80007, ts.DiagnosticCategory.Suggestion, "await_has_no_effect_on_the_type_of_this_expression_80007", "'await' has no effect on the type of this expression."),
        Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accurately_as_integers: diag(80008, ts.DiagnosticCategory.Suggestion, "Numeric_literals_with_absolute_values_equal_to_2_53_or_greater_are_too_large_to_be_represented_accur_80008", "Numeric literals with absolute values equal to 2^53 or greater are too large to be represented accurately as integers."),
        Add_missing_super_call: diag(90001, ts.DiagnosticCategory.Message, "Add_missing_super_call_90001", "Add missing 'super()' call"),
        Make_super_call_the_first_statement_in_the_constructor: diag(90002, ts.DiagnosticCategory.Message, "Make_super_call_the_first_statement_in_the_constructor_90002", "Make 'super()' call the first statement in the constructor"),
        Change_extends_to_implements: diag(90003, ts.DiagnosticCategory.Message, "Change_extends_to_implements_90003", "Change 'extends' to 'implements'"),
        Remove_unused_declaration_for_Colon_0: diag(90004, ts.DiagnosticCategory.Message, "Remove_unused_declaration_for_Colon_0_90004", "Remove unused declaration for: '{0}'"),
        Remove_import_from_0: diag(90005, ts.DiagnosticCategory.Message, "Remove_import_from_0_90005", "Remove import from '{0}'"),
        Implement_interface_0: diag(90006, ts.DiagnosticCategory.Message, "Implement_interface_0_90006", "Implement interface '{0}'"),
        Implement_inherited_abstract_class: diag(90007, ts.DiagnosticCategory.Message, "Implement_inherited_abstract_class_90007", "Implement inherited abstract class"),
        Add_0_to_unresolved_variable: diag(90008, ts.DiagnosticCategory.Message, "Add_0_to_unresolved_variable_90008", "Add '{0}.' to unresolved variable"),
        Remove_variable_statement: diag(90010, ts.DiagnosticCategory.Message, "Remove_variable_statement_90010", "Remove variable statement"),
        Remove_template_tag: diag(90011, ts.DiagnosticCategory.Message, "Remove_template_tag_90011", "Remove template tag"),
        Remove_type_parameters: diag(90012, ts.DiagnosticCategory.Message, "Remove_type_parameters_90012", "Remove type parameters"),
        Import_0_from_1: diag(90013, ts.DiagnosticCategory.Message, "Import_0_from_1_90013", "Import '{0}' from \"{1}\""),
        Change_0_to_1: diag(90014, ts.DiagnosticCategory.Message, "Change_0_to_1_90014", "Change '{0}' to '{1}'"),
        Declare_property_0: diag(90016, ts.DiagnosticCategory.Message, "Declare_property_0_90016", "Declare property '{0}'"),
        Add_index_signature_for_property_0: diag(90017, ts.DiagnosticCategory.Message, "Add_index_signature_for_property_0_90017", "Add index signature for property '{0}'"),
        Disable_checking_for_this_file: diag(90018, ts.DiagnosticCategory.Message, "Disable_checking_for_this_file_90018", "Disable checking for this file"),
        Ignore_this_error_message: diag(90019, ts.DiagnosticCategory.Message, "Ignore_this_error_message_90019", "Ignore this error message"),
        Initialize_property_0_in_the_constructor: diag(90020, ts.DiagnosticCategory.Message, "Initialize_property_0_in_the_constructor_90020", "Initialize property '{0}' in the constructor"),
        Initialize_static_property_0: diag(90021, ts.DiagnosticCategory.Message, "Initialize_static_property_0_90021", "Initialize static property '{0}'"),
        Change_spelling_to_0: diag(90022, ts.DiagnosticCategory.Message, "Change_spelling_to_0_90022", "Change spelling to '{0}'"),
        Declare_method_0: diag(90023, ts.DiagnosticCategory.Message, "Declare_method_0_90023", "Declare method '{0}'"),
        Declare_static_method_0: diag(90024, ts.DiagnosticCategory.Message, "Declare_static_method_0_90024", "Declare static method '{0}'"),
        Prefix_0_with_an_underscore: diag(90025, ts.DiagnosticCategory.Message, "Prefix_0_with_an_underscore_90025", "Prefix '{0}' with an underscore"),
        Rewrite_as_the_indexed_access_type_0: diag(90026, ts.DiagnosticCategory.Message, "Rewrite_as_the_indexed_access_type_0_90026", "Rewrite as the indexed access type '{0}'"),
        Declare_static_property_0: diag(90027, ts.DiagnosticCategory.Message, "Declare_static_property_0_90027", "Declare static property '{0}'"),
        Call_decorator_expression: diag(90028, ts.DiagnosticCategory.Message, "Call_decorator_expression_90028", "Call decorator expression"),
        Add_async_modifier_to_containing_function: diag(90029, ts.DiagnosticCategory.Message, "Add_async_modifier_to_containing_function_90029", "Add async modifier to containing function"),
        Replace_infer_0_with_unknown: diag(90030, ts.DiagnosticCategory.Message, "Replace_infer_0_with_unknown_90030", "Replace 'infer {0}' with 'unknown'"),
        Replace_all_unused_infer_with_unknown: diag(90031, ts.DiagnosticCategory.Message, "Replace_all_unused_infer_with_unknown_90031", "Replace all unused 'infer' with 'unknown'"),
        Add_parameter_name: diag(90034, ts.DiagnosticCategory.Message, "Add_parameter_name_90034", "Add parameter name"),
        Declare_private_property_0: diag(90035, ts.DiagnosticCategory.Message, "Declare_private_property_0_90035", "Declare private property '{0}'"),
        Replace_0_with_Promise_1: diag(90036, ts.DiagnosticCategory.Message, "Replace_0_with_Promise_1_90036", "Replace '{0}' with 'Promise<{1}>'"),
        Fix_all_incorrect_return_type_of_an_async_functions: diag(90037, ts.DiagnosticCategory.Message, "Fix_all_incorrect_return_type_of_an_async_functions_90037", "Fix all incorrect return type of an async functions"),
        Declare_private_method_0: diag(90038, ts.DiagnosticCategory.Message, "Declare_private_method_0_90038", "Declare private method '{0}'"),
        Remove_unused_destructuring_declaration: diag(90039, ts.DiagnosticCategory.Message, "Remove_unused_destructuring_declaration_90039", "Remove unused destructuring declaration"),
        Remove_unused_declarations_for_Colon_0: diag(90041, ts.DiagnosticCategory.Message, "Remove_unused_declarations_for_Colon_0_90041", "Remove unused declarations for: '{0}'"),
        Declare_a_private_field_named_0: diag(90053, ts.DiagnosticCategory.Message, "Declare_a_private_field_named_0_90053", "Declare a private field named '{0}'."),
        Includes_imports_of_types_referenced_by_0: diag(90054, ts.DiagnosticCategory.Message, "Includes_imports_of_types_referenced_by_0_90054", "Includes imports of types referenced by '{0}'"),
        Remove_type_from_import_declaration_from_0: diag(90055, ts.DiagnosticCategory.Message, "Remove_type_from_import_declaration_from_0_90055", "Remove 'type' from import declaration from \"{0}\""),
        Remove_type_from_import_of_0_from_1: diag(90056, ts.DiagnosticCategory.Message, "Remove_type_from_import_of_0_from_1_90056", "Remove 'type' from import of '{0}' from \"{1}\""),
        Add_import_from_0: diag(90057, ts.DiagnosticCategory.Message, "Add_import_from_0_90057", "Add import from \"{0}\""),
        Update_import_from_0: diag(90058, ts.DiagnosticCategory.Message, "Update_import_from_0_90058", "Update import from \"{0}\""),
        Convert_function_to_an_ES2015_class: diag(95001, ts.DiagnosticCategory.Message, "Convert_function_to_an_ES2015_class_95001", "Convert function to an ES2015 class"),
        Convert_0_to_1_in_0: diag(95003, ts.DiagnosticCategory.Message, "Convert_0_to_1_in_0_95003", "Convert '{0}' to '{1} in {0}'"),
        Extract_to_0_in_1: diag(95004, ts.DiagnosticCategory.Message, "Extract_to_0_in_1_95004", "Extract to {0} in {1}"),
        Extract_function: diag(95005, ts.DiagnosticCategory.Message, "Extract_function_95005", "Extract function"),
        Extract_constant: diag(95006, ts.DiagnosticCategory.Message, "Extract_constant_95006", "Extract constant"),
        Extract_to_0_in_enclosing_scope: diag(95007, ts.DiagnosticCategory.Message, "Extract_to_0_in_enclosing_scope_95007", "Extract to {0} in enclosing scope"),
        Extract_to_0_in_1_scope: diag(95008, ts.DiagnosticCategory.Message, "Extract_to_0_in_1_scope_95008", "Extract to {0} in {1} scope"),
        Annotate_with_type_from_JSDoc: diag(95009, ts.DiagnosticCategory.Message, "Annotate_with_type_from_JSDoc_95009", "Annotate with type from JSDoc"),
        Infer_type_of_0_from_usage: diag(95011, ts.DiagnosticCategory.Message, "Infer_type_of_0_from_usage_95011", "Infer type of '{0}' from usage"),
        Infer_parameter_types_from_usage: diag(95012, ts.DiagnosticCategory.Message, "Infer_parameter_types_from_usage_95012", "Infer parameter types from usage"),
        Convert_to_default_import: diag(95013, ts.DiagnosticCategory.Message, "Convert_to_default_import_95013", "Convert to default import"),
        Install_0: diag(95014, ts.DiagnosticCategory.Message, "Install_0_95014", "Install '{0}'"),
        Replace_import_with_0: diag(95015, ts.DiagnosticCategory.Message, "Replace_import_with_0_95015", "Replace import with '{0}'."),
        Use_synthetic_default_member: diag(95016, ts.DiagnosticCategory.Message, "Use_synthetic_default_member_95016", "Use synthetic 'default' member."),
        Convert_to_ES_module: diag(95017, ts.DiagnosticCategory.Message, "Convert_to_ES_module_95017", "Convert to ES module"),
        Add_undefined_type_to_property_0: diag(95018, ts.DiagnosticCategory.Message, "Add_undefined_type_to_property_0_95018", "Add 'undefined' type to property '{0}'"),
        Add_initializer_to_property_0: diag(95019, ts.DiagnosticCategory.Message, "Add_initializer_to_property_0_95019", "Add initializer to property '{0}'"),
        Add_definite_assignment_assertion_to_property_0: diag(95020, ts.DiagnosticCategory.Message, "Add_definite_assignment_assertion_to_property_0_95020", "Add definite assignment assertion to property '{0}'"),
        Convert_all_type_literals_to_mapped_type: diag(95021, ts.DiagnosticCategory.Message, "Convert_all_type_literals_to_mapped_type_95021", "Convert all type literals to mapped type"),
        Add_all_missing_members: diag(95022, ts.DiagnosticCategory.Message, "Add_all_missing_members_95022", "Add all missing members"),
        Infer_all_types_from_usage: diag(95023, ts.DiagnosticCategory.Message, "Infer_all_types_from_usage_95023", "Infer all types from usage"),
        Delete_all_unused_declarations: diag(95024, ts.DiagnosticCategory.Message, "Delete_all_unused_declarations_95024", "Delete all unused declarations"),
        Prefix_all_unused_declarations_with_where_possible: diag(95025, ts.DiagnosticCategory.Message, "Prefix_all_unused_declarations_with_where_possible_95025", "Prefix all unused declarations with '_' where possible"),
        Fix_all_detected_spelling_errors: diag(95026, ts.DiagnosticCategory.Message, "Fix_all_detected_spelling_errors_95026", "Fix all detected spelling errors"),
        Add_initializers_to_all_uninitialized_properties: diag(95027, ts.DiagnosticCategory.Message, "Add_initializers_to_all_uninitialized_properties_95027", "Add initializers to all uninitialized properties"),
        Add_definite_assignment_assertions_to_all_uninitialized_properties: diag(95028, ts.DiagnosticCategory.Message, "Add_definite_assignment_assertions_to_all_uninitialized_properties_95028", "Add definite assignment assertions to all uninitialized properties"),
        Add_undefined_type_to_all_uninitialized_properties: diag(95029, ts.DiagnosticCategory.Message, "Add_undefined_type_to_all_uninitialized_properties_95029", "Add undefined type to all uninitialized properties"),
        Change_all_jsdoc_style_types_to_TypeScript: diag(95030, ts.DiagnosticCategory.Message, "Change_all_jsdoc_style_types_to_TypeScript_95030", "Change all jsdoc-style types to TypeScript"),
        Change_all_jsdoc_style_types_to_TypeScript_and_add_undefined_to_nullable_types: diag(95031, ts.DiagnosticCategory.Message, "Change_all_jsdoc_style_types_to_TypeScript_and_add_undefined_to_nullable_types_95031", "Change all jsdoc-style types to TypeScript (and add '| undefined' to nullable types)"),
        Implement_all_unimplemented_interfaces: diag(95032, ts.DiagnosticCategory.Message, "Implement_all_unimplemented_interfaces_95032", "Implement all unimplemented interfaces"),
        Install_all_missing_types_packages: diag(95033, ts.DiagnosticCategory.Message, "Install_all_missing_types_packages_95033", "Install all missing types packages"),
        Rewrite_all_as_indexed_access_types: diag(95034, ts.DiagnosticCategory.Message, "Rewrite_all_as_indexed_access_types_95034", "Rewrite all as indexed access types"),
        Convert_all_to_default_imports: diag(95035, ts.DiagnosticCategory.Message, "Convert_all_to_default_imports_95035", "Convert all to default imports"),
        Make_all_super_calls_the_first_statement_in_their_constructor: diag(95036, ts.DiagnosticCategory.Message, "Make_all_super_calls_the_first_statement_in_their_constructor_95036", "Make all 'super()' calls the first statement in their constructor"),
        Add_qualifier_to_all_unresolved_variables_matching_a_member_name: diag(95037, ts.DiagnosticCategory.Message, "Add_qualifier_to_all_unresolved_variables_matching_a_member_name_95037", "Add qualifier to all unresolved variables matching a member name"),
        Change_all_extended_interfaces_to_implements: diag(95038, ts.DiagnosticCategory.Message, "Change_all_extended_interfaces_to_implements_95038", "Change all extended interfaces to 'implements'"),
        Add_all_missing_super_calls: diag(95039, ts.DiagnosticCategory.Message, "Add_all_missing_super_calls_95039", "Add all missing super calls"),
        Implement_all_inherited_abstract_classes: diag(95040, ts.DiagnosticCategory.Message, "Implement_all_inherited_abstract_classes_95040", "Implement all inherited abstract classes"),
        Add_all_missing_async_modifiers: diag(95041, ts.DiagnosticCategory.Message, "Add_all_missing_async_modifiers_95041", "Add all missing 'async' modifiers"),
        Add_ts_ignore_to_all_error_messages: diag(95042, ts.DiagnosticCategory.Message, "Add_ts_ignore_to_all_error_messages_95042", "Add '@ts-ignore' to all error messages"),
        Annotate_everything_with_types_from_JSDoc: diag(95043, ts.DiagnosticCategory.Message, "Annotate_everything_with_types_from_JSDoc_95043", "Annotate everything with types from JSDoc"),
        Add_to_all_uncalled_decorators: diag(95044, ts.DiagnosticCategory.Message, "Add_to_all_uncalled_decorators_95044", "Add '()' to all uncalled decorators"),
        Convert_all_constructor_functions_to_classes: diag(95045, ts.DiagnosticCategory.Message, "Convert_all_constructor_functions_to_classes_95045", "Convert all constructor functions to classes"),
        Generate_get_and_set_accessors: diag(95046, ts.DiagnosticCategory.Message, "Generate_get_and_set_accessors_95046", "Generate 'get' and 'set' accessors"),
        Convert_require_to_import: diag(95047, ts.DiagnosticCategory.Message, "Convert_require_to_import_95047", "Convert 'require' to 'import'"),
        Convert_all_require_to_import: diag(95048, ts.DiagnosticCategory.Message, "Convert_all_require_to_import_95048", "Convert all 'require' to 'import'"),
        Move_to_a_new_file: diag(95049, ts.DiagnosticCategory.Message, "Move_to_a_new_file_95049", "Move to a new file"),
        Remove_unreachable_code: diag(95050, ts.DiagnosticCategory.Message, "Remove_unreachable_code_95050", "Remove unreachable code"),
        Remove_all_unreachable_code: diag(95051, ts.DiagnosticCategory.Message, "Remove_all_unreachable_code_95051", "Remove all unreachable code"),
        Add_missing_typeof: diag(95052, ts.DiagnosticCategory.Message, "Add_missing_typeof_95052", "Add missing 'typeof'"),
        Remove_unused_label: diag(95053, ts.DiagnosticCategory.Message, "Remove_unused_label_95053", "Remove unused label"),
        Remove_all_unused_labels: diag(95054, ts.DiagnosticCategory.Message, "Remove_all_unused_labels_95054", "Remove all unused labels"),
        Convert_0_to_mapped_object_type: diag(95055, ts.DiagnosticCategory.Message, "Convert_0_to_mapped_object_type_95055", "Convert '{0}' to mapped object type"),
        Convert_namespace_import_to_named_imports: diag(95056, ts.DiagnosticCategory.Message, "Convert_namespace_import_to_named_imports_95056", "Convert namespace import to named imports"),
        Convert_named_imports_to_namespace_import: diag(95057, ts.DiagnosticCategory.Message, "Convert_named_imports_to_namespace_import_95057", "Convert named imports to namespace import"),
        Add_or_remove_braces_in_an_arrow_function: diag(95058, ts.DiagnosticCategory.Message, "Add_or_remove_braces_in_an_arrow_function_95058", "Add or remove braces in an arrow function"),
        Add_braces_to_arrow_function: diag(95059, ts.DiagnosticCategory.Message, "Add_braces_to_arrow_function_95059", "Add braces to arrow function"),
        Remove_braces_from_arrow_function: diag(95060, ts.DiagnosticCategory.Message, "Remove_braces_from_arrow_function_95060", "Remove braces from arrow function"),
        Convert_default_export_to_named_export: diag(95061, ts.DiagnosticCategory.Message, "Convert_default_export_to_named_export_95061", "Convert default export to named export"),
        Convert_named_export_to_default_export: diag(95062, ts.DiagnosticCategory.Message, "Convert_named_export_to_default_export_95062", "Convert named export to default export"),
        Add_missing_enum_member_0: diag(95063, ts.DiagnosticCategory.Message, "Add_missing_enum_member_0_95063", "Add missing enum member '{0}'"),
        Add_all_missing_imports: diag(95064, ts.DiagnosticCategory.Message, "Add_all_missing_imports_95064", "Add all missing imports"),
        Convert_to_async_function: diag(95065, ts.DiagnosticCategory.Message, "Convert_to_async_function_95065", "Convert to async function"),
        Convert_all_to_async_functions: diag(95066, ts.DiagnosticCategory.Message, "Convert_all_to_async_functions_95066", "Convert all to async functions"),
        Add_missing_call_parentheses: diag(95067, ts.DiagnosticCategory.Message, "Add_missing_call_parentheses_95067", "Add missing call parentheses"),
        Add_all_missing_call_parentheses: diag(95068, ts.DiagnosticCategory.Message, "Add_all_missing_call_parentheses_95068", "Add all missing call parentheses"),
        Add_unknown_conversion_for_non_overlapping_types: diag(95069, ts.DiagnosticCategory.Message, "Add_unknown_conversion_for_non_overlapping_types_95069", "Add 'unknown' conversion for non-overlapping types"),
        Add_unknown_to_all_conversions_of_non_overlapping_types: diag(95070, ts.DiagnosticCategory.Message, "Add_unknown_to_all_conversions_of_non_overlapping_types_95070", "Add 'unknown' to all conversions of non-overlapping types"),
        Add_missing_new_operator_to_call: diag(95071, ts.DiagnosticCategory.Message, "Add_missing_new_operator_to_call_95071", "Add missing 'new' operator to call"),
        Add_missing_new_operator_to_all_calls: diag(95072, ts.DiagnosticCategory.Message, "Add_missing_new_operator_to_all_calls_95072", "Add missing 'new' operator to all calls"),
        Add_names_to_all_parameters_without_names: diag(95073, ts.DiagnosticCategory.Message, "Add_names_to_all_parameters_without_names_95073", "Add names to all parameters without names"),
        Enable_the_experimentalDecorators_option_in_your_configuration_file: diag(95074, ts.DiagnosticCategory.Message, "Enable_the_experimentalDecorators_option_in_your_configuration_file_95074", "Enable the 'experimentalDecorators' option in your configuration file"),
        Convert_parameters_to_destructured_object: diag(95075, ts.DiagnosticCategory.Message, "Convert_parameters_to_destructured_object_95075", "Convert parameters to destructured object"),
        Extract_type: diag(95077, ts.DiagnosticCategory.Message, "Extract_type_95077", "Extract type"),
        Extract_to_type_alias: diag(95078, ts.DiagnosticCategory.Message, "Extract_to_type_alias_95078", "Extract to type alias"),
        Extract_to_typedef: diag(95079, ts.DiagnosticCategory.Message, "Extract_to_typedef_95079", "Extract to typedef"),
        Infer_this_type_of_0_from_usage: diag(95080, ts.DiagnosticCategory.Message, "Infer_this_type_of_0_from_usage_95080", "Infer 'this' type of '{0}' from usage"),
        Add_const_to_unresolved_variable: diag(95081, ts.DiagnosticCategory.Message, "Add_const_to_unresolved_variable_95081", "Add 'const' to unresolved variable"),
        Add_const_to_all_unresolved_variables: diag(95082, ts.DiagnosticCategory.Message, "Add_const_to_all_unresolved_variables_95082", "Add 'const' to all unresolved variables"),
        Add_await: diag(95083, ts.DiagnosticCategory.Message, "Add_await_95083", "Add 'await'"),
        Add_await_to_initializer_for_0: diag(95084, ts.DiagnosticCategory.Message, "Add_await_to_initializer_for_0_95084", "Add 'await' to initializer for '{0}'"),
        Fix_all_expressions_possibly_missing_await: diag(95085, ts.DiagnosticCategory.Message, "Fix_all_expressions_possibly_missing_await_95085", "Fix all expressions possibly missing 'await'"),
        Remove_unnecessary_await: diag(95086, ts.DiagnosticCategory.Message, "Remove_unnecessary_await_95086", "Remove unnecessary 'await'"),
        Remove_all_unnecessary_uses_of_await: diag(95087, ts.DiagnosticCategory.Message, "Remove_all_unnecessary_uses_of_await_95087", "Remove all unnecessary uses of 'await'"),
        Enable_the_jsx_flag_in_your_configuration_file: diag(95088, ts.DiagnosticCategory.Message, "Enable_the_jsx_flag_in_your_configuration_file_95088", "Enable the '--jsx' flag in your configuration file"),
        Add_await_to_initializers: diag(95089, ts.DiagnosticCategory.Message, "Add_await_to_initializers_95089", "Add 'await' to initializers"),
        Extract_to_interface: diag(95090, ts.DiagnosticCategory.Message, "Extract_to_interface_95090", "Extract to interface"),
        Convert_to_a_bigint_numeric_literal: diag(95091, ts.DiagnosticCategory.Message, "Convert_to_a_bigint_numeric_literal_95091", "Convert to a bigint numeric literal"),
        Convert_all_to_bigint_numeric_literals: diag(95092, ts.DiagnosticCategory.Message, "Convert_all_to_bigint_numeric_literals_95092", "Convert all to bigint numeric literals"),
        Convert_const_to_let: diag(95093, ts.DiagnosticCategory.Message, "Convert_const_to_let_95093", "Convert 'const' to 'let'"),
        Prefix_with_declare: diag(95094, ts.DiagnosticCategory.Message, "Prefix_with_declare_95094", "Prefix with 'declare'"),
        Prefix_all_incorrect_property_declarations_with_declare: diag(95095, ts.DiagnosticCategory.Message, "Prefix_all_incorrect_property_declarations_with_declare_95095", "Prefix all incorrect property declarations with 'declare'"),
        Convert_to_template_string: diag(95096, ts.DiagnosticCategory.Message, "Convert_to_template_string_95096", "Convert to template string"),
        Add_export_to_make_this_file_into_a_module: diag(95097, ts.DiagnosticCategory.Message, "Add_export_to_make_this_file_into_a_module_95097", "Add 'export {}' to make this file into a module"),
        Set_the_target_option_in_your_configuration_file_to_0: diag(95098, ts.DiagnosticCategory.Message, "Set_the_target_option_in_your_configuration_file_to_0_95098", "Set the 'target' option in your configuration file to '{0}'"),
        Set_the_module_option_in_your_configuration_file_to_0: diag(95099, ts.DiagnosticCategory.Message, "Set_the_module_option_in_your_configuration_file_to_0_95099", "Set the 'module' option in your configuration file to '{0}'"),
        Convert_invalid_character_to_its_html_entity_code: diag(95100, ts.DiagnosticCategory.Message, "Convert_invalid_character_to_its_html_entity_code_95100", "Convert invalid character to its html entity code"),
        Convert_all_invalid_characters_to_HTML_entity_code: diag(95101, ts.DiagnosticCategory.Message, "Convert_all_invalid_characters_to_HTML_entity_code_95101", "Convert all invalid characters to HTML entity code"),
        Convert_function_expression_0_to_arrow_function: diag(95105, ts.DiagnosticCategory.Message, "Convert_function_expression_0_to_arrow_function_95105", "Convert function expression '{0}' to arrow function"),
        Convert_function_declaration_0_to_arrow_function: diag(95106, ts.DiagnosticCategory.Message, "Convert_function_declaration_0_to_arrow_function_95106", "Convert function declaration '{0}' to arrow function"),
        Fix_all_implicit_this_errors: diag(95107, ts.DiagnosticCategory.Message, "Fix_all_implicit_this_errors_95107", "Fix all implicit-'this' errors"),
        Wrap_invalid_character_in_an_expression_container: diag(95108, ts.DiagnosticCategory.Message, "Wrap_invalid_character_in_an_expression_container_95108", "Wrap invalid character in an expression container"),
        Wrap_all_invalid_characters_in_an_expression_container: diag(95109, ts.DiagnosticCategory.Message, "Wrap_all_invalid_characters_in_an_expression_container_95109", "Wrap all invalid characters in an expression container"),
        Visit_https_Colon_Slash_Slashaka_ms_Slashtsconfig_to_read_more_about_this_file: diag(95110, ts.DiagnosticCategory.Message, "Visit_https_Colon_Slash_Slashaka_ms_Slashtsconfig_to_read_more_about_this_file_95110", "Visit https://aka.ms/tsconfig to read more about this file"),
        Add_a_return_statement: diag(95111, ts.DiagnosticCategory.Message, "Add_a_return_statement_95111", "Add a return statement"),
        Remove_braces_from_arrow_function_body: diag(95112, ts.DiagnosticCategory.Message, "Remove_braces_from_arrow_function_body_95112", "Remove braces from arrow function body"),
        Wrap_the_following_body_with_parentheses_which_should_be_an_object_literal: diag(95113, ts.DiagnosticCategory.Message, "Wrap_the_following_body_with_parentheses_which_should_be_an_object_literal_95113", "Wrap the following body with parentheses which should be an object literal"),
        Add_all_missing_return_statement: diag(95114, ts.DiagnosticCategory.Message, "Add_all_missing_return_statement_95114", "Add all missing return statement"),
        Remove_braces_from_all_arrow_function_bodies_with_relevant_issues: diag(95115, ts.DiagnosticCategory.Message, "Remove_braces_from_all_arrow_function_bodies_with_relevant_issues_95115", "Remove braces from all arrow function bodies with relevant issues"),
        Wrap_all_object_literal_with_parentheses: diag(95116, ts.DiagnosticCategory.Message, "Wrap_all_object_literal_with_parentheses_95116", "Wrap all object literal with parentheses"),
        Move_labeled_tuple_element_modifiers_to_labels: diag(95117, ts.DiagnosticCategory.Message, "Move_labeled_tuple_element_modifiers_to_labels_95117", "Move labeled tuple element modifiers to labels"),
        Convert_overload_list_to_single_signature: diag(95118, ts.DiagnosticCategory.Message, "Convert_overload_list_to_single_signature_95118", "Convert overload list to single signature"),
        Generate_get_and_set_accessors_for_all_overriding_properties: diag(95119, ts.DiagnosticCategory.Message, "Generate_get_and_set_accessors_for_all_overriding_properties_95119", "Generate 'get' and 'set' accessors for all overriding properties"),
        Wrap_in_JSX_fragment: diag(95120, ts.DiagnosticCategory.Message, "Wrap_in_JSX_fragment_95120", "Wrap in JSX fragment"),
        Wrap_all_unparented_JSX_in_JSX_fragment: diag(95121, ts.DiagnosticCategory.Message, "Wrap_all_unparented_JSX_in_JSX_fragment_95121", "Wrap all unparented JSX in JSX fragment"),
        Convert_arrow_function_or_function_expression: diag(95122, ts.DiagnosticCategory.Message, "Convert_arrow_function_or_function_expression_95122", "Convert arrow function or function expression"),
        Convert_to_anonymous_function: diag(95123, ts.DiagnosticCategory.Message, "Convert_to_anonymous_function_95123", "Convert to anonymous function"),
        Convert_to_named_function: diag(95124, ts.DiagnosticCategory.Message, "Convert_to_named_function_95124", "Convert to named function"),
        Convert_to_arrow_function: diag(95125, ts.DiagnosticCategory.Message, "Convert_to_arrow_function_95125", "Convert to arrow function"),
        Remove_parentheses: diag(95126, ts.DiagnosticCategory.Message, "Remove_parentheses_95126", "Remove parentheses"),
        Could_not_find_a_containing_arrow_function: diag(95127, ts.DiagnosticCategory.Message, "Could_not_find_a_containing_arrow_function_95127", "Could not find a containing arrow function"),
        Containing_function_is_not_an_arrow_function: diag(95128, ts.DiagnosticCategory.Message, "Containing_function_is_not_an_arrow_function_95128", "Containing function is not an arrow function"),
        Could_not_find_export_statement: diag(95129, ts.DiagnosticCategory.Message, "Could_not_find_export_statement_95129", "Could not find export statement"),
        This_file_already_has_a_default_export: diag(95130, ts.DiagnosticCategory.Message, "This_file_already_has_a_default_export_95130", "This file already has a default export"),
        Could_not_find_import_clause: diag(95131, ts.DiagnosticCategory.Message, "Could_not_find_import_clause_95131", "Could not find import clause"),
        Could_not_find_namespace_import_or_named_imports: diag(95132, ts.DiagnosticCategory.Message, "Could_not_find_namespace_import_or_named_imports_95132", "Could not find namespace import or named imports"),
        Selection_is_not_a_valid_type_node: diag(95133, ts.DiagnosticCategory.Message, "Selection_is_not_a_valid_type_node_95133", "Selection is not a valid type node"),
        No_type_could_be_extracted_from_this_type_node: diag(95134, ts.DiagnosticCategory.Message, "No_type_could_be_extracted_from_this_type_node_95134", "No type could be extracted from this type node"),
        Could_not_find_property_for_which_to_generate_accessor: diag(95135, ts.DiagnosticCategory.Message, "Could_not_find_property_for_which_to_generate_accessor_95135", "Could not find property for which to generate accessor"),
        Name_is_not_valid: diag(95136, ts.DiagnosticCategory.Message, "Name_is_not_valid_95136", "Name is not valid"),
        Can_only_convert_property_with_modifier: diag(95137, ts.DiagnosticCategory.Message, "Can_only_convert_property_with_modifier_95137", "Can only convert property with modifier"),
        Switch_each_misused_0_to_1: diag(95138, ts.DiagnosticCategory.Message, "Switch_each_misused_0_to_1_95138", "Switch each misused '{0}' to '{1}'"),
        Convert_to_optional_chain_expression: diag(95139, ts.DiagnosticCategory.Message, "Convert_to_optional_chain_expression_95139", "Convert to optional chain expression"),
        Could_not_find_convertible_access_expression: diag(95140, ts.DiagnosticCategory.Message, "Could_not_find_convertible_access_expression_95140", "Could not find convertible access expression"),
        Could_not_find_matching_access_expressions: diag(95141, ts.DiagnosticCategory.Message, "Could_not_find_matching_access_expressions_95141", "Could not find matching access expressions"),
        Can_only_convert_logical_AND_access_chains: diag(95142, ts.DiagnosticCategory.Message, "Can_only_convert_logical_AND_access_chains_95142", "Can only convert logical AND access chains"),
        Add_void_to_Promise_resolved_without_a_value: diag(95143, ts.DiagnosticCategory.Message, "Add_void_to_Promise_resolved_without_a_value_95143", "Add 'void' to Promise resolved without a value"),
        Add_void_to_all_Promises_resolved_without_a_value: diag(95144, ts.DiagnosticCategory.Message, "Add_void_to_all_Promises_resolved_without_a_value_95144", "Add 'void' to all Promises resolved without a value"),
        Use_element_access_for_0: diag(95145, ts.DiagnosticCategory.Message, "Use_element_access_for_0_95145", "Use element access for '{0}'"),
        Use_element_access_for_all_undeclared_properties: diag(95146, ts.DiagnosticCategory.Message, "Use_element_access_for_all_undeclared_properties_95146", "Use element access for all undeclared properties."),
        Delete_all_unused_imports: diag(95147, ts.DiagnosticCategory.Message, "Delete_all_unused_imports_95147", "Delete all unused imports"),
        Infer_function_return_type: diag(95148, ts.DiagnosticCategory.Message, "Infer_function_return_type_95148", "Infer function return type"),
        Return_type_must_be_inferred_from_a_function: diag(95149, ts.DiagnosticCategory.Message, "Return_type_must_be_inferred_from_a_function_95149", "Return type must be inferred from a function"),
        Could_not_determine_function_return_type: diag(95150, ts.DiagnosticCategory.Message, "Could_not_determine_function_return_type_95150", "Could not determine function return type"),
        Could_not_convert_to_arrow_function: diag(95151, ts.DiagnosticCategory.Message, "Could_not_convert_to_arrow_function_95151", "Could not convert to arrow function"),
        Could_not_convert_to_named_function: diag(95152, ts.DiagnosticCategory.Message, "Could_not_convert_to_named_function_95152", "Could not convert to named function"),
        Could_not_convert_to_anonymous_function: diag(95153, ts.DiagnosticCategory.Message, "Could_not_convert_to_anonymous_function_95153", "Could not convert to anonymous function"),
        Can_only_convert_string_concatenation: diag(95154, ts.DiagnosticCategory.Message, "Can_only_convert_string_concatenation_95154", "Can only convert string concatenation"),
        Selection_is_not_a_valid_statement_or_statements: diag(95155, ts.DiagnosticCategory.Message, "Selection_is_not_a_valid_statement_or_statements_95155", "Selection is not a valid statement or statements"),
        Add_missing_function_declaration_0: diag(95156, ts.DiagnosticCategory.Message, "Add_missing_function_declaration_0_95156", "Add missing function declaration '{0}'"),
        Add_all_missing_function_declarations: diag(95157, ts.DiagnosticCategory.Message, "Add_all_missing_function_declarations_95157", "Add all missing function declarations"),
        Method_not_implemented: diag(95158, ts.DiagnosticCategory.Message, "Method_not_implemented_95158", "Method not implemented."),
        Function_not_implemented: diag(95159, ts.DiagnosticCategory.Message, "Function_not_implemented_95159", "Function not implemented."),
        Add_override_modifier: diag(95160, ts.DiagnosticCategory.Message, "Add_override_modifier_95160", "Add 'override' modifier"),
        Remove_override_modifier: diag(95161, ts.DiagnosticCategory.Message, "Remove_override_modifier_95161", "Remove 'override' modifier"),
        Add_all_missing_override_modifiers: diag(95162, ts.DiagnosticCategory.Message, "Add_all_missing_override_modifiers_95162", "Add all missing 'override' modifiers"),
        Remove_all_unnecessary_override_modifiers: diag(95163, ts.DiagnosticCategory.Message, "Remove_all_unnecessary_override_modifiers_95163", "Remove all unnecessary 'override' modifiers"),
        Can_only_convert_named_export: diag(95164, ts.DiagnosticCategory.Message, "Can_only_convert_named_export_95164", "Can only convert named export"),
        Add_missing_properties: diag(95165, ts.DiagnosticCategory.Message, "Add_missing_properties_95165", "Add missing properties"),
        Add_all_missing_properties: diag(95166, ts.DiagnosticCategory.Message, "Add_all_missing_properties_95166", "Add all missing properties"),
        Add_missing_attributes: diag(95167, ts.DiagnosticCategory.Message, "Add_missing_attributes_95167", "Add missing attributes"),
        Add_all_missing_attributes: diag(95168, ts.DiagnosticCategory.Message, "Add_all_missing_attributes_95168", "Add all missing attributes"),
        Add_undefined_to_optional_property_type: diag(95169, ts.DiagnosticCategory.Message, "Add_undefined_to_optional_property_type_95169", "Add 'undefined' to optional property type"),
        Convert_named_imports_to_default_import: diag(95170, ts.DiagnosticCategory.Message, "Convert_named_imports_to_default_import_95170", "Convert named imports to default import"),
        Delete_unused_param_tag_0: diag(95171, ts.DiagnosticCategory.Message, "Delete_unused_param_tag_0_95171", "Delete unused '@param' tag '{0}'"),
        Delete_all_unused_param_tags: diag(95172, ts.DiagnosticCategory.Message, "Delete_all_unused_param_tags_95172", "Delete all unused '@param' tags"),
        Rename_param_tag_name_0_to_1: diag(95173, ts.DiagnosticCategory.Message, "Rename_param_tag_name_0_to_1_95173", "Rename '@param' tag name '{0}' to '{1}'"),
        No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer: diag(18004, ts.DiagnosticCategory.Error, "No_value_exists_in_scope_for_the_shorthand_property_0_Either_declare_one_or_provide_an_initializer_18004", "No value exists in scope for the shorthand property '{0}'. Either declare one or provide an initializer."),
        Classes_may_not_have_a_field_named_constructor: diag(18006, ts.DiagnosticCategory.Error, "Classes_may_not_have_a_field_named_constructor_18006", "Classes may not have a field named 'constructor'."),
        JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array: diag(18007, ts.DiagnosticCategory.Error, "JSX_expressions_may_not_use_the_comma_operator_Did_you_mean_to_write_an_array_18007", "JSX expressions may not use the comma operator. Did you mean to write an array?"),
        Private_identifiers_cannot_be_used_as_parameters: diag(18009, ts.DiagnosticCategory.Error, "Private_identifiers_cannot_be_used_as_parameters_18009", "Private identifiers cannot be used as parameters."),
        An_accessibility_modifier_cannot_be_used_with_a_private_identifier: diag(18010, ts.DiagnosticCategory.Error, "An_accessibility_modifier_cannot_be_used_with_a_private_identifier_18010", "An accessibility modifier cannot be used with a private identifier."),
        The_operand_of_a_delete_operator_cannot_be_a_private_identifier: diag(18011, ts.DiagnosticCategory.Error, "The_operand_of_a_delete_operator_cannot_be_a_private_identifier_18011", "The operand of a 'delete' operator cannot be a private identifier."),
        constructor_is_a_reserved_word: diag(18012, ts.DiagnosticCategory.Error, "constructor_is_a_reserved_word_18012", "'#constructor' is a reserved word."),
        Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier: diag(18013, ts.DiagnosticCategory.Error, "Property_0_is_not_accessible_outside_class_1_because_it_has_a_private_identifier_18013", "Property '{0}' is not accessible outside class '{1}' because it has a private identifier."),
        The_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_private_identifier_with_the_same_spelling: diag(18014, ts.DiagnosticCategory.Error, "The_property_0_cannot_be_accessed_on_type_1_within_this_class_because_it_is_shadowed_by_another_priv_18014", "The property '{0}' cannot be accessed on type '{1}' within this class because it is shadowed by another private identifier with the same spelling."),
        Property_0_in_type_1_refers_to_a_different_member_that_cannot_be_accessed_from_within_type_2: diag(18015, ts.DiagnosticCategory.Error, "Property_0_in_type_1_refers_to_a_different_member_that_cannot_be_accessed_from_within_type_2_18015", "Property '{0}' in type '{1}' refers to a different member that cannot be accessed from within type '{2}'."),
        Private_identifiers_are_not_allowed_outside_class_bodies: diag(18016, ts.DiagnosticCategory.Error, "Private_identifiers_are_not_allowed_outside_class_bodies_18016", "Private identifiers are not allowed outside class bodies."),
        The_shadowing_declaration_of_0_is_defined_here: diag(18017, ts.DiagnosticCategory.Error, "The_shadowing_declaration_of_0_is_defined_here_18017", "The shadowing declaration of '{0}' is defined here"),
        The_declaration_of_0_that_you_probably_intended_to_use_is_defined_here: diag(18018, ts.DiagnosticCategory.Error, "The_declaration_of_0_that_you_probably_intended_to_use_is_defined_here_18018", "The declaration of '{0}' that you probably intended to use is defined here"),
        _0_modifier_cannot_be_used_with_a_private_identifier: diag(18019, ts.DiagnosticCategory.Error, "_0_modifier_cannot_be_used_with_a_private_identifier_18019", "'{0}' modifier cannot be used with a private identifier."),
        An_enum_member_cannot_be_named_with_a_private_identifier: diag(18024, ts.DiagnosticCategory.Error, "An_enum_member_cannot_be_named_with_a_private_identifier_18024", "An enum member cannot be named with a private identifier."),
        can_only_be_used_at_the_start_of_a_file: diag(18026, ts.DiagnosticCategory.Error, "can_only_be_used_at_the_start_of_a_file_18026", "'#!' can only be used at the start of a file."),
        Compiler_reserves_name_0_when_emitting_private_identifier_downlevel: diag(18027, ts.DiagnosticCategory.Error, "Compiler_reserves_name_0_when_emitting_private_identifier_downlevel_18027", "Compiler reserves name '{0}' when emitting private identifier downlevel."),
        Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher: diag(18028, ts.DiagnosticCategory.Error, "Private_identifiers_are_only_available_when_targeting_ECMAScript_2015_and_higher_18028", "Private identifiers are only available when targeting ECMAScript 2015 and higher."),
        Private_identifiers_are_not_allowed_in_variable_declarations: diag(18029, ts.DiagnosticCategory.Error, "Private_identifiers_are_not_allowed_in_variable_declarations_18029", "Private identifiers are not allowed in variable declarations."),
        An_optional_chain_cannot_contain_private_identifiers: diag(18030, ts.DiagnosticCategory.Error, "An_optional_chain_cannot_contain_private_identifiers_18030", "An optional chain cannot contain private identifiers."),
        The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituents: diag(18031, ts.DiagnosticCategory.Error, "The_intersection_0_was_reduced_to_never_because_property_1_has_conflicting_types_in_some_constituent_18031", "The intersection '{0}' was reduced to 'never' because property '{1}' has conflicting types in some constituents."),
        The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_private_in_some: diag(18032, ts.DiagnosticCategory.Error, "The_intersection_0_was_reduced_to_never_because_property_1_exists_in_multiple_constituents_and_is_pr_18032", "The intersection '{0}' was reduced to 'never' because property '{1}' exists in multiple constituents and is private in some."),
        Only_numeric_enums_can_have_computed_members_but_this_expression_has_type_0_If_you_do_not_need_exhaustiveness_checks_consider_using_an_object_literal_instead: diag(18033, ts.DiagnosticCategory.Error, "Only_numeric_enums_can_have_computed_members_but_this_expression_has_type_0_If_you_do_not_need_exhau_18033", "Only numeric enums can have computed members, but this expression has type '{0}'. If you do not need exhaustiveness checks, consider using an object literal instead."),
        Specify_the_JSX_fragment_factory_function_to_use_when_targeting_react_JSX_emit_with_jsxFactory_compiler_option_is_specified_e_g_Fragment: diag(18034, ts.DiagnosticCategory.Message, "Specify_the_JSX_fragment_factory_function_to_use_when_targeting_react_JSX_emit_with_jsxFactory_compi_18034", "Specify the JSX fragment factory function to use when targeting 'react' JSX emit with 'jsxFactory' compiler option is specified, e.g. 'Fragment'."),
        Invalid_value_for_jsxFragmentFactory_0_is_not_a_valid_identifier_or_qualified_name: diag(18035, ts.DiagnosticCategory.Error, "Invalid_value_for_jsxFragmentFactory_0_is_not_a_valid_identifier_or_qualified_name_18035", "Invalid value for 'jsxFragmentFactory'. '{0}' is not a valid identifier or qualified-name."),
        Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_decorator: diag(18036, ts.DiagnosticCategory.Error, "Class_decorators_can_t_be_used_with_static_private_identifier_Consider_removing_the_experimental_dec_18036", "Class decorators can't be used with static private identifier. Consider removing the experimental decorator."),
        Await_expression_cannot_be_used_inside_a_class_static_block: diag(18037, ts.DiagnosticCategory.Error, "Await_expression_cannot_be_used_inside_a_class_static_block_18037", "Await expression cannot be used inside a class static block."),
        For_await_loops_cannot_be_used_inside_a_class_static_block: diag(18038, ts.DiagnosticCategory.Error, "For_await_loops_cannot_be_used_inside_a_class_static_block_18038", "'For await' loops cannot be used inside a class static block."),
        Invalid_use_of_0_It_cannot_be_used_inside_a_class_static_block: diag(18039, ts.DiagnosticCategory.Error, "Invalid_use_of_0_It_cannot_be_used_inside_a_class_static_block_18039", "Invalid use of '{0}'. It cannot be used inside a class static block."),
        A_return_statement_cannot_be_used_inside_a_class_static_block: diag(18041, ts.DiagnosticCategory.Error, "A_return_statement_cannot_be_used_inside_a_class_static_block_18041", "A 'return' statement cannot be used inside a class static block."),
        _0_is_a_type_and_cannot_be_imported_in_JavaScript_files_Use_1_in_a_JSDoc_type_annotation: diag(18042, ts.DiagnosticCategory.Error, "_0_is_a_type_and_cannot_be_imported_in_JavaScript_files_Use_1_in_a_JSDoc_type_annotation_18042", "'{0}' is a type and cannot be imported in JavaScript files. Use '{1}' in a JSDoc type annotation."),
        Types_cannot_appear_in_export_declarations_in_JavaScript_files: diag(18043, ts.DiagnosticCategory.Error, "Types_cannot_appear_in_export_declarations_in_JavaScript_files_18043", "Types cannot appear in export declarations in JavaScript files."),
        _0_is_automatically_exported_here: diag(18044, ts.DiagnosticCategory.Message, "_0_is_automatically_exported_here_18044", "'{0}' is automatically exported here."),
    };
})(ts || (ts = {}));
var ts;
(function (ts) {
    var _a;
    /* @internal */
    function tokenIsIdentifierOrKeyword(token) {
        return token >= 79 /* SyntaxKind.Identifier */;
    }
    ts.tokenIsIdentifierOrKeyword = tokenIsIdentifierOrKeyword;
    /* @internal */
    function tokenIsIdentifierOrKeywordOrGreaterThan(token) {
        return token === 31 /* SyntaxKind.GreaterThanToken */ || tokenIsIdentifierOrKeyword(token);
    }
    ts.tokenIsIdentifierOrKeywordOrGreaterThan = tokenIsIdentifierOrKeywordOrGreaterThan;
    /** @internal */
    ts.textToKeywordObj = (_a = {
            abstract: 126 /* SyntaxKind.AbstractKeyword */,
            any: 130 /* SyntaxKind.AnyKeyword */,
            as: 127 /* SyntaxKind.AsKeyword */,
            asserts: 128 /* SyntaxKind.AssertsKeyword */,
            assert: 129 /* SyntaxKind.AssertKeyword */,
            bigint: 158 /* SyntaxKind.BigIntKeyword */,
            boolean: 133 /* SyntaxKind.BooleanKeyword */,
            break: 81 /* SyntaxKind.BreakKeyword */,
            case: 82 /* SyntaxKind.CaseKeyword */,
            catch: 83 /* SyntaxKind.CatchKeyword */,
            class: 84 /* SyntaxKind.ClassKeyword */,
            continue: 86 /* SyntaxKind.ContinueKeyword */,
            const: 85 /* SyntaxKind.ConstKeyword */
        },
        _a["" + "constructor"] = 134 /* SyntaxKind.ConstructorKeyword */,
        _a.debugger = 87 /* SyntaxKind.DebuggerKeyword */,
        _a.declare = 135 /* SyntaxKind.DeclareKeyword */,
        _a.default = 88 /* SyntaxKind.DefaultKeyword */,
        _a.delete = 89 /* SyntaxKind.DeleteKeyword */,
        _a.do = 90 /* SyntaxKind.DoKeyword */,
        _a.else = 91 /* SyntaxKind.ElseKeyword */,
        _a.enum = 92 /* SyntaxKind.EnumKeyword */,
        _a.export = 93 /* SyntaxKind.ExportKeyword */,
        _a.extends = 94 /* SyntaxKind.ExtendsKeyword */,
        _a.false = 95 /* SyntaxKind.FalseKeyword */,
        _a.finally = 96 /* SyntaxKind.FinallyKeyword */,
        _a.for = 97 /* SyntaxKind.ForKeyword */,
        _a.from = 156 /* SyntaxKind.FromKeyword */,
        _a.function = 98 /* SyntaxKind.FunctionKeyword */,
        _a.get = 136 /* SyntaxKind.GetKeyword */,
        _a.if = 99 /* SyntaxKind.IfKeyword */,
        _a.implements = 117 /* SyntaxKind.ImplementsKeyword */,
        _a.import = 100 /* SyntaxKind.ImportKeyword */,
        _a.in = 101 /* SyntaxKind.InKeyword */,
        _a.infer = 137 /* SyntaxKind.InferKeyword */,
        _a.instanceof = 102 /* SyntaxKind.InstanceOfKeyword */,
        _a.interface = 118 /* SyntaxKind.InterfaceKeyword */,
        _a.intrinsic = 138 /* SyntaxKind.IntrinsicKeyword */,
        _a.is = 139 /* SyntaxKind.IsKeyword */,
        _a.keyof = 140 /* SyntaxKind.KeyOfKeyword */,
        _a.let = 119 /* SyntaxKind.LetKeyword */,
        _a.module = 141 /* SyntaxKind.ModuleKeyword */,
        _a.namespace = 142 /* SyntaxKind.NamespaceKeyword */,
        _a.never = 143 /* SyntaxKind.NeverKeyword */,
        _a.new = 103 /* SyntaxKind.NewKeyword */,
        _a.null = 104 /* SyntaxKind.NullKeyword */,
        _a.number = 147 /* SyntaxKind.NumberKeyword */,
        _a.object = 148 /* SyntaxKind.ObjectKeyword */,
        _a.package = 120 /* SyntaxKind.PackageKeyword */,
        _a.private = 121 /* SyntaxKind.PrivateKeyword */,
        _a.protected = 122 /* SyntaxKind.ProtectedKeyword */,
        _a.public = 123 /* SyntaxKind.PublicKeyword */,
        _a.override = 159 /* SyntaxKind.OverrideKeyword */,
        _a.out = 144 /* SyntaxKind.OutKeyword */,
        _a.readonly = 145 /* SyntaxKind.ReadonlyKeyword */,
        _a.require = 146 /* SyntaxKind.RequireKeyword */,
        _a.global = 157 /* SyntaxKind.GlobalKeyword */,
        _a.return = 105 /* SyntaxKind.ReturnKeyword */,
        _a.set = 149 /* SyntaxKind.SetKeyword */,
        _a.static = 124 /* SyntaxKind.StaticKeyword */,
        _a.string = 150 /* SyntaxKind.StringKeyword */,
        _a.super = 106 /* SyntaxKind.SuperKeyword */,
        _a.switch = 107 /* SyntaxKind.SwitchKeyword */,
        _a.symbol = 151 /* SyntaxKind.SymbolKeyword */,
        _a.this = 108 /* SyntaxKind.ThisKeyword */,
        _a.throw = 109 /* SyntaxKind.ThrowKeyword */,
        _a.true = 110 /* SyntaxKind.TrueKeyword */,
        _a.try = 111 /* SyntaxKind.TryKeyword */,
        _a.type = 152 /* SyntaxKind.TypeKeyword */,
        _a.typeof = 112 /* SyntaxKind.TypeOfKeyword */,
        _a.undefined = 153 /* SyntaxKind.UndefinedKeyword */,
        _a.unique = 154 /* SyntaxKind.UniqueKeyword */,
        _a.unknown = 155 /* SyntaxKind.UnknownKeyword */,
        _a.var = 113 /* SyntaxKind.VarKeyword */,
        _a.void = 114 /* SyntaxKind.VoidKeyword */,
        _a.while = 115 /* SyntaxKind.WhileKeyword */,
        _a.with = 116 /* SyntaxKind.WithKeyword */,
        _a.yield = 125 /* SyntaxKind.YieldKeyword */,
        _a.async = 131 /* SyntaxKind.AsyncKeyword */,
        _a.await = 132 /* SyntaxKind.AwaitKeyword */,
        _a.of = 160 /* SyntaxKind.OfKeyword */,
        _a);
    var textToKeyword = new ts.Map(ts.getEntries(ts.textToKeywordObj));
    var textToToken = new ts.Map(ts.getEntries(__assign(__assign({}, ts.textToKeywordObj), { "{": 18 /* SyntaxKind.OpenBraceToken */, "}": 19 /* SyntaxKind.CloseBraceToken */, "(": 20 /* SyntaxKind.OpenParenToken */, ")": 21 /* SyntaxKind.CloseParenToken */, "[": 22 /* SyntaxKind.OpenBracketToken */, "]": 23 /* SyntaxKind.CloseBracketToken */, ".": 24 /* SyntaxKind.DotToken */, "...": 25 /* SyntaxKind.DotDotDotToken */, ";": 26 /* SyntaxKind.SemicolonToken */, ",": 27 /* SyntaxKind.CommaToken */, "<": 29 /* SyntaxKind.LessThanToken */, ">": 31 /* SyntaxKind.GreaterThanToken */, "<=": 32 /* SyntaxKind.LessThanEqualsToken */, ">=": 33 /* SyntaxKind.GreaterThanEqualsToken */, "==": 34 /* SyntaxKind.EqualsEqualsToken */, "!=": 35 /* SyntaxKind.ExclamationEqualsToken */, "===": 36 /* SyntaxKind.EqualsEqualsEqualsToken */, "!==": 37 /* SyntaxKind.ExclamationEqualsEqualsToken */, "=>": 38 /* SyntaxKind.EqualsGreaterThanToken */, "+": 39 /* SyntaxKind.PlusToken */, "-": 40 /* SyntaxKind.MinusToken */, "**": 42 /* SyntaxKind.AsteriskAsteriskToken */, "*": 41 /* SyntaxKind.AsteriskToken */, "/": 43 /* SyntaxKind.SlashToken */, "%": 44 /* SyntaxKind.PercentToken */, "++": 45 /* SyntaxKind.PlusPlusToken */, "--": 46 /* SyntaxKind.MinusMinusToken */, "<<": 47 /* SyntaxKind.LessThanLessThanToken */, "</": 30 /* SyntaxKind.LessThanSlashToken */, ">>": 48 /* SyntaxKind.GreaterThanGreaterThanToken */, ">>>": 49 /* SyntaxKind.GreaterThanGreaterThanGreaterThanToken */, "&": 50 /* SyntaxKind.AmpersandToken */, "|": 51 /* SyntaxKind.BarToken */, "^": 52 /* SyntaxKind.CaretToken */, "!": 53 /* SyntaxKind.ExclamationToken */, "~": 54 /* SyntaxKind.TildeToken */, "&&": 55 /* SyntaxKind.AmpersandAmpersandToken */, "||": 56 /* SyntaxKind.BarBarToken */, "?": 57 /* SyntaxKind.QuestionToken */, "??": 60 /* SyntaxKind.QuestionQuestionToken */, "?.": 28 /* SyntaxKind.QuestionDotToken */, ":": 58 /* SyntaxKind.ColonToken */, "=": 63 /* SyntaxKind.EqualsToken */, "+=": 64 /* SyntaxKind.PlusEqualsToken */, "-=": 65 /* SyntaxKind.MinusEqualsToken */, "*=": 66 /* SyntaxKind.AsteriskEqualsToken */, "**=": 67 /* SyntaxKind.AsteriskAsteriskEqualsToken */, "/=": 68 /* SyntaxKind.SlashEqualsToken */, "%=": 69 /* SyntaxKind.PercentEqualsToken */, "<<=": 70 /* SyntaxKind.LessThanLessThanEqualsToken */, ">>=": 71 /* SyntaxKind.GreaterThanGreaterThanEqualsToken */, ">>>=": 72 /* SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken */, "&=": 73 /* SyntaxKind.AmpersandEqualsToken */, "|=": 74 /* SyntaxKind.BarEqualsToken */, "^=": 78 /* SyntaxKind.CaretEqualsToken */, "||=": 75 /* SyntaxKind.BarBarEqualsToken */, "&&=": 76 /* SyntaxKind.AmpersandAmpersandEqualsToken */, "??=": 77 /* SyntaxKind.QuestionQuestionEqualsToken */, "@": 59 /* SyntaxKind.AtToken */, "#": 62 /* SyntaxKind.HashToken */, "`": 61 /* SyntaxKind.BacktickToken */ })));
    /*
        As per ECMAScript Language Specification 3th Edition, Section 7.6: Identifiers
        IdentifierStart ::
            Can contain Unicode 3.0.0 categories:
            Uppercase letter (Lu),
            Lowercase letter (Ll),
            Titlecase letter (Lt),
            Modifier letter (Lm),
            Other letter (Lo), or
            Letter number (Nl).
        IdentifierPart :: =
            Can contain IdentifierStart + Unicode 3.0.0 categories:
            Non-spacing mark (Mn),
            Combining spacing mark (Mc),
            Decimal number (Nd), or
            Connector punctuation (Pc).

        Codepoint ranges for ES3 Identifiers are extracted from the Unicode 3.0.0 specification at:
        http://www.unicode.org/Public/3.0-Update/UnicodeData-3.0.0.txt
    */
    var unicodeES3IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1610, 1649, 1747, 1749, 1749, 1765, 1766, 1786, 1788, 1808, 1808, 1810, 1836, 1920, 1957, 2309, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2784, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3294, 3294, 3296, 3297, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3424, 3425, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805, 3840, 3840, 3904, 3911, 3913, 3946, 3976, 3979, 4096, 4129, 4131, 4135, 4137, 4138, 4176, 4181, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6067, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12353, 12436, 12445, 12446, 12449, 12538, 12540, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65138, 65140, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,];
    var unicodeES3IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 768, 846, 864, 866, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1155, 1158, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1441, 1443, 1465, 1467, 1469, 1471, 1471, 1473, 1474, 1476, 1476, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1621, 1632, 1641, 1648, 1747, 1749, 1756, 1759, 1768, 1770, 1773, 1776, 1788, 1808, 1836, 1840, 1866, 1920, 1968, 2305, 2307, 2309, 2361, 2364, 2381, 2384, 2388, 2392, 2403, 2406, 2415, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2492, 2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2562, 2562, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2649, 2652, 2654, 2654, 2662, 2676, 2689, 2691, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2784, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2876, 2883, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2913, 2918, 2927, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3031, 3031, 3047, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3168, 3169, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3297, 3302, 3311, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3390, 3395, 3398, 3400, 3402, 3405, 3415, 3415, 3424, 3425, 3430, 3439, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3805, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3946, 3953, 3972, 3974, 3979, 3984, 3991, 3993, 4028, 4038, 4038, 4096, 4129, 4131, 4135, 4137, 4138, 4140, 4146, 4150, 4153, 4160, 4169, 4176, 4185, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 4969, 4977, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6099, 6112, 6121, 6160, 6169, 6176, 6263, 6272, 6313, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8255, 8256, 8319, 8319, 8400, 8412, 8417, 8417, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12346, 12353, 12436, 12441, 12442, 12445, 12446, 12449, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65056, 65059, 65075, 65076, 65101, 65103, 65136, 65138, 65140, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65381, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,];
    /*
        As per ECMAScript Language Specification 5th Edition, Section 7.6: ISyntaxToken Names and Identifiers
        IdentifierStart ::
            Can contain Unicode 6.2 categories:
            Uppercase letter (Lu),
            Lowercase letter (Ll),
            Titlecase letter (Lt),
            Modifier letter (Lm),
            Other letter (Lo), or
            Letter number (Nl).
        IdentifierPart ::
            Can contain IdentifierStart + Unicode 6.2 categories:
            Non-spacing mark (Mn),
            Combining spacing mark (Mc),
            Decimal number (Nd),
            Connector punctuation (Pc),
            <ZWNJ>, or
            <ZWJ>.

        Codepoint ranges for ES5 Identifiers are extracted from the Unicode 6.2 specification at:
        http://www.unicode.org/Public/6.2.0/ucd/UnicodeData.txt
    */
    var unicodeES5IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,];
    var unicodeES5IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520, 1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788, 1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112, 2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423, 2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424, 3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272, 6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205, 8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43047, 43072, 43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500,];
    /**
     * Generated by scripts/regenerate-unicode-identifier-parts.js on node v12.4.0 with unicode 12.1
     * based on http://www.unicode.org/reports/tr31/ and https://www.ecma-international.org/ecma-262/6.0/#sec-names-and-keywords
     * unicodeESNextIdentifierStart corresponds to the ID_Start and Other_ID_Start property, and
     * unicodeESNextIdentifierPart corresponds to ID_Continue, Other_ID_Continue, plus ID_Start and Other_ID_Start
     */
    var unicodeESNextIdentifierStart = [65, 90, 97, 122, 170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 895, 895, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1327, 1329, 1366, 1369, 1369, 1376, 1416, 1488, 1514, 1519, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2144, 2154, 2208, 2228, 2230, 2237, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2432, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2556, 2556, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2809, 2809, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3129, 3133, 3133, 3160, 3162, 3168, 3169, 3200, 3200, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3412, 3414, 3423, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3718, 3722, 3724, 3747, 3749, 3749, 3751, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5109, 5112, 5117, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5880, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6264, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6430, 6480, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7296, 7304, 7312, 7354, 7357, 7359, 7401, 7404, 7406, 7411, 7413, 7414, 7418, 7418, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8472, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12443, 12447, 12449, 12538, 12540, 12543, 12549, 12591, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40943, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42653, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42943, 42946, 42950, 42999, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43261, 43262, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43488, 43492, 43494, 43503, 43514, 43518, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43646, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43824, 43866, 43868, 43879, 43888, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65536, 65547, 65549, 65574, 65576, 65594, 65596, 65597, 65599, 65613, 65616, 65629, 65664, 65786, 65856, 65908, 66176, 66204, 66208, 66256, 66304, 66335, 66349, 66378, 66384, 66421, 66432, 66461, 66464, 66499, 66504, 66511, 66513, 66517, 66560, 66717, 66736, 66771, 66776, 66811, 66816, 66855, 66864, 66915, 67072, 67382, 67392, 67413, 67424, 67431, 67584, 67589, 67592, 67592, 67594, 67637, 67639, 67640, 67644, 67644, 67647, 67669, 67680, 67702, 67712, 67742, 67808, 67826, 67828, 67829, 67840, 67861, 67872, 67897, 67968, 68023, 68030, 68031, 68096, 68096, 68112, 68115, 68117, 68119, 68121, 68149, 68192, 68220, 68224, 68252, 68288, 68295, 68297, 68324, 68352, 68405, 68416, 68437, 68448, 68466, 68480, 68497, 68608, 68680, 68736, 68786, 68800, 68850, 68864, 68899, 69376, 69404, 69415, 69415, 69424, 69445, 69600, 69622, 69635, 69687, 69763, 69807, 69840, 69864, 69891, 69926, 69956, 69956, 69968, 70002, 70006, 70006, 70019, 70066, 70081, 70084, 70106, 70106, 70108, 70108, 70144, 70161, 70163, 70187, 70272, 70278, 70280, 70280, 70282, 70285, 70287, 70301, 70303, 70312, 70320, 70366, 70405, 70412, 70415, 70416, 70419, 70440, 70442, 70448, 70450, 70451, 70453, 70457, 70461, 70461, 70480, 70480, 70493, 70497, 70656, 70708, 70727, 70730, 70751, 70751, 70784, 70831, 70852, 70853, 70855, 70855, 71040, 71086, 71128, 71131, 71168, 71215, 71236, 71236, 71296, 71338, 71352, 71352, 71424, 71450, 71680, 71723, 71840, 71903, 71935, 71935, 72096, 72103, 72106, 72144, 72161, 72161, 72163, 72163, 72192, 72192, 72203, 72242, 72250, 72250, 72272, 72272, 72284, 72329, 72349, 72349, 72384, 72440, 72704, 72712, 72714, 72750, 72768, 72768, 72818, 72847, 72960, 72966, 72968, 72969, 72971, 73008, 73030, 73030, 73056, 73061, 73063, 73064, 73066, 73097, 73112, 73112, 73440, 73458, 73728, 74649, 74752, 74862, 74880, 75075, 77824, 78894, 82944, 83526, 92160, 92728, 92736, 92766, 92880, 92909, 92928, 92975, 92992, 92995, 93027, 93047, 93053, 93071, 93760, 93823, 93952, 94026, 94032, 94032, 94099, 94111, 94176, 94177, 94179, 94179, 94208, 100343, 100352, 101106, 110592, 110878, 110928, 110930, 110948, 110951, 110960, 111355, 113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817, 119808, 119892, 119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993, 119995, 119995, 119997, 120003, 120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144, 120146, 120485, 120488, 120512, 120514, 120538, 120540, 120570, 120572, 120596, 120598, 120628, 120630, 120654, 120656, 120686, 120688, 120712, 120714, 120744, 120746, 120770, 120772, 120779, 123136, 123180, 123191, 123197, 123214, 123214, 123584, 123627, 124928, 125124, 125184, 125251, 125259, 125259, 126464, 126467, 126469, 126495, 126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514, 126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530, 126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543, 126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553, 126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562, 126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583, 126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619, 126625, 126627, 126629, 126633, 126635, 126651, 131072, 173782, 173824, 177972, 177984, 178205, 178208, 183969, 183984, 191456, 194560, 195101];
    var unicodeESNextIdentifierPart = [48, 57, 65, 90, 95, 95, 97, 122, 170, 170, 181, 181, 183, 183, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 895, 895, 902, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1327, 1329, 1366, 1369, 1369, 1376, 1416, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1519, 1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788, 1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2045, 2045, 2048, 2093, 2112, 2139, 2144, 2154, 2208, 2228, 2230, 2237, 2259, 2273, 2275, 2403, 2406, 2415, 2417, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2556, 2556, 2558, 2558, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2809, 2815, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3072, 3084, 3086, 3088, 3090, 3112, 3114, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3162, 3168, 3171, 3174, 3183, 3200, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3328, 3331, 3333, 3340, 3342, 3344, 3346, 3396, 3398, 3400, 3402, 3406, 3412, 3415, 3423, 3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3558, 3567, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3718, 3722, 3724, 3747, 3749, 3749, 3751, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4969, 4977, 4992, 5007, 5024, 5109, 5112, 5117, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5880, 5888, 5900, 5902, 5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6264, 6272, 6314, 6320, 6389, 6400, 6430, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6618, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6832, 6845, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7296, 7304, 7312, 7354, 7357, 7359, 7376, 7378, 7380, 7418, 7424, 7673, 7675, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8472, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12447, 12449, 12538, 12540, 12543, 12549, 12591, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40943, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42737, 42775, 42783, 42786, 42888, 42891, 42943, 42946, 42950, 42999, 43047, 43072, 43123, 43136, 43205, 43216, 43225, 43232, 43255, 43259, 43259, 43261, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43488, 43518, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43824, 43866, 43868, 43879, 43888, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65071, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500, 65536, 65547, 65549, 65574, 65576, 65594, 65596, 65597, 65599, 65613, 65616, 65629, 65664, 65786, 65856, 65908, 66045, 66045, 66176, 66204, 66208, 66256, 66272, 66272, 66304, 66335, 66349, 66378, 66384, 66426, 66432, 66461, 66464, 66499, 66504, 66511, 66513, 66517, 66560, 66717, 66720, 66729, 66736, 66771, 66776, 66811, 66816, 66855, 66864, 66915, 67072, 67382, 67392, 67413, 67424, 67431, 67584, 67589, 67592, 67592, 67594, 67637, 67639, 67640, 67644, 67644, 67647, 67669, 67680, 67702, 67712, 67742, 67808, 67826, 67828, 67829, 67840, 67861, 67872, 67897, 67968, 68023, 68030, 68031, 68096, 68099, 68101, 68102, 68108, 68115, 68117, 68119, 68121, 68149, 68152, 68154, 68159, 68159, 68192, 68220, 68224, 68252, 68288, 68295, 68297, 68326, 68352, 68405, 68416, 68437, 68448, 68466, 68480, 68497, 68608, 68680, 68736, 68786, 68800, 68850, 68864, 68903, 68912, 68921, 69376, 69404, 69415, 69415, 69424, 69456, 69600, 69622, 69632, 69702, 69734, 69743, 69759, 69818, 69840, 69864, 69872, 69881, 69888, 69940, 69942, 69951, 69956, 69958, 69968, 70003, 70006, 70006, 70016, 70084, 70089, 70092, 70096, 70106, 70108, 70108, 70144, 70161, 70163, 70199, 70206, 70206, 70272, 70278, 70280, 70280, 70282, 70285, 70287, 70301, 70303, 70312, 70320, 70378, 70384, 70393, 70400, 70403, 70405, 70412, 70415, 70416, 70419, 70440, 70442, 70448, 70450, 70451, 70453, 70457, 70459, 70468, 70471, 70472, 70475, 70477, 70480, 70480, 70487, 70487, 70493, 70499, 70502, 70508, 70512, 70516, 70656, 70730, 70736, 70745, 70750, 70751, 70784, 70853, 70855, 70855, 70864, 70873, 71040, 71093, 71096, 71104, 71128, 71133, 71168, 71232, 71236, 71236, 71248, 71257, 71296, 71352, 71360, 71369, 71424, 71450, 71453, 71467, 71472, 71481, 71680, 71738, 71840, 71913, 71935, 71935, 72096, 72103, 72106, 72151, 72154, 72161, 72163, 72164, 72192, 72254, 72263, 72263, 72272, 72345, 72349, 72349, 72384, 72440, 72704, 72712, 72714, 72758, 72760, 72768, 72784, 72793, 72818, 72847, 72850, 72871, 72873, 72886, 72960, 72966, 72968, 72969, 72971, 73014, 73018, 73018, 73020, 73021, 73023, 73031, 73040, 73049, 73056, 73061, 73063, 73064, 73066, 73102, 73104, 73105, 73107, 73112, 73120, 73129, 73440, 73462, 73728, 74649, 74752, 74862, 74880, 75075, 77824, 78894, 82944, 83526, 92160, 92728, 92736, 92766, 92768, 92777, 92880, 92909, 92912, 92916, 92928, 92982, 92992, 92995, 93008, 93017, 93027, 93047, 93053, 93071, 93760, 93823, 93952, 94026, 94031, 94087, 94095, 94111, 94176, 94177, 94179, 94179, 94208, 100343, 100352, 101106, 110592, 110878, 110928, 110930, 110948, 110951, 110960, 111355, 113664, 113770, 113776, 113788, 113792, 113800, 113808, 113817, 113821, 113822, 119141, 119145, 119149, 119154, 119163, 119170, 119173, 119179, 119210, 119213, 119362, 119364, 119808, 119892, 119894, 119964, 119966, 119967, 119970, 119970, 119973, 119974, 119977, 119980, 119982, 119993, 119995, 119995, 119997, 120003, 120005, 120069, 120071, 120074, 120077, 120084, 120086, 120092, 120094, 120121, 120123, 120126, 120128, 120132, 120134, 120134, 120138, 120144, 120146, 120485, 120488, 120512, 120514, 120538, 120540, 120570, 120572, 120596, 120598, 120628, 120630, 120654, 120656, 120686, 120688, 120712, 120714, 120744, 120746, 120770, 120772, 120779, 120782, 120831, 121344, 121398, 121403, 121452, 121461, 121461, 121476, 121476, 121499, 121503, 121505, 121519, 122880, 122886, 122888, 122904, 122907, 122913, 122915, 122916, 122918, 122922, 123136, 123180, 123184, 123197, 123200, 123209, 123214, 123214, 123584, 123641, 124928, 125124, 125136, 125142, 125184, 125259, 125264, 125273, 126464, 126467, 126469, 126495, 126497, 126498, 126500, 126500, 126503, 126503, 126505, 126514, 126516, 126519, 126521, 126521, 126523, 126523, 126530, 126530, 126535, 126535, 126537, 126537, 126539, 126539, 126541, 126543, 126545, 126546, 126548, 126548, 126551, 126551, 126553, 126553, 126555, 126555, 126557, 126557, 126559, 126559, 126561, 126562, 126564, 126564, 126567, 126570, 126572, 126578, 126580, 126583, 126585, 126588, 126590, 126590, 126592, 126601, 126603, 126619, 126625, 126627, 126629, 126633, 126635, 126651, 131072, 173782, 173824, 177972, 177984, 178205, 178208, 183969, 183984, 191456, 194560, 195101, 917760, 917999];
    /**
     * Test for whether a single line comment with leading whitespace trimmed's text contains a directive.
     */
    var commentDirectiveRegExSingleLine = /^\/\/\/?\s*@(ts-expect-error|ts-ignore)/;
    /**
     * Test for whether a multi-line comment with leading whitespace trimmed's last line contains a directive.
     */
    var commentDirectiveRegExMultiLine = /^(?:\/|\*)*\s*@(ts-expect-error|ts-ignore)/;
    function lookupInUnicodeMap(code, map) {
        // Bail out quickly if it couldn't possibly be in the map.
        if (code < map[0]) {
            return false;
        }
        // Perform binary search in one of the Unicode range maps
        var lo = 0;
        var hi = map.length;
        var mid;
        while (lo + 1 < hi) {
            mid = lo + (hi - lo) / 2;
            // mid has to be even to catch a range's beginning
            mid -= mid % 2;
            if (map[mid] <= code && code <= map[mid + 1]) {
                return true;
            }
            if (code < map[mid]) {
                hi = mid;
            }
            else {
                lo = mid + 2;
            }
        }
        return false;
    }
    /* @internal */ function isUnicodeIdentifierStart(code, languageVersion) {
        return languageVersion >= 2 /* ScriptTarget.ES2015 */ ?
            lookupInUnicodeMap(code, unicodeESNextIdentifierStart) :
            languageVersion === 1 /* ScriptTarget.ES5 */ ? lookupInUnicodeMap(code, unicodeES5IdentifierStart) :
                lookupInUnicodeMap(code, unicodeES3IdentifierStart);
    }
    ts.isUnicodeIdentifierStart = isUnicodeIdentifierStart;
    function isUnicodeIdentifierPart(code, languageVersion) {
        return languageVersion >= 2 /* ScriptTarget.ES2015 */ ?
            lookupInUnicodeMap(code, unicodeESNextIdentifierPart) :
            languageVersion === 1 /* ScriptTarget.ES5 */ ? lookupInUnicodeMap(code, unicodeES5IdentifierPart) :
                lookupInUnicodeMap(code, unicodeES3IdentifierPart);
    }
    function makeReverseMap(source) {
        var result = [];
        source.forEach(function (value, name) {
            result[value] = name;
        });
        return result;
    }
    var tokenStrings = makeReverseMap(textToToken);
    function tokenToString(t) {
        return tokenStrings[t];
    }
    ts.tokenToString = tokenToString;
    /* @internal */
    function stringToToken(s) {
        return textToToken.get(s);
    }
    ts.stringToToken = stringToToken;
    /* @internal */
    function computeLineStarts(text) {
        var result = new Array();
        var pos = 0;
        var lineStart = 0;
        while (pos < text.length) {
            var ch = text.charCodeAt(pos);
            pos++;
            switch (ch) {
                case 13 /* CharacterCodes.carriageReturn */:
                    if (text.charCodeAt(pos) === 10 /* CharacterCodes.lineFeed */) {
                        pos++;
                    }
                // falls through
                case 10 /* CharacterCodes.lineFeed */:
                    result.push(lineStart);
                    lineStart = pos;
                    break;
                default:
                    if (ch > 127 /* CharacterCodes.maxAsciiCharacter */ && isLineBreak(ch)) {
                        result.push(lineStart);
                        lineStart = pos;
                    }
                    break;
            }
        }
        result.push(lineStart);
        return result;
    }
    ts.computeLineStarts = computeLineStarts;
    function getPositionOfLineAndCharacter(sourceFile, line, character, allowEdits) {
        return sourceFile.getPositionOfLineAndCharacter ?
            sourceFile.getPositionOfLineAndCharacter(line, character, allowEdits) :
            computePositionOfLineAndCharacter(getLineStarts(sourceFile), line, character, sourceFile.text, allowEdits);
    }
    ts.getPositionOfLineAndCharacter = getPositionOfLineAndCharacter;
    /* @internal */
    function computePositionOfLineAndCharacter(lineStarts, line, character, debugText, allowEdits) {
        if (line < 0 || line >= lineStarts.length) {
            if (allowEdits) {
                // Clamp line to nearest allowable value
                line = line < 0 ? 0 : line >= lineStarts.length ? lineStarts.length - 1 : line;
            }
            else {
                ts.Debug.fail("Bad line number. Line: ".concat(line, ", lineStarts.length: ").concat(lineStarts.length, " , line map is correct? ").concat(debugText !== undefined ? ts.arraysEqual(lineStarts, computeLineStarts(debugText)) : "unknown"));
            }
        }
        var res = lineStarts[line] + character;
        if (allowEdits) {
            // Clamp to nearest allowable values to allow the underlying to be edited without crashing (accuracy is lost, instead)
            // TODO: Somehow track edits between file as it was during the creation of sourcemap we have and the current file and
            // apply them to the computed position to improve accuracy
            return res > lineStarts[line + 1] ? lineStarts[line + 1] : typeof debugText === "string" && res > debugText.length ? debugText.length : res;
        }
        if (line < lineStarts.length - 1) {
            ts.Debug.assert(res < lineStarts[line + 1]);
        }
        else if (debugText !== undefined) {
            ts.Debug.assert(res <= debugText.length); // Allow single character overflow for trailing newline
        }
        return res;
    }
    ts.computePositionOfLineAndCharacter = computePositionOfLineAndCharacter;
    /* @internal */
    function getLineStarts(sourceFile) {
        return sourceFile.lineMap || (sourceFile.lineMap = computeLineStarts(sourceFile.text));
    }
    ts.getLineStarts = getLineStarts;
    /* @internal */
    function computeLineAndCharacterOfPosition(lineStarts, position) {
        var lineNumber = computeLineOfPosition(lineStarts, position);
        return {
            line: lineNumber,
            character: position - lineStarts[lineNumber]
        };
    }
    ts.computeLineAndCharacterOfPosition = computeLineAndCharacterOfPosition;
    /**
     * @internal
     * We assume the first line starts at position 0 and 'position' is non-negative.
     */
    function computeLineOfPosition(lineStarts, position, lowerBound) {
        var lineNumber = ts.binarySearch(lineStarts, position, ts.identity, ts.compareValues, lowerBound);
        if (lineNumber < 0) {
            // If the actual position was not found,
            // the binary search returns the 2's-complement of the next line start
            // e.g. if the line starts at [5, 10, 23, 80] and the position requested was 20
            // then the search will return -2.
            //
            // We want the index of the previous line start, so we subtract 1.
            // Review 2's-complement if this is confusing.
            lineNumber = ~lineNumber - 1;
            ts.Debug.assert(lineNumber !== -1, "position cannot precede the beginning of the file");
        }
        return lineNumber;
    }
    ts.computeLineOfPosition = computeLineOfPosition;
    /** @internal */
    function getLinesBetweenPositions(sourceFile, pos1, pos2) {
        if (pos1 === pos2)
            return 0;
        var lineStarts = getLineStarts(sourceFile);
        var lower = Math.min(pos1, pos2);
        var isNegative = lower === pos2;
        var upper = isNegative ? pos1 : pos2;
        var lowerLine = computeLineOfPosition(lineStarts, lower);
        var upperLine = computeLineOfPosition(lineStarts, upper, lowerLine);
        return isNegative ? lowerLine - upperLine : upperLine - lowerLine;
    }
    ts.getLinesBetweenPositions = getLinesBetweenPositions;
    function getLineAndCharacterOfPosition(sourceFile, position) {
        return computeLineAndCharacterOfPosition(getLineStarts(sourceFile), position);
    }
    ts.getLineAndCharacterOfPosition = getLineAndCharacterOfPosition;
    function isWhiteSpaceLike(ch) {
        return isWhiteSpaceSingleLine(ch) || isLineBreak(ch);
    }
    ts.isWhiteSpaceLike = isWhiteSpaceLike;
    /** Does not include line breaks. For that, see isWhiteSpaceLike. */
    function isWhiteSpaceSingleLine(ch) {
        // Note: nextLine is in the Zs space, and should be considered to be a whitespace.
        // It is explicitly not a line-break as it isn't in the exact set specified by EcmaScript.
        return ch === 32 /* CharacterCodes.space */ ||
            ch === 9 /* CharacterCodes.tab */ ||
            ch === 11 /* CharacterCodes.verticalTab */ ||
            ch === 12 /* CharacterCodes.formFeed */ ||
            ch === 160 /* CharacterCodes.nonBreakingSpace */ ||
            ch === 133 /* CharacterCodes.nextLine */ ||
            ch === 5760 /* CharacterCodes.ogham */ ||
            ch >= 8192 /* CharacterCodes.enQuad */ && ch <= 8203 /* CharacterCodes.zeroWidthSpace */ ||
            ch === 8239 /* CharacterCodes.narrowNoBreakSpace */ ||
            ch === 8287 /* CharacterCodes.mathematicalSpace */ ||
            ch === 12288 /* CharacterCodes.ideographicSpace */ ||
            ch === 65279 /* CharacterCodes.byteOrderMark */;
    }
    ts.isWhiteSpaceSingleLine = isWhiteSpaceSingleLine;
    function isLineBreak(ch) {
        // ES5 7.3:
        // The ECMAScript line terminator characters are listed in Table 3.
        //     Table 3: Line Terminator Characters
        //     Code Unit Value     Name                    Formal Name
        //     \u000A              Line Feed               <LF>
        //     \u000D              Carriage Return         <CR>
        //     \u2028              Line separator          <LS>
        //     \u2029              Paragraph separator     <PS>
        // Only the characters in Table 3 are treated as line terminators. Other new line or line
        // breaking characters are treated as white space but not as line terminators.
        return ch === 10 /* CharacterCodes.lineFeed */ ||
            ch === 13 /* CharacterCodes.carriageReturn */ ||
            ch === 8232 /* CharacterCodes.lineSeparator */ ||
            ch === 8233 /* CharacterCodes.paragraphSeparator */;
    }
    ts.isLineBreak = isLineBreak;
    function isDigit(ch) {
        return ch >= 48 /* CharacterCodes._0 */ && ch <= 57 /* CharacterCodes._9 */;
    }
    function isHexDigit(ch) {
        return isDigit(ch) || ch >= 65 /* CharacterCodes.A */ && ch <= 70 /* CharacterCodes.F */ || ch >= 97 /* CharacterCodes.a */ && ch <= 102 /* CharacterCodes.f */;
    }
    function isCodePoint(code) {
        return code <= 0x10FFFF;
    }
    /* @internal */
    function isOctalDigit(ch) {
        return ch >= 48 /* CharacterCodes._0 */ && ch <= 55 /* CharacterCodes._7 */;
    }
    ts.isOctalDigit = isOctalDigit;
    function couldStartTrivia(text, pos) {
        // Keep in sync with skipTrivia
        var ch = text.charCodeAt(pos);
        switch (ch) {
            case 13 /* CharacterCodes.carriageReturn */:
            case 10 /* CharacterCodes.lineFeed */:
            case 9 /* CharacterCodes.tab */:
            case 11 /* CharacterCodes.verticalTab */:
            case 12 /* CharacterCodes.formFeed */:
            case 32 /* CharacterCodes.space */:
            case 47 /* CharacterCodes.slash */:
            // starts of normal trivia
            // falls through
            case 60 /* CharacterCodes.lessThan */:
            case 124 /* CharacterCodes.bar */:
            case 61 /* CharacterCodes.equals */:
            case 62 /* CharacterCodes.greaterThan */:
                // Starts of conflict marker trivia
                return true;
            case 35 /* CharacterCodes.hash */:
                // Only if its the beginning can we have #! trivia
                return pos === 0;
            default:
                return ch > 127 /* CharacterCodes.maxAsciiCharacter */;
        }
    }
    ts.couldStartTrivia = couldStartTrivia;
    /* @internal */
    function skipTrivia(text, pos, stopAfterLineBreak, stopAtComments, inJSDoc) {
        if (ts.positionIsSynthesized(pos)) {
            return pos;
        }
        var canConsumeStar = false;
        // Keep in sync with couldStartTrivia
        while (true) {
            var ch = text.charCodeAt(pos);
            switch (ch) {
                case 13 /* CharacterCodes.carriageReturn */:
                    if (text.charCodeAt(pos + 1) === 10 /* CharacterCodes.lineFeed */) {
                        pos++;
                    }
                // falls through
                case 10 /* CharacterCodes.lineFeed */:
                    pos++;
                    if (stopAfterLineBreak) {
                        return pos;
                    }
                    canConsumeStar = !!inJSDoc;
                    continue;
                case 9 /* CharacterCodes.tab */:
                case 11 /* CharacterCodes.verticalTab */:
                case 12 /* CharacterCodes.formFeed */:
                case 32 /* CharacterCodes.space */:
                    pos++;
                    continue;
                case 47 /* CharacterCodes.slash */:
                    if (stopAtComments) {
                        break;
                    }
                    if (text.charCodeAt(pos + 1) === 47 /* CharacterCodes.slash */) {
                        pos += 2;
                        while (pos < text.length) {
                            if (isLineBreak(text.charCodeAt(pos))) {
                                break;
                            }
                            pos++;
                        }
                        canConsumeStar = false;
                        continue;
                    }
                    if (text.charCodeAt(pos + 1) === 42 /* CharacterCodes.asterisk */) {
                        pos += 2;
                        while (pos < text.length) {
                            if (text.charCodeAt(pos) === 42 /* CharacterCodes.asterisk */ && text.charCodeAt(pos + 1) === 47 /* CharacterCodes.slash */) {
                                pos += 2;
                                break;
                            }
                            pos++;
                        }
                        canConsumeStar = false;
                        continue;
                    }
                    break;
                case 60 /* CharacterCodes.lessThan */:
                case 124 /* CharacterCodes.bar */:
                case 61 /* CharacterCodes.equals */:
                case 62 /* CharacterCodes.greaterThan */:
                    if (isConflictMarkerTrivia(text, pos)) {
                        pos = scanConflictMarkerTrivia(text, pos);
                        canConsumeStar = false;
                        continue;
                    }
                    break;
                case 35 /* CharacterCodes.hash */:
                    if (pos === 0 && isShebangTrivia(text, pos)) {
                        pos = scanShebangTrivia(text, pos);
                        canConsumeStar = false;
                        continue;
                    }
                    break;
                case 42 /* CharacterCodes.asterisk */:
                    if (canConsumeStar) {
                        pos++;
                        canConsumeStar = false;
                        continue;
                    }
                    break;
                default:
                    if (ch > 127 /* CharacterCodes.maxAsciiCharacter */ && (isWhiteSpaceLike(ch))) {
                        pos++;
                        continue;
                    }
                    break;
            }
            return pos;
        }
    }
    ts.skipTrivia = skipTrivia;
    // All conflict markers consist of the same character repeated seven times.  If it is
    // a <<<<<<< or >>>>>>> marker then it is also followed by a space.
    var mergeConflictMarkerLength = "<<<<<<<".length;
    function isConflictMarkerTrivia(text, pos) {
        ts.Debug.assert(pos >= 0);
        // Conflict markers must be at the start of a line.
        if (pos === 0 || isLineBreak(text.charCodeAt(pos - 1))) {
            var ch = text.charCodeAt(pos);
            if ((pos + mergeConflictMarkerLength) < text.length) {
                for (var i = 0; i < mergeConflictMarkerLength; i++) {
                    if (text.charCodeAt(pos + i) !== ch) {
                        return false;
                    }
                }
                return ch === 61 /* CharacterCodes.equals */ ||
                    text.charCodeAt(pos + mergeConflictMarkerLength) === 32 /* CharacterCodes.space */;
            }
        }
        return false;
    }
    function scanConflictMarkerTrivia(text, pos, error) {
        if (error) {
            error(ts.Diagnostics.Merge_conflict_marker_encountered, pos, mergeConflictMarkerLength);
        }
        var ch = text.charCodeAt(pos);
        var len = text.length;
        if (ch === 60 /* CharacterCodes.lessThan */ || ch === 62 /* CharacterCodes.greaterThan */) {
            while (pos < len && !isLineBreak(text.charCodeAt(pos))) {
                pos++;
            }
        }
        else {
            ts.Debug.assert(ch === 124 /* CharacterCodes.bar */ || ch === 61 /* CharacterCodes.equals */);
            // Consume everything from the start of a ||||||| or ======= marker to the start
            // of the next ======= or >>>>>>> marker.
            while (pos < len) {
                var currentChar = text.charCodeAt(pos);
                if ((currentChar === 61 /* CharacterCodes.equals */ || currentChar === 62 /* CharacterCodes.greaterThan */) && currentChar !== ch && isConflictMarkerTrivia(text, pos)) {
                    break;
                }
                pos++;
            }
        }
        return pos;
    }
    var shebangTriviaRegex = /^#!.*/;
    /*@internal*/
    function isShebangTrivia(text, pos) {
        // Shebangs check must only be done at the start of the file
        ts.Debug.assert(pos === 0);
        return shebangTriviaRegex.test(text);
    }
    ts.isShebangTrivia = isShebangTrivia;
    /*@internal*/
    function scanShebangTrivia(text, pos) {
        var shebang = shebangTriviaRegex.exec(text)[0];
        pos = pos + shebang.length;
        return pos;
    }
    ts.scanShebangTrivia = scanShebangTrivia;
    /**
     * Invokes a callback for each comment range following the provided position.
     *
     * Single-line comment ranges include the leading double-slash characters but not the ending
     * line break. Multi-line comment ranges include the leading slash-asterisk and trailing
     * asterisk-slash characters.
     *
     * @param reduce If true, accumulates the result of calling the callback in a fashion similar
     *      to reduceLeft. If false, iteration stops when the callback returns a truthy value.
     * @param text The source text to scan.
     * @param pos The position at which to start scanning.
     * @param trailing If false, whitespace is skipped until the first line break and comments
     *      between that location and the next token are returned. If true, comments occurring
     *      between the given position and the next line break are returned.
     * @param cb The callback to execute as each comment range is encountered.
     * @param state A state value to pass to each iteration of the callback.
     * @param initial An initial value to pass when accumulating results (when "reduce" is true).
     * @returns If "reduce" is true, the accumulated value. If "reduce" is false, the first truthy
     *      return value of the callback.
     */
    function iterateCommentRanges(reduce, text, pos, trailing, cb, state, initial) {
        var pendingPos;
        var pendingEnd;
        var pendingKind;
        var pendingHasTrailingNewLine;
        var hasPendingCommentRange = false;
        var collecting = trailing;
        var accumulator = initial;
        if (pos === 0) {
            collecting = true;
            var shebang = getShebang(text);
            if (shebang) {
                pos = shebang.length;
            }
        }
        scan: while (pos >= 0 && pos < text.length) {
            var ch = text.charCodeAt(pos);
            switch (ch) {
                case 13 /* CharacterCodes.carriageReturn */:
                    if (text.charCodeAt(pos + 1) === 10 /* CharacterCodes.lineFeed */) {
                        pos++;
                    }
                // falls through
                case 10 /* CharacterCodes.lineFeed */:
                    pos++;
                    if (trailing) {
                        break scan;
                    }
                    collecting = true;
                    if (hasPendingCommentRange) {
                        pendingHasTrailingNewLine = true;
                    }
                    continue;
                case 9 /* CharacterCodes.tab */:
                case 11 /* CharacterCodes.verticalTab */:
                case 12 /* CharacterCodes.formFeed */:
                case 32 /* CharacterCodes.space */:
                    pos++;
                    continue;
                case 47 /* CharacterCodes.slash */:
                    var nextChar = text.charCodeAt(pos + 1);
                    var hasTrailingNewLine = false;
                    if (nextChar === 47 /* CharacterCodes.slash */ || nextChar === 42 /* CharacterCodes.asterisk */) {
                        var kind = nextChar === 47 /* CharacterCodes.slash */ ? 2 /* SyntaxKind.SingleLineCommentTrivia */ : 3 /* SyntaxKind.MultiLineCommentTrivia */;
                        var startPos = pos;
                        pos += 2;
                        if (nextChar === 47 /* CharacterCodes.slash */) {
                            while (pos < text.length) {
                                if (isLineBreak(text.charCodeAt(pos))) {
                                    hasTrailingNewLine = true;
                                    break;
                                }
                                pos++;
                            }
                        }
                        else {
                            while (pos < text.length) {
                                if (text.charCodeAt(pos) === 42 /* CharacterCodes.asterisk */ && text.charCodeAt(pos + 1) === 47 /* CharacterCodes.slash */) {
                                    pos += 2;
                                    break;
                                }
                                pos++;
                            }
                        }
                        if (collecting) {
                            if (hasPendingCommentRange) {
                                accumulator = cb(pendingPos, pendingEnd, pendingKind, pendingHasTrailingNewLine, state, accumulator);
                                if (!reduce && accumulator) {
                                    // If we are not reducing and we have a truthy result, return it.
                                    return accumulator;
                                }
                            }
                            pendingPos = startPos;
                            pendingEnd = pos;
                            pendingKind = kind;
                            pendingHasTrailingNewLine = hasTrailingNewLine;
                            hasPendingCommentRange = true;
                        }
                        continue;
                    }
                    break scan;
                default:
                    if (ch > 127 /* CharacterCodes.maxAsciiCharacter */ && (isWhiteSpaceLike(ch))) {
                        if (hasPendingCommentRange && isLineBreak(ch)) {
                            pendingHasTrailingNewLine = true;
                        }
                        pos++;
                        continue;
                    }
                    break scan;
            }
        }
        if (hasPendingCommentRange) {
            accumulator = cb(pendingPos, pendingEnd, pendingKind, pendingHasTrailingNewLine, state, accumulator);
        }
        return accumulator;
    }
    function forEachLeadingCommentRange(text, pos, cb, state) {
        return iterateCommentRanges(/*reduce*/ false, text, pos, /*trailing*/ false, cb, state);
    }
    ts.forEachLeadingCommentRange = forEachLeadingCommentRange;
    function forEachTrailingCommentRange(text, pos, cb, state) {
        return iterateCommentRanges(/*reduce*/ false, text, pos, /*trailing*/ true, cb, state);
    }
    ts.forEachTrailingCommentRange = forEachTrailingCommentRange;
    function reduceEachLeadingCommentRange(text, pos, cb, state, initial) {
        return iterateCommentRanges(/*reduce*/ true, text, pos, /*trailing*/ false, cb, state, initial);
    }
    ts.reduceEachLeadingCommentRange = reduceEachLeadingCommentRange;
    function reduceEachTrailingCommentRange(text, pos, cb, state, initial) {
        return iterateCommentRanges(/*reduce*/ true, text, pos, /*trailing*/ true, cb, state, initial);
    }
    ts.reduceEachTrailingCommentRange = reduceEachTrailingCommentRange;
    function appendCommentRange(pos, end, kind, hasTrailingNewLine, _state, comments) {
        if (!comments) {
            comments = [];
        }
        comments.push({ kind: kind, pos: pos, end: end, hasTrailingNewLine: hasTrailingNewLine });
        return comments;
    }
    function getLeadingCommentRanges(text, pos) {
        return reduceEachLeadingCommentRange(text, pos, appendCommentRange, /*state*/ undefined, /*initial*/ undefined);
    }
    ts.getLeadingCommentRanges = getLeadingCommentRanges;
    function getTrailingCommentRanges(text, pos) {
        return reduceEachTrailingCommentRange(text, pos, appendCommentRange, /*state*/ undefined, /*initial*/ undefined);
    }
    ts.getTrailingCommentRanges = getTrailingCommentRanges;
    /** Optionally, get the shebang */
    function getShebang(text) {
        var match = shebangTriviaRegex.exec(text);
        if (match) {
            return match[0];
        }
    }
    ts.getShebang = getShebang;
    function isIdentifierStart(ch, languageVersion) {
        return ch >= 65 /* CharacterCodes.A */ && ch <= 90 /* CharacterCodes.Z */ || ch >= 97 /* CharacterCodes.a */ && ch <= 122 /* CharacterCodes.z */ ||
            ch === 36 /* CharacterCodes.$ */ || ch === 95 /* CharacterCodes._ */ ||
            ch > 127 /* CharacterCodes.maxAsciiCharacter */ && isUnicodeIdentifierStart(ch, languageVersion);
    }
    ts.isIdentifierStart = isIdentifierStart;
    function isIdentifierPart(ch, languageVersion, identifierVariant) {
        return ch >= 65 /* CharacterCodes.A */ && ch <= 90 /* CharacterCodes.Z */ || ch >= 97 /* CharacterCodes.a */ && ch <= 122 /* CharacterCodes.z */ ||
            ch >= 48 /* CharacterCodes._0 */ && ch <= 57 /* CharacterCodes._9 */ || ch === 36 /* CharacterCodes.$ */ || ch === 95 /* CharacterCodes._ */ ||
            // "-" and ":" are valid in JSX Identifiers
            (identifierVariant === 1 /* LanguageVariant.JSX */ ? (ch === 45 /* CharacterCodes.minus */ || ch === 58 /* CharacterCodes.colon */) : false) ||
            ch > 127 /* CharacterCodes.maxAsciiCharacter */ && isUnicodeIdentifierPart(ch, languageVersion);
    }
    ts.isIdentifierPart = isIdentifierPart;
    /* @internal */
    function isIdentifierText(name, languageVersion, identifierVariant) {
        var ch = codePointAt(name, 0);
        if (!isIdentifierStart(ch, languageVersion)) {
            return false;
        }
        for (var i = charSize(ch); i < name.length; i += charSize(ch)) {
            if (!isIdentifierPart(ch = codePointAt(name, i), languageVersion, identifierVariant)) {
                return false;
            }
        }
        return true;
    }
    ts.isIdentifierText = isIdentifierText;
    // Creates a scanner over a (possibly unspecified) range of a piece of text.
    function createScanner(languageVersion, skipTrivia, languageVariant, textInitial, onError, start, length) {
        if (languageVariant === void 0) { languageVariant = 0 /* LanguageVariant.Standard */; }
        var text = textInitial;
        // Current position (end position of text of current token)
        var pos;
        // end of text
        var end;
        // Start position of whitespace before current token
        var startPos;
        // Start position of text of current token
        var tokenPos;
        var token;
        var tokenValue;
        var tokenFlags;
        var commentDirectives;
        var inJSDocType = 0;
        setText(text, start, length);
        var scanner = {
            getStartPos: function () { return startPos; },
            getTextPos: function () { return pos; },
            getToken: function () { return token; },
            getTokenPos: function () { return tokenPos; },
            getTokenText: function () { return text.substring(tokenPos, pos); },
            getTokenValue: function () { return tokenValue; },
            hasUnicodeEscape: function () { return (tokenFlags & 1024 /* TokenFlags.UnicodeEscape */) !== 0; },
            hasExtendedUnicodeEscape: function () { return (tokenFlags & 8 /* TokenFlags.ExtendedUnicodeEscape */) !== 0; },
            hasPrecedingLineBreak: function () { return (tokenFlags & 1 /* TokenFlags.PrecedingLineBreak */) !== 0; },
            hasPrecedingJSDocComment: function () { return (tokenFlags & 2 /* TokenFlags.PrecedingJSDocComment */) !== 0; },
            isIdentifier: function () { return token === 79 /* SyntaxKind.Identifier */ || token > 116 /* SyntaxKind.LastReservedWord */; },
            isReservedWord: function () { return token >= 81 /* SyntaxKind.FirstReservedWord */ && token <= 116 /* SyntaxKind.LastReservedWord */; },
            isUnterminated: function () { return (tokenFlags & 4 /* TokenFlags.Unterminated */) !== 0; },
            getCommentDirectives: function () { return commentDirectives; },
            getNumericLiteralFlags: function () { return tokenFlags & 1008 /* TokenFlags.NumericLiteralFlags */; },
            getTokenFlags: function () { return tokenFlags; },
            reScanGreaterToken: reScanGreaterToken,
            reScanAsteriskEqualsToken: reScanAsteriskEqualsToken,
            reScanSlashToken: reScanSlashToken,
            reScanTemplateToken: reScanTemplateToken,
            reScanTemplateHeadOrNoSubstitutionTemplate: reScanTemplateHeadOrNoSubstitutionTemplate,
            scanJsxIdentifier: scanJsxIdentifier,
            scanJsxAttributeValue: scanJsxAttributeValue,
            reScanJsxAttributeValue: reScanJsxAttributeValue,
            reScanJsxToken: reScanJsxToken,
            reScanLessThanToken: reScanLessThanToken,
            reScanHashToken: reScanHashToken,
            reScanQuestionToken: reScanQuestionToken,
            reScanInvalidIdentifier: reScanInvalidIdentifier,
            scanJsxToken: scanJsxToken,
            scanJsDocToken: scanJsDocToken,
            scan: scan,
            getText: getText,
            clearCommentDirectives: clearCommentDirectives,
            setText: setText,
            setScriptTarget: setScriptTarget,
            setLanguageVariant: setLanguageVariant,
            setOnError: setOnError,
            setTextPos: setTextPos,
            setInJSDocType: setInJSDocType,
            tryScan: tryScan,
            lookAhead: lookAhead,
            scanRange: scanRange,
        };
        if (ts.Debug.isDebugging) {
            Object.defineProperty(scanner, "__debugShowCurrentPositionInText", {
                get: function () {
                    var text = scanner.getText();
                    return text.slice(0, scanner.getStartPos()) + "" + text.slice(scanner.getStartPos());
                },
            });
        }
        return scanner;
        function error(message, errPos, length) {
            if (errPos === void 0) { errPos = pos; }
            if (onError) {
                var oldPos = pos;
                pos = errPos;
                onError(message, length || 0);
                pos = oldPos;
            }
        }
        function scanNumberFragment() {
            var start = pos;
            var allowSeparator = false;
            var isPreviousTokenSeparator = false;
            var result = "";
            while (true) {
                var ch = text.charCodeAt(pos);
                if (ch === 95 /* CharacterCodes._ */) {
                    tokenFlags |= 512 /* TokenFlags.ContainsSeparator */;
                    if (allowSeparator) {
                        allowSeparator = false;
                        isPreviousTokenSeparator = true;
                        result += text.substring(start, pos);
                    }
                    else if (isPreviousTokenSeparator) {
                        error(ts.Diagnostics.Multiple_consecutive_numeric_separators_are_not_permitted, pos, 1);
                    }
                    else {
                        error(ts.Diagnostics.Numeric_separators_are_not_allowed_here, pos, 1);
                    }
                    pos++;
                    start = pos;
                    continue;
                }
                if (isDigit(ch)) {
                    allowSeparator = true;
                    isPreviousTokenSeparator = false;
                    pos++;
                    continue;
                }
                break;
            }
            if (text.charCodeAt(pos - 1) === 95 /* CharacterCodes._ */) {
                error(ts.Diagnostics.Numeric_separators_are_not_allowed_here, pos - 1, 1);
            }
            return result + text.substring(start, pos);
        }
        function scanNumber() {
            var start = pos;
            var mainFragment = scanNumberFragment();
            var decimalFragment;
            var scientificFragment;
            if (text.charCodeAt(pos) === 46 /* CharacterCodes.dot */) {
                pos++;
                decimalFragment = scanNumberFragment();
            }
            var end = pos;
            if (text.charCodeAt(pos) === 69 /* CharacterCodes.E */ || text.charCodeAt(pos) === 101 /* CharacterCodes.e */) {
                pos++;
                tokenFlags |= 16 /* TokenFlags.Scientific */;
                if (text.charCodeAt(pos) === 43 /* CharacterCodes.plus */ || text.charCodeAt(pos) === 45 /* CharacterCodes.minus */)
                    pos++;
                var preNumericPart = pos;
                var finalFragment = scanNumberFragment();
                if (!finalFragment) {
                    error(ts.Diagnostics.Digit_expected);
                }
                else {
                    scientificFragment = text.substring(end, preNumericPart) + finalFragment;
                    end = pos;
                }
            }
            var result;
            if (tokenFlags & 512 /* TokenFlags.ContainsSeparator */) {
                result = mainFragment;
                if (decimalFragment) {
                    result += "." + decimalFragment;
                }
                if (scientificFragment) {
                    result += scientificFragment;
                }
            }
            else {
                result = text.substring(start, end); // No need to use all the fragments; no _ removal needed
            }
            if (decimalFragment !== undefined || tokenFlags & 16 /* TokenFlags.Scientific */) {
                checkForIdentifierStartAfterNumericLiteral(start, decimalFragment === undefined && !!(tokenFlags & 16 /* TokenFlags.Scientific */));
                return {
                    type: 8 /* SyntaxKind.NumericLiteral */,
                    value: "" + +result // if value is not an integer, it can be safely coerced to a number
                };
            }
            else {
                tokenValue = result;
                var type = checkBigIntSuffix(); // if value is an integer, check whether it is a bigint
                checkForIdentifierStartAfterNumericLiteral(start);
                return { type: type, value: tokenValue };
            }
        }
        function checkForIdentifierStartAfterNumericLiteral(numericStart, isScientific) {
            if (!isIdentifierStart(codePointAt(text, pos), languageVersion)) {
                return;
            }
            var identifierStart = pos;
            var length = scanIdentifierParts().length;
            if (length === 1 && text[identifierStart] === "n") {
                if (isScientific) {
                    error(ts.Diagnostics.A_bigint_literal_cannot_use_exponential_notation, numericStart, identifierStart - numericStart + 1);
                }
                else {
                    error(ts.Diagnostics.A_bigint_literal_must_be_an_integer, numericStart, identifierStart - numericStart + 1);
                }
            }
            else {
                error(ts.Diagnostics.An_identifier_or_keyword_cannot_immediately_follow_a_numeric_literal, identifierStart, length);
                pos = identifierStart;
            }
        }
        function scanOctalDigits() {
            var start = pos;
            while (isOctalDigit(text.charCodeAt(pos))) {
                pos++;
            }
            return +(text.substring(start, pos));
        }
        /**
         * Scans the given number of hexadecimal digits in the text,
         * returning -1 if the given number is unavailable.
         */
        function scanExactNumberOfHexDigits(count, canHaveSeparators) {
            var valueString = scanHexDigits(/*minCount*/ count, /*scanAsManyAsPossible*/ false, canHaveSeparators);
            return valueString ? parseInt(valueString, 16) : -1;
        }
        /**
         * Scans as many hexadecimal digits as are available in the text,
         * returning "" if the given number of digits was unavailable.
         */
        function scanMinimumNumberOfHexDigits(count, canHaveSeparators) {
            return scanHexDigits(/*minCount*/ count, /*scanAsManyAsPossible*/ true, canHaveSeparators);
        }
        function scanHexDigits(minCount, scanAsManyAsPossible, canHaveSeparators) {
            var valueChars = [];
            var allowSeparator = false;
            var isPreviousTokenSeparator = false;
            while (valueChars.length < minCount || scanAsManyAsPossible) {
                var ch = text.charCodeAt(pos);
                if (canHaveSeparators && ch === 95 /* CharacterCodes._ */) {
                    tokenFlags |= 512 /* TokenFlags.ContainsSeparator */;
                    if (allowSeparator) {
                        allowSeparator = false;
                        isPreviousTokenSeparator = true;
                    }
                    else if (isPreviousTokenSeparator) {
                        error(ts.Diagnostics.Multiple_consecutive_numeric_separators_are_not_permitted, pos, 1);
                    }
                    else {
                        error(ts.Diagnostics.Numeric_separators_are_not_allowed_here, pos, 1);
                    }
                    pos++;
                    continue;
                }
                allowSeparator = canHaveSeparators;
                if (ch >= 65 /* CharacterCodes.A */ && ch <= 70 /* CharacterCodes.F */) {
                    ch += 97 /* CharacterCodes.a */ - 65 /* CharacterCodes.A */; // standardize hex literals to lowercase
                }
                else if (!((ch >= 48 /* CharacterCodes._0 */ && ch <= 57 /* CharacterCodes._9 */) ||
                    (ch >= 97 /* CharacterCodes.a */ && ch <= 102 /* CharacterCodes.f */))) {
                    break;
                }
                valueChars.push(ch);
                pos++;
                isPreviousTokenSeparator = false;
            }
            if (valueChars.length < minCount) {
                valueChars = [];
            }
            if (text.charCodeAt(pos - 1) === 95 /* CharacterCodes._ */) {
                error(ts.Diagnostics.Numeric_separators_are_not_allowed_here, pos - 1, 1);
            }
            return String.fromCharCode.apply(String, valueChars);
        }
        function scanString(jsxAttributeString) {
            if (jsxAttributeString === void 0) { jsxAttributeString = false; }
            var quote = text.charCodeAt(pos);
            pos++;
            var result = "";
            var start = pos;
            while (true) {
                if (pos >= end) {
                    result += text.substring(start, pos);
                    tokenFlags |= 4 /* TokenFlags.Unterminated */;
                    error(ts.Diagnostics.Unterminated_string_literal);
                    break;
                }
                var ch = text.charCodeAt(pos);
                if (ch === quote) {
                    result += text.substring(start, pos);
                    pos++;
                    break;
                }
                if (ch === 92 /* CharacterCodes.backslash */ && !jsxAttributeString) {
                    result += text.substring(start, pos);
                    result += scanEscapeSequence();
                    start = pos;
                    continue;
                }
                if (isLineBreak(ch) && !jsxAttributeString) {
                    result += text.substring(start, pos);
                    tokenFlags |= 4 /* TokenFlags.Unterminated */;
                    error(ts.Diagnostics.Unterminated_string_literal);
                    break;
                }
                pos++;
            }
            return result;
        }
        /**
         * Sets the current 'tokenValue' and returns a NoSubstitutionTemplateLiteral or
         * a literal component of a TemplateExpression.
         */
        function scanTemplateAndSetTokenValue(isTaggedTemplate) {
            var startedWithBacktick = text.charCodeAt(pos) === 96 /* CharacterCodes.backtick */;
            pos++;
            var start = pos;
            var contents = "";
            var resultingToken;
            while (true) {
                if (pos >= end) {
                    contents += text.substring(start, pos);
                    tokenFlags |= 4 /* TokenFlags.Unterminated */;
                    error(ts.Diagnostics.Unterminated_template_literal);
                    resultingToken = startedWithBacktick ? 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */ : 17 /* SyntaxKind.TemplateTail */;
                    break;
                }
                var currChar = text.charCodeAt(pos);
                // '`'
                if (currChar === 96 /* CharacterCodes.backtick */) {
                    contents += text.substring(start, pos);
                    pos++;
                    resultingToken = startedWithBacktick ? 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */ : 17 /* SyntaxKind.TemplateTail */;
                    break;
                }
                // '${'
                if (currChar === 36 /* CharacterCodes.$ */ && pos + 1 < end && text.charCodeAt(pos + 1) === 123 /* CharacterCodes.openBrace */) {
                    contents += text.substring(start, pos);
                    pos += 2;
                    resultingToken = startedWithBacktick ? 15 /* SyntaxKind.TemplateHead */ : 16 /* SyntaxKind.TemplateMiddle */;
                    break;
                }
                // Escape character
                if (currChar === 92 /* CharacterCodes.backslash */) {
                    contents += text.substring(start, pos);
                    contents += scanEscapeSequence(isTaggedTemplate);
                    start = pos;
                    continue;
                }
                // Speculated ECMAScript 6 Spec 11.8.6.1:
                // <CR><LF> and <CR> LineTerminatorSequences are normalized to <LF> for Template Values
                if (currChar === 13 /* CharacterCodes.carriageReturn */) {
                    contents += text.substring(start, pos);
                    pos++;
                    if (pos < end && text.charCodeAt(pos) === 10 /* CharacterCodes.lineFeed */) {
                        pos++;
                    }
                    contents += "\n";
                    start = pos;
                    continue;
                }
                pos++;
            }
            ts.Debug.assert(resultingToken !== undefined);
            tokenValue = contents;
            return resultingToken;
        }
        function scanEscapeSequence(isTaggedTemplate) {
            var start = pos;
            pos++;
            if (pos >= end) {
                error(ts.Diagnostics.Unexpected_end_of_text);
                return "";
            }
            var ch = text.charCodeAt(pos);
            pos++;
            switch (ch) {
                case 48 /* CharacterCodes._0 */:
                    // '\01'
                    if (isTaggedTemplate && pos < end && isDigit(text.charCodeAt(pos))) {
                        pos++;
                        tokenFlags |= 2048 /* TokenFlags.ContainsInvalidEscape */;
                        return text.substring(start, pos);
                    }
                    return "\0";
                case 98 /* CharacterCodes.b */:
                    return "\b";
                case 116 /* CharacterCodes.t */:
                    return "\t";
                case 110 /* CharacterCodes.n */:
                    return "\n";
                case 118 /* CharacterCodes.v */:
                    return "\v";
                case 102 /* CharacterCodes.f */:
                    return "\f";
                case 114 /* CharacterCodes.r */:
                    return "\r";
                case 39 /* CharacterCodes.singleQuote */:
                    return "\'";
                case 34 /* CharacterCodes.doubleQuote */:
                    return "\"";
                case 117 /* CharacterCodes.u */:
                    if (isTaggedTemplate) {
                        // '\u' or '\u0' or '\u00' or '\u000'
                        for (var escapePos = pos; escapePos < pos + 4; escapePos++) {
                            if (escapePos < end && !isHexDigit(text.charCodeAt(escapePos)) && text.charCodeAt(escapePos) !== 123 /* CharacterCodes.openBrace */) {
                                pos = escapePos;
                                tokenFlags |= 2048 /* TokenFlags.ContainsInvalidEscape */;
                                return text.substring(start, pos);
                            }
                        }
                    }
                    // '\u{DDDDDDDD}'
                    if (pos < end && text.charCodeAt(pos) === 123 /* CharacterCodes.openBrace */) {
                        pos++;
                        // '\u{'
                        if (isTaggedTemplate && !isHexDigit(text.charCodeAt(pos))) {
                            tokenFlags |= 2048 /* TokenFlags.ContainsInvalidEscape */;
                            return text.substring(start, pos);
                        }
                        if (isTaggedTemplate) {
                            var savePos = pos;
                            var escapedValueString = scanMinimumNumberOfHexDigits(1, /*canHaveSeparators*/ false);
                            var escapedValue = escapedValueString ? parseInt(escapedValueString, 16) : -1;
                            // '\u{Not Code Point' or '\u{CodePoint'
                            if (!isCodePoint(escapedValue) || text.charCodeAt(pos) !== 125 /* CharacterCodes.closeBrace */) {
                                tokenFlags |= 2048 /* TokenFlags.ContainsInvalidEscape */;
                                return text.substring(start, pos);
                            }
                            else {
                                pos = savePos;
                            }
                        }
                        tokenFlags |= 8 /* TokenFlags.ExtendedUnicodeEscape */;
                        return scanExtendedUnicodeEscape();
                    }
                    tokenFlags |= 1024 /* TokenFlags.UnicodeEscape */;
                    // '\uDDDD'
                    return scanHexadecimalEscape(/*numDigits*/ 4);
                case 120 /* CharacterCodes.x */:
                    if (isTaggedTemplate) {
                        if (!isHexDigit(text.charCodeAt(pos))) {
                            tokenFlags |= 2048 /* TokenFlags.ContainsInvalidEscape */;
                            return text.substring(start, pos);
                        }
                        else if (!isHexDigit(text.charCodeAt(pos + 1))) {
                            pos++;
                            tokenFlags |= 2048 /* TokenFlags.ContainsInvalidEscape */;
                            return text.substring(start, pos);
                        }
                    }
                    // '\xDD'
                    return scanHexadecimalEscape(/*numDigits*/ 2);
                // when encountering a LineContinuation (i.e. a backslash and a line terminator sequence),
                // the line terminator is interpreted to be "the empty code unit sequence".
                case 13 /* CharacterCodes.carriageReturn */:
                    if (pos < end && text.charCodeAt(pos) === 10 /* CharacterCodes.lineFeed */) {
                        pos++;
                    }
                // falls through
                case 10 /* CharacterCodes.lineFeed */:
                case 8232 /* CharacterCodes.lineSeparator */:
                case 8233 /* CharacterCodes.paragraphSeparator */:
                    return "";
                default:
                    return String.fromCharCode(ch);
            }
        }
        function scanHexadecimalEscape(numDigits) {
            var escapedValue = scanExactNumberOfHexDigits(numDigits, /*canHaveSeparators*/ false);
            if (escapedValue >= 0) {
                return String.fromCharCode(escapedValue);
            }
            else {
                error(ts.Diagnostics.Hexadecimal_digit_expected);
                return "";
            }
        }
        function scanExtendedUnicodeEscape() {
            var escapedValueString = scanMinimumNumberOfHexDigits(1, /*canHaveSeparators*/ false);
            var escapedValue = escapedValueString ? parseInt(escapedValueString, 16) : -1;
            var isInvalidExtendedEscape = false;
            // Validate the value of the digit
            if (escapedValue < 0) {
                error(ts.Diagnostics.Hexadecimal_digit_expected);
                isInvalidExtendedEscape = true;
            }
            else if (escapedValue > 0x10FFFF) {
                error(ts.Diagnostics.An_extended_Unicode_escape_value_must_be_between_0x0_and_0x10FFFF_inclusive);
                isInvalidExtendedEscape = true;
            }
            if (pos >= end) {
                error(ts.Diagnostics.Unexpected_end_of_text);
                isInvalidExtendedEscape = true;
            }
            else if (text.charCodeAt(pos) === 125 /* CharacterCodes.closeBrace */) {
                // Only swallow the following character up if it's a '}'.
                pos++;
            }
            else {
                error(ts.Diagnostics.Unterminated_Unicode_escape_sequence);
                isInvalidExtendedEscape = true;
            }
            if (isInvalidExtendedEscape) {
                return "";
            }
            return utf16EncodeAsString(escapedValue);
        }
        // Current character is known to be a backslash. Check for Unicode escape of the form '\uXXXX'
        // and return code point value if valid Unicode escape is found. Otherwise return -1.
        function peekUnicodeEscape() {
            if (pos + 5 < end && text.charCodeAt(pos + 1) === 117 /* CharacterCodes.u */) {
                var start_1 = pos;
                pos += 2;
                var value = scanExactNumberOfHexDigits(4, /*canHaveSeparators*/ false);
                pos = start_1;
                return value;
            }
            return -1;
        }
        function peekExtendedUnicodeEscape() {
            if (languageVersion >= 2 /* ScriptTarget.ES2015 */ && codePointAt(text, pos + 1) === 117 /* CharacterCodes.u */ && codePointAt(text, pos + 2) === 123 /* CharacterCodes.openBrace */) {
                var start_2 = pos;
                pos += 3;
                var escapedValueString = scanMinimumNumberOfHexDigits(1, /*canHaveSeparators*/ false);
                var escapedValue = escapedValueString ? parseInt(escapedValueString, 16) : -1;
                pos = start_2;
                return escapedValue;
            }
            return -1;
        }
        function scanIdentifierParts() {
            var result = "";
            var start = pos;
            while (pos < end) {
                var ch = codePointAt(text, pos);
                if (isIdentifierPart(ch, languageVersion)) {
                    pos += charSize(ch);
                }
                else if (ch === 92 /* CharacterCodes.backslash */) {
                    ch = peekExtendedUnicodeEscape();
                    if (ch >= 0 && isIdentifierPart(ch, languageVersion)) {
                        pos += 3;
                        tokenFlags |= 8 /* TokenFlags.ExtendedUnicodeEscape */;
                        result += scanExtendedUnicodeEscape();
                        start = pos;
                        continue;
                    }
                    ch = peekUnicodeEscape();
                    if (!(ch >= 0 && isIdentifierPart(ch, languageVersion))) {
                        break;
                    }
                    tokenFlags |= 1024 /* TokenFlags.UnicodeEscape */;
                    result += text.substring(start, pos);
                    result += utf16EncodeAsString(ch);
                    // Valid Unicode escape is always six characters
                    pos += 6;
                    start = pos;
                }
                else {
                    break;
                }
            }
            result += text.substring(start, pos);
            return result;
        }
        function getIdentifierToken() {
            // Reserved words are between 2 and 12 characters long and start with a lowercase letter
            var len = tokenValue.length;
            if (len >= 2 && len <= 12) {
                var ch = tokenValue.charCodeAt(0);
                if (ch >= 97 /* CharacterCodes.a */ && ch <= 122 /* CharacterCodes.z */) {
                    var keyword = textToKeyword.get(tokenValue);
                    if (keyword !== undefined) {
                        return token = keyword;
                    }
                }
            }
            return token = 79 /* SyntaxKind.Identifier */;
        }
        function scanBinaryOrOctalDigits(base) {
            var value = "";
            // For counting number of digits; Valid binaryIntegerLiteral must have at least one binary digit following B or b.
            // Similarly valid octalIntegerLiteral must have at least one octal digit following o or O.
            var separatorAllowed = false;
            var isPreviousTokenSeparator = false;
            while (true) {
                var ch = text.charCodeAt(pos);
                // Numeric separators are allowed anywhere within a numeric literal, except not at the beginning, or following another separator
                if (ch === 95 /* CharacterCodes._ */) {
                    tokenFlags |= 512 /* TokenFlags.ContainsSeparator */;
                    if (separatorAllowed) {
                        separatorAllowed = false;
                        isPreviousTokenSeparator = true;
                    }
                    else if (isPreviousTokenSeparator) {
                        error(ts.Diagnostics.Multiple_consecutive_numeric_separators_are_not_permitted, pos, 1);
                    }
                    else {
                        error(ts.Diagnostics.Numeric_separators_are_not_allowed_here, pos, 1);
                    }
                    pos++;
                    continue;
                }
                separatorAllowed = true;
                if (!isDigit(ch) || ch - 48 /* CharacterCodes._0 */ >= base) {
                    break;
                }
                value += text[pos];
                pos++;
                isPreviousTokenSeparator = false;
            }
            if (text.charCodeAt(pos - 1) === 95 /* CharacterCodes._ */) {
                // Literal ends with underscore - not allowed
                error(ts.Diagnostics.Numeric_separators_are_not_allowed_here, pos - 1, 1);
            }
            return value;
        }
        function checkBigIntSuffix() {
            if (text.charCodeAt(pos) === 110 /* CharacterCodes.n */) {
                tokenValue += "n";
                // Use base 10 instead of base 2 or base 8 for shorter literals
                if (tokenFlags & 384 /* TokenFlags.BinaryOrOctalSpecifier */) {
                    tokenValue = ts.parsePseudoBigInt(tokenValue) + "n";
                }
                pos++;
                return 9 /* SyntaxKind.BigIntLiteral */;
            }
            else { // not a bigint, so can convert to number in simplified form
                // Number() may not support 0b or 0o, so use parseInt() instead
                var numericValue = tokenFlags & 128 /* TokenFlags.BinarySpecifier */
                    ? parseInt(tokenValue.slice(2), 2) // skip "0b"
                    : tokenFlags & 256 /* TokenFlags.OctalSpecifier */
                        ? parseInt(tokenValue.slice(2), 8) // skip "0o"
                        : +tokenValue;
                tokenValue = "" + numericValue;
                return 8 /* SyntaxKind.NumericLiteral */;
            }
        }
        function scan() {
            var _a;
            startPos = pos;
            tokenFlags = 0 /* TokenFlags.None */;
            var asteriskSeen = false;
            while (true) {
                tokenPos = pos;
                if (pos >= end) {
                    return token = 1 /* SyntaxKind.EndOfFileToken */;
                }
                var ch = codePointAt(text, pos);
                // Special handling for shebang
                if (ch === 35 /* CharacterCodes.hash */ && pos === 0 && isShebangTrivia(text, pos)) {
                    pos = scanShebangTrivia(text, pos);
                    if (skipTrivia) {
                        continue;
                    }
                    else {
                        return token = 6 /* SyntaxKind.ShebangTrivia */;
                    }
                }
                switch (ch) {
                    case 10 /* CharacterCodes.lineFeed */:
                    case 13 /* CharacterCodes.carriageReturn */:
                        tokenFlags |= 1 /* TokenFlags.PrecedingLineBreak */;
                        if (skipTrivia) {
                            pos++;
                            continue;
                        }
                        else {
                            if (ch === 13 /* CharacterCodes.carriageReturn */ && pos + 1 < end && text.charCodeAt(pos + 1) === 10 /* CharacterCodes.lineFeed */) {
                                // consume both CR and LF
                                pos += 2;
                            }
                            else {
                                pos++;
                            }
                            return token = 4 /* SyntaxKind.NewLineTrivia */;
                        }
                    case 9 /* CharacterCodes.tab */:
                    case 11 /* CharacterCodes.verticalTab */:
                    case 12 /* CharacterCodes.formFeed */:
                    case 32 /* CharacterCodes.space */:
                    case 160 /* CharacterCodes.nonBreakingSpace */:
                    case 5760 /* CharacterCodes.ogham */:
                    case 8192 /* CharacterCodes.enQuad */:
                    case 8193 /* CharacterCodes.emQuad */:
                    case 8194 /* CharacterCodes.enSpace */:
                    case 8195 /* CharacterCodes.emSpace */:
                    case 8196 /* CharacterCodes.threePerEmSpace */:
                    case 8197 /* CharacterCodes.fourPerEmSpace */:
                    case 8198 /* CharacterCodes.sixPerEmSpace */:
                    case 8199 /* CharacterCodes.figureSpace */:
                    case 8200 /* CharacterCodes.punctuationSpace */:
                    case 8201 /* CharacterCodes.thinSpace */:
                    case 8202 /* CharacterCodes.hairSpace */:
                    case 8203 /* CharacterCodes.zeroWidthSpace */:
                    case 8239 /* CharacterCodes.narrowNoBreakSpace */:
                    case 8287 /* CharacterCodes.mathematicalSpace */:
                    case 12288 /* CharacterCodes.ideographicSpace */:
                    case 65279 /* CharacterCodes.byteOrderMark */:
                        if (skipTrivia) {
                            pos++;
                            continue;
                        }
                        else {
                            while (pos < end && isWhiteSpaceSingleLine(text.charCodeAt(pos))) {
                                pos++;
                            }
                            return token = 5 /* SyntaxKind.WhitespaceTrivia */;
                        }
                    case 33 /* CharacterCodes.exclamation */:
                        if (text.charCodeAt(pos + 1) === 61 /* CharacterCodes.equals */) {
                            if (text.charCodeAt(pos + 2) === 61 /* CharacterCodes.equals */) {
                                return pos += 3, token = 37 /* SyntaxKind.ExclamationEqualsEqualsToken */;
                            }
                            return pos += 2, token = 35 /* SyntaxKind.ExclamationEqualsToken */;
                        }
                        pos++;
                        return token = 53 /* SyntaxKind.ExclamationToken */;
                    case 34 /* CharacterCodes.doubleQuote */:
                    case 39 /* CharacterCodes.singleQuote */:
                        tokenValue = scanString();
                        return token = 10 /* SyntaxKind.StringLiteral */;
                    case 96 /* CharacterCodes.backtick */:
                        return token = scanTemplateAndSetTokenValue(/* isTaggedTemplate */ false);
                    case 37 /* CharacterCodes.percent */:
                        if (text.charCodeAt(pos + 1) === 61 /* CharacterCodes.equals */) {
                            return pos += 2, token = 69 /* SyntaxKind.PercentEqualsToken */;
                        }
                        pos++;
                        return token = 44 /* SyntaxKind.PercentToken */;
                    case 38 /* CharacterCodes.ampersand */:
                        if (text.charCodeAt(pos + 1) === 38 /* CharacterCodes.ampersand */) {
                            if (text.charCodeAt(pos + 2) === 61 /* CharacterCodes.equals */) {
                                return pos += 3, token = 76 /* SyntaxKind.AmpersandAmpersandEqualsToken */;
                            }
                            return pos += 2, token = 55 /* SyntaxKind.AmpersandAmpersandToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* CharacterCodes.equals */) {
                            return pos += 2, token = 73 /* SyntaxKind.AmpersandEqualsToken */;
                        }
                        pos++;
                        return token = 50 /* SyntaxKind.AmpersandToken */;
                    case 40 /* CharacterCodes.openParen */:
                        pos++;
                        return token = 20 /* SyntaxKind.OpenParenToken */;
                    case 41 /* CharacterCodes.closeParen */:
                        pos++;
                        return token = 21 /* SyntaxKind.CloseParenToken */;
                    case 42 /* CharacterCodes.asterisk */:
                        if (text.charCodeAt(pos + 1) === 61 /* CharacterCodes.equals */) {
                            return pos += 2, token = 66 /* SyntaxKind.AsteriskEqualsToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 42 /* CharacterCodes.asterisk */) {
                            if (text.charCodeAt(pos + 2) === 61 /* CharacterCodes.equals */) {
                                return pos += 3, token = 67 /* SyntaxKind.AsteriskAsteriskEqualsToken */;
                            }
                            return pos += 2, token = 42 /* SyntaxKind.AsteriskAsteriskToken */;
                        }
                        pos++;
                        if (inJSDocType && !asteriskSeen && (tokenFlags & 1 /* TokenFlags.PrecedingLineBreak */)) {
                            // decoration at the start of a JSDoc comment line
                            asteriskSeen = true;
                            continue;
                        }
                        return token = 41 /* SyntaxKind.AsteriskToken */;
                    case 43 /* CharacterCodes.plus */:
                        if (text.charCodeAt(pos + 1) === 43 /* CharacterCodes.plus */) {
                            return pos += 2, token = 45 /* SyntaxKind.PlusPlusToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* CharacterCodes.equals */) {
                            return pos += 2, token = 64 /* SyntaxKind.PlusEqualsToken */;
                        }
                        pos++;
                        return token = 39 /* SyntaxKind.PlusToken */;
                    case 44 /* CharacterCodes.comma */:
                        pos++;
                        return token = 27 /* SyntaxKind.CommaToken */;
                    case 45 /* CharacterCodes.minus */:
                        if (text.charCodeAt(pos + 1) === 45 /* CharacterCodes.minus */) {
                            return pos += 2, token = 46 /* SyntaxKind.MinusMinusToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* CharacterCodes.equals */) {
                            return pos += 2, token = 65 /* SyntaxKind.MinusEqualsToken */;
                        }
                        pos++;
                        return token = 40 /* SyntaxKind.MinusToken */;
                    case 46 /* CharacterCodes.dot */:
                        if (isDigit(text.charCodeAt(pos + 1))) {
                            tokenValue = scanNumber().value;
                            return token = 8 /* SyntaxKind.NumericLiteral */;
                        }
                        if (text.charCodeAt(pos + 1) === 46 /* CharacterCodes.dot */ && text.charCodeAt(pos + 2) === 46 /* CharacterCodes.dot */) {
                            return pos += 3, token = 25 /* SyntaxKind.DotDotDotToken */;
                        }
                        pos++;
                        return token = 24 /* SyntaxKind.DotToken */;
                    case 47 /* CharacterCodes.slash */:
                        // Single-line comment
                        if (text.charCodeAt(pos + 1) === 47 /* CharacterCodes.slash */) {
                            pos += 2;
                            while (pos < end) {
                                if (isLineBreak(text.charCodeAt(pos))) {
                                    break;
                                }
                                pos++;
                            }
                            commentDirectives = appendIfCommentDirective(commentDirectives, text.slice(tokenPos, pos), commentDirectiveRegExSingleLine, tokenPos);
                            if (skipTrivia) {
                                continue;
                            }
                            else {
                                return token = 2 /* SyntaxKind.SingleLineCommentTrivia */;
                            }
                        }
                        // Multi-line comment
                        if (text.charCodeAt(pos + 1) === 42 /* CharacterCodes.asterisk */) {
                            pos += 2;
                            if (text.charCodeAt(pos) === 42 /* CharacterCodes.asterisk */ && text.charCodeAt(pos + 1) !== 47 /* CharacterCodes.slash */) {
                                tokenFlags |= 2 /* TokenFlags.PrecedingJSDocComment */;
                            }
                            var commentClosed = false;
                            var lastLineStart = tokenPos;
                            while (pos < end) {
                                var ch_1 = text.charCodeAt(pos);
                                if (ch_1 === 42 /* CharacterCodes.asterisk */ && text.charCodeAt(pos + 1) === 47 /* CharacterCodes.slash */) {
                                    pos += 2;
                                    commentClosed = true;
                                    break;
                                }
                                pos++;
                                if (isLineBreak(ch_1)) {
                                    lastLineStart = pos;
                                    tokenFlags |= 1 /* TokenFlags.PrecedingLineBreak */;
                                }
                            }
                            commentDirectives = appendIfCommentDirective(commentDirectives, text.slice(lastLineStart, pos), commentDirectiveRegExMultiLine, lastLineStart);
                            if (!commentClosed) {
                                error(ts.Diagnostics.Asterisk_Slash_expected);
                            }
                            if (skipTrivia) {
                                continue;
                            }
                            else {
                                if (!commentClosed) {
                                    tokenFlags |= 4 /* TokenFlags.Unterminated */;
                                }
                                return token = 3 /* SyntaxKind.MultiLineCommentTrivia */;
                            }
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* CharacterCodes.equals */) {
                            return pos += 2, token = 68 /* SyntaxKind.SlashEqualsToken */;
                        }
                        pos++;
                        return token = 43 /* SyntaxKind.SlashToken */;
                    case 48 /* CharacterCodes._0 */:
                        if (pos + 2 < end && (text.charCodeAt(pos + 1) === 88 /* CharacterCodes.X */ || text.charCodeAt(pos + 1) === 120 /* CharacterCodes.x */)) {
                            pos += 2;
                            tokenValue = scanMinimumNumberOfHexDigits(1, /*canHaveSeparators*/ true);
                            if (!tokenValue) {
                                error(ts.Diagnostics.Hexadecimal_digit_expected);
                                tokenValue = "0";
                            }
                            tokenValue = "0x" + tokenValue;
                            tokenFlags |= 64 /* TokenFlags.HexSpecifier */;
                            return token = checkBigIntSuffix();
                        }
                        else if (pos + 2 < end && (text.charCodeAt(pos + 1) === 66 /* CharacterCodes.B */ || text.charCodeAt(pos + 1) === 98 /* CharacterCodes.b */)) {
                            pos += 2;
                            tokenValue = scanBinaryOrOctalDigits(/* base */ 2);
                            if (!tokenValue) {
                                error(ts.Diagnostics.Binary_digit_expected);
                                tokenValue = "0";
                            }
                            tokenValue = "0b" + tokenValue;
                            tokenFlags |= 128 /* TokenFlags.BinarySpecifier */;
                            return token = checkBigIntSuffix();
                        }
                        else if (pos + 2 < end && (text.charCodeAt(pos + 1) === 79 /* CharacterCodes.O */ || text.charCodeAt(pos + 1) === 111 /* CharacterCodes.o */)) {
                            pos += 2;
                            tokenValue = scanBinaryOrOctalDigits(/* base */ 8);
                            if (!tokenValue) {
                                error(ts.Diagnostics.Octal_digit_expected);
                                tokenValue = "0";
                            }
                            tokenValue = "0o" + tokenValue;
                            tokenFlags |= 256 /* TokenFlags.OctalSpecifier */;
                            return token = checkBigIntSuffix();
                        }
                        // Try to parse as an octal
                        if (pos + 1 < end && isOctalDigit(text.charCodeAt(pos + 1))) {
                            tokenValue = "" + scanOctalDigits();
                            tokenFlags |= 32 /* TokenFlags.Octal */;
                            return token = 8 /* SyntaxKind.NumericLiteral */;
                        }
                    // This fall-through is a deviation from the EcmaScript grammar. The grammar says that a leading zero
                    // can only be followed by an octal digit, a dot, or the end of the number literal. However, we are being
                    // permissive and allowing decimal digits of the form 08* and 09* (which many browsers also do).
                    // falls through
                    case 49 /* CharacterCodes._1 */:
                    case 50 /* CharacterCodes._2 */:
                    case 51 /* CharacterCodes._3 */:
                    case 52 /* CharacterCodes._4 */:
                    case 53 /* CharacterCodes._5 */:
                    case 54 /* CharacterCodes._6 */:
                    case 55 /* CharacterCodes._7 */:
                    case 56 /* CharacterCodes._8 */:
                    case 57 /* CharacterCodes._9 */:
                        (_a = scanNumber(), token = _a.type, tokenValue = _a.value);
                        return token;
                    case 58 /* CharacterCodes.colon */:
                        pos++;
                        return token = 58 /* SyntaxKind.ColonToken */;
                    case 59 /* CharacterCodes.semicolon */:
                        pos++;
                        return token = 26 /* SyntaxKind.SemicolonToken */;
                    case 60 /* CharacterCodes.lessThan */:
                        if (isConflictMarkerTrivia(text, pos)) {
                            pos = scanConflictMarkerTrivia(text, pos, error);
                            if (skipTrivia) {
                                continue;
                            }
                            else {
                                return token = 7 /* SyntaxKind.ConflictMarkerTrivia */;
                            }
                        }
                        if (text.charCodeAt(pos + 1) === 60 /* CharacterCodes.lessThan */) {
                            if (text.charCodeAt(pos + 2) === 61 /* CharacterCodes.equals */) {
                                return pos += 3, token = 70 /* SyntaxKind.LessThanLessThanEqualsToken */;
                            }
                            return pos += 2, token = 47 /* SyntaxKind.LessThanLessThanToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* CharacterCodes.equals */) {
                            return pos += 2, token = 32 /* SyntaxKind.LessThanEqualsToken */;
                        }
                        if (languageVariant === 1 /* LanguageVariant.JSX */ &&
                            text.charCodeAt(pos + 1) === 47 /* CharacterCodes.slash */ &&
                            text.charCodeAt(pos + 2) !== 42 /* CharacterCodes.asterisk */) {
                            return pos += 2, token = 30 /* SyntaxKind.LessThanSlashToken */;
                        }
                        pos++;
                        return token = 29 /* SyntaxKind.LessThanToken */;
                    case 61 /* CharacterCodes.equals */:
                        if (isConflictMarkerTrivia(text, pos)) {
                            pos = scanConflictMarkerTrivia(text, pos, error);
                            if (skipTrivia) {
                                continue;
                            }
                            else {
                                return token = 7 /* SyntaxKind.ConflictMarkerTrivia */;
                            }
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* CharacterCodes.equals */) {
                            if (text.charCodeAt(pos + 2) === 61 /* CharacterCodes.equals */) {
                                return pos += 3, token = 36 /* SyntaxKind.EqualsEqualsEqualsToken */;
                            }
                            return pos += 2, token = 34 /* SyntaxKind.EqualsEqualsToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 62 /* CharacterCodes.greaterThan */) {
                            return pos += 2, token = 38 /* SyntaxKind.EqualsGreaterThanToken */;
                        }
                        pos++;
                        return token = 63 /* SyntaxKind.EqualsToken */;
                    case 62 /* CharacterCodes.greaterThan */:
                        if (isConflictMarkerTrivia(text, pos)) {
                            pos = scanConflictMarkerTrivia(text, pos, error);
                            if (skipTrivia) {
                                continue;
                            }
                            else {
                                return token = 7 /* SyntaxKind.ConflictMarkerTrivia */;
                            }
                        }
                        pos++;
                        return token = 31 /* SyntaxKind.GreaterThanToken */;
                    case 63 /* CharacterCodes.question */:
                        if (text.charCodeAt(pos + 1) === 46 /* CharacterCodes.dot */ && !isDigit(text.charCodeAt(pos + 2))) {
                            return pos += 2, token = 28 /* SyntaxKind.QuestionDotToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 63 /* CharacterCodes.question */) {
                            if (text.charCodeAt(pos + 2) === 61 /* CharacterCodes.equals */) {
                                return pos += 3, token = 77 /* SyntaxKind.QuestionQuestionEqualsToken */;
                            }
                            return pos += 2, token = 60 /* SyntaxKind.QuestionQuestionToken */;
                        }
                        pos++;
                        return token = 57 /* SyntaxKind.QuestionToken */;
                    case 91 /* CharacterCodes.openBracket */:
                        pos++;
                        return token = 22 /* SyntaxKind.OpenBracketToken */;
                    case 93 /* CharacterCodes.closeBracket */:
                        pos++;
                        return token = 23 /* SyntaxKind.CloseBracketToken */;
                    case 94 /* CharacterCodes.caret */:
                        if (text.charCodeAt(pos + 1) === 61 /* CharacterCodes.equals */) {
                            return pos += 2, token = 78 /* SyntaxKind.CaretEqualsToken */;
                        }
                        pos++;
                        return token = 52 /* SyntaxKind.CaretToken */;
                    case 123 /* CharacterCodes.openBrace */:
                        pos++;
                        return token = 18 /* SyntaxKind.OpenBraceToken */;
                    case 124 /* CharacterCodes.bar */:
                        if (isConflictMarkerTrivia(text, pos)) {
                            pos = scanConflictMarkerTrivia(text, pos, error);
                            if (skipTrivia) {
                                continue;
                            }
                            else {
                                return token = 7 /* SyntaxKind.ConflictMarkerTrivia */;
                            }
                        }
                        if (text.charCodeAt(pos + 1) === 124 /* CharacterCodes.bar */) {
                            if (text.charCodeAt(pos + 2) === 61 /* CharacterCodes.equals */) {
                                return pos += 3, token = 75 /* SyntaxKind.BarBarEqualsToken */;
                            }
                            return pos += 2, token = 56 /* SyntaxKind.BarBarToken */;
                        }
                        if (text.charCodeAt(pos + 1) === 61 /* CharacterCodes.equals */) {
                            return pos += 2, token = 74 /* SyntaxKind.BarEqualsToken */;
                        }
                        pos++;
                        return token = 51 /* SyntaxKind.BarToken */;
                    case 125 /* CharacterCodes.closeBrace */:
                        pos++;
                        return token = 19 /* SyntaxKind.CloseBraceToken */;
                    case 126 /* CharacterCodes.tilde */:
                        pos++;
                        return token = 54 /* SyntaxKind.TildeToken */;
                    case 64 /* CharacterCodes.at */:
                        pos++;
                        return token = 59 /* SyntaxKind.AtToken */;
                    case 92 /* CharacterCodes.backslash */:
                        var extendedCookedChar = peekExtendedUnicodeEscape();
                        if (extendedCookedChar >= 0 && isIdentifierStart(extendedCookedChar, languageVersion)) {
                            pos += 3;
                            tokenFlags |= 8 /* TokenFlags.ExtendedUnicodeEscape */;
                            tokenValue = scanExtendedUnicodeEscape() + scanIdentifierParts();
                            return token = getIdentifierToken();
                        }
                        var cookedChar = peekUnicodeEscape();
                        if (cookedChar >= 0 && isIdentifierStart(cookedChar, languageVersion)) {
                            pos += 6;
                            tokenFlags |= 1024 /* TokenFlags.UnicodeEscape */;
                            tokenValue = String.fromCharCode(cookedChar) + scanIdentifierParts();
                            return token = getIdentifierToken();
                        }
                        error(ts.Diagnostics.Invalid_character);
                        pos++;
                        return token = 0 /* SyntaxKind.Unknown */;
                    case 35 /* CharacterCodes.hash */:
                        if (pos !== 0 && text[pos + 1] === "!") {
                            error(ts.Diagnostics.can_only_be_used_at_the_start_of_a_file);
                            pos++;
                            return token = 0 /* SyntaxKind.Unknown */;
                        }
                        if (isIdentifierStart(codePointAt(text, pos + 1), languageVersion)) {
                            pos++;
                            scanIdentifier(codePointAt(text, pos), languageVersion);
                        }
                        else {
                            tokenValue = String.fromCharCode(codePointAt(text, pos));
                            error(ts.Diagnostics.Invalid_character, pos++, charSize(ch));
                        }
                        return token = 80 /* SyntaxKind.PrivateIdentifier */;
                    default:
                        var identifierKind = scanIdentifier(ch, languageVersion);
                        if (identifierKind) {
                            return token = identifierKind;
                        }
                        else if (isWhiteSpaceSingleLine(ch)) {
                            pos += charSize(ch);
                            continue;
                        }
                        else if (isLineBreak(ch)) {
                            tokenFlags |= 1 /* TokenFlags.PrecedingLineBreak */;
                            pos += charSize(ch);
                            continue;
                        }
                        var size = charSize(ch);
                        error(ts.Diagnostics.Invalid_character, pos, size);
                        pos += size;
                        return token = 0 /* SyntaxKind.Unknown */;
                }
            }
        }
        function reScanInvalidIdentifier() {
            ts.Debug.assert(token === 0 /* SyntaxKind.Unknown */, "'reScanInvalidIdentifier' should only be called when the current token is 'SyntaxKind.Unknown'.");
            pos = tokenPos = startPos;
            tokenFlags = 0;
            var ch = codePointAt(text, pos);
            var identifierKind = scanIdentifier(ch, 99 /* ScriptTarget.ESNext */);
            if (identifierKind) {
                return token = identifierKind;
            }
            pos += charSize(ch);
            return token; // Still `SyntaKind.Unknown`
        }
        function scanIdentifier(startCharacter, languageVersion) {
            var ch = startCharacter;
            if (isIdentifierStart(ch, languageVersion)) {
                pos += charSize(ch);
                while (pos < end && isIdentifierPart(ch = codePointAt(text, pos), languageVersion))
                    pos += charSize(ch);
                tokenValue = text.substring(tokenPos, pos);
                if (ch === 92 /* CharacterCodes.backslash */) {
                    tokenValue += scanIdentifierParts();
                }
                return getIdentifierToken();
            }
        }
        function reScanGreaterToken() {
            if (token === 31 /* SyntaxKind.GreaterThanToken */) {
                if (text.charCodeAt(pos) === 62 /* CharacterCodes.greaterThan */) {
                    if (text.charCodeAt(pos + 1) === 62 /* CharacterCodes.greaterThan */) {
                        if (text.charCodeAt(pos + 2) === 61 /* CharacterCodes.equals */) {
                            return pos += 3, token = 72 /* SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken */;
                        }
                        return pos += 2, token = 49 /* SyntaxKind.GreaterThanGreaterThanGreaterThanToken */;
                    }
                    if (text.charCodeAt(pos + 1) === 61 /* CharacterCodes.equals */) {
                        return pos += 2, token = 71 /* SyntaxKind.GreaterThanGreaterThanEqualsToken */;
                    }
                    pos++;
                    return token = 48 /* SyntaxKind.GreaterThanGreaterThanToken */;
                }
                if (text.charCodeAt(pos) === 61 /* CharacterCodes.equals */) {
                    pos++;
                    return token = 33 /* SyntaxKind.GreaterThanEqualsToken */;
                }
            }
            return token;
        }
        function reScanAsteriskEqualsToken() {
            ts.Debug.assert(token === 66 /* SyntaxKind.AsteriskEqualsToken */, "'reScanAsteriskEqualsToken' should only be called on a '*='");
            pos = tokenPos + 1;
            return token = 63 /* SyntaxKind.EqualsToken */;
        }
        function reScanSlashToken() {
            if (token === 43 /* SyntaxKind.SlashToken */ || token === 68 /* SyntaxKind.SlashEqualsToken */) {
                var p = tokenPos + 1;
                var inEscape = false;
                var inCharacterClass = false;
                while (true) {
                    // If we reach the end of a file, or hit a newline, then this is an unterminated
                    // regex.  Report error and return what we have so far.
                    if (p >= end) {
                        tokenFlags |= 4 /* TokenFlags.Unterminated */;
                        error(ts.Diagnostics.Unterminated_regular_expression_literal);
                        break;
                    }
                    var ch = text.charCodeAt(p);
                    if (isLineBreak(ch)) {
                        tokenFlags |= 4 /* TokenFlags.Unterminated */;
                        error(ts.Diagnostics.Unterminated_regular_expression_literal);
                        break;
                    }
                    if (inEscape) {
                        // Parsing an escape character;
                        // reset the flag and just advance to the next char.
                        inEscape = false;
                    }
                    else if (ch === 47 /* CharacterCodes.slash */ && !inCharacterClass) {
                        // A slash within a character class is permissible,
                        // but in general it signals the end of the regexp literal.
                        p++;
                        break;
                    }
                    else if (ch === 91 /* CharacterCodes.openBracket */) {
                        inCharacterClass = true;
                    }
                    else if (ch === 92 /* CharacterCodes.backslash */) {
                        inEscape = true;
                    }
                    else if (ch === 93 /* CharacterCodes.closeBracket */) {
                        inCharacterClass = false;
                    }
                    p++;
                }
                while (p < end && isIdentifierPart(text.charCodeAt(p), languageVersion)) {
                    p++;
                }
                pos = p;
                tokenValue = text.substring(tokenPos, pos);
                token = 13 /* SyntaxKind.RegularExpressionLiteral */;
            }
            return token;
        }
        function appendIfCommentDirective(commentDirectives, text, commentDirectiveRegEx, lineStart) {
            var type = getDirectiveFromComment(ts.trimStringStart(text), commentDirectiveRegEx);
            if (type === undefined) {
                return commentDirectives;
            }
            return ts.append(commentDirectives, {
                range: { pos: lineStart, end: pos },
                type: type,
            });
        }
        function getDirectiveFromComment(text, commentDirectiveRegEx) {
            var match = commentDirectiveRegEx.exec(text);
            if (!match) {
                return undefined;
            }
            switch (match[1]) {
                case "ts-expect-error":
                    return 0 /* CommentDirectiveType.ExpectError */;
                case "ts-ignore":
                    return 1 /* CommentDirectiveType.Ignore */;
            }
            return undefined;
        }
        /**
         * Unconditionally back up and scan a template expression portion.
         */
        function reScanTemplateToken(isTaggedTemplate) {
            ts.Debug.assert(token === 19 /* SyntaxKind.CloseBraceToken */, "'reScanTemplateToken' should only be called on a '}'");
            pos = tokenPos;
            return token = scanTemplateAndSetTokenValue(isTaggedTemplate);
        }
        function reScanTemplateHeadOrNoSubstitutionTemplate() {
            pos = tokenPos;
            return token = scanTemplateAndSetTokenValue(/* isTaggedTemplate */ true);
        }
        function reScanJsxToken(allowMultilineJsxText) {
            if (allowMultilineJsxText === void 0) { allowMultilineJsxText = true; }
            pos = tokenPos = startPos;
            return token = scanJsxToken(allowMultilineJsxText);
        }
        function reScanLessThanToken() {
            if (token === 47 /* SyntaxKind.LessThanLessThanToken */) {
                pos = tokenPos + 1;
                return token = 29 /* SyntaxKind.LessThanToken */;
            }
            return token;
        }
        function reScanHashToken() {
            if (token === 80 /* SyntaxKind.PrivateIdentifier */) {
                pos = tokenPos + 1;
                return token = 62 /* SyntaxKind.HashToken */;
            }
            return token;
        }
        function reScanQuestionToken() {
            ts.Debug.assert(token === 60 /* SyntaxKind.QuestionQuestionToken */, "'reScanQuestionToken' should only be called on a '??'");
            pos = tokenPos + 1;
            return token = 57 /* SyntaxKind.QuestionToken */;
        }
        function scanJsxToken(allowMultilineJsxText) {
            if (allowMultilineJsxText === void 0) { allowMultilineJsxText = true; }
            startPos = tokenPos = pos;
            if (pos >= end) {
                return token = 1 /* SyntaxKind.EndOfFileToken */;
            }
            var char = text.charCodeAt(pos);
            if (char === 60 /* CharacterCodes.lessThan */) {
                if (text.charCodeAt(pos + 1) === 47 /* CharacterCodes.slash */) {
                    pos += 2;
                    return token = 30 /* SyntaxKind.LessThanSlashToken */;
                }
                pos++;
                return token = 29 /* SyntaxKind.LessThanToken */;
            }
            if (char === 123 /* CharacterCodes.openBrace */) {
                pos++;
                return token = 18 /* SyntaxKind.OpenBraceToken */;
            }
            // First non-whitespace character on this line.
            var firstNonWhitespace = 0;
            // These initial values are special because the first line is:
            // firstNonWhitespace = 0 to indicate that we want leading whitespace,
            while (pos < end) {
                char = text.charCodeAt(pos);
                if (char === 123 /* CharacterCodes.openBrace */) {
                    break;
                }
                if (char === 60 /* CharacterCodes.lessThan */) {
                    if (isConflictMarkerTrivia(text, pos)) {
                        pos = scanConflictMarkerTrivia(text, pos, error);
                        return token = 7 /* SyntaxKind.ConflictMarkerTrivia */;
                    }
                    break;
                }
                if (char === 62 /* CharacterCodes.greaterThan */) {
                    error(ts.Diagnostics.Unexpected_token_Did_you_mean_or_gt, pos, 1);
                }
                if (char === 125 /* CharacterCodes.closeBrace */) {
                    error(ts.Diagnostics.Unexpected_token_Did_you_mean_or_rbrace, pos, 1);
                }
                // FirstNonWhitespace is 0, then we only see whitespaces so far. If we see a linebreak, we want to ignore that whitespaces.
                // i.e (- : whitespace)
                //      <div>----
                //      </div> becomes <div></div>
                //
                //      <div>----</div> becomes <div>----</div>
                if (isLineBreak(char) && firstNonWhitespace === 0) {
                    firstNonWhitespace = -1;
                }
                else if (!allowMultilineJsxText && isLineBreak(char) && firstNonWhitespace > 0) {
                    // Stop JsxText on each line during formatting. This allows the formatter to
                    // indent each line correctly.
                    break;
                }
                else if (!isWhiteSpaceLike(char)) {
                    firstNonWhitespace = pos;
                }
                pos++;
            }
            tokenValue = text.substring(startPos, pos);
            return firstNonWhitespace === -1 ? 12 /* SyntaxKind.JsxTextAllWhiteSpaces */ : 11 /* SyntaxKind.JsxText */;
        }
        // Scans a JSX identifier; these differ from normal identifiers in that
        // they allow dashes
        function scanJsxIdentifier() {
            if (tokenIsIdentifierOrKeyword(token)) {
                // An identifier or keyword has already been parsed - check for a `-` or a single instance of `:` and then append it and
                // everything after it to the token
                // Do note that this means that `scanJsxIdentifier` effectively _mutates_ the visible token without advancing to a new token
                // Any caller should be expecting this behavior and should only read the pos or token value after calling it.
                var namespaceSeparator = false;
                while (pos < end) {
                    var ch = text.charCodeAt(pos);
                    if (ch === 45 /* CharacterCodes.minus */) {
                        tokenValue += "-";
                        pos++;
                        continue;
                    }
                    else if (ch === 58 /* CharacterCodes.colon */ && !namespaceSeparator) {
                        tokenValue += ":";
                        pos++;
                        namespaceSeparator = true;
                        token = 79 /* SyntaxKind.Identifier */; // swap from keyword kind to identifier kind
                        continue;
                    }
                    var oldPos = pos;
                    tokenValue += scanIdentifierParts(); // reuse `scanIdentifierParts` so unicode escapes are handled
                    if (pos === oldPos) {
                        break;
                    }
                }
                // Do not include a trailing namespace separator in the token, since this is against the spec.
                if (tokenValue.slice(-1) === ":") {
                    tokenValue = tokenValue.slice(0, -1);
                    pos--;
                }
                return getIdentifierToken();
            }
            return token;
        }
        function scanJsxAttributeValue() {
            startPos = pos;
            switch (text.charCodeAt(pos)) {
                case 34 /* CharacterCodes.doubleQuote */:
                case 39 /* CharacterCodes.singleQuote */:
                    tokenValue = scanString(/*jsxAttributeString*/ true);
                    return token = 10 /* SyntaxKind.StringLiteral */;
                default:
                    // If this scans anything other than `{`, it's a parse error.
                    return scan();
            }
        }
        function reScanJsxAttributeValue() {
            pos = tokenPos = startPos;
            return scanJsxAttributeValue();
        }
        function scanJsDocToken() {
            startPos = tokenPos = pos;
            tokenFlags = 0 /* TokenFlags.None */;
            if (pos >= end) {
                return token = 1 /* SyntaxKind.EndOfFileToken */;
            }
            var ch = codePointAt(text, pos);
            pos += charSize(ch);
            switch (ch) {
                case 9 /* CharacterCodes.tab */:
                case 11 /* CharacterCodes.verticalTab */:
                case 12 /* CharacterCodes.formFeed */:
                case 32 /* CharacterCodes.space */:
                    while (pos < end && isWhiteSpaceSingleLine(text.charCodeAt(pos))) {
                        pos++;
                    }
                    return token = 5 /* SyntaxKind.WhitespaceTrivia */;
                case 64 /* CharacterCodes.at */:
                    return token = 59 /* SyntaxKind.AtToken */;
                case 13 /* CharacterCodes.carriageReturn */:
                    if (text.charCodeAt(pos) === 10 /* CharacterCodes.lineFeed */) {
                        pos++;
                    }
                // falls through
                case 10 /* CharacterCodes.lineFeed */:
                    tokenFlags |= 1 /* TokenFlags.PrecedingLineBreak */;
                    return token = 4 /* SyntaxKind.NewLineTrivia */;
                case 42 /* CharacterCodes.asterisk */:
                    return token = 41 /* SyntaxKind.AsteriskToken */;
                case 123 /* CharacterCodes.openBrace */:
                    return token = 18 /* SyntaxKind.OpenBraceToken */;
                case 125 /* CharacterCodes.closeBrace */:
                    return token = 19 /* SyntaxKind.CloseBraceToken */;
                case 91 /* CharacterCodes.openBracket */:
                    return token = 22 /* SyntaxKind.OpenBracketToken */;
                case 93 /* CharacterCodes.closeBracket */:
                    return token = 23 /* SyntaxKind.CloseBracketToken */;
                case 60 /* CharacterCodes.lessThan */:
                    return token = 29 /* SyntaxKind.LessThanToken */;
                case 62 /* CharacterCodes.greaterThan */:
                    return token = 31 /* SyntaxKind.GreaterThanToken */;
                case 61 /* CharacterCodes.equals */:
                    return token = 63 /* SyntaxKind.EqualsToken */;
                case 44 /* CharacterCodes.comma */:
                    return token = 27 /* SyntaxKind.CommaToken */;
                case 46 /* CharacterCodes.dot */:
                    return token = 24 /* SyntaxKind.DotToken */;
                case 96 /* CharacterCodes.backtick */:
                    return token = 61 /* SyntaxKind.BacktickToken */;
                case 35 /* CharacterCodes.hash */:
                    return token = 62 /* SyntaxKind.HashToken */;
                case 92 /* CharacterCodes.backslash */:
                    pos--;
                    var extendedCookedChar = peekExtendedUnicodeEscape();
                    if (extendedCookedChar >= 0 && isIdentifierStart(extendedCookedChar, languageVersion)) {
                        pos += 3;
                        tokenFlags |= 8 /* TokenFlags.ExtendedUnicodeEscape */;
                        tokenValue = scanExtendedUnicodeEscape() + scanIdentifierParts();
                        return token = getIdentifierToken();
                    }
                    var cookedChar = peekUnicodeEscape();
                    if (cookedChar >= 0 && isIdentifierStart(cookedChar, languageVersion)) {
                        pos += 6;
                        tokenFlags |= 1024 /* TokenFlags.UnicodeEscape */;
                        tokenValue = String.fromCharCode(cookedChar) + scanIdentifierParts();
                        return token = getIdentifierToken();
                    }
                    pos++;
                    return token = 0 /* SyntaxKind.Unknown */;
            }
            if (isIdentifierStart(ch, languageVersion)) {
                var char = ch;
                while (pos < end && isIdentifierPart(char = codePointAt(text, pos), languageVersion) || text.charCodeAt(pos) === 45 /* CharacterCodes.minus */)
                    pos += charSize(char);
                tokenValue = text.substring(tokenPos, pos);
                if (char === 92 /* CharacterCodes.backslash */) {
                    tokenValue += scanIdentifierParts();
                }
                return token = getIdentifierToken();
            }
            else {
                return token = 0 /* SyntaxKind.Unknown */;
            }
        }
        function speculationHelper(callback, isLookahead) {
            var savePos = pos;
            var saveStartPos = startPos;
            var saveTokenPos = tokenPos;
            var saveToken = token;
            var saveTokenValue = tokenValue;
            var saveTokenFlags = tokenFlags;
            var result = callback();
            // If our callback returned something 'falsy' or we're just looking ahead,
            // then unconditionally restore us to where we were.
            if (!result || isLookahead) {
                pos = savePos;
                startPos = saveStartPos;
                tokenPos = saveTokenPos;
                token = saveToken;
                tokenValue = saveTokenValue;
                tokenFlags = saveTokenFlags;
            }
            return result;
        }
        function scanRange(start, length, callback) {
            var saveEnd = end;
            var savePos = pos;
            var saveStartPos = startPos;
            var saveTokenPos = tokenPos;
            var saveToken = token;
            var saveTokenValue = tokenValue;
            var saveTokenFlags = tokenFlags;
            var saveErrorExpectations = commentDirectives;
            setText(text, start, length);
            var result = callback();
            end = saveEnd;
            pos = savePos;
            startPos = saveStartPos;
            tokenPos = saveTokenPos;
            token = saveToken;
            tokenValue = saveTokenValue;
            tokenFlags = saveTokenFlags;
            commentDirectives = saveErrorExpectations;
            return result;
        }
        function lookAhead(callback) {
            return speculationHelper(callback, /*isLookahead*/ true);
        }
        function tryScan(callback) {
            return speculationHelper(callback, /*isLookahead*/ false);
        }
        function getText() {
            return text;
        }
        function clearCommentDirectives() {
            commentDirectives = undefined;
        }
        function setText(newText, start, length) {
            text = newText || "";
            end = length === undefined ? text.length : start + length;
            setTextPos(start || 0);
        }
        function setOnError(errorCallback) {
            onError = errorCallback;
        }
        function setScriptTarget(scriptTarget) {
            languageVersion = scriptTarget;
        }
        function setLanguageVariant(variant) {
            languageVariant = variant;
        }
        function setTextPos(textPos) {
            ts.Debug.assert(textPos >= 0);
            pos = textPos;
            startPos = textPos;
            tokenPos = textPos;
            token = 0 /* SyntaxKind.Unknown */;
            tokenValue = undefined;
            tokenFlags = 0 /* TokenFlags.None */;
        }
        function setInJSDocType(inType) {
            inJSDocType += inType ? 1 : -1;
        }
    }
    ts.createScanner = createScanner;
    /* @internal */
    var codePointAt = String.prototype.codePointAt ? function (s, i) { return s.codePointAt(i); } : function codePointAt(str, i) {
        // from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt
        var size = str.length;
        // Account for out-of-bounds indices:
        if (i < 0 || i >= size) {
            return undefined; // String.codePointAt returns `undefined` for OOB indexes
        }
        // Get the first code unit
        var first = str.charCodeAt(i);
        // check if its the start of a surrogate pair
        if (first >= 0xD800 && first <= 0xDBFF && size > i + 1) { // high surrogate and there is a next code unit
            var second = str.charCodeAt(i + 1);
            if (second >= 0xDC00 && second <= 0xDFFF) { // low surrogate
                // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
                return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
            }
        }
        return first;
    };
    /* @internal */
    function charSize(ch) {
        if (ch >= 0x10000) {
            return 2;
        }
        return 1;
    }
    // Derived from the 10.1.1 UTF16Encoding of the ES6 Spec.
    function utf16EncodeAsStringFallback(codePoint) {
        ts.Debug.assert(0x0 <= codePoint && codePoint <= 0x10FFFF);
        if (codePoint <= 65535) {
            return String.fromCharCode(codePoint);
        }
        var codeUnit1 = Math.floor((codePoint - 65536) / 1024) + 0xD800;
        var codeUnit2 = ((codePoint - 65536) % 1024) + 0xDC00;
        return String.fromCharCode(codeUnit1, codeUnit2);
    }
    var utf16EncodeAsStringWorker = String.fromCodePoint ? function (codePoint) { return String.fromCodePoint(codePoint); } : utf16EncodeAsStringFallback;
    /* @internal */
    function utf16EncodeAsString(codePoint) {
        return utf16EncodeAsStringWorker(codePoint);
    }
    ts.utf16EncodeAsString = utf16EncodeAsString;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function isExternalModuleNameRelative(moduleName) {
        // TypeScript 1.0 spec (April 2014): 11.2.1
        // An external module name is "relative" if the first term is "." or "..".
        // Update: We also consider a path like `C:\foo.ts` "relative" because we do not search for it in `node_modules` or treat it as an ambient module.
        return ts.pathIsRelative(moduleName) || ts.isRootedDiskPath(moduleName);
    }
    ts.isExternalModuleNameRelative = isExternalModuleNameRelative;
    function sortAndDeduplicateDiagnostics(diagnostics) {
        return ts.sortAndDeduplicate(diagnostics, ts.compareDiagnostics);
    }
    ts.sortAndDeduplicateDiagnostics = sortAndDeduplicateDiagnostics;
    function getDefaultLibFileName(options) {
        switch (ts.getEmitScriptTarget(options)) {
            case 99 /* ScriptTarget.ESNext */:
                return "lib.esnext.full.d.ts";
            case 9 /* ScriptTarget.ES2022 */:
                return "lib.es2022.full.d.ts";
            case 8 /* ScriptTarget.ES2021 */:
                return "lib.es2021.full.d.ts";
            case 7 /* ScriptTarget.ES2020 */:
                return "lib.es2020.full.d.ts";
            case 6 /* ScriptTarget.ES2019 */:
                return "lib.es2019.full.d.ts";
            case 5 /* ScriptTarget.ES2018 */:
                return "lib.es2018.full.d.ts";
            case 4 /* ScriptTarget.ES2017 */:
                return "lib.es2017.full.d.ts";
            case 3 /* ScriptTarget.ES2016 */:
                return "lib.es2016.full.d.ts";
            case 2 /* ScriptTarget.ES2015 */:
                return "lib.es6.d.ts"; // We don't use lib.es2015.full.d.ts due to breaking change.
            default:
                return "lib.d.ts";
        }
    }
    ts.getDefaultLibFileName = getDefaultLibFileName;
    function textSpanEnd(span) {
        return span.start + span.length;
    }
    ts.textSpanEnd = textSpanEnd;
    function textSpanIsEmpty(span) {
        return span.length === 0;
    }
    ts.textSpanIsEmpty = textSpanIsEmpty;
    function textSpanContainsPosition(span, position) {
        return position >= span.start && position < textSpanEnd(span);
    }
    ts.textSpanContainsPosition = textSpanContainsPosition;
    /* @internal */
    function textRangeContainsPositionInclusive(span, position) {
        return position >= span.pos && position <= span.end;
    }
    ts.textRangeContainsPositionInclusive = textRangeContainsPositionInclusive;
    // Returns true if 'span' contains 'other'.
    function textSpanContainsTextSpan(span, other) {
        return other.start >= span.start && textSpanEnd(other) <= textSpanEnd(span);
    }
    ts.textSpanContainsTextSpan = textSpanContainsTextSpan;
    function textSpanOverlapsWith(span, other) {
        return textSpanOverlap(span, other) !== undefined;
    }
    ts.textSpanOverlapsWith = textSpanOverlapsWith;
    function textSpanOverlap(span1, span2) {
        var overlap = textSpanIntersection(span1, span2);
        return overlap && overlap.length === 0 ? undefined : overlap;
    }
    ts.textSpanOverlap = textSpanOverlap;
    function textSpanIntersectsWithTextSpan(span, other) {
        return decodedTextSpanIntersectsWith(span.start, span.length, other.start, other.length);
    }
    ts.textSpanIntersectsWithTextSpan = textSpanIntersectsWithTextSpan;
    function textSpanIntersectsWith(span, start, length) {
        return decodedTextSpanIntersectsWith(span.start, span.length, start, length);
    }
    ts.textSpanIntersectsWith = textSpanIntersectsWith;
    function decodedTextSpanIntersectsWith(start1, length1, start2, length2) {
        var end1 = start1 + length1;
        var end2 = start2 + length2;
        return start2 <= end1 && end2 >= start1;
    }
    ts.decodedTextSpanIntersectsWith = decodedTextSpanIntersectsWith;
    function textSpanIntersectsWithPosition(span, position) {
        return position <= textSpanEnd(span) && position >= span.start;
    }
    ts.textSpanIntersectsWithPosition = textSpanIntersectsWithPosition;
    function textSpanIntersection(span1, span2) {
        var start = Math.max(span1.start, span2.start);
        var end = Math.min(textSpanEnd(span1), textSpanEnd(span2));
        return start <= end ? createTextSpanFromBounds(start, end) : undefined;
    }
    ts.textSpanIntersection = textSpanIntersection;
    function createTextSpan(start, length) {
        if (start < 0) {
            throw new Error("start < 0");
        }
        if (length < 0) {
            throw new Error("length < 0");
        }
        return { start: start, length: length };
    }
    ts.createTextSpan = createTextSpan;
    function createTextSpanFromBounds(start, end) {
        return createTextSpan(start, end - start);
    }
    ts.createTextSpanFromBounds = createTextSpanFromBounds;
    function textChangeRangeNewSpan(range) {
        return createTextSpan(range.span.start, range.newLength);
    }
    ts.textChangeRangeNewSpan = textChangeRangeNewSpan;
    function textChangeRangeIsUnchanged(range) {
        return textSpanIsEmpty(range.span) && range.newLength === 0;
    }
    ts.textChangeRangeIsUnchanged = textChangeRangeIsUnchanged;
    function createTextChangeRange(span, newLength) {
        if (newLength < 0) {
            throw new Error("newLength < 0");
        }
        return { span: span, newLength: newLength };
    }
    ts.createTextChangeRange = createTextChangeRange;
    ts.unchangedTextChangeRange = createTextChangeRange(createTextSpan(0, 0), 0); // eslint-disable-line prefer-const
    /**
     * Called to merge all the changes that occurred across several versions of a script snapshot
     * into a single change.  i.e. if a user keeps making successive edits to a script we will
     * have a text change from V1 to V2, V2 to V3, ..., Vn.
     *
     * This function will then merge those changes into a single change range valid between V1 and
     * Vn.
     */
    function collapseTextChangeRangesAcrossMultipleVersions(changes) {
        if (changes.length === 0) {
            return ts.unchangedTextChangeRange;
        }
        if (changes.length === 1) {
            return changes[0];
        }
        // We change from talking about { { oldStart, oldLength }, newLength } to { oldStart, oldEnd, newEnd }
        // as it makes things much easier to reason about.
        var change0 = changes[0];
        var oldStartN = change0.span.start;
        var oldEndN = textSpanEnd(change0.span);
        var newEndN = oldStartN + change0.newLength;
        for (var i = 1; i < changes.length; i++) {
            var nextChange = changes[i];
            // Consider the following case:
            // i.e. two edits.  The first represents the text change range { { 10, 50 }, 30 }.  i.e. The span starting
            // at 10, with length 50 is reduced to length 30.  The second represents the text change range { { 30, 30 }, 40 }.
            // i.e. the span starting at 30 with length 30 is increased to length 40.
            //
            //      0         10        20        30        40        50        60        70        80        90        100
            //      -------------------------------------------------------------------------------------------------------
            //                |                                                 /
            //                |                                            /----
            //  T1            |                                       /----
            //                |                                  /----
            //                |                             /----
            //      -------------------------------------------------------------------------------------------------------
            //                                     |                            \
            //                                     |                               \
            //   T2                                |                                 \
            //                                     |                                   \
            //                                     |                                      \
            //      -------------------------------------------------------------------------------------------------------
            //
            // Merging these turns out to not be too difficult.  First, determining the new start of the change is trivial
            // it's just the min of the old and new starts.  i.e.:
            //
            //      0         10        20        30        40        50        60        70        80        90        100
            //      ------------------------------------------------------------*------------------------------------------
            //                |                                                 /
            //                |                                            /----
            //  T1            |                                       /----
            //                |                                  /----
            //                |                             /----
            //      ----------------------------------------$-------------------$------------------------------------------
            //                .                    |                            \
            //                .                    |                               \
            //   T2           .                    |                                 \
            //                .                    |                                   \
            //                .                    |                                      \
            //      ----------------------------------------------------------------------*--------------------------------
            //
            // (Note the dots represent the newly inferred start.
            // Determining the new and old end is also pretty simple.  Basically it boils down to paying attention to the
            // absolute positions at the asterisks, and the relative change between the dollar signs. Basically, we see
            // which if the two $'s precedes the other, and we move that one forward until they line up.  in this case that
            // means:
            //
            //      0         10        20        30        40        50        60        70        80        90        100
            //      --------------------------------------------------------------------------------*----------------------
            //                |                                                                     /
            //                |                                                                /----
            //  T1            |                                                           /----
            //                |                                                      /----
            //                |                                                 /----
            //      ------------------------------------------------------------$------------------------------------------
            //                .                    |                            \
            //                .                    |                               \
            //   T2           .                    |                                 \
            //                .                    |                                   \
            //                .                    |                                      \
            //      ----------------------------------------------------------------------*--------------------------------
            //
            // In other words (in this case), we're recognizing that the second edit happened after where the first edit
            // ended with a delta of 20 characters (60 - 40).  Thus, if we go back in time to where the first edit started
            // that's the same as if we started at char 80 instead of 60.
            //
            // As it so happens, the same logic applies if the second edit precedes the first edit.  In that case rather
            // than pushing the first edit forward to match the second, we'll push the second edit forward to match the
            // first.
            //
            // In this case that means we have { oldStart: 10, oldEnd: 80, newEnd: 70 } or, in TextChangeRange
            // semantics: { { start: 10, length: 70 }, newLength: 60 }
            //
            // The math then works out as follows.
            // If we have { oldStart1, oldEnd1, newEnd1 } and { oldStart2, oldEnd2, newEnd2 } then we can compute the
            // final result like so:
            //
            // {
            //      oldStart3: Min(oldStart1, oldStart2),
            //      oldEnd3: Max(oldEnd1, oldEnd1 + (oldEnd2 - newEnd1)),
            //      newEnd3: Max(newEnd2, newEnd2 + (newEnd1 - oldEnd2))
            // }
            var oldStart1 = oldStartN;
            var oldEnd1 = oldEndN;
            var newEnd1 = newEndN;
            var oldStart2 = nextChange.span.start;
            var oldEnd2 = textSpanEnd(nextChange.span);
            var newEnd2 = oldStart2 + nextChange.newLength;
            oldStartN = Math.min(oldStart1, oldStart2);
            oldEndN = Math.max(oldEnd1, oldEnd1 + (oldEnd2 - newEnd1));
            newEndN = Math.max(newEnd2, newEnd2 + (newEnd1 - oldEnd2));
        }
        return createTextChangeRange(createTextSpanFromBounds(oldStartN, oldEndN), /*newLength*/ newEndN - oldStartN);
    }
    ts.collapseTextChangeRangesAcrossMultipleVersions = collapseTextChangeRangesAcrossMultipleVersions;
    function getTypeParameterOwner(d) {
        if (d && d.kind === 163 /* SyntaxKind.TypeParameter */) {
            for (var current = d; current; current = current.parent) {
                if (isFunctionLike(current) || isClassLike(current) || current.kind === 258 /* SyntaxKind.InterfaceDeclaration */) {
                    return current;
                }
            }
        }
    }
    ts.getTypeParameterOwner = getTypeParameterOwner;
    function isParameterPropertyDeclaration(node, parent) {
        return ts.hasSyntacticModifier(node, 16476 /* ModifierFlags.ParameterPropertyModifier */) && parent.kind === 171 /* SyntaxKind.Constructor */;
    }
    ts.isParameterPropertyDeclaration = isParameterPropertyDeclaration;
    function isEmptyBindingPattern(node) {
        if (isBindingPattern(node)) {
            return ts.every(node.elements, isEmptyBindingElement);
        }
        return false;
    }
    ts.isEmptyBindingPattern = isEmptyBindingPattern;
    function isEmptyBindingElement(node) {
        if (ts.isOmittedExpression(node)) {
            return true;
        }
        return isEmptyBindingPattern(node.name);
    }
    ts.isEmptyBindingElement = isEmptyBindingElement;
    function walkUpBindingElementsAndPatterns(binding) {
        var node = binding.parent;
        while (ts.isBindingElement(node.parent)) {
            node = node.parent.parent;
        }
        return node.parent;
    }
    ts.walkUpBindingElementsAndPatterns = walkUpBindingElementsAndPatterns;
    function getCombinedFlags(node, getFlags) {
        if (ts.isBindingElement(node)) {
            node = walkUpBindingElementsAndPatterns(node);
        }
        var flags = getFlags(node);
        if (node.kind === 254 /* SyntaxKind.VariableDeclaration */) {
            node = node.parent;
        }
        if (node && node.kind === 255 /* SyntaxKind.VariableDeclarationList */) {
            flags |= getFlags(node);
            node = node.parent;
        }
        if (node && node.kind === 237 /* SyntaxKind.VariableStatement */) {
            flags |= getFlags(node);
        }
        return flags;
    }
    function getCombinedModifierFlags(node) {
        return getCombinedFlags(node, ts.getEffectiveModifierFlags);
    }
    ts.getCombinedModifierFlags = getCombinedModifierFlags;
    /* @internal */
    function getCombinedNodeFlagsAlwaysIncludeJSDoc(node) {
        return getCombinedFlags(node, ts.getEffectiveModifierFlagsAlwaysIncludeJSDoc);
    }
    ts.getCombinedNodeFlagsAlwaysIncludeJSDoc = getCombinedNodeFlagsAlwaysIncludeJSDoc;
    // Returns the node flags for this node and all relevant parent nodes.  This is done so that
    // nodes like variable declarations and binding elements can returned a view of their flags
    // that includes the modifiers from their container.  i.e. flags like export/declare aren't
    // stored on the variable declaration directly, but on the containing variable statement
    // (if it has one).  Similarly, flags for let/const are stored on the variable declaration
    // list.  By calling this function, all those flags are combined so that the client can treat
    // the node as if it actually had those flags.
    function getCombinedNodeFlags(node) {
        return getCombinedFlags(node, function (n) { return n.flags; });
    }
    ts.getCombinedNodeFlags = getCombinedNodeFlags;
    /* @internal */
    ts.supportedLocaleDirectories = ["cs", "de", "es", "fr", "it", "ja", "ko", "pl", "pt-br", "ru", "tr", "zh-cn", "zh-tw"];
    /**
     * Checks to see if the locale is in the appropriate format,
     * and if it is, attempts to set the appropriate language.
     */
    function validateLocaleAndSetLanguage(locale, sys, errors) {
        var lowerCaseLocale = locale.toLowerCase();
        var matchResult = /^([a-z]+)([_\-]([a-z]+))?$/.exec(lowerCaseLocale);
        if (!matchResult) {
            if (errors) {
                errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1, "en", "ja-jp"));
            }
            return;
        }
        var language = matchResult[1];
        var territory = matchResult[3];
        // First try the entire locale, then fall back to just language if that's all we have.
        // Either ways do not fail, and fallback to the English diagnostic strings.
        if (ts.contains(ts.supportedLocaleDirectories, lowerCaseLocale) && !trySetLanguageAndTerritory(language, territory, errors)) {
            trySetLanguageAndTerritory(language, /*territory*/ undefined, errors);
        }
        // Set the UI locale for string collation
        ts.setUILocale(locale);
        function trySetLanguageAndTerritory(language, territory, errors) {
            var compilerFilePath = ts.normalizePath(sys.getExecutingFilePath());
            var containingDirectoryPath = ts.getDirectoryPath(compilerFilePath);
            var filePath = ts.combinePaths(containingDirectoryPath, language);
            if (territory) {
                filePath = filePath + "-" + territory;
            }
            filePath = sys.resolvePath(ts.combinePaths(filePath, "diagnosticMessages.generated.json"));
            if (!sys.fileExists(filePath)) {
                return false;
            }
            // TODO: Add codePage support for readFile?
            var fileContents = "";
            try {
                fileContents = sys.readFile(filePath);
            }
            catch (e) {
                if (errors) {
                    errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Unable_to_open_file_0, filePath));
                }
                return false;
            }
            try {
                // this is a global mutation (or live binding update)!
                ts.setLocalizedDiagnosticMessages(JSON.parse(fileContents));
            }
            catch (_a) {
                if (errors) {
                    errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Corrupted_locale_file_0, filePath));
                }
                return false;
            }
            return true;
        }
    }
    ts.validateLocaleAndSetLanguage = validateLocaleAndSetLanguage;
    function getOriginalNode(node, nodeTest) {
        if (node) {
            while (node.original !== undefined) {
                node = node.original;
            }
        }
        return !nodeTest || nodeTest(node) ? node : undefined;
    }
    ts.getOriginalNode = getOriginalNode;
    function findAncestor(node, callback) {
        while (node) {
            var result = callback(node);
            if (result === "quit") {
                return undefined;
            }
            else if (result) {
                return node;
            }
            node = node.parent;
        }
        return undefined;
    }
    ts.findAncestor = findAncestor;
    /**
     * Gets a value indicating whether a node originated in the parse tree.
     *
     * @param node The node to test.
     */
    function isParseTreeNode(node) {
        return (node.flags & 8 /* NodeFlags.Synthesized */) === 0;
    }
    ts.isParseTreeNode = isParseTreeNode;
    function getParseTreeNode(node, nodeTest) {
        if (node === undefined || isParseTreeNode(node)) {
            return node;
        }
        node = node.original;
        while (node) {
            if (isParseTreeNode(node)) {
                return !nodeTest || nodeTest(node) ? node : undefined;
            }
            node = node.original;
        }
    }
    ts.getParseTreeNode = getParseTreeNode;
    /** Add an extra underscore to identifiers that start with two underscores to avoid issues with magic names like '__proto__' */
    function escapeLeadingUnderscores(identifier) {
        return (identifier.length >= 2 && identifier.charCodeAt(0) === 95 /* CharacterCodes._ */ && identifier.charCodeAt(1) === 95 /* CharacterCodes._ */ ? "_" + identifier : identifier);
    }
    ts.escapeLeadingUnderscores = escapeLeadingUnderscores;
    /**
     * Remove extra underscore from escaped identifier text content.
     *
     * @param identifier The escaped identifier text.
     * @returns The unescaped identifier text.
     */
    function unescapeLeadingUnderscores(identifier) {
        var id = identifier;
        return id.length >= 3 && id.charCodeAt(0) === 95 /* CharacterCodes._ */ && id.charCodeAt(1) === 95 /* CharacterCodes._ */ && id.charCodeAt(2) === 95 /* CharacterCodes._ */ ? id.substr(1) : id;
    }
    ts.unescapeLeadingUnderscores = unescapeLeadingUnderscores;
    function idText(identifierOrPrivateName) {
        return unescapeLeadingUnderscores(identifierOrPrivateName.escapedText);
    }
    ts.idText = idText;
    function symbolName(symbol) {
        if (symbol.valueDeclaration && isPrivateIdentifierClassElementDeclaration(symbol.valueDeclaration)) {
            return idText(symbol.valueDeclaration.name);
        }
        return unescapeLeadingUnderscores(symbol.escapedName);
    }
    ts.symbolName = symbolName;
    /**
     * A JSDocTypedef tag has an _optional_ name field - if a name is not directly present, we should
     * attempt to draw the name from the node the declaration is on (as that declaration is what its' symbol
     * will be merged with)
     */
    function nameForNamelessJSDocTypedef(declaration) {
        var hostNode = declaration.parent.parent;
        if (!hostNode) {
            return undefined;
        }
        // Covers classes, functions - any named declaration host node
        if (isDeclaration(hostNode)) {
            return getDeclarationIdentifier(hostNode);
        }
        // Covers remaining cases (returning undefined if none match).
        switch (hostNode.kind) {
            case 237 /* SyntaxKind.VariableStatement */:
                if (hostNode.declarationList && hostNode.declarationList.declarations[0]) {
                    return getDeclarationIdentifier(hostNode.declarationList.declarations[0]);
                }
                break;
            case 238 /* SyntaxKind.ExpressionStatement */:
                var expr = hostNode.expression;
                if (expr.kind === 221 /* SyntaxKind.BinaryExpression */ && expr.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */) {
                    expr = expr.left;
                }
                switch (expr.kind) {
                    case 206 /* SyntaxKind.PropertyAccessExpression */:
                        return expr.name;
                    case 207 /* SyntaxKind.ElementAccessExpression */:
                        var arg = expr.argumentExpression;
                        if (ts.isIdentifier(arg)) {
                            return arg;
                        }
                }
                break;
            case 212 /* SyntaxKind.ParenthesizedExpression */: {
                return getDeclarationIdentifier(hostNode.expression);
            }
            case 250 /* SyntaxKind.LabeledStatement */: {
                if (isDeclaration(hostNode.statement) || isExpression(hostNode.statement)) {
                    return getDeclarationIdentifier(hostNode.statement);
                }
                break;
            }
        }
    }
    function getDeclarationIdentifier(node) {
        var name = getNameOfDeclaration(node);
        return name && ts.isIdentifier(name) ? name : undefined;
    }
    /** @internal */
    function nodeHasName(statement, name) {
        if (isNamedDeclaration(statement) && ts.isIdentifier(statement.name) && idText(statement.name) === idText(name)) {
            return true;
        }
        if (ts.isVariableStatement(statement) && ts.some(statement.declarationList.declarations, function (d) { return nodeHasName(d, name); })) {
            return true;
        }
        return false;
    }
    ts.nodeHasName = nodeHasName;
    function getNameOfJSDocTypedef(declaration) {
        return declaration.name || nameForNamelessJSDocTypedef(declaration);
    }
    ts.getNameOfJSDocTypedef = getNameOfJSDocTypedef;
    /** @internal */
    function isNamedDeclaration(node) {
        return !!node.name; // A 'name' property should always be a DeclarationName.
    }
    ts.isNamedDeclaration = isNamedDeclaration;
    /** @internal */
    function getNonAssignedNameOfDeclaration(declaration) {
        switch (declaration.kind) {
            case 79 /* SyntaxKind.Identifier */:
                return declaration;
            case 347 /* SyntaxKind.JSDocPropertyTag */:
            case 340 /* SyntaxKind.JSDocParameterTag */: {
                var name = declaration.name;
                if (name.kind === 161 /* SyntaxKind.QualifiedName */) {
                    return name.right;
                }
                break;
            }
            case 208 /* SyntaxKind.CallExpression */:
            case 221 /* SyntaxKind.BinaryExpression */: {
                var expr_1 = declaration;
                switch (ts.getAssignmentDeclarationKind(expr_1)) {
                    case 1 /* AssignmentDeclarationKind.ExportsProperty */:
                    case 4 /* AssignmentDeclarationKind.ThisProperty */:
                    case 5 /* AssignmentDeclarationKind.Property */:
                    case 3 /* AssignmentDeclarationKind.PrototypeProperty */:
                        return ts.getElementOrPropertyAccessArgumentExpressionOrName(expr_1.left);
                    case 7 /* AssignmentDeclarationKind.ObjectDefinePropertyValue */:
                    case 8 /* AssignmentDeclarationKind.ObjectDefinePropertyExports */:
                    case 9 /* AssignmentDeclarationKind.ObjectDefinePrototypeProperty */:
                        return expr_1.arguments[1];
                    default:
                        return undefined;
                }
            }
            case 345 /* SyntaxKind.JSDocTypedefTag */:
                return getNameOfJSDocTypedef(declaration);
            case 339 /* SyntaxKind.JSDocEnumTag */:
                return nameForNamelessJSDocTypedef(declaration);
            case 271 /* SyntaxKind.ExportAssignment */: {
                var expression = declaration.expression;
                return ts.isIdentifier(expression) ? expression : undefined;
            }
            case 207 /* SyntaxKind.ElementAccessExpression */:
                var expr = declaration;
                if (ts.isBindableStaticElementAccessExpression(expr)) {
                    return expr.argumentExpression;
                }
        }
        return declaration.name;
    }
    ts.getNonAssignedNameOfDeclaration = getNonAssignedNameOfDeclaration;
    function getNameOfDeclaration(declaration) {
        if (declaration === undefined)
            return undefined;
        return getNonAssignedNameOfDeclaration(declaration) ||
            (ts.isFunctionExpression(declaration) || ts.isArrowFunction(declaration) || ts.isClassExpression(declaration) ? getAssignedName(declaration) : undefined);
    }
    ts.getNameOfDeclaration = getNameOfDeclaration;
    /*@internal*/
    function getAssignedName(node) {
        if (!node.parent) {
            return undefined;
        }
        else if (ts.isPropertyAssignment(node.parent) || ts.isBindingElement(node.parent)) {
            return node.parent.name;
        }
        else if (ts.isBinaryExpression(node.parent) && node === node.parent.right) {
            if (ts.isIdentifier(node.parent.left)) {
                return node.parent.left;
            }
            else if (ts.isAccessExpression(node.parent.left)) {
                return ts.getElementOrPropertyAccessArgumentExpressionOrName(node.parent.left);
            }
        }
        else if (ts.isVariableDeclaration(node.parent) && ts.isIdentifier(node.parent.name)) {
            return node.parent.name;
        }
    }
    ts.getAssignedName = getAssignedName;
    function getDecorators(node) {
        if (ts.hasDecorators(node)) {
            return ts.filter(node.modifiers, ts.isDecorator);
        }
    }
    ts.getDecorators = getDecorators;
    function getModifiers(node) {
        if (ts.hasSyntacticModifier(node, 125951 /* ModifierFlags.Modifier */)) {
            return ts.filter(node.modifiers, isModifier);
        }
    }
    ts.getModifiers = getModifiers;
    function getJSDocParameterTagsWorker(param, noCache) {
        if (param.name) {
            if (ts.isIdentifier(param.name)) {
                var name_1 = param.name.escapedText;
                return getJSDocTagsWorker(param.parent, noCache).filter(function (tag) { return ts.isJSDocParameterTag(tag) && ts.isIdentifier(tag.name) && tag.name.escapedText === name_1; });
            }
            else {
                var i = param.parent.parameters.indexOf(param);
                ts.Debug.assert(i > -1, "Parameters should always be in their parents' parameter list");
                var paramTags = getJSDocTagsWorker(param.parent, noCache).filter(ts.isJSDocParameterTag);
                if (i < paramTags.length) {
                    return [paramTags[i]];
                }
            }
        }
        // return empty array for: out-of-order binding patterns and JSDoc function syntax, which has un-named parameters
        return ts.emptyArray;
    }
    /**
     * Gets the JSDoc parameter tags for the node if present.
     *
     * @remarks Returns any JSDoc param tag whose name matches the provided
     * parameter, whether a param tag on a containing function
     * expression, or a param tag on a variable declaration whose
     * initializer is the containing function. The tags closest to the
     * node are returned first, so in the previous example, the param
     * tag on the containing function expression would be first.
     *
     * For binding patterns, parameter tags are matched by position.
     */
    function getJSDocParameterTags(param) {
        return getJSDocParameterTagsWorker(param, /*noCache*/ false);
    }
    ts.getJSDocParameterTags = getJSDocParameterTags;
    /* @internal */
    function getJSDocParameterTagsNoCache(param) {
        return getJSDocParameterTagsWorker(param, /*noCache*/ true);
    }
    ts.getJSDocParameterTagsNoCache = getJSDocParameterTagsNoCache;
    function getJSDocTypeParameterTagsWorker(param, noCache) {
        var name = param.name.escapedText;
        return getJSDocTagsWorker(param.parent, noCache).filter(function (tag) {
            return ts.isJSDocTemplateTag(tag) && tag.typeParameters.some(function (tp) { return tp.name.escapedText === name; });
        });
    }
    /**
     * Gets the JSDoc type parameter tags for the node if present.
     *
     * @remarks Returns any JSDoc template tag whose names match the provided
     * parameter, whether a template tag on a containing function
     * expression, or a template tag on a variable declaration whose
     * initializer is the containing function. The tags closest to the
     * node are returned first, so in the previous example, the template
     * tag on the containing function expression would be first.
     */
    function getJSDocTypeParameterTags(param) {
        return getJSDocTypeParameterTagsWorker(param, /*noCache*/ false);
    }
    ts.getJSDocTypeParameterTags = getJSDocTypeParameterTags;
    /* @internal */
    function getJSDocTypeParameterTagsNoCache(param) {
        return getJSDocTypeParameterTagsWorker(param, /*noCache*/ true);
    }
    ts.getJSDocTypeParameterTagsNoCache = getJSDocTypeParameterTagsNoCache;
    /**
     * Return true if the node has JSDoc parameter tags.
     *
     * @remarks Includes parameter tags that are not directly on the node,
     * for example on a variable declaration whose initializer is a function expression.
     */
    function hasJSDocParameterTags(node) {
        return !!getFirstJSDocTag(node, ts.isJSDocParameterTag);
    }
    ts.hasJSDocParameterTags = hasJSDocParameterTags;
    /** Gets the JSDoc augments tag for the node if present */
    function getJSDocAugmentsTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocAugmentsTag);
    }
    ts.getJSDocAugmentsTag = getJSDocAugmentsTag;
    /** Gets the JSDoc implements tags for the node if present */
    function getJSDocImplementsTags(node) {
        return getAllJSDocTags(node, ts.isJSDocImplementsTag);
    }
    ts.getJSDocImplementsTags = getJSDocImplementsTags;
    /** Gets the JSDoc class tag for the node if present */
    function getJSDocClassTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocClassTag);
    }
    ts.getJSDocClassTag = getJSDocClassTag;
    /** Gets the JSDoc public tag for the node if present */
    function getJSDocPublicTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocPublicTag);
    }
    ts.getJSDocPublicTag = getJSDocPublicTag;
    /*@internal*/
    function getJSDocPublicTagNoCache(node) {
        return getFirstJSDocTag(node, ts.isJSDocPublicTag, /*noCache*/ true);
    }
    ts.getJSDocPublicTagNoCache = getJSDocPublicTagNoCache;
    /** Gets the JSDoc private tag for the node if present */
    function getJSDocPrivateTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocPrivateTag);
    }
    ts.getJSDocPrivateTag = getJSDocPrivateTag;
    /*@internal*/
    function getJSDocPrivateTagNoCache(node) {
        return getFirstJSDocTag(node, ts.isJSDocPrivateTag, /*noCache*/ true);
    }
    ts.getJSDocPrivateTagNoCache = getJSDocPrivateTagNoCache;
    /** Gets the JSDoc protected tag for the node if present */
    function getJSDocProtectedTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocProtectedTag);
    }
    ts.getJSDocProtectedTag = getJSDocProtectedTag;
    /*@internal*/
    function getJSDocProtectedTagNoCache(node) {
        return getFirstJSDocTag(node, ts.isJSDocProtectedTag, /*noCache*/ true);
    }
    ts.getJSDocProtectedTagNoCache = getJSDocProtectedTagNoCache;
    /** Gets the JSDoc protected tag for the node if present */
    function getJSDocReadonlyTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocReadonlyTag);
    }
    ts.getJSDocReadonlyTag = getJSDocReadonlyTag;
    /*@internal*/
    function getJSDocReadonlyTagNoCache(node) {
        return getFirstJSDocTag(node, ts.isJSDocReadonlyTag, /*noCache*/ true);
    }
    ts.getJSDocReadonlyTagNoCache = getJSDocReadonlyTagNoCache;
    function getJSDocOverrideTagNoCache(node) {
        return getFirstJSDocTag(node, ts.isJSDocOverrideTag, /*noCache*/ true);
    }
    ts.getJSDocOverrideTagNoCache = getJSDocOverrideTagNoCache;
    /** Gets the JSDoc deprecated tag for the node if present */
    function getJSDocDeprecatedTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocDeprecatedTag);
    }
    ts.getJSDocDeprecatedTag = getJSDocDeprecatedTag;
    /*@internal */
    function getJSDocDeprecatedTagNoCache(node) {
        return getFirstJSDocTag(node, ts.isJSDocDeprecatedTag, /*noCache*/ true);
    }
    ts.getJSDocDeprecatedTagNoCache = getJSDocDeprecatedTagNoCache;
    /** Gets the JSDoc enum tag for the node if present */
    function getJSDocEnumTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocEnumTag);
    }
    ts.getJSDocEnumTag = getJSDocEnumTag;
    /** Gets the JSDoc this tag for the node if present */
    function getJSDocThisTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocThisTag);
    }
    ts.getJSDocThisTag = getJSDocThisTag;
    /** Gets the JSDoc return tag for the node if present */
    function getJSDocReturnTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocReturnTag);
    }
    ts.getJSDocReturnTag = getJSDocReturnTag;
    /** Gets the JSDoc template tag for the node if present */
    function getJSDocTemplateTag(node) {
        return getFirstJSDocTag(node, ts.isJSDocTemplateTag);
    }
    ts.getJSDocTemplateTag = getJSDocTemplateTag;
    /** Gets the JSDoc type tag for the node if present and valid */
    function getJSDocTypeTag(node) {
        // We should have already issued an error if there were multiple type jsdocs, so just use the first one.
        var tag = getFirstJSDocTag(node, ts.isJSDocTypeTag);
        if (tag && tag.typeExpression && tag.typeExpression.type) {
            return tag;
        }
        return undefined;
    }
    ts.getJSDocTypeTag = getJSDocTypeTag;
    /**
     * Gets the type node for the node if provided via JSDoc.
     *
     * @remarks The search includes any JSDoc param tag that relates
     * to the provided parameter, for example a type tag on the
     * parameter itself, or a param tag on a containing function
     * expression, or a param tag on a variable declaration whose
     * initializer is the containing function. The tags closest to the
     * node are examined first, so in the previous example, the type
     * tag directly on the node would be returned.
     */
    function getJSDocType(node) {
        var tag = getFirstJSDocTag(node, ts.isJSDocTypeTag);
        if (!tag && ts.isParameter(node)) {
            tag = ts.find(getJSDocParameterTags(node), function (tag) { return !!tag.typeExpression; });
        }
        return tag && tag.typeExpression && tag.typeExpression.type;
    }
    ts.getJSDocType = getJSDocType;
    /**
     * Gets the return type node for the node if provided via JSDoc return tag or type tag.
     *
     * @remarks `getJSDocReturnTag` just gets the whole JSDoc tag. This function
     * gets the type from inside the braces, after the fat arrow, etc.
     */
    function getJSDocReturnType(node) {
        var returnTag = getJSDocReturnTag(node);
        if (returnTag && returnTag.typeExpression) {
            return returnTag.typeExpression.type;
        }
        var typeTag = getJSDocTypeTag(node);
        if (typeTag && typeTag.typeExpression) {
            var type = typeTag.typeExpression.type;
            if (ts.isTypeLiteralNode(type)) {
                var sig = ts.find(type.members, ts.isCallSignatureDeclaration);
                return sig && sig.type;
            }
            if (ts.isFunctionTypeNode(type) || ts.isJSDocFunctionType(type)) {
                return type.type;
            }
        }
    }
    ts.getJSDocReturnType = getJSDocReturnType;
    function getJSDocTagsWorker(node, noCache) {
        var tags = node.jsDocCache;
        // If cache is 'null', that means we did the work of searching for JSDoc tags and came up with nothing.
        if (tags === undefined || noCache) {
            var comments = ts.getJSDocCommentsAndTags(node, noCache);
            ts.Debug.assert(comments.length < 2 || comments[0] !== comments[1]);
            tags = ts.flatMap(comments, function (j) { return ts.isJSDoc(j) ? j.tags : j; });
            if (!noCache) {
                node.jsDocCache = tags;
            }
        }
        return tags;
    }
    /** Get all JSDoc tags related to a node, including those on parent nodes. */
    function getJSDocTags(node) {
        return getJSDocTagsWorker(node, /*noCache*/ false);
    }
    ts.getJSDocTags = getJSDocTags;
    /* @internal */
    function getJSDocTagsNoCache(node) {
        return getJSDocTagsWorker(node, /*noCache*/ true);
    }
    ts.getJSDocTagsNoCache = getJSDocTagsNoCache;
    /** Get the first JSDoc tag of a specified kind, or undefined if not present. */
    function getFirstJSDocTag(node, predicate, noCache) {
        return ts.find(getJSDocTagsWorker(node, noCache), predicate);
    }
    /** Gets all JSDoc tags that match a specified predicate */
    function getAllJSDocTags(node, predicate) {
        return getJSDocTags(node).filter(predicate);
    }
    ts.getAllJSDocTags = getAllJSDocTags;
    /** Gets all JSDoc tags of a specified kind */
    function getAllJSDocTagsOfKind(node, kind) {
        return getJSDocTags(node).filter(function (doc) { return doc.kind === kind; });
    }
    ts.getAllJSDocTagsOfKind = getAllJSDocTagsOfKind;
    /** Gets the text of a jsdoc comment, flattening links to their text. */
    function getTextOfJSDocComment(comment) {
        return typeof comment === "string" ? comment
            : comment === null || comment === void 0 ? void 0 : comment.map(function (c) { return c.kind === 321 /* SyntaxKind.JSDocText */ ? c.text : formatJSDocLink(c); }).join("");
    }
    ts.getTextOfJSDocComment = getTextOfJSDocComment;
    function formatJSDocLink(link) {
        var kind = link.kind === 324 /* SyntaxKind.JSDocLink */ ? "link"
            : link.kind === 325 /* SyntaxKind.JSDocLinkCode */ ? "linkcode"
                : "linkplain";
        var name = link.name ? ts.entityNameToString(link.name) : "";
        var space = link.name && link.text.startsWith("://") ? "" : " ";
        return "{@".concat(kind, " ").concat(name).concat(space).concat(link.text, "}");
    }
    /**
     * Gets the effective type parameters. If the node was parsed in a
     * JavaScript file, gets the type parameters from the `@template` tag from JSDoc.
     *
     * This does *not* return type parameters from a jsdoc reference to a generic type, eg
     *
     * type Id = <T>(x: T) => T
     * /** @type {Id} /
     * function id(x) { return x }
     */
    function getEffectiveTypeParameterDeclarations(node) {
        if (ts.isJSDocSignature(node)) {
            return ts.emptyArray;
        }
        if (ts.isJSDocTypeAlias(node)) {
            ts.Debug.assert(node.parent.kind === 320 /* SyntaxKind.JSDoc */);
            return ts.flatMap(node.parent.tags, function (tag) { return ts.isJSDocTemplateTag(tag) ? tag.typeParameters : undefined; });
        }
        if (node.typeParameters) {
            return node.typeParameters;
        }
        if (ts.canHaveIllegalTypeParameters(node) && node.typeParameters) {
            return node.typeParameters;
        }
        if (ts.isInJSFile(node)) {
            var decls = ts.getJSDocTypeParameterDeclarations(node);
            if (decls.length) {
                return decls;
            }
            var typeTag = getJSDocType(node);
            if (typeTag && ts.isFunctionTypeNode(typeTag) && typeTag.typeParameters) {
                return typeTag.typeParameters;
            }
        }
        return ts.emptyArray;
    }
    ts.getEffectiveTypeParameterDeclarations = getEffectiveTypeParameterDeclarations;
    function getEffectiveConstraintOfTypeParameter(node) {
        return node.constraint ? node.constraint :
            ts.isJSDocTemplateTag(node.parent) && node === node.parent.typeParameters[0] ? node.parent.constraint :
                undefined;
    }
    ts.getEffectiveConstraintOfTypeParameter = getEffectiveConstraintOfTypeParameter;
    // #region
    function isMemberName(node) {
        return node.kind === 79 /* SyntaxKind.Identifier */ || node.kind === 80 /* SyntaxKind.PrivateIdentifier */;
    }
    ts.isMemberName = isMemberName;
    /* @internal */
    function isGetOrSetAccessorDeclaration(node) {
        return node.kind === 173 /* SyntaxKind.SetAccessor */ || node.kind === 172 /* SyntaxKind.GetAccessor */;
    }
    ts.isGetOrSetAccessorDeclaration = isGetOrSetAccessorDeclaration;
    function isPropertyAccessChain(node) {
        return ts.isPropertyAccessExpression(node) && !!(node.flags & 32 /* NodeFlags.OptionalChain */);
    }
    ts.isPropertyAccessChain = isPropertyAccessChain;
    function isElementAccessChain(node) {
        return ts.isElementAccessExpression(node) && !!(node.flags & 32 /* NodeFlags.OptionalChain */);
    }
    ts.isElementAccessChain = isElementAccessChain;
    function isCallChain(node) {
        return ts.isCallExpression(node) && !!(node.flags & 32 /* NodeFlags.OptionalChain */);
    }
    ts.isCallChain = isCallChain;
    function isOptionalChain(node) {
        var kind = node.kind;
        return !!(node.flags & 32 /* NodeFlags.OptionalChain */) &&
            (kind === 206 /* SyntaxKind.PropertyAccessExpression */
                || kind === 207 /* SyntaxKind.ElementAccessExpression */
                || kind === 208 /* SyntaxKind.CallExpression */
                || kind === 230 /* SyntaxKind.NonNullExpression */);
    }
    ts.isOptionalChain = isOptionalChain;
    /* @internal */
    function isOptionalChainRoot(node) {
        return isOptionalChain(node) && !ts.isNonNullExpression(node) && !!node.questionDotToken;
    }
    ts.isOptionalChainRoot = isOptionalChainRoot;
    /**
     * Determines whether a node is the expression preceding an optional chain (i.e. `a` in `a?.b`).
     */
    /* @internal */
    function isExpressionOfOptionalChainRoot(node) {
        return isOptionalChainRoot(node.parent) && node.parent.expression === node;
    }
    ts.isExpressionOfOptionalChainRoot = isExpressionOfOptionalChainRoot;
    /**
     * Determines whether a node is the outermost `OptionalChain` in an ECMAScript `OptionalExpression`:
     *
     * 1. For `a?.b.c`, the outermost chain is `a?.b.c` (`c` is the end of the chain starting at `a?.`)
     * 2. For `a?.b!`, the outermost chain is `a?.b` (`b` is the end of the chain starting at `a?.`)
     * 3. For `(a?.b.c).d`, the outermost chain is `a?.b.c` (`c` is the end of the chain starting at `a?.` since parens end the chain)
     * 4. For `a?.b.c?.d`, both `a?.b.c` and `a?.b.c?.d` are outermost (`c` is the end of the chain starting at `a?.`, and `d` is
     *   the end of the chain starting at `c?.`)
     * 5. For `a?.(b?.c).d`, both `b?.c` and `a?.(b?.c)d` are outermost (`c` is the end of the chain starting at `b`, and `d` is
     *   the end of the chain starting at `a?.`)
     */
    /* @internal */
    function isOutermostOptionalChain(node) {
        return !isOptionalChain(node.parent) // cases 1, 2, and 3
            || isOptionalChainRoot(node.parent) // case 4
            || node !== node.parent.expression; // case 5
    }
    ts.isOutermostOptionalChain = isOutermostOptionalChain;
    function isNullishCoalesce(node) {
        return node.kind === 221 /* SyntaxKind.BinaryExpression */ && node.operatorToken.kind === 60 /* SyntaxKind.QuestionQuestionToken */;
    }
    ts.isNullishCoalesce = isNullishCoalesce;
    function isConstTypeReference(node) {
        return ts.isTypeReferenceNode(node) && ts.isIdentifier(node.typeName) &&
            node.typeName.escapedText === "const" && !node.typeArguments;
    }
    ts.isConstTypeReference = isConstTypeReference;
    function skipPartiallyEmittedExpressions(node) {
        return ts.skipOuterExpressions(node, 8 /* OuterExpressionKinds.PartiallyEmittedExpressions */);
    }
    ts.skipPartiallyEmittedExpressions = skipPartiallyEmittedExpressions;
    function isNonNullChain(node) {
        return ts.isNonNullExpression(node) && !!(node.flags & 32 /* NodeFlags.OptionalChain */);
    }
    ts.isNonNullChain = isNonNullChain;
    function isBreakOrContinueStatement(node) {
        return node.kind === 246 /* SyntaxKind.BreakStatement */ || node.kind === 245 /* SyntaxKind.ContinueStatement */;
    }
    ts.isBreakOrContinueStatement = isBreakOrContinueStatement;
    function isNamedExportBindings(node) {
        return node.kind === 274 /* SyntaxKind.NamespaceExport */ || node.kind === 273 /* SyntaxKind.NamedExports */;
    }
    ts.isNamedExportBindings = isNamedExportBindings;
    function isUnparsedTextLike(node) {
        switch (node.kind) {
            case 302 /* SyntaxKind.UnparsedText */:
            case 303 /* SyntaxKind.UnparsedInternalText */:
                return true;
            default:
                return false;
        }
    }
    ts.isUnparsedTextLike = isUnparsedTextLike;
    function isUnparsedNode(node) {
        return isUnparsedTextLike(node) ||
            node.kind === 300 /* SyntaxKind.UnparsedPrologue */ ||
            node.kind === 304 /* SyntaxKind.UnparsedSyntheticReference */;
    }
    ts.isUnparsedNode = isUnparsedNode;
    function isJSDocPropertyLikeTag(node) {
        return node.kind === 347 /* SyntaxKind.JSDocPropertyTag */ || node.kind === 340 /* SyntaxKind.JSDocParameterTag */;
    }
    ts.isJSDocPropertyLikeTag = isJSDocPropertyLikeTag;
    // #endregion
    // #region
    // Node tests
    //
    // All node tests in the following list should *not* reference parent pointers so that
    // they may be used with transformations.
    /* @internal */
    function isNode(node) {
        return isNodeKind(node.kind);
    }
    ts.isNode = isNode;
    /* @internal */
    function isNodeKind(kind) {
        return kind >= 161 /* SyntaxKind.FirstNode */;
    }
    ts.isNodeKind = isNodeKind;
    /**
     * True if kind is of some token syntax kind.
     * For example, this is true for an IfKeyword but not for an IfStatement.
     * Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.
     */
    function isTokenKind(kind) {
        return kind >= 0 /* SyntaxKind.FirstToken */ && kind <= 160 /* SyntaxKind.LastToken */;
    }
    ts.isTokenKind = isTokenKind;
    /**
     * True if node is of some token syntax kind.
     * For example, this is true for an IfKeyword but not for an IfStatement.
     * Literals are considered tokens, except TemplateLiteral, but does include TemplateHead/Middle/Tail.
     */
    function isToken(n) {
        return isTokenKind(n.kind);
    }
    ts.isToken = isToken;
    // Node Arrays
    /* @internal */
    function isNodeArray(array) {
        return array.hasOwnProperty("pos") && array.hasOwnProperty("end");
    }
    ts.isNodeArray = isNodeArray;
    // Literals
    /* @internal */
    function isLiteralKind(kind) {
        return 8 /* SyntaxKind.FirstLiteralToken */ <= kind && kind <= 14 /* SyntaxKind.LastLiteralToken */;
    }
    ts.isLiteralKind = isLiteralKind;
    function isLiteralExpression(node) {
        return isLiteralKind(node.kind);
    }
    ts.isLiteralExpression = isLiteralExpression;
    /** @internal */
    function isLiteralExpressionOfObject(node) {
        switch (node.kind) {
            case 205 /* SyntaxKind.ObjectLiteralExpression */:
            case 204 /* SyntaxKind.ArrayLiteralExpression */:
            case 13 /* SyntaxKind.RegularExpressionLiteral */:
            case 213 /* SyntaxKind.FunctionExpression */:
            case 226 /* SyntaxKind.ClassExpression */:
                return true;
        }
        return false;
    }
    ts.isLiteralExpressionOfObject = isLiteralExpressionOfObject;
    // Pseudo-literals
    /* @internal */
    function isTemplateLiteralKind(kind) {
        return 14 /* SyntaxKind.FirstTemplateToken */ <= kind && kind <= 17 /* SyntaxKind.LastTemplateToken */;
    }
    ts.isTemplateLiteralKind = isTemplateLiteralKind;
    function isTemplateLiteralToken(node) {
        return isTemplateLiteralKind(node.kind);
    }
    ts.isTemplateLiteralToken = isTemplateLiteralToken;
    function isTemplateMiddleOrTemplateTail(node) {
        var kind = node.kind;
        return kind === 16 /* SyntaxKind.TemplateMiddle */
            || kind === 17 /* SyntaxKind.TemplateTail */;
    }
    ts.isTemplateMiddleOrTemplateTail = isTemplateMiddleOrTemplateTail;
    function isImportOrExportSpecifier(node) {
        return ts.isImportSpecifier(node) || ts.isExportSpecifier(node);
    }
    ts.isImportOrExportSpecifier = isImportOrExportSpecifier;
    function isTypeOnlyImportOrExportDeclaration(node) {
        switch (node.kind) {
            case 270 /* SyntaxKind.ImportSpecifier */:
            case 275 /* SyntaxKind.ExportSpecifier */:
                return node.isTypeOnly || node.parent.parent.isTypeOnly;
            case 268 /* SyntaxKind.NamespaceImport */:
                return node.parent.isTypeOnly;
            case 267 /* SyntaxKind.ImportClause */:
            case 265 /* SyntaxKind.ImportEqualsDeclaration */:
                return node.isTypeOnly;
            default:
                return false;
        }
    }
    ts.isTypeOnlyImportOrExportDeclaration = isTypeOnlyImportOrExportDeclaration;
    function isAssertionKey(node) {
        return ts.isStringLiteral(node) || ts.isIdentifier(node);
    }
    ts.isAssertionKey = isAssertionKey;
    function isStringTextContainingNode(node) {
        return node.kind === 10 /* SyntaxKind.StringLiteral */ || isTemplateLiteralKind(node.kind);
    }
    ts.isStringTextContainingNode = isStringTextContainingNode;
    // Identifiers
    /* @internal */
    function isGeneratedIdentifier(node) {
        return ts.isIdentifier(node) && (node.autoGenerateFlags & 7 /* GeneratedIdentifierFlags.KindMask */) > 0 /* GeneratedIdentifierFlags.None */;
    }
    ts.isGeneratedIdentifier = isGeneratedIdentifier;
    // Private Identifiers
    /*@internal*/
    function isPrivateIdentifierClassElementDeclaration(node) {
        return (ts.isPropertyDeclaration(node) || isMethodOrAccessor(node)) && ts.isPrivateIdentifier(node.name);
    }
    ts.isPrivateIdentifierClassElementDeclaration = isPrivateIdentifierClassElementDeclaration;
    /*@internal*/
    function isPrivateIdentifierPropertyAccessExpression(node) {
        return ts.isPropertyAccessExpression(node) && ts.isPrivateIdentifier(node.name);
    }
    ts.isPrivateIdentifierPropertyAccessExpression = isPrivateIdentifierPropertyAccessExpression;
    // Keywords
    /* @internal */
    function isModifierKind(token) {
        switch (token) {
            case 126 /* SyntaxKind.AbstractKeyword */:
            case 131 /* SyntaxKind.AsyncKeyword */:
            case 85 /* SyntaxKind.ConstKeyword */:
            case 135 /* SyntaxKind.DeclareKeyword */:
            case 88 /* SyntaxKind.DefaultKeyword */:
            case 93 /* SyntaxKind.ExportKeyword */:
            case 101 /* SyntaxKind.InKeyword */:
            case 123 /* SyntaxKind.PublicKeyword */:
            case 121 /* SyntaxKind.PrivateKeyword */:
            case 122 /* SyntaxKind.ProtectedKeyword */:
            case 145 /* SyntaxKind.ReadonlyKeyword */:
            case 124 /* SyntaxKind.StaticKeyword */:
            case 144 /* SyntaxKind.OutKeyword */:
            case 159 /* SyntaxKind.OverrideKeyword */:
                return true;
        }
        return false;
    }
    ts.isModifierKind = isModifierKind;
    /* @internal */
    function isParameterPropertyModifier(kind) {
        return !!(ts.modifierToFlag(kind) & 16476 /* ModifierFlags.ParameterPropertyModifier */);
    }
    ts.isParameterPropertyModifier = isParameterPropertyModifier;
    /* @internal */
    function isClassMemberModifier(idToken) {
        return isParameterPropertyModifier(idToken) || idToken === 124 /* SyntaxKind.StaticKeyword */ || idToken === 159 /* SyntaxKind.OverrideKeyword */;
    }
    ts.isClassMemberModifier = isClassMemberModifier;
    function isModifier(node) {
        return isModifierKind(node.kind);
    }
    ts.isModifier = isModifier;
    function isEntityName(node) {
        var kind = node.kind;
        return kind === 161 /* SyntaxKind.QualifiedName */
            || kind === 79 /* SyntaxKind.Identifier */;
    }
    ts.isEntityName = isEntityName;
    function isPropertyName(node) {
        var kind = node.kind;
        return kind === 79 /* SyntaxKind.Identifier */
            || kind === 80 /* SyntaxKind.PrivateIdentifier */
            || kind === 10 /* SyntaxKind.StringLiteral */
            || kind === 8 /* SyntaxKind.NumericLiteral */
            || kind === 162 /* SyntaxKind.ComputedPropertyName */;
    }
    ts.isPropertyName = isPropertyName;
    function isBindingName(node) {
        var kind = node.kind;
        return kind === 79 /* SyntaxKind.Identifier */
            || kind === 201 /* SyntaxKind.ObjectBindingPattern */
            || kind === 202 /* SyntaxKind.ArrayBindingPattern */;
    }
    ts.isBindingName = isBindingName;
    // Functions
    function isFunctionLike(node) {
        return !!node && isFunctionLikeKind(node.kind);
    }
    ts.isFunctionLike = isFunctionLike;
    /* @internal */
    function isFunctionLikeOrClassStaticBlockDeclaration(node) {
        return !!node && (isFunctionLikeKind(node.kind) || ts.isClassStaticBlockDeclaration(node));
    }
    ts.isFunctionLikeOrClassStaticBlockDeclaration = isFunctionLikeOrClassStaticBlockDeclaration;
    /* @internal */
    function isFunctionLikeDeclaration(node) {
        return node && isFunctionLikeDeclarationKind(node.kind);
    }
    ts.isFunctionLikeDeclaration = isFunctionLikeDeclaration;
    /* @internal */
    function isBooleanLiteral(node) {
        return node.kind === 110 /* SyntaxKind.TrueKeyword */ || node.kind === 95 /* SyntaxKind.FalseKeyword */;
    }
    ts.isBooleanLiteral = isBooleanLiteral;
    function isFunctionLikeDeclarationKind(kind) {
        switch (kind) {
            case 256 /* SyntaxKind.FunctionDeclaration */:
            case 169 /* SyntaxKind.MethodDeclaration */:
            case 171 /* SyntaxKind.Constructor */:
            case 172 /* SyntaxKind.GetAccessor */:
            case 173 /* SyntaxKind.SetAccessor */:
            case 213 /* SyntaxKind.FunctionExpression */:
            case 214 /* SyntaxKind.ArrowFunction */:
                return true;
            default:
                return false;
        }
    }
    /* @internal */
    function isFunctionLikeKind(kind) {
        switch (kind) {
            case 168 /* SyntaxKind.MethodSignature */:
            case 174 /* SyntaxKind.CallSignature */:
            case 323 /* SyntaxKind.JSDocSignature */:
            case 175 /* SyntaxKind.ConstructSignature */:
            case 176 /* SyntaxKind.IndexSignature */:
            case 179 /* SyntaxKind.FunctionType */:
            case 317 /* SyntaxKind.JSDocFunctionType */:
            case 180 /* SyntaxKind.ConstructorType */:
                return true;
            default:
                return isFunctionLikeDeclarationKind(kind);
        }
    }
    ts.isFunctionLikeKind = isFunctionLikeKind;
    /* @internal */
    function isFunctionOrModuleBlock(node) {
        return ts.isSourceFile(node) || ts.isModuleBlock(node) || ts.isBlock(node) && isFunctionLike(node.parent);
    }
    ts.isFunctionOrModuleBlock = isFunctionOrModuleBlock;
    // Classes
    function isClassElement(node) {
        var kind = node.kind;
        return kind === 171 /* SyntaxKind.Constructor */
            || kind === 167 /* SyntaxKind.PropertyDeclaration */
            || kind === 169 /* SyntaxKind.MethodDeclaration */
            || kind === 172 /* SyntaxKind.GetAccessor */
            || kind === 173 /* SyntaxKind.SetAccessor */
            || kind === 176 /* SyntaxKind.IndexSignature */
            || kind === 170 /* SyntaxKind.ClassStaticBlockDeclaration */
            || kind === 234 /* SyntaxKind.SemicolonClassElement */;
    }
    ts.isClassElement = isClassElement;
    function isClassLike(node) {
        return node && (node.kind === 257 /* SyntaxKind.ClassDeclaration */ || node.kind === 226 /* SyntaxKind.ClassExpression */);
    }
    ts.isClassLike = isClassLike;
    function isAccessor(node) {
        return node && (node.kind === 172 /* SyntaxKind.GetAccessor */ || node.kind === 173 /* SyntaxKind.SetAccessor */);
    }
    ts.isAccessor = isAccessor;
    /* @internal */
    function isMethodOrAccessor(node) {
        switch (node.kind) {
            case 169 /* SyntaxKind.MethodDeclaration */:
            case 172 /* SyntaxKind.GetAccessor */:
            case 173 /* SyntaxKind.SetAccessor */:
                return true;
            default:
                return false;
        }
    }
    ts.isMethodOrAccessor = isMethodOrAccessor;
    // Type members
    function isModifierLike(node) {
        return isModifier(node) || ts.isDecorator(node);
    }
    ts.isModifierLike = isModifierLike;
    function isTypeElement(node) {
        var kind = node.kind;
        return kind === 175 /* SyntaxKind.ConstructSignature */
            || kind === 174 /* SyntaxKind.CallSignature */
            || kind === 166 /* SyntaxKind.PropertySignature */
            || kind === 168 /* SyntaxKind.MethodSignature */
            || kind === 176 /* SyntaxKind.IndexSignature */
            || kind === 172 /* SyntaxKind.GetAccessor */
            || kind === 173 /* SyntaxKind.SetAccessor */;
    }
    ts.isTypeElement = isTypeElement;
    function isClassOrTypeElement(node) {
        return isTypeElement(node) || isClassElement(node);
    }
    ts.isClassOrTypeElement = isClassOrTypeElement;
    function isObjectLiteralElementLike(node) {
        var kind = node.kind;
        return kind === 296 /* SyntaxKind.PropertyAssignment */
            || kind === 297 /* SyntaxKind.ShorthandPropertyAssignment */
            || kind === 298 /* SyntaxKind.SpreadAssignment */
            || kind === 169 /* SyntaxKind.MethodDeclaration */
            || kind === 172 /* SyntaxKind.GetAccessor */
            || kind === 173 /* SyntaxKind.SetAccessor */;
    }
    ts.isObjectLiteralElementLike = isObjectLiteralElementLike;
    // Type
    /**
     * Node test that determines whether a node is a valid type node.
     * This differs from the `isPartOfTypeNode` function which determines whether a node is *part*
     * of a TypeNode.
     */
    function isTypeNode(node) {
        return ts.isTypeNodeKind(node.kind);
    }
    ts.isTypeNode = isTypeNode;
    function isFunctionOrConstructorTypeNode(node) {
        switch (node.kind) {
            case 179 /* SyntaxKind.FunctionType */:
            case 180 /* SyntaxKind.ConstructorType */:
                return true;
        }
        return false;
    }
    ts.isFunctionOrConstructorTypeNode = isFunctionOrConstructorTypeNode;
    // Binding patterns
    /* @internal */
    function isBindingPattern(node) {
        if (node) {
            var kind = node.kind;
            return kind === 202 /* SyntaxKind.ArrayBindingPattern */
                || kind === 201 /* SyntaxKind.ObjectBindingPattern */;
        }
        return false;
    }
    ts.isBindingPattern = isBindingPattern;
    /* @internal */
    function isAssignmentPattern(node) {
        var kind = node.kind;
        return kind === 204 /* SyntaxKind.ArrayLiteralExpression */
            || kind === 205 /* SyntaxKind.ObjectLiteralExpression */;
    }
    ts.isAssignmentPattern = isAssignmentPattern;
    /* @internal */
    function isArrayBindingElement(node) {
        var kind = node.kind;
        return kind === 203 /* SyntaxKind.BindingElement */
            || kind === 227 /* SyntaxKind.OmittedExpression */;
    }
    ts.isArrayBindingElement = isArrayBindingElement;
    /**
     * Determines whether the BindingOrAssignmentElement is a BindingElement-like declaration
     */
    /* @internal */
    function isDeclarationBindingElement(bindingElement) {
        switch (bindingElement.kind) {
            case 254 /* SyntaxKind.VariableDeclaration */:
            case 164 /* SyntaxKind.Parameter */:
            case 203 /* SyntaxKind.BindingElement */:
                return true;
        }
        return false;
    }
    ts.isDeclarationBindingElement = isDeclarationBindingElement;
    /**
     * Determines whether a node is a BindingOrAssignmentPattern
     */
    /* @internal */
    function isBindingOrAssignmentPattern(node) {
        return isObjectBindingOrAssignmentPattern(node)
            || isArrayBindingOrAssignmentPattern(node);
    }
    ts.isBindingOrAssignmentPattern = isBindingOrAssignmentPattern;
    /**
     * Determines whether a node is an ObjectBindingOrAssignmentPattern
     */
    /* @internal */
    function isObjectBindingOrAssignmentPattern(node) {
        switch (node.kind) {
            case 201 /* SyntaxKind.ObjectBindingPattern */:
            case 205 /* SyntaxKind.ObjectLiteralExpression */:
                return true;
        }
        return false;
    }
    ts.isObjectBindingOrAssignmentPattern = isObjectBindingOrAssignmentPattern;
    /* @internal */
    function isObjectBindingOrAssignmentElement(node) {
        switch (node.kind) {
            case 203 /* SyntaxKind.BindingElement */:
            case 296 /* SyntaxKind.PropertyAssignment */: // AssignmentProperty
            case 297 /* SyntaxKind.ShorthandPropertyAssignment */: // AssignmentProperty
            case 298 /* SyntaxKind.SpreadAssignment */: // AssignmentRestProperty
                return true;
        }
        return false;
    }
    ts.isObjectBindingOrAssignmentElement = isObjectBindingOrAssignmentElement;
    /**
     * Determines whether a node is an ArrayBindingOrAssignmentPattern
     */
    /* @internal */
    function isArrayBindingOrAssignmentPattern(node) {
        switch (node.kind) {
            case 202 /* SyntaxKind.ArrayBindingPattern */:
            case 204 /* SyntaxKind.ArrayLiteralExpression */:
                return true;
        }
        return false;
    }
    ts.isArrayBindingOrAssignmentPattern = isArrayBindingOrAssignmentPattern;
    /* @internal */
    function isPropertyAccessOrQualifiedNameOrImportTypeNode(node) {
        var kind = node.kind;
        return kind === 206 /* SyntaxKind.PropertyAccessExpression */
            || kind === 161 /* SyntaxKind.QualifiedName */
            || kind === 200 /* SyntaxKind.ImportType */;
    }
    ts.isPropertyAccessOrQualifiedNameOrImportTypeNode = isPropertyAccessOrQualifiedNameOrImportTypeNode;
    // Expression
    function isPropertyAccessOrQualifiedName(node) {
        var kind = node.kind;
        return kind === 206 /* SyntaxKind.PropertyAccessExpression */
            || kind === 161 /* SyntaxKind.QualifiedName */;
    }
    ts.isPropertyAccessOrQualifiedName = isPropertyAccessOrQualifiedName;
    function isCallLikeExpression(node) {
        switch (node.kind) {
            case 280 /* SyntaxKind.JsxOpeningElement */:
            case 279 /* SyntaxKind.JsxSelfClosingElement */:
            case 208 /* SyntaxKind.CallExpression */:
            case 209 /* SyntaxKind.NewExpression */:
            case 210 /* SyntaxKind.TaggedTemplateExpression */:
            case 165 /* SyntaxKind.Decorator */:
                return true;
            default:
                return false;
        }
    }
    ts.isCallLikeExpression = isCallLikeExpression;
    function isCallOrNewExpression(node) {
        return node.kind === 208 /* SyntaxKind.CallExpression */ || node.kind === 209 /* SyntaxKind.NewExpression */;
    }
    ts.isCallOrNewExpression = isCallOrNewExpression;
    function isTemplateLiteral(node) {
        var kind = node.kind;
        return kind === 223 /* SyntaxKind.TemplateExpression */
            || kind === 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */;
    }
    ts.isTemplateLiteral = isTemplateLiteral;
    /* @internal */
    function isLeftHandSideExpression(node) {
        return isLeftHandSideExpressionKind(skipPartiallyEmittedExpressions(node).kind);
    }
    ts.isLeftHandSideExpression = isLeftHandSideExpression;
    function isLeftHandSideExpressionKind(kind) {
        switch (kind) {
            case 206 /* SyntaxKind.PropertyAccessExpression */:
            case 207 /* SyntaxKind.ElementAccessExpression */:
            case 209 /* SyntaxKind.NewExpression */:
            case 208 /* SyntaxKind.CallExpression */:
            case 278 /* SyntaxKind.JsxElement */:
            case 279 /* SyntaxKind.JsxSelfClosingElement */:
            case 282 /* SyntaxKind.JsxFragment */:
            case 210 /* SyntaxKind.TaggedTemplateExpression */:
            case 204 /* SyntaxKind.ArrayLiteralExpression */:
            case 212 /* SyntaxKind.ParenthesizedExpression */:
            case 205 /* SyntaxKind.ObjectLiteralExpression */:
            case 226 /* SyntaxKind.ClassExpression */:
            case 213 /* SyntaxKind.FunctionExpression */:
            case 79 /* SyntaxKind.Identifier */:
            case 80 /* SyntaxKind.PrivateIdentifier */: // technically this is only an Expression if it's in a `#field in expr` BinaryExpression
            case 13 /* SyntaxKind.RegularExpressionLiteral */:
            case 8 /* SyntaxKind.NumericLiteral */:
            case 9 /* SyntaxKind.BigIntLiteral */:
            case 10 /* SyntaxKind.StringLiteral */:
            case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
            case 223 /* SyntaxKind.TemplateExpression */:
            case 95 /* SyntaxKind.FalseKeyword */:
            case 104 /* SyntaxKind.NullKeyword */:
            case 108 /* SyntaxKind.ThisKeyword */:
            case 110 /* SyntaxKind.TrueKeyword */:
            case 106 /* SyntaxKind.SuperKeyword */:
            case 230 /* SyntaxKind.NonNullExpression */:
            case 228 /* SyntaxKind.ExpressionWithTypeArguments */:
            case 231 /* SyntaxKind.MetaProperty */:
            case 100 /* SyntaxKind.ImportKeyword */: // technically this is only an Expression if it's in a CallExpression
                return true;
            default:
                return false;
        }
    }
    /* @internal */
    function isUnaryExpression(node) {
        return isUnaryExpressionKind(skipPartiallyEmittedExpressions(node).kind);
    }
    ts.isUnaryExpression = isUnaryExpression;
    function isUnaryExpressionKind(kind) {
        switch (kind) {
            case 219 /* SyntaxKind.PrefixUnaryExpression */:
            case 220 /* SyntaxKind.PostfixUnaryExpression */:
            case 215 /* SyntaxKind.DeleteExpression */:
            case 216 /* SyntaxKind.TypeOfExpression */:
            case 217 /* SyntaxKind.VoidExpression */:
            case 218 /* SyntaxKind.AwaitExpression */:
            case 211 /* SyntaxKind.TypeAssertionExpression */:
                return true;
            default:
                return isLeftHandSideExpressionKind(kind);
        }
    }
    /* @internal */
    function isUnaryExpressionWithWrite(expr) {
        switch (expr.kind) {
            case 220 /* SyntaxKind.PostfixUnaryExpression */:
                return true;
            case 219 /* SyntaxKind.PrefixUnaryExpression */:
                return expr.operator === 45 /* SyntaxKind.PlusPlusToken */ ||
                    expr.operator === 46 /* SyntaxKind.MinusMinusToken */;
            default:
                return false;
        }
    }
    ts.isUnaryExpressionWithWrite = isUnaryExpressionWithWrite;
    /* @internal */
    /**
     * Determines whether a node is an expression based only on its kind.
     * Use `isExpressionNode` if not in transforms.
     */
    function isExpression(node) {
        return isExpressionKind(skipPartiallyEmittedExpressions(node).kind);
    }
    ts.isExpression = isExpression;
    function isExpressionKind(kind) {
        switch (kind) {
            case 222 /* SyntaxKind.ConditionalExpression */:
            case 224 /* SyntaxKind.YieldExpression */:
            case 214 /* SyntaxKind.ArrowFunction */:
            case 221 /* SyntaxKind.BinaryExpression */:
            case 225 /* SyntaxKind.SpreadElement */:
            case 229 /* SyntaxKind.AsExpression */:
            case 227 /* SyntaxKind.OmittedExpression */:
            case 351 /* SyntaxKind.CommaListExpression */:
            case 350 /* SyntaxKind.PartiallyEmittedExpression */:
                return true;
            default:
                return isUnaryExpressionKind(kind);
        }
    }
    function isAssertionExpression(node) {
        var kind = node.kind;
        return kind === 211 /* SyntaxKind.TypeAssertionExpression */
            || kind === 229 /* SyntaxKind.AsExpression */;
    }
    ts.isAssertionExpression = isAssertionExpression;
    /* @internal */
    function isNotEmittedOrPartiallyEmittedNode(node) {
        return ts.isNotEmittedStatement(node)
            || ts.isPartiallyEmittedExpression(node);
    }
    ts.isNotEmittedOrPartiallyEmittedNode = isNotEmittedOrPartiallyEmittedNode;
    function isIterationStatement(node, lookInLabeledStatements) {
        switch (node.kind) {
            case 242 /* SyntaxKind.ForStatement */:
            case 243 /* SyntaxKind.ForInStatement */:
            case 244 /* SyntaxKind.ForOfStatement */:
            case 240 /* SyntaxKind.DoStatement */:
            case 241 /* SyntaxKind.WhileStatement */:
                return true;
            case 250 /* SyntaxKind.LabeledStatement */:
                return lookInLabeledStatements && isIterationStatement(node.statement, lookInLabeledStatements);
        }
        return false;
    }
    ts.isIterationStatement = isIterationStatement;
    /* @internal */
    function isScopeMarker(node) {
        return ts.isExportAssignment(node) || ts.isExportDeclaration(node);
    }
    ts.isScopeMarker = isScopeMarker;
    /* @internal */
    function hasScopeMarker(statements) {
        return ts.some(statements, isScopeMarker);
    }
    ts.hasScopeMarker = hasScopeMarker;
    /* @internal */
    function needsScopeMarker(result) {
        return !ts.isAnyImportOrReExport(result) && !ts.isExportAssignment(result) && !ts.hasSyntacticModifier(result, 1 /* ModifierFlags.Export */) && !ts.isAmbientModule(result);
    }
    ts.needsScopeMarker = needsScopeMarker;
    /* @internal */
    function isExternalModuleIndicator(result) {
        // Exported top-level member indicates moduleness
        return ts.isAnyImportOrReExport(result) || ts.isExportAssignment(result) || ts.hasSyntacticModifier(result, 1 /* ModifierFlags.Export */);
    }
    ts.isExternalModuleIndicator = isExternalModuleIndicator;
    /* @internal */
    function isForInOrOfStatement(node) {
        return node.kind === 243 /* SyntaxKind.ForInStatement */ || node.kind === 244 /* SyntaxKind.ForOfStatement */;
    }
    ts.isForInOrOfStatement = isForInOrOfStatement;
    // Element
    /* @internal */
    function isConciseBody(node) {
        return ts.isBlock(node)
            || isExpression(node);
    }
    ts.isConciseBody = isConciseBody;
    /* @internal */
    function isFunctionBody(node) {
        return ts.isBlock(node);
    }
    ts.isFunctionBody = isFunctionBody;
    /* @internal */
    function isForInitializer(node) {
        return ts.isVariableDeclarationList(node)
            || isExpression(node);
    }
    ts.isForInitializer = isForInitializer;
    /* @internal */
    function isModuleBody(node) {
        var kind = node.kind;
        return kind === 262 /* SyntaxKind.ModuleBlock */
            || kind === 261 /* SyntaxKind.ModuleDeclaration */
            || kind === 79 /* SyntaxKind.Identifier */;
    }
    ts.isModuleBody = isModuleBody;
    /* @internal */
    function isNamespaceBody(node) {
        var kind = node.kind;
        return kind === 262 /* SyntaxKind.ModuleBlock */
            || kind === 261 /* SyntaxKind.ModuleDeclaration */;
    }
    ts.isNamespaceBody = isNamespaceBody;
    /* @internal */
    function isJSDocNamespaceBody(node) {
        var kind = node.kind;
        return kind === 79 /* SyntaxKind.Identifier */
            || kind === 261 /* SyntaxKind.ModuleDeclaration */;
    }
    ts.isJSDocNamespaceBody = isJSDocNamespaceBody;
    /* @internal */
    function isNamedImportBindings(node) {
        var kind = node.kind;
        return kind === 269 /* SyntaxKind.NamedImports */
            || kind === 268 /* SyntaxKind.NamespaceImport */;
    }
    ts.isNamedImportBindings = isNamedImportBindings;
    /* @internal */
    function isModuleOrEnumDeclaration(node) {
        return node.kind === 261 /* SyntaxKind.ModuleDeclaration */ || node.kind === 260 /* SyntaxKind.EnumDeclaration */;
    }
    ts.isModuleOrEnumDeclaration = isModuleOrEnumDeclaration;
    function isDeclarationKind(kind) {
        return kind === 214 /* SyntaxKind.ArrowFunction */
            || kind === 203 /* SyntaxKind.BindingElement */
            || kind === 257 /* SyntaxKind.ClassDeclaration */
            || kind === 226 /* SyntaxKind.ClassExpression */
            || kind === 170 /* SyntaxKind.ClassStaticBlockDeclaration */
            || kind === 171 /* SyntaxKind.Constructor */
            || kind === 260 /* SyntaxKind.EnumDeclaration */
            || kind === 299 /* SyntaxKind.EnumMember */
            || kind === 275 /* SyntaxKind.ExportSpecifier */
            || kind === 256 /* SyntaxKind.FunctionDeclaration */
            || kind === 213 /* SyntaxKind.FunctionExpression */
            || kind === 172 /* SyntaxKind.GetAccessor */
            || kind === 267 /* SyntaxKind.ImportClause */
            || kind === 265 /* SyntaxKind.ImportEqualsDeclaration */
            || kind === 270 /* SyntaxKind.ImportSpecifier */
            || kind === 258 /* SyntaxKind.InterfaceDeclaration */
            || kind === 285 /* SyntaxKind.JsxAttribute */
            || kind === 169 /* SyntaxKind.MethodDeclaration */
            || kind === 168 /* SyntaxKind.MethodSignature */
            || kind === 261 /* SyntaxKind.ModuleDeclaration */
            || kind === 264 /* SyntaxKind.NamespaceExportDeclaration */
            || kind === 268 /* SyntaxKind.NamespaceImport */
            || kind === 274 /* SyntaxKind.NamespaceExport */
            || kind === 164 /* SyntaxKind.Parameter */
            || kind === 296 /* SyntaxKind.PropertyAssignment */
            || kind === 167 /* SyntaxKind.PropertyDeclaration */
            || kind === 166 /* SyntaxKind.PropertySignature */
            || kind === 173 /* SyntaxKind.SetAccessor */
            || kind === 297 /* SyntaxKind.ShorthandPropertyAssignment */
            || kind === 259 /* SyntaxKind.TypeAliasDeclaration */
            || kind === 163 /* SyntaxKind.TypeParameter */
            || kind === 254 /* SyntaxKind.VariableDeclaration */
            || kind === 345 /* SyntaxKind.JSDocTypedefTag */
            || kind === 338 /* SyntaxKind.JSDocCallbackTag */
            || kind === 347 /* SyntaxKind.JSDocPropertyTag */;
    }
    function isDeclarationStatementKind(kind) {
        return kind === 256 /* SyntaxKind.FunctionDeclaration */
            || kind === 276 /* SyntaxKind.MissingDeclaration */
            || kind === 257 /* SyntaxKind.ClassDeclaration */
            || kind === 258 /* SyntaxKind.InterfaceDeclaration */
            || kind === 259 /* SyntaxKind.TypeAliasDeclaration */
            || kind === 260 /* SyntaxKind.EnumDeclaration */
            || kind === 261 /* SyntaxKind.ModuleDeclaration */
            || kind === 266 /* SyntaxKind.ImportDeclaration */
            || kind === 265 /* SyntaxKind.ImportEqualsDeclaration */
            || kind === 272 /* SyntaxKind.ExportDeclaration */
            || kind === 271 /* SyntaxKind.ExportAssignment */
            || kind === 264 /* SyntaxKind.NamespaceExportDeclaration */;
    }
    function isStatementKindButNotDeclarationKind(kind) {
        return kind === 246 /* SyntaxKind.BreakStatement */
            || kind === 245 /* SyntaxKind.ContinueStatement */
            || kind === 253 /* SyntaxKind.DebuggerStatement */
            || kind === 240 /* SyntaxKind.DoStatement */
            || kind === 238 /* SyntaxKind.ExpressionStatement */
            || kind === 236 /* SyntaxKind.EmptyStatement */
            || kind === 243 /* SyntaxKind.ForInStatement */
            || kind === 244 /* SyntaxKind.ForOfStatement */
            || kind === 242 /* SyntaxKind.ForStatement */
            || kind === 239 /* SyntaxKind.IfStatement */
            || kind === 250 /* SyntaxKind.LabeledStatement */
            || kind === 247 /* SyntaxKind.ReturnStatement */
            || kind === 249 /* SyntaxKind.SwitchStatement */
            || kind === 251 /* SyntaxKind.ThrowStatement */
            || kind === 252 /* SyntaxKind.TryStatement */
            || kind === 237 /* SyntaxKind.VariableStatement */
            || kind === 241 /* SyntaxKind.WhileStatement */
            || kind === 248 /* SyntaxKind.WithStatement */
            || kind === 349 /* SyntaxKind.NotEmittedStatement */
            || kind === 353 /* SyntaxKind.EndOfDeclarationMarker */
            || kind === 352 /* SyntaxKind.MergeDeclarationMarker */;
    }
    /* @internal */
    function isDeclaration(node) {
        if (node.kind === 163 /* SyntaxKind.TypeParameter */) {
            return (node.parent && node.parent.kind !== 344 /* SyntaxKind.JSDocTemplateTag */) || ts.isInJSFile(node);
        }
        return isDeclarationKind(node.kind);
    }
    ts.isDeclaration = isDeclaration;
    /* @internal */
    function isDeclarationStatement(node) {
        return isDeclarationStatementKind(node.kind);
    }
    ts.isDeclarationStatement = isDeclarationStatement;
    /**
     * Determines whether the node is a statement that is not also a declaration
     */
    /* @internal */
    function isStatementButNotDeclaration(node) {
        return isStatementKindButNotDeclarationKind(node.kind);
    }
    ts.isStatementButNotDeclaration = isStatementButNotDeclaration;
    /* @internal */
    function isStatement(node) {
        var kind = node.kind;
        return isStatementKindButNotDeclarationKind(kind)
            || isDeclarationStatementKind(kind)
            || isBlockStatement(node);
    }
    ts.isStatement = isStatement;
    function isBlockStatement(node) {
        if (node.kind !== 235 /* SyntaxKind.Block */)
            return false;
        if (node.parent !== undefined) {
            if (node.parent.kind === 252 /* SyntaxKind.TryStatement */ || node.parent.kind === 292 /* SyntaxKind.CatchClause */) {
                return false;
            }
        }
        return !ts.isFunctionBlock(node);
    }
    /**
     * NOTE: This is similar to `isStatement` but does not access parent pointers.
     */
    /* @internal */
    function isStatementOrBlock(node) {
        var kind = node.kind;
        return isStatementKindButNotDeclarationKind(kind)
            || isDeclarationStatementKind(kind)
            || kind === 235 /* SyntaxKind.Block */;
    }
    ts.isStatementOrBlock = isStatementOrBlock;
    // Module references
    /* @internal */
    function isModuleReference(node) {
        var kind = node.kind;
        return kind === 277 /* SyntaxKind.ExternalModuleReference */
            || kind === 161 /* SyntaxKind.QualifiedName */
            || kind === 79 /* SyntaxKind.Identifier */;
    }
    ts.isModuleReference = isModuleReference;
    // JSX
    /* @internal */
    function isJsxTagNameExpression(node) {
        var kind = node.kind;
        return kind === 108 /* SyntaxKind.ThisKeyword */
            || kind === 79 /* SyntaxKind.Identifier */
            || kind === 206 /* SyntaxKind.PropertyAccessExpression */;
    }
    ts.isJsxTagNameExpression = isJsxTagNameExpression;
    /* @internal */
    function isJsxChild(node) {
        var kind = node.kind;
        return kind === 278 /* SyntaxKind.JsxElement */
            || kind === 288 /* SyntaxKind.JsxExpression */
            || kind === 279 /* SyntaxKind.JsxSelfClosingElement */
            || kind === 11 /* SyntaxKind.JsxText */
            || kind === 282 /* SyntaxKind.JsxFragment */;
    }
    ts.isJsxChild = isJsxChild;
    /* @internal */
    function isJsxAttributeLike(node) {
        var kind = node.kind;
        return kind === 285 /* SyntaxKind.JsxAttribute */
            || kind === 287 /* SyntaxKind.JsxSpreadAttribute */;
    }
    ts.isJsxAttributeLike = isJsxAttributeLike;
    /* @internal */
    function isStringLiteralOrJsxExpression(node) {
        var kind = node.kind;
        return kind === 10 /* SyntaxKind.StringLiteral */
            || kind === 288 /* SyntaxKind.JsxExpression */;
    }
    ts.isStringLiteralOrJsxExpression = isStringLiteralOrJsxExpression;
    function isJsxOpeningLikeElement(node) {
        var kind = node.kind;
        return kind === 280 /* SyntaxKind.JsxOpeningElement */
            || kind === 279 /* SyntaxKind.JsxSelfClosingElement */;
    }
    ts.isJsxOpeningLikeElement = isJsxOpeningLikeElement;
    // Clauses
    function isCaseOrDefaultClause(node) {
        var kind = node.kind;
        return kind === 289 /* SyntaxKind.CaseClause */
            || kind === 290 /* SyntaxKind.DefaultClause */;
    }
    ts.isCaseOrDefaultClause = isCaseOrDefaultClause;
    // JSDoc
    /** True if node is of some JSDoc syntax kind. */
    /* @internal */
    function isJSDocNode(node) {
        return node.kind >= 309 /* SyntaxKind.FirstJSDocNode */ && node.kind <= 347 /* SyntaxKind.LastJSDocNode */;
    }
    ts.isJSDocNode = isJSDocNode;
    /** True if node is of a kind that may contain comment text. */
    function isJSDocCommentContainingNode(node) {
        return node.kind === 320 /* SyntaxKind.JSDoc */
            || node.kind === 319 /* SyntaxKind.JSDocNamepathType */
            || node.kind === 321 /* SyntaxKind.JSDocText */
            || isJSDocLinkLike(node)
            || isJSDocTag(node)
            || ts.isJSDocTypeLiteral(node)
            || ts.isJSDocSignature(node);
    }
    ts.isJSDocCommentContainingNode = isJSDocCommentContainingNode;
    // TODO: determine what this does before making it public.
    /* @internal */
    function isJSDocTag(node) {
        return node.kind >= 327 /* SyntaxKind.FirstJSDocTagNode */ && node.kind <= 347 /* SyntaxKind.LastJSDocTagNode */;
    }
    ts.isJSDocTag = isJSDocTag;
    function isSetAccessor(node) {
        return node.kind === 173 /* SyntaxKind.SetAccessor */;
    }
    ts.isSetAccessor = isSetAccessor;
    function isGetAccessor(node) {
        return node.kind === 172 /* SyntaxKind.GetAccessor */;
    }
    ts.isGetAccessor = isGetAccessor;
    /** True if has jsdoc nodes attached to it. */
    /* @internal */
    // TODO: GH#19856 Would like to return `node is Node & { jsDoc: JSDoc[] }` but it causes long compile times
    function hasJSDocNodes(node) {
        var jsDoc = node.jsDoc;
        return !!jsDoc && jsDoc.length > 0;
    }
    ts.hasJSDocNodes = hasJSDocNodes;
    /** True if has type node attached to it. */
    /* @internal */
    function hasType(node) {
        return !!node.type;
    }
    ts.hasType = hasType;
    /** True if has initializer node attached to it. */
    /* @internal */
    function hasInitializer(node) {
        return !!node.initializer;
    }
    ts.hasInitializer = hasInitializer;
    /** True if has initializer node attached to it. */
    function hasOnlyExpressionInitializer(node) {
        switch (node.kind) {
            case 254 /* SyntaxKind.VariableDeclaration */:
            case 164 /* SyntaxKind.Parameter */:
            case 203 /* SyntaxKind.BindingElement */:
            case 167 /* SyntaxKind.PropertyDeclaration */:
            case 296 /* SyntaxKind.PropertyAssignment */:
            case 299 /* SyntaxKind.EnumMember */:
                return true;
            default:
                return false;
        }
    }
    ts.hasOnlyExpressionInitializer = hasOnlyExpressionInitializer;
    function isObjectLiteralElement(node) {
        return node.kind === 285 /* SyntaxKind.JsxAttribute */ || node.kind === 287 /* SyntaxKind.JsxSpreadAttribute */ || isObjectLiteralElementLike(node);
    }
    ts.isObjectLiteralElement = isObjectLiteralElement;
    /* @internal */
    function isTypeReferenceType(node) {
        return node.kind === 178 /* SyntaxKind.TypeReference */ || node.kind === 228 /* SyntaxKind.ExpressionWithTypeArguments */;
    }
    ts.isTypeReferenceType = isTypeReferenceType;
    var MAX_SMI_X86 = 1073741823;
    /* @internal */
    function guessIndentation(lines) {
        var indentation = MAX_SMI_X86;
        for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
            var line = lines_1[_i];
            if (!line.length) {
                continue;
            }
            var i = 0;
            for (; i < line.length && i < indentation; i++) {
                if (!ts.isWhiteSpaceLike(line.charCodeAt(i))) {
                    break;
                }
            }
            if (i < indentation) {
                indentation = i;
            }
            if (indentation === 0) {
                return 0;
            }
        }
        return indentation === MAX_SMI_X86 ? undefined : indentation;
    }
    ts.guessIndentation = guessIndentation;
    function isStringLiteralLike(node) {
        return node.kind === 10 /* SyntaxKind.StringLiteral */ || node.kind === 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */;
    }
    ts.isStringLiteralLike = isStringLiteralLike;
    function isJSDocLinkLike(node) {
        return node.kind === 324 /* SyntaxKind.JSDocLink */ || node.kind === 325 /* SyntaxKind.JSDocLinkCode */ || node.kind === 326 /* SyntaxKind.JSDocLinkPlain */;
    }
    ts.isJSDocLinkLike = isJSDocLinkLike;
    function hasRestParameter(s) {
        var last = ts.lastOrUndefined(s.parameters);
        return !!last && isRestParameter(last);
    }
    ts.hasRestParameter = hasRestParameter;
    function isRestParameter(node) {
        var type = ts.isJSDocParameterTag(node) ? (node.typeExpression && node.typeExpression.type) : node.type;
        return node.dotDotDotToken !== undefined || !!type && type.kind === 318 /* SyntaxKind.JSDocVariadicType */;
    }
    ts.isRestParameter = isRestParameter;
    // #endregion
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    ts.resolvingEmptyArray = [];
    ts.externalHelpersModuleNameText = "tslib";
    ts.defaultMaximumTruncationLength = 160;
    ts.noTruncationMaximumTruncationLength = 1000000;
    function getDeclarationOfKind(symbol, kind) {
        var declarations = symbol.declarations;
        if (declarations) {
            for (var _i = 0, declarations_1 = declarations; _i < declarations_1.length; _i++) {
                var declaration = declarations_1[_i];
                if (declaration.kind === kind) {
                    return declaration;
                }
            }
        }
        return undefined;
    }
    ts.getDeclarationOfKind = getDeclarationOfKind;
    function getDeclarationsOfKind(symbol, kind) {
        return ts.filter(symbol.declarations || ts.emptyArray, function (d) { return d.kind === kind; });
    }
    ts.getDeclarationsOfKind = getDeclarationsOfKind;
    function createSymbolTable(symbols) {
        var result = new ts.Map();
        if (symbols) {
            for (var _i = 0, symbols_1 = symbols; _i < symbols_1.length; _i++) {
                var symbol = symbols_1[_i];
                result.set(symbol.escapedName, symbol);
            }
        }
        return result;
    }
    ts.createSymbolTable = createSymbolTable;
    function isTransientSymbol(symbol) {
        return (symbol.flags & 33554432 /* SymbolFlags.Transient */) !== 0;
    }
    ts.isTransientSymbol = isTransientSymbol;
    var stringWriter = createSingleLineStringWriter();
    function createSingleLineStringWriter() {
        var str = "";
        var writeText = function (text) { return str += text; };
        return {
            getText: function () { return str; },
            write: writeText,
            rawWrite: writeText,
            writeKeyword: writeText,
            writeOperator: writeText,
            writePunctuation: writeText,
            writeSpace: writeText,
            writeStringLiteral: writeText,
            writeLiteral: writeText,
            writeParameter: writeText,
            writeProperty: writeText,
            writeSymbol: function (s, _) { return writeText(s); },
            writeTrailingSemicolon: writeText,
            writeComment: writeText,
            getTextPos: function () { return str.length; },
            getLine: function () { return 0; },
            getColumn: function () { return 0; },
            getIndent: function () { return 0; },
            isAtStartOfLine: function () { return false; },
            hasTrailingComment: function () { return false; },
            hasTrailingWhitespace: function () { return !!str.length && ts.isWhiteSpaceLike(str.charCodeAt(str.length - 1)); },
            // Completely ignore indentation for string writers.  And map newlines to
            // a single space.
            writeLine: function () { return str += " "; },
            increaseIndent: ts.noop,
            decreaseIndent: ts.noop,
            clear: function () { return str = ""; },
            trackSymbol: function () { return false; },
            reportInaccessibleThisError: ts.noop,
            reportInaccessibleUniqueSymbolError: ts.noop,
            reportPrivateInBaseOfClassExpression: ts.noop,
        };
    }
    function changesAffectModuleResolution(oldOptions, newOptions) {
        return oldOptions.configFilePath !== newOptions.configFilePath ||
            optionsHaveModuleResolutionChanges(oldOptions, newOptions);
    }
    ts.changesAffectModuleResolution = changesAffectModuleResolution;
    function optionsHaveModuleResolutionChanges(oldOptions, newOptions) {
        return optionsHaveChanges(oldOptions, newOptions, ts.moduleResolutionOptionDeclarations);
    }
    ts.optionsHaveModuleResolutionChanges = optionsHaveModuleResolutionChanges;
    function changesAffectingProgramStructure(oldOptions, newOptions) {
        return optionsHaveChanges(oldOptions, newOptions, ts.optionsAffectingProgramStructure);
    }
    ts.changesAffectingProgramStructure = changesAffectingProgramStructure;
    function optionsHaveChanges(oldOptions, newOptions, optionDeclarations) {
        return oldOptions !== newOptions && optionDeclarations.some(function (o) {
            return !isJsonEqual(getCompilerOptionValue(oldOptions, o), getCompilerOptionValue(newOptions, o));
        });
    }
    ts.optionsHaveChanges = optionsHaveChanges;
    function forEachAncestor(node, callback) {
        while (true) {
            var res = callback(node);
            if (res === "quit")
                return undefined;
            if (res !== undefined)
                return res;
            if (ts.isSourceFile(node))
                return undefined;
            node = node.parent;
        }
    }
    ts.forEachAncestor = forEachAncestor;
    /**
     * Calls `callback` for each entry in the map, returning the first truthy result.
     * Use `map.forEach` instead for normal iteration.
     */
    function forEachEntry(map, callback) {
        var iterator = map.entries();
        for (var iterResult = iterator.next(); !iterResult.done; iterResult = iterator.next()) {
            var _a = iterResult.value, key = _a[0], value = _a[1];
            var result = callback(value, key);
            if (result) {
                return result;
            }
        }
        return undefined;
    }
    ts.forEachEntry = forEachEntry;
    /** `forEachEntry` for just keys. */
    function forEachKey(map, callback) {
        var iterator = map.keys();
        for (var iterResult = iterator.next(); !iterResult.done; iterResult = iterator.next()) {
            var result = callback(iterResult.value);
            if (result) {
                return result;
            }
        }
        return undefined;
    }
    ts.forEachKey = forEachKey;
    /** Copy entries from `source` to `target`. */
    function copyEntries(source, target) {
        source.forEach(function (value, key) {
            target.set(key, value);
        });
    }
    ts.copyEntries = copyEntries;
    function usingSingleLineStringWriter(action) {
        var oldString = stringWriter.getText();
        try {
            action(stringWriter);
            return stringWriter.getText();
        }
        finally {
            stringWriter.clear();
            stringWriter.writeKeyword(oldString);
        }
    }
    ts.usingSingleLineStringWriter = usingSingleLineStringWriter;
    function getFullWidth(node) {
        return node.end - node.pos;
    }
    ts.getFullWidth = getFullWidth;
    function getResolvedModule(sourceFile, moduleNameText, mode) {
        return sourceFile && sourceFile.resolvedModules && sourceFile.resolvedModules.get(moduleNameText, mode);
    }
    ts.getResolvedModule = getResolvedModule;
    function setResolvedModule(sourceFile, moduleNameText, resolvedModule, mode) {
        if (!sourceFile.resolvedModules) {
            sourceFile.resolvedModules = ts.createModeAwareCache();
        }
        sourceFile.resolvedModules.set(moduleNameText, mode, resolvedModule);
    }
    ts.setResolvedModule = setResolvedModule;
    function setResolvedTypeReferenceDirective(sourceFile, typeReferenceDirectiveName, resolvedTypeReferenceDirective) {
        if (!sourceFile.resolvedTypeReferenceDirectiveNames) {
            sourceFile.resolvedTypeReferenceDirectiveNames = ts.createModeAwareCache();
        }
        sourceFile.resolvedTypeReferenceDirectiveNames.set(typeReferenceDirectiveName, /*mode*/ undefined, resolvedTypeReferenceDirective);
    }
    ts.setResolvedTypeReferenceDirective = setResolvedTypeReferenceDirective;
    function projectReferenceIsEqualTo(oldRef, newRef) {
        return oldRef.path === newRef.path &&
            !oldRef.prepend === !newRef.prepend &&
            !oldRef.circular === !newRef.circular;
    }
    ts.projectReferenceIsEqualTo = projectReferenceIsEqualTo;
    function moduleResolutionIsEqualTo(oldResolution, newResolution) {
        return oldResolution.isExternalLibraryImport === newResolution.isExternalLibraryImport &&
            oldResolution.extension === newResolution.extension &&
            oldResolution.resolvedFileName === newResolution.resolvedFileName &&
            oldResolution.originalPath === newResolution.originalPath &&
            packageIdIsEqual(oldResolution.packageId, newResolution.packageId);
    }
    ts.moduleResolutionIsEqualTo = moduleResolutionIsEqualTo;
    function packageIdIsEqual(a, b) {
        return a === b || !!a && !!b && a.name === b.name && a.subModuleName === b.subModuleName && a.version === b.version;
    }
    function packageIdToPackageName(_a) {
        var name = _a.name, subModuleName = _a.subModuleName;
        return subModuleName ? "".concat(name, "/").concat(subModuleName) : name;
    }
    ts.packageIdToPackageName = packageIdToPackageName;
    function packageIdToString(packageId) {
        return "".concat(packageIdToPackageName(packageId), "@").concat(packageId.version);
    }
    ts.packageIdToString = packageIdToString;
    function typeDirectiveIsEqualTo(oldResolution, newResolution) {
        return oldResolution.resolvedFileName === newResolution.resolvedFileName
            && oldResolution.primary === newResolution.primary
            && oldResolution.originalPath === newResolution.originalPath;
    }
    ts.typeDirectiveIsEqualTo = typeDirectiveIsEqualTo;
    function hasChangesInResolutions(names, newResolutions, oldResolutions, oldSourceFile, comparer) {
        ts.Debug.assert(names.length === newResolutions.length);
        for (var i = 0; i < names.length; i++) {
            var newResolution = newResolutions[i];
            var entry = names[i];
            // We lower-case all type references because npm automatically lowercases all packages. See GH#9824.
            var name = !ts.isString(entry) ? entry.fileName.toLowerCase() : entry;
            var mode = !ts.isString(entry) ? ts.getModeForFileReference(entry, oldSourceFile === null || oldSourceFile === void 0 ? void 0 : oldSourceFile.impliedNodeFormat) : oldSourceFile && ts.getModeForResolutionAtIndex(oldSourceFile, i);
            var oldResolution = oldResolutions && oldResolutions.get(name, mode);
            var changed = oldResolution
                ? !newResolution || !comparer(oldResolution, newResolution)
                : newResolution;
            if (changed) {
                return true;
            }
        }
        return false;
    }
    ts.hasChangesInResolutions = hasChangesInResolutions;
    // Returns true if this node contains a parse error anywhere underneath it.
    function containsParseError(node) {
        aggregateChildData(node);
        return (node.flags & 524288 /* NodeFlags.ThisNodeOrAnySubNodesHasError */) !== 0;
    }
    ts.containsParseError = containsParseError;
    function aggregateChildData(node) {
        if (!(node.flags & 1048576 /* NodeFlags.HasAggregatedChildData */)) {
            // A node is considered to contain a parse error if:
            //  a) the parser explicitly marked that it had an error
            //  b) any of it's children reported that it had an error.
            var thisNodeOrAnySubNodesHasError = ((node.flags & 131072 /* NodeFlags.ThisNodeHasError */) !== 0) ||
                ts.forEachChild(node, containsParseError);
            // If so, mark ourselves accordingly.
            if (thisNodeOrAnySubNodesHasError) {
                node.flags |= 524288 /* NodeFlags.ThisNodeOrAnySubNodesHasError */;
            }
            // Also mark that we've propagated the child information to this node.  This way we can
            // always consult the bit directly on this node without needing to check its children
            // again.
            node.flags |= 1048576 /* NodeFlags.HasAggregatedChildData */;
        }
    }
    function getSourceFileOfNode(node) {
        while (node && node.kind !== 305 /* SyntaxKind.SourceFile */) {
            node = node.parent;
        }
        return node;
    }
    ts.getSourceFileOfNode = getSourceFileOfNode;
    function getSourceFileOfModule(module) {
        return getSourceFileOfNode(module.valueDeclaration || getNonAugmentationDeclaration(module));
    }
    ts.getSourceFileOfModule = getSourceFileOfModule;
    function isPlainJsFile(file, checkJs) {
        return !!file && (file.scriptKind === 1 /* ScriptKind.JS */ || file.scriptKind === 2 /* ScriptKind.JSX */) && !file.checkJsDirective && checkJs === undefined;
    }
    ts.isPlainJsFile = isPlainJsFile;
    function isStatementWithLocals(node) {
        switch (node.kind) {
            case 235 /* SyntaxKind.Block */:
            case 263 /* SyntaxKind.CaseBlock */:
            case 242 /* SyntaxKind.ForStatement */:
            case 243 /* SyntaxKind.ForInStatement */:
            case 244 /* SyntaxKind.ForOfStatement */:
                return true;
        }
        return false;
    }
    ts.isStatementWithLocals = isStatementWithLocals;
    function getStartPositionOfLine(line, sourceFile) {
        ts.Debug.assert(line >= 0);
        return ts.getLineStarts(sourceFile)[line];
    }
    ts.getStartPositionOfLine = getStartPositionOfLine;
    // This is a useful function for debugging purposes.
    function nodePosToString(node) {
        var file = getSourceFileOfNode(node);
        var loc = ts.getLineAndCharacterOfPosition(file, node.pos);
        return "".concat(file.fileName, "(").concat(loc.line + 1, ",").concat(loc.character + 1, ")");
    }
    ts.nodePosToString = nodePosToString;
    function getEndLinePosition(line, sourceFile) {
        ts.Debug.assert(line >= 0);
        var lineStarts = ts.getLineStarts(sourceFile);
        var lineIndex = line;
        var sourceText = sourceFile.text;
        if (lineIndex + 1 === lineStarts.length) {
            // last line - return EOF
            return sourceText.length - 1;
        }
        else {
            // current line start
            var start = lineStarts[lineIndex];
            // take the start position of the next line - 1 = it should be some line break
            var pos = lineStarts[lineIndex + 1] - 1;
            ts.Debug.assert(ts.isLineBreak(sourceText.charCodeAt(pos)));
            // walk backwards skipping line breaks, stop the the beginning of current line.
            // i.e:
            // <some text>
            // $ <- end of line for this position should match the start position
            while (start <= pos && ts.isLineBreak(sourceText.charCodeAt(pos))) {
                pos--;
            }
            return pos;
        }
    }
    ts.getEndLinePosition = getEndLinePosition;
    /**
     * Returns a value indicating whether a name is unique globally or within the current file.
     * Note: This does not consider whether a name appears as a free identifier or not, so at the expression `x.y` this includes both `x` and `y`.
     */
    function isFileLevelUniqueName(sourceFile, name, hasGlobalName) {
        return !(hasGlobalName && hasGlobalName(name)) && !sourceFile.identifiers.has(name);
    }
    ts.isFileLevelUniqueName = isFileLevelUniqueName;
    // Returns true if this node is missing from the actual source code. A 'missing' node is different
    // from 'undefined/defined'. When a node is undefined (which can happen for optional nodes
    // in the tree), it is definitely missing. However, a node may be defined, but still be
    // missing.  This happens whenever the parser knows it needs to parse something, but can't
    // get anything in the source code that it expects at that location. For example:
    //
    //          let a: ;
    //
    // Here, the Type in the Type-Annotation is not-optional (as there is a colon in the source
    // code). So the parser will attempt to parse out a type, and will create an actual node.
    // However, this node will be 'missing' in the sense that no actual source-code/tokens are
    // contained within it.
    function nodeIsMissing(node) {
        if (node === undefined) {
            return true;
        }
        return node.pos === node.end && node.pos >= 0 && node.kind !== 1 /* SyntaxKind.EndOfFileToken */;
    }
    ts.nodeIsMissing = nodeIsMissing;
    function nodeIsPresent(node) {
        return !nodeIsMissing(node);
    }
    ts.nodeIsPresent = nodeIsPresent;
    function insertStatementsAfterPrologue(to, from, isPrologueDirective) {
        if (from === undefined || from.length === 0)
            return to;
        var statementIndex = 0;
        // skip all prologue directives to insert at the correct position
        for (; statementIndex < to.length; ++statementIndex) {
            if (!isPrologueDirective(to[statementIndex])) {
                break;
            }
        }
        to.splice.apply(to, __spreadArray([statementIndex, 0], from, false));
        return to;
    }
    function insertStatementAfterPrologue(to, statement, isPrologueDirective) {
        if (statement === undefined)
            return to;
        var statementIndex = 0;
        // skip all prologue directives to insert at the correct position
        for (; statementIndex < to.length; ++statementIndex) {
            if (!isPrologueDirective(to[statementIndex])) {
                break;
            }
        }
        to.splice(statementIndex, 0, statement);
        return to;
    }
    function isAnyPrologueDirective(node) {
        return isPrologueDirective(node) || !!(getEmitFlags(node) & 1048576 /* EmitFlags.CustomPrologue */);
    }
    /**
     * Prepends statements to an array while taking care of prologue directives.
     */
    function insertStatementsAfterStandardPrologue(to, from) {
        return insertStatementsAfterPrologue(to, from, isPrologueDirective);
    }
    ts.insertStatementsAfterStandardPrologue = insertStatementsAfterStandardPrologue;
    function insertStatementsAfterCustomPrologue(to, from) {
        return insertStatementsAfterPrologue(to, from, isAnyPrologueDirective);
    }
    ts.insertStatementsAfterCustomPrologue = insertStatementsAfterCustomPrologue;
    /**
     * Prepends statements to an array while taking care of prologue directives.
     */
    function insertStatementAfterStandardPrologue(to, statement) {
        return insertStatementAfterPrologue(to, statement, isPrologueDirective);
    }
    ts.insertStatementAfterStandardPrologue = insertStatementAfterStandardPrologue;
    function insertStatementAfterCustomPrologue(to, statement) {
        return insertStatementAfterPrologue(to, statement, isAnyPrologueDirective);
    }
    ts.insertStatementAfterCustomPrologue = insertStatementAfterCustomPrologue;
    /**
     * Determine if the given comment is a triple-slash
     *
     * @return true if the comment is a triple-slash comment else false
     */
    function isRecognizedTripleSlashComment(text, commentPos, commentEnd) {
        // Verify this is /// comment, but do the regexp match only when we first can find /// in the comment text
        // so that we don't end up computing comment string and doing match for all // comments
        if (text.charCodeAt(commentPos + 1) === 47 /* CharacterCodes.slash */ &&
            commentPos + 2 < commentEnd &&
            text.charCodeAt(commentPos + 2) === 47 /* CharacterCodes.slash */) {
            var textSubStr = text.substring(commentPos, commentEnd);
            return ts.fullTripleSlashReferencePathRegEx.test(textSubStr) ||
                ts.fullTripleSlashAMDReferencePathRegEx.test(textSubStr) ||
                fullTripleSlashReferenceTypeReferenceDirectiveRegEx.test(textSubStr) ||
                defaultLibReferenceRegEx.test(textSubStr) ?
                true : false;
        }
        return false;
    }
    ts.isRecognizedTripleSlashComment = isRecognizedTripleSlashComment;
    function isPinnedComment(text, start) {
        return text.charCodeAt(start + 1) === 42 /* CharacterCodes.asterisk */ &&
            text.charCodeAt(start + 2) === 33 /* CharacterCodes.exclamation */;
    }
    ts.isPinnedComment = isPinnedComment;
    function createCommentDirectivesMap(sourceFile, commentDirectives) {
        var directivesByLine = new ts.Map(commentDirectives.map(function (commentDirective) { return ([
            "".concat(ts.getLineAndCharacterOfPosition(sourceFile, commentDirective.range.end).line),
            commentDirective,
        ]); }));
        var usedLines = new ts.Map();
        return { getUnusedExpectations: getUnusedExpectations, markUsed: markUsed };
        function getUnusedExpectations() {
            return ts.arrayFrom(directivesByLine.entries())
                .filter(function (_a) {
                var line = _a[0], directive = _a[1];
                return directive.type === 0 /* CommentDirectiveType.ExpectError */ && !usedLines.get(line);
            })
                .map(function (_a) {
                var _ = _a[0], directive = _a[1];
                return directive;
            });
        }
        function markUsed(line) {
            if (!directivesByLine.has("".concat(line))) {
                return false;
            }
            usedLines.set("".concat(line), true);
            return true;
        }
    }
    ts.createCommentDirectivesMap = createCommentDirectivesMap;
    function getTokenPosOfNode(node, sourceFile, includeJsDoc) {
        // With nodes that have no width (i.e. 'Missing' nodes), we actually *don't*
        // want to skip trivia because this will launch us forward to the next token.
        if (nodeIsMissing(node)) {
            return node.pos;
        }
        if (ts.isJSDocNode(node) || node.kind === 11 /* SyntaxKind.JsxText */) {
            // JsxText cannot actually contain comments, even though the scanner will think it sees comments
            return ts.skipTrivia((sourceFile || getSourceFileOfNode(node)).text, node.pos, /*stopAfterLineBreak*/ false, /*stopAtComments*/ true);
        }
        if (includeJsDoc && ts.hasJSDocNodes(node)) {
            return getTokenPosOfNode(node.jsDoc[0], sourceFile);
        }
        // For a syntax list, it is possible that one of its children has JSDocComment nodes, while
        // the syntax list itself considers them as normal trivia. Therefore if we simply skip
        // trivia for the list, we may have skipped the JSDocComment as well. So we should process its
        // first child to determine the actual position of its first token.
        if (node.kind === 348 /* SyntaxKind.SyntaxList */ && node._children.length > 0) {
            return getTokenPosOfNode(node._children[0], sourceFile, includeJsDoc);
        }
        return ts.skipTrivia((sourceFile || getSourceFileOfNode(node)).text, node.pos, 
        /*stopAfterLineBreak*/ false, 
        /*stopAtComments*/ false, isInJSDoc(node));
    }
    ts.getTokenPosOfNode = getTokenPosOfNode;
    function getNonDecoratorTokenPosOfNode(node, sourceFile) {
        var lastDecorator = !nodeIsMissing(node) && ts.canHaveModifiers(node) ? ts.findLast(node.modifiers, ts.isDecorator) : undefined;
        if (!lastDecorator) {
            return getTokenPosOfNode(node, sourceFile);
        }
        return ts.skipTrivia((sourceFile || getSourceFileOfNode(node)).text, lastDecorator.end);
    }
    ts.getNonDecoratorTokenPosOfNode = getNonDecoratorTokenPosOfNode;
    function getSourceTextOfNodeFromSourceFile(sourceFile, node, includeTrivia) {
        if (includeTrivia === void 0) { includeTrivia = false; }
        return getTextOfNodeFromSourceText(sourceFile.text, node, includeTrivia);
    }
    ts.getSourceTextOfNodeFromSourceFile = getSourceTextOfNodeFromSourceFile;
    function isJSDocTypeExpressionOrChild(node) {
        return !!ts.findAncestor(node, ts.isJSDocTypeExpression);
    }
    function isExportNamespaceAsDefaultDeclaration(node) {
        return !!(ts.isExportDeclaration(node) && node.exportClause && ts.isNamespaceExport(node.exportClause) && node.exportClause.name.escapedText === "default");
    }
    ts.isExportNamespaceAsDefaultDeclaration = isExportNamespaceAsDefaultDeclaration;
    function getTextOfNodeFromSourceText(sourceText, node, includeTrivia) {
        if (includeTrivia === void 0) { includeTrivia = false; }
        if (nodeIsMissing(node)) {
            return "";
        }
        var text = sourceText.substring(includeTrivia ? node.pos : ts.skipTrivia(sourceText, node.pos), node.end);
        if (isJSDocTypeExpressionOrChild(node)) {
            // strip space + asterisk at line start
            text = text.split(/\r\n|\n|\r/).map(function (line) { return ts.trimStringStart(line.replace(/^\s*\*/, "")); }).join("\n");
        }
        return text;
    }
    ts.getTextOfNodeFromSourceText = getTextOfNodeFromSourceText;
    function getTextOfNode(node, includeTrivia) {
        if (includeTrivia === void 0) { includeTrivia = false; }
        return getSourceTextOfNodeFromSourceFile(getSourceFileOfNode(node), node, includeTrivia);
    }
    ts.getTextOfNode = getTextOfNode;
    function getPos(range) {
        return range.pos;
    }
    /**
     * Note: it is expected that the `nodeArray` and the `node` are within the same file.
     * For example, searching for a `SourceFile` in a `SourceFile[]` wouldn't work.
     */
    function indexOfNode(nodeArray, node) {
        return ts.binarySearch(nodeArray, node, getPos, ts.compareValues);
    }
    ts.indexOfNode = indexOfNode;
    /**
     * Gets flags that control emit behavior of a node.
     */
    function getEmitFlags(node) {
        var emitNode = node.emitNode;
        return emitNode && emitNode.flags || 0;
    }
    ts.getEmitFlags = getEmitFlags;
    ;
    function getScriptTargetFeatures() {
        return {
            es2015: {
                Array: ["find", "findIndex", "fill", "copyWithin", "entries", "keys", "values"],
                RegExp: ["flags", "sticky", "unicode"],
                Reflect: ["apply", "construct", "defineProperty", "deleteProperty", "get", " getOwnPropertyDescriptor", "getPrototypeOf", "has", "isExtensible", "ownKeys", "preventExtensions", "set", "setPrototypeOf"],
                ArrayConstructor: ["from", "of"],
                ObjectConstructor: ["assign", "getOwnPropertySymbols", "keys", "is", "setPrototypeOf"],
                NumberConstructor: ["isFinite", "isInteger", "isNaN", "isSafeInteger", "parseFloat", "parseInt"],
                Math: ["clz32", "imul", "sign", "log10", "log2", "log1p", "expm1", "cosh", "sinh", "tanh", "acosh", "asinh", "atanh", "hypot", "trunc", "fround", "cbrt"],
                Map: ["entries", "keys", "values"],
                Set: ["entries", "keys", "values"],
                Promise: ts.emptyArray,
                PromiseConstructor: ["all", "race", "reject", "resolve"],
                Symbol: ["for", "keyFor"],
                WeakMap: ["entries", "keys", "values"],
                WeakSet: ["entries", "keys", "values"],
                Iterator: ts.emptyArray,
                AsyncIterator: ts.emptyArray,
                String: ["codePointAt", "includes", "endsWith", "normalize", "repeat", "startsWith", "anchor", "big", "blink", "bold", "fixed", "fontcolor", "fontsize", "italics", "link", "small", "strike", "sub", "sup"],
                StringConstructor: ["fromCodePoint", "raw"]
            },
            es2016: {
                Array: ["includes"]
            },
            es2017: {
                Atomics: ts.emptyArray,
                SharedArrayBuffer: ts.emptyArray,
                String: ["padStart", "padEnd"],
                ObjectConstructor: ["values", "entries", "getOwnPropertyDescriptors"],
                DateTimeFormat: ["formatToParts"]
            },
            es2018: {
                Promise: ["finally"],
                RegExpMatchArray: ["groups"],
                RegExpExecArray: ["groups"],
                RegExp: ["dotAll"],
                Intl: ["PluralRules"],
                AsyncIterable: ts.emptyArray,
                AsyncIterableIterator: ts.emptyArray,
                AsyncGenerator: ts.emptyArray,
                AsyncGeneratorFunction: ts.emptyArray,
                NumberFormat: ["formatToParts"]
            },
            es2019: {
                Array: ["flat", "flatMap"],
                ObjectConstructor: ["fromEntries"],
                String: ["trimStart", "trimEnd", "trimLeft", "trimRight"],
                Symbol: ["description"]
            },
            es2020: {
                BigInt: ts.emptyArray,
                BigInt64Array: ts.emptyArray,
                BigUint64Array: ts.emptyArray,
                PromiseConstructor: ["allSettled"],
                SymbolConstructor: ["matchAll"],
                String: ["matchAll"],
                DataView: ["setBigInt64", "setBigUint64", "getBigInt64", "getBigUint64"],
                RelativeTimeFormat: ["format", "formatToParts", "resolvedOptions"]
            },
            es2021: {
                PromiseConstructor: ["any"],
                String: ["replaceAll"]
            },
            es2022: {
                Array: ["at"],
                String: ["at"],
                Int8Array: ["at"],
                Uint8Array: ["at"],
                Uint8ClampedArray: ["at"],
                Int16Array: ["at"],
                Uint16Array: ["at"],
                Int32Array: ["at"],
                Uint32Array: ["at"],
                Float32Array: ["at"],
                Float64Array: ["at"],
                BigInt64Array: ["at"],
                BigUint64Array: ["at"],
                ObjectConstructor: ["hasOwn"],
                Error: ["cause"]
            }
        };
    }
    ts.getScriptTargetFeatures = getScriptTargetFeatures;
    var GetLiteralTextFlags;
    (function (GetLiteralTextFlags) {
        GetLiteralTextFlags[GetLiteralTextFlags["None"] = 0] = "None";
        GetLiteralTextFlags[GetLiteralTextFlags["NeverAsciiEscape"] = 1] = "NeverAsciiEscape";
        GetLiteralTextFlags[GetLiteralTextFlags["JsxAttributeEscape"] = 2] = "JsxAttributeEscape";
        GetLiteralTextFlags[GetLiteralTextFlags["TerminateUnterminatedLiterals"] = 4] = "TerminateUnterminatedLiterals";
        GetLiteralTextFlags[GetLiteralTextFlags["AllowNumericSeparator"] = 8] = "AllowNumericSeparator";
    })(GetLiteralTextFlags = ts.GetLiteralTextFlags || (ts.GetLiteralTextFlags = {}));
    function getLiteralText(node, sourceFile, flags) {
        var _a;
        // If we don't need to downlevel and we can reach the original source text using
        // the node's parent reference, then simply get the text as it was originally written.
        if (sourceFile && canUseOriginalText(node, flags)) {
            return getSourceTextOfNodeFromSourceFile(sourceFile, node);
        }
        // If we can't reach the original source text, use the canonical form if it's a number,
        // or a (possibly escaped) quoted form of the original text if it's string-like.
        switch (node.kind) {
            case 10 /* SyntaxKind.StringLiteral */: {
                var escapeText = flags & 2 /* GetLiteralTextFlags.JsxAttributeEscape */ ? escapeJsxAttributeString :
                    flags & 1 /* GetLiteralTextFlags.NeverAsciiEscape */ || (getEmitFlags(node) & 16777216 /* EmitFlags.NoAsciiEscaping */) ? escapeString :
                        escapeNonAsciiString;
                if (node.singleQuote) {
                    return "'" + escapeText(node.text, 39 /* CharacterCodes.singleQuote */) + "'";
                }
                else {
                    return '"' + escapeText(node.text, 34 /* CharacterCodes.doubleQuote */) + '"';
                }
            }
            case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
            case 15 /* SyntaxKind.TemplateHead */:
            case 16 /* SyntaxKind.TemplateMiddle */:
            case 17 /* SyntaxKind.TemplateTail */: {
                // If a NoSubstitutionTemplateLiteral appears to have a substitution in it, the original text
                // had to include a backslash: `not \${a} substitution`.
                var escapeText = flags & 1 /* GetLiteralTextFlags.NeverAsciiEscape */ || (getEmitFlags(node) & 16777216 /* EmitFlags.NoAsciiEscaping */) ? escapeString :
                    escapeNonAsciiString;
                var rawText = (_a = node.rawText) !== null && _a !== void 0 ? _a : escapeTemplateSubstitution(escapeText(node.text, 96 /* CharacterCodes.backtick */));
                switch (node.kind) {
                    case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                        return "`" + rawText + "`";
                    case 15 /* SyntaxKind.TemplateHead */:
                        return "`" + rawText + "${";
                    case 16 /* SyntaxKind.TemplateMiddle */:
                        return "}" + rawText + "${";
                    case 17 /* SyntaxKind.TemplateTail */:
                        return "}" + rawText + "`";
                }
                break;
            }
            case 8 /* SyntaxKind.NumericLiteral */:
            case 9 /* SyntaxKind.BigIntLiteral */:
                return node.text;
            case 13 /* SyntaxKind.RegularExpressionLiteral */:
                if (flags & 4 /* GetLiteralTextFlags.TerminateUnterminatedLiterals */ && node.isUnterminated) {
                    return node.text + (node.text.charCodeAt(node.text.length - 1) === 92 /* CharacterCodes.backslash */ ? " /" : "/");
                }
                return node.text;
        }
        return ts.Debug.fail("Literal kind '".concat(node.kind, "' not accounted for."));
    }
    ts.getLiteralText = getLiteralText;
    function canUseOriginalText(node, flags) {
        if (nodeIsSynthesized(node) || !node.parent || (flags & 4 /* GetLiteralTextFlags.TerminateUnterminatedLiterals */ && node.isUnterminated)) {
            return false;
        }
        if (ts.isNumericLiteral(node) && node.numericLiteralFlags & 512 /* TokenFlags.ContainsSeparator */) {
            return !!(flags & 8 /* GetLiteralTextFlags.AllowNumericSeparator */);
        }
        return !ts.isBigIntLiteral(node);
    }
    function getTextOfConstantValue(value) {
        return ts.isString(value) ? '"' + escapeNonAsciiString(value) + '"' : "" + value;
    }
    ts.getTextOfConstantValue = getTextOfConstantValue;
    // Make an identifier from an external module name by extracting the string after the last "/" and replacing
    // all non-alphanumeric characters with underscores
    function makeIdentifierFromModuleName(moduleName) {
        return ts.getBaseFileName(moduleName).replace(/^(\d)/, "_$1").replace(/\W/g, "_");
    }
    ts.makeIdentifierFromModuleName = makeIdentifierFromModuleName;
    function isBlockOrCatchScoped(declaration) {
        return (ts.getCombinedNodeFlags(declaration) & 3 /* NodeFlags.BlockScoped */) !== 0 ||
            isCatchClauseVariableDeclarationOrBindingElement(declaration);
    }
    ts.isBlockOrCatchScoped = isBlockOrCatchScoped;
    function isCatchClauseVariableDeclarationOrBindingElement(declaration) {
        var node = getRootDeclaration(declaration);
        return node.kind === 254 /* SyntaxKind.VariableDeclaration */ && node.parent.kind === 292 /* SyntaxKind.CatchClause */;
    }
    ts.isCatchClauseVariableDeclarationOrBindingElement = isCatchClauseVariableDeclarationOrBindingElement;
    function isAmbientModule(node) {
        return ts.isModuleDeclaration(node) && (node.name.kind === 10 /* SyntaxKind.StringLiteral */ || isGlobalScopeAugmentation(node));
    }
    ts.isAmbientModule = isAmbientModule;
    function isModuleWithStringLiteralName(node) {
        return ts.isModuleDeclaration(node) && node.name.kind === 10 /* SyntaxKind.StringLiteral */;
    }
    ts.isModuleWithStringLiteralName = isModuleWithStringLiteralName;
    function isNonGlobalAmbientModule(node) {
        return ts.isModuleDeclaration(node) && ts.isStringLiteral(node.name);
    }
    ts.isNonGlobalAmbientModule = isNonGlobalAmbientModule;
    /**
     * An effective module (namespace) declaration is either
     * 1. An actual declaration: namespace X { ... }
     * 2. A Javascript declaration, which is:
     *    An identifier in a nested property access expression: Y in `X.Y.Z = { ... }`
     */
    function isEffectiveModuleDeclaration(node) {
        return ts.isModuleDeclaration(node) || ts.isIdentifier(node);
    }
    ts.isEffectiveModuleDeclaration = isEffectiveModuleDeclaration;
    /** Given a symbol for a module, checks that it is a shorthand ambient module. */
    function isShorthandAmbientModuleSymbol(moduleSymbol) {
        return isShorthandAmbientModule(moduleSymbol.valueDeclaration);
    }
    ts.isShorthandAmbientModuleSymbol = isShorthandAmbientModuleSymbol;
    function isShorthandAmbientModule(node) {
        // The only kind of module that can be missing a body is a shorthand ambient module.
        return !!node && node.kind === 261 /* SyntaxKind.ModuleDeclaration */ && (!node.body);
    }
    function isBlockScopedContainerTopLevel(node) {
        return node.kind === 305 /* SyntaxKind.SourceFile */ ||
            node.kind === 261 /* SyntaxKind.ModuleDeclaration */ ||
            ts.isFunctionLikeOrClassStaticBlockDeclaration(node);
    }
    ts.isBlockScopedContainerTopLevel = isBlockScopedContainerTopLevel;
    function isGlobalScopeAugmentation(module) {
        return !!(module.flags & 1024 /* NodeFlags.GlobalAugmentation */);
    }
    ts.isGlobalScopeAugmentation = isGlobalScopeAugmentation;
    function isExternalModuleAugmentation(node) {
        return isAmbientModule(node) && isModuleAugmentationExternal(node);
    }
    ts.isExternalModuleAugmentation = isExternalModuleAugmentation;
    function isModuleAugmentationExternal(node) {
        // external module augmentation is a ambient module declaration that is either:
        // - defined in the top level scope and source file is an external module
        // - defined inside ambient module declaration located in the top level scope and source file not an external module
        switch (node.parent.kind) {
            case 305 /* SyntaxKind.SourceFile */:
                return ts.isExternalModule(node.parent);
            case 262 /* SyntaxKind.ModuleBlock */:
                return isAmbientModule(node.parent.parent) && ts.isSourceFile(node.parent.parent.parent) && !ts.isExternalModule(node.parent.parent.parent);
        }
        return false;
    }
    ts.isModuleAugmentationExternal = isModuleAugmentationExternal;
    function getNonAugmentationDeclaration(symbol) {
        var _a;
        return (_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.find(function (d) { return !isExternalModuleAugmentation(d) && !(ts.isModuleDeclaration(d) && isGlobalScopeAugmentation(d)); });
    }
    ts.getNonAugmentationDeclaration = getNonAugmentationDeclaration;
    function isCommonJSContainingModuleKind(kind) {
        return kind === ts.ModuleKind.CommonJS || kind === ts.ModuleKind.Node16 || kind === ts.ModuleKind.NodeNext;
    }
    function isEffectiveExternalModule(node, compilerOptions) {
        return ts.isExternalModule(node) || compilerOptions.isolatedModules || (isCommonJSContainingModuleKind(getEmitModuleKind(compilerOptions)) && !!node.commonJsModuleIndicator);
    }
    ts.isEffectiveExternalModule = isEffectiveExternalModule;
    /**
     * Returns whether the source file will be treated as if it were in strict mode at runtime.
     */
    function isEffectiveStrictModeSourceFile(node, compilerOptions) {
        // We can only verify strict mode for JS/TS files
        switch (node.scriptKind) {
            case 1 /* ScriptKind.JS */:
            case 3 /* ScriptKind.TS */:
            case 2 /* ScriptKind.JSX */:
            case 4 /* ScriptKind.TSX */:
                break;
            default:
                return false;
        }
        // Strict mode does not matter for declaration files.
        if (node.isDeclarationFile) {
            return false;
        }
        // If `alwaysStrict` is set, then treat the file as strict.
        if (getStrictOptionValue(compilerOptions, "alwaysStrict")) {
            return true;
        }
        // Starting with a "use strict" directive indicates the file is strict.
        if (ts.startsWithUseStrict(node.statements)) {
            return true;
        }
        if (ts.isExternalModule(node) || compilerOptions.isolatedModules) {
            // ECMAScript Modules are always strict.
            if (getEmitModuleKind(compilerOptions) >= ts.ModuleKind.ES2015) {
                return true;
            }
            // Other modules are strict unless otherwise specified.
            return !compilerOptions.noImplicitUseStrict;
        }
        return false;
    }
    ts.isEffectiveStrictModeSourceFile = isEffectiveStrictModeSourceFile;
    function isBlockScope(node, parentNode) {
        switch (node.kind) {
            case 305 /* SyntaxKind.SourceFile */:
            case 263 /* SyntaxKind.CaseBlock */:
            case 292 /* SyntaxKind.CatchClause */:
            case 261 /* SyntaxKind.ModuleDeclaration */:
            case 242 /* SyntaxKind.ForStatement */:
            case 243 /* SyntaxKind.ForInStatement */:
            case 244 /* SyntaxKind.ForOfStatement */:
            case 171 /* SyntaxKind.Constructor */:
            case 169 /* SyntaxKind.MethodDeclaration */:
            case 172 /* SyntaxKind.GetAccessor */:
            case 173 /* SyntaxKind.SetAccessor */:
            case 256 /* SyntaxKind.FunctionDeclaration */:
            case 213 /* SyntaxKind.FunctionExpression */:
            case 214 /* SyntaxKind.ArrowFunction */:
            case 167 /* SyntaxKind.PropertyDeclaration */:
            case 170 /* SyntaxKind.ClassStaticBlockDeclaration */:
                return true;
            case 235 /* SyntaxKind.Block */:
                // function block is not considered block-scope container
                // see comment in binder.ts: bind(...), case for SyntaxKind.Block
                return !ts.isFunctionLikeOrClassStaticBlockDeclaration(parentNode);
        }
        return false;
    }
    ts.isBlockScope = isBlockScope;
    function isDeclarationWithTypeParameters(node) {
        switch (node.kind) {
            case 338 /* SyntaxKind.JSDocCallbackTag */:
            case 345 /* SyntaxKind.JSDocTypedefTag */:
            case 323 /* SyntaxKind.JSDocSignature */:
                return true;
            default:
                ts.assertType(node);
                return isDeclarationWithTypeParameterChildren(node);
        }
    }
    ts.isDeclarationWithTypeParameters = isDeclarationWithTypeParameters;
    function isDeclarationWithTypeParameterChildren(node) {
        switch (node.kind) {
            case 174 /* SyntaxKind.CallSignature */:
            case 175 /* SyntaxKind.ConstructSignature */:
            case 168 /* SyntaxKind.MethodSignature */:
            case 176 /* SyntaxKind.IndexSignature */:
            case 179 /* SyntaxKind.FunctionType */:
            case 180 /* SyntaxKind.ConstructorType */:
            case 317 /* SyntaxKind.JSDocFunctionType */:
            case 257 /* SyntaxKind.ClassDeclaration */:
            case 226 /* SyntaxKind.ClassExpression */:
            case 258 /* SyntaxKind.InterfaceDeclaration */:
            case 259 /* SyntaxKind.TypeAliasDeclaration */:
            case 344 /* SyntaxKind.JSDocTemplateTag */:
            case 256 /* SyntaxKind.FunctionDeclaration */:
            case 169 /* SyntaxKind.MethodDeclaration */:
            case 171 /* SyntaxKind.Constructor */:
            case 172 /* SyntaxKind.GetAccessor */:
            case 173 /* SyntaxKind.SetAccessor */:
            case 213 /* SyntaxKind.FunctionExpression */:
            case 214 /* SyntaxKind.ArrowFunction */:
                return true;
            default:
                ts.assertType(node);
                return false;
        }
    }
    ts.isDeclarationWithTypeParameterChildren = isDeclarationWithTypeParameterChildren;
    function isAnyImportSyntax(node) {
        switch (node.kind) {
            case 266 /* SyntaxKind.ImportDeclaration */:
            case 265 /* SyntaxKind.ImportEqualsDeclaration */:
                return true;
            default:
                return false;
        }
    }
    ts.isAnyImportSyntax = isAnyImportSyntax;
    function isAnyImportOrBareOrAccessedRequire(node) {
        return isAnyImportSyntax(node) || isVariableDeclarationInitializedToBareOrAccessedRequire(node);
    }
    ts.isAnyImportOrBareOrAccessedRequire = isAnyImportOrBareOrAccessedRequire;
    function isLateVisibilityPaintedStatement(node) {
        switch (node.kind) {
            case 266 /* SyntaxKind.ImportDeclaration */:
            case 265 /* SyntaxKind.ImportEqualsDeclaration */:
            case 237 /* SyntaxKind.VariableStatement */:
            case 257 /* SyntaxKind.ClassDeclaration */:
            case 256 /* SyntaxKind.FunctionDeclaration */:
            case 261 /* SyntaxKind.ModuleDeclaration */:
            case 259 /* SyntaxKind.TypeAliasDeclaration */:
            case 258 /* SyntaxKind.InterfaceDeclaration */:
            case 260 /* SyntaxKind.EnumDeclaration */:
                return true;
            default:
                return false;
        }
    }
    ts.isLateVisibilityPaintedStatement = isLateVisibilityPaintedStatement;
    function hasPossibleExternalModuleReference(node) {
        return isAnyImportOrReExport(node) || ts.isModuleDeclaration(node) || ts.isImportTypeNode(node) || isImportCall(node);
    }
    ts.hasPossibleExternalModuleReference = hasPossibleExternalModuleReference;
    function isAnyImportOrReExport(node) {
        return isAnyImportSyntax(node) || ts.isExportDeclaration(node);
    }
    ts.isAnyImportOrReExport = isAnyImportOrReExport;
    // Gets the nearest enclosing block scope container that has the provided node
    // as a descendant, that is not the provided node.
    function getEnclosingBlockScopeContainer(node) {
        return ts.findAncestor(node.parent, function (current) { return isBlockScope(current, current.parent); });
    }
    ts.getEnclosingBlockScopeContainer = getEnclosingBlockScopeContainer;
    function forEachEnclosingBlockScopeContainer(node, cb) {
        var container = getEnclosingBlockScopeContainer(node);
        while (container) {
            cb(container);
            container = getEnclosingBlockScopeContainer(container);
        }
    }
    ts.forEachEnclosingBlockScopeContainer = forEachEnclosingBlockScopeContainer;
    // Return display name of an identifier
    // Computed property names will just be emitted as "[<expr>]", where <expr> is the source
    // text of the expression in the computed property.
    function declarationNameToString(name) {
        return !name || getFullWidth(name) === 0 ? "(Missing)" : getTextOfNode(name);
    }
    ts.declarationNameToString = declarationNameToString;
    function getNameFromIndexInfo(info) {
        return info.declaration ? declarationNameToString(info.declaration.parameters[0].name) : undefined;
    }
    ts.getNameFromIndexInfo = getNameFromIndexInfo;
    function isComputedNonLiteralName(name) {
        return name.kind === 162 /* SyntaxKind.ComputedPropertyName */ && !isStringOrNumericLiteralLike(name.expression);
    }
    ts.isComputedNonLiteralName = isComputedNonLiteralName;
    function tryGetTextOfPropertyName(name) {
        switch (name.kind) {
            case 79 /* SyntaxKind.Identifier */:
            case 80 /* SyntaxKind.PrivateIdentifier */:
                return name.escapedText;
            case 10 /* SyntaxKind.StringLiteral */:
            case 8 /* SyntaxKind.NumericLiteral */:
            case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                return ts.escapeLeadingUnderscores(name.text);
            case 162 /* SyntaxKind.ComputedPropertyName */:
                if (isStringOrNumericLiteralLike(name.expression))
                    return ts.escapeLeadingUnderscores(name.expression.text);
                return undefined;
            default:
                return ts.Debug.assertNever(name);
        }
    }
    ts.tryGetTextOfPropertyName = tryGetTextOfPropertyName;
    function getTextOfPropertyName(name) {
        return ts.Debug.checkDefined(tryGetTextOfPropertyName(name));
    }
    ts.getTextOfPropertyName = getTextOfPropertyName;
    function entityNameToString(name) {
        switch (name.kind) {
            case 108 /* SyntaxKind.ThisKeyword */:
                return "this";
            case 80 /* SyntaxKind.PrivateIdentifier */:
            case 79 /* SyntaxKind.Identifier */:
                return getFullWidth(name) === 0 ? ts.idText(name) : getTextOfNode(name);
            case 161 /* SyntaxKind.QualifiedName */:
                return entityNameToString(name.left) + "." + entityNameToString(name.right);
            case 206 /* SyntaxKind.PropertyAccessExpression */:
                if (ts.isIdentifier(name.name) || ts.isPrivateIdentifier(name.name)) {
                    return entityNameToString(name.expression) + "." + entityNameToString(name.name);
                }
                else {
                    return ts.Debug.assertNever(name.name);
                }
            case 311 /* SyntaxKind.JSDocMemberName */:
                return entityNameToString(name.left) + entityNameToString(name.right);
            default:
                return ts.Debug.assertNever(name);
        }
    }
    ts.entityNameToString = entityNameToString;
    function createDiagnosticForNode(node, message, arg0, arg1, arg2, arg3) {
        var sourceFile = getSourceFileOfNode(node);
        return createDiagnosticForNodeInSourceFile(sourceFile, node, message, arg0, arg1, arg2, arg3);
    }
    ts.createDiagnosticForNode = createDiagnosticForNode;
    function createDiagnosticForNodeArray(sourceFile, nodes, message, arg0, arg1, arg2, arg3) {
        var start = ts.skipTrivia(sourceFile.text, nodes.pos);
        return createFileDiagnostic(sourceFile, start, nodes.end - start, message, arg0, arg1, arg2, arg3);
    }
    ts.createDiagnosticForNodeArray = createDiagnosticForNodeArray;
    function createDiagnosticForNodeInSourceFile(sourceFile, node, message, arg0, arg1, arg2, arg3) {
        var span = getErrorSpanForNode(sourceFile, node);
        return createFileDiagnostic(sourceFile, span.start, span.length, message, arg0, arg1, arg2, arg3);
    }
    ts.createDiagnosticForNodeInSourceFile = createDiagnosticForNodeInSourceFile;
    function createDiagnosticForNodeFromMessageChain(node, messageChain, relatedInformation) {
        var sourceFile = getSourceFileOfNode(node);
        var span = getErrorSpanForNode(sourceFile, node);
        return createFileDiagnosticFromMessageChain(sourceFile, span.start, span.length, messageChain, relatedInformation);
    }
    ts.createDiagnosticForNodeFromMessageChain = createDiagnosticForNodeFromMessageChain;
    function assertDiagnosticLocation(file, start, length) {
        ts.Debug.assertGreaterThanOrEqual(start, 0);
        ts.Debug.assertGreaterThanOrEqual(length, 0);
        if (file) {
            ts.Debug.assertLessThanOrEqual(start, file.text.length);
            ts.Debug.assertLessThanOrEqual(start + length, file.text.length);
        }
    }
    function createFileDiagnosticFromMessageChain(file, start, length, messageChain, relatedInformation) {
        assertDiagnosticLocation(file, start, length);
        return {
            file: file,
            start: start,
            length: length,
            code: messageChain.code,
            category: messageChain.category,
            messageText: messageChain.next ? messageChain : messageChain.messageText,
            relatedInformation: relatedInformation
        };
    }
    ts.createFileDiagnosticFromMessageChain = createFileDiagnosticFromMessageChain;
    function createDiagnosticForFileFromMessageChain(sourceFile, messageChain, relatedInformation) {
        return {
            file: sourceFile,
            start: 0,
            length: 0,
            code: messageChain.code,
            category: messageChain.category,
            messageText: messageChain.next ? messageChain : messageChain.messageText,
            relatedInformation: relatedInformation
        };
    }
    ts.createDiagnosticForFileFromMessageChain = createDiagnosticForFileFromMessageChain;
    function createDiagnosticMessageChainFromDiagnostic(diagnostic) {
        return typeof diagnostic.messageText === "string" ? {
            code: diagnostic.code,
            category: diagnostic.category,
            messageText: diagnostic.messageText,
            next: diagnostic.next,
        } : diagnostic.messageText;
    }
    ts.createDiagnosticMessageChainFromDiagnostic = createDiagnosticMessageChainFromDiagnostic;
    function createDiagnosticForRange(sourceFile, range, message) {
        return {
            file: sourceFile,
            start: range.pos,
            length: range.end - range.pos,
            code: message.code,
            category: message.category,
            messageText: message.message,
        };
    }
    ts.createDiagnosticForRange = createDiagnosticForRange;
    function getSpanOfTokenAtPosition(sourceFile, pos) {
        var scanner = ts.createScanner(sourceFile.languageVersion, /*skipTrivia*/ true, sourceFile.languageVariant, sourceFile.text, /*onError:*/ undefined, pos);
        scanner.scan();
        var start = scanner.getTokenPos();
        return ts.createTextSpanFromBounds(start, scanner.getTextPos());
    }
    ts.getSpanOfTokenAtPosition = getSpanOfTokenAtPosition;
    function getErrorSpanForArrowFunction(sourceFile, node) {
        var pos = ts.skipTrivia(sourceFile.text, node.pos);
        if (node.body && node.body.kind === 235 /* SyntaxKind.Block */) {
            var startLine = ts.getLineAndCharacterOfPosition(sourceFile, node.body.pos).line;
            var endLine = ts.getLineAndCharacterOfPosition(sourceFile, node.body.end).line;
            if (startLine < endLine) {
                // The arrow function spans multiple lines,
                // make the error span be the first line, inclusive.
                return ts.createTextSpan(pos, getEndLinePosition(startLine, sourceFile) - pos + 1);
            }
        }
        return ts.createTextSpanFromBounds(pos, node.end);
    }
    function getErrorSpanForNode(sourceFile, node) {
        var errorNode = node;
        switch (node.kind) {
            case 305 /* SyntaxKind.SourceFile */:
                var pos_1 = ts.skipTrivia(sourceFile.text, 0, /*stopAfterLineBreak*/ false);
                if (pos_1 === sourceFile.text.length) {
                    // file is empty - return span for the beginning of the file
                    return ts.createTextSpan(0, 0);
                }
                return getSpanOfTokenAtPosition(sourceFile, pos_1);
            // This list is a work in progress. Add missing node kinds to improve their error
            // spans.
            case 254 /* SyntaxKind.VariableDeclaration */:
            case 203 /* SyntaxKind.BindingElement */:
            case 257 /* SyntaxKind.ClassDeclaration */:
            case 226 /* SyntaxKind.ClassExpression */:
            case 258 /* SyntaxKind.InterfaceDeclaration */:
            case 261 /* SyntaxKind.ModuleDeclaration */:
            case 260 /* SyntaxKind.EnumDeclaration */:
            case 299 /* SyntaxKind.EnumMember */:
            case 256 /* SyntaxKind.FunctionDeclaration */:
            case 213 /* SyntaxKind.FunctionExpression */:
            case 169 /* SyntaxKind.MethodDeclaration */:
            case 172 /* SyntaxKind.GetAccessor */:
            case 173 /* SyntaxKind.SetAccessor */:
            case 259 /* SyntaxKind.TypeAliasDeclaration */:
            case 167 /* SyntaxKind.PropertyDeclaration */:
            case 166 /* SyntaxKind.PropertySignature */:
            case 268 /* SyntaxKind.NamespaceImport */:
                errorNode = node.name;
                break;
            case 214 /* SyntaxKind.ArrowFunction */:
                return getErrorSpanForArrowFunction(sourceFile, node);
            case 289 /* SyntaxKind.CaseClause */:
            case 290 /* SyntaxKind.DefaultClause */:
                var start = ts.skipTrivia(sourceFile.text, node.pos);
                var end = node.statements.length > 0 ? node.statements[0].pos : node.end;
                return ts.createTextSpanFromBounds(start, end);
        }
        if (errorNode === undefined) {
            // If we don't have a better node, then just set the error on the first token of
            // construct.
            return getSpanOfTokenAtPosition(sourceFile, node.pos);
        }
        ts.Debug.assert(!ts.isJSDoc(errorNode));
        var isMissing = nodeIsMissing(errorNode);
        var pos = isMissing || ts.isJsxText(node)
            ? errorNode.pos
            : ts.skipTrivia(sourceFile.text, errorNode.pos);
        // These asserts should all be satisfied for a properly constructed `errorNode`.
        if (isMissing) {
            ts.Debug.assert(pos === errorNode.pos, "This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809");
            ts.Debug.assert(pos === errorNode.end, "This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809");
        }
        else {
            ts.Debug.assert(pos >= errorNode.pos, "This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809");
            ts.Debug.assert(pos <= errorNode.end, "This failure could trigger https://github.com/Microsoft/TypeScript/issues/20809");
        }
        return ts.createTextSpanFromBounds(pos, errorNode.end);
    }
    ts.getErrorSpanForNode = getErrorSpanForNode;
    function isExternalOrCommonJsModule(file) {
        return (file.externalModuleIndicator || file.commonJsModuleIndicator) !== undefined;
    }
    ts.isExternalOrCommonJsModule = isExternalOrCommonJsModule;
    function isJsonSourceFile(file) {
        return file.scriptKind === 6 /* ScriptKind.JSON */;
    }
    ts.isJsonSourceFile = isJsonSourceFile;
    function isEnumConst(node) {
        return !!(ts.getCombinedModifierFlags(node) & 2048 /* ModifierFlags.Const */);
    }
    ts.isEnumConst = isEnumConst;
    function isDeclarationReadonly(declaration) {
        return !!(ts.getCombinedModifierFlags(declaration) & 64 /* ModifierFlags.Readonly */ && !ts.isParameterPropertyDeclaration(declaration, declaration.parent));
    }
    ts.isDeclarationReadonly = isDeclarationReadonly;
    function isVarConst(node) {
        return !!(ts.getCombinedNodeFlags(node) & 2 /* NodeFlags.Const */);
    }
    ts.isVarConst = isVarConst;
    function isLet(node) {
        return !!(ts.getCombinedNodeFlags(node) & 1 /* NodeFlags.Let */);
    }
    ts.isLet = isLet;
    function isSuperCall(n) {
        return n.kind === 208 /* SyntaxKind.CallExpression */ && n.expression.kind === 106 /* SyntaxKind.SuperKeyword */;
    }
    ts.isSuperCall = isSuperCall;
    function isImportCall(n) {
        return n.kind === 208 /* SyntaxKind.CallExpression */ && n.expression.kind === 100 /* SyntaxKind.ImportKeyword */;
    }
    ts.isImportCall = isImportCall;
    function isImportMeta(n) {
        return ts.isMetaProperty(n)
            && n.keywordToken === 100 /* SyntaxKind.ImportKeyword */
            && n.name.escapedText === "meta";
    }
    ts.isImportMeta = isImportMeta;
    function isLiteralImportTypeNode(n) {
        return ts.isImportTypeNode(n) && ts.isLiteralTypeNode(n.argument) && ts.isStringLiteral(n.argument.literal);
    }
    ts.isLiteralImportTypeNode = isLiteralImportTypeNode;
    function isPrologueDirective(node) {
        return node.kind === 238 /* SyntaxKind.ExpressionStatement */
            && node.expression.kind === 10 /* SyntaxKind.StringLiteral */;
    }
    ts.isPrologueDirective = isPrologueDirective;
    function isCustomPrologue(node) {
        return !!(getEmitFlags(node) & 1048576 /* EmitFlags.CustomPrologue */);
    }
    ts.isCustomPrologue = isCustomPrologue;
    function isHoistedFunction(node) {
        return isCustomPrologue(node)
            && ts.isFunctionDeclaration(node);
    }
    ts.isHoistedFunction = isHoistedFunction;
    function isHoistedVariable(node) {
        return ts.isIdentifier(node.name)
            && !node.initializer;
    }
    function isHoistedVariableStatement(node) {
        return isCustomPrologue(node)
            && ts.isVariableStatement(node)
            && ts.every(node.declarationList.declarations, isHoistedVariable);
    }
    ts.isHoistedVariableStatement = isHoistedVariableStatement;
    function getLeadingCommentRangesOfNode(node, sourceFileOfNode) {
        return node.kind !== 11 /* SyntaxKind.JsxText */ ? ts.getLeadingCommentRanges(sourceFileOfNode.text, node.pos) : undefined;
    }
    ts.getLeadingCommentRangesOfNode = getLeadingCommentRangesOfNode;
    function getJSDocCommentRanges(node, text) {
        var commentRanges = (node.kind === 164 /* SyntaxKind.Parameter */ ||
            node.kind === 163 /* SyntaxKind.TypeParameter */ ||
            node.kind === 213 /* SyntaxKind.FunctionExpression */ ||
            node.kind === 214 /* SyntaxKind.ArrowFunction */ ||
            node.kind === 212 /* SyntaxKind.ParenthesizedExpression */ ||
            node.kind === 254 /* SyntaxKind.VariableDeclaration */ ||
            node.kind === 275 /* SyntaxKind.ExportSpecifier */) ?
            ts.concatenate(ts.getTrailingCommentRanges(text, node.pos), ts.getLeadingCommentRanges(text, node.pos)) :
            ts.getLeadingCommentRanges(text, node.pos);
        // True if the comment starts with '/**' but not if it is '/**/'
        return ts.filter(commentRanges, function (comment) {
            return text.charCodeAt(comment.pos + 1) === 42 /* CharacterCodes.asterisk */ &&
                text.charCodeAt(comment.pos + 2) === 42 /* CharacterCodes.asterisk */ &&
                text.charCodeAt(comment.pos + 3) !== 47 /* CharacterCodes.slash */;
        });
    }
    ts.getJSDocCommentRanges = getJSDocCommentRanges;
    ts.fullTripleSlashReferencePathRegEx = /^(\/\/\/\s*<reference\s+path\s*=\s*)(('[^']*')|("[^"]*")).*?\/>/;
    var fullTripleSlashReferenceTypeReferenceDirectiveRegEx = /^(\/\/\/\s*<reference\s+types\s*=\s*)(('[^']*')|("[^"]*")).*?\/>/;
    ts.fullTripleSlashAMDReferencePathRegEx = /^(\/\/\/\s*<amd-dependency\s+path\s*=\s*)(('[^']*')|("[^"]*")).*?\/>/;
    var defaultLibReferenceRegEx = /^(\/\/\/\s*<reference\s+no-default-lib\s*=\s*)(('[^']*')|("[^"]*"))\s*\/>/;
    function isPartOfTypeNode(node) {
        if (177 /* SyntaxKind.FirstTypeNode */ <= node.kind && node.kind <= 200 /* SyntaxKind.LastTypeNode */) {
            return true;
        }
        switch (node.kind) {
            case 130 /* SyntaxKind.AnyKeyword */:
            case 155 /* SyntaxKind.UnknownKeyword */:
            case 147 /* SyntaxKind.NumberKeyword */:
            case 158 /* SyntaxKind.BigIntKeyword */:
            case 150 /* SyntaxKind.StringKeyword */:
            case 133 /* SyntaxKind.BooleanKeyword */:
            case 151 /* SyntaxKind.SymbolKeyword */:
            case 148 /* SyntaxKind.ObjectKeyword */:
            case 153 /* SyntaxKind.UndefinedKeyword */:
            case 143 /* SyntaxKind.NeverKeyword */:
                return true;
            case 114 /* SyntaxKind.VoidKeyword */:
                return node.parent.kind !== 217 /* SyntaxKind.VoidExpression */;
            case 228 /* SyntaxKind.ExpressionWithTypeArguments */:
                return ts.isHeritageClause(node.parent) && !isExpressionWithTypeArgumentsInClassExtendsClause(node);
            case 163 /* SyntaxKind.TypeParameter */:
                return node.parent.kind === 195 /* SyntaxKind.MappedType */ || node.parent.kind === 190 /* SyntaxKind.InferType */;
            // Identifiers and qualified names may be type nodes, depending on their context. Climb
            // above them to find the lowest container
            case 79 /* SyntaxKind.Identifier */:
                // If the identifier is the RHS of a qualified name, then it's a type iff its parent is.
                if (node.parent.kind === 161 /* SyntaxKind.QualifiedName */ && node.parent.right === node) {
                    node = node.parent;
                }
                else if (node.parent.kind === 206 /* SyntaxKind.PropertyAccessExpression */ && node.parent.name === node) {
                    node = node.parent;
                }
                // At this point, node is either a qualified name or an identifier
                ts.Debug.assert(node.kind === 79 /* SyntaxKind.Identifier */ || node.kind === 161 /* SyntaxKind.QualifiedName */ || node.kind === 206 /* SyntaxKind.PropertyAccessExpression */, "'node' was expected to be a qualified name, identifier or property access in 'isPartOfTypeNode'.");
            // falls through
            case 161 /* SyntaxKind.QualifiedName */:
            case 206 /* SyntaxKind.PropertyAccessExpression */:
            case 108 /* SyntaxKind.ThisKeyword */: {
                var parent = node.parent;
                if (parent.kind === 181 /* SyntaxKind.TypeQuery */) {
                    return false;
                }
                if (parent.kind === 200 /* SyntaxKind.ImportType */) {
                    return !parent.isTypeOf;
                }
                // Do not recursively call isPartOfTypeNode on the parent. In the example:
                //
                //     let a: A.B.C;
                //
                // Calling isPartOfTypeNode would consider the qualified name A.B a type node.
                // Only C and A.B.C are type nodes.
                if (177 /* SyntaxKind.FirstTypeNode */ <= parent.kind && parent.kind <= 200 /* SyntaxKind.LastTypeNode */) {
                    return true;
                }
                switch (parent.kind) {
                    case 228 /* SyntaxKind.ExpressionWithTypeArguments */:
                        return ts.isHeritageClause(parent.parent) && !isExpressionWithTypeArgumentsInClassExtendsClause(parent);
                    case 163 /* SyntaxKind.TypeParameter */:
                        return node === parent.constraint;
                    case 344 /* SyntaxKind.JSDocTemplateTag */:
                        return node === parent.constraint;
                    case 167 /* SyntaxKind.PropertyDeclaration */:
                    case 166 /* SyntaxKind.PropertySignature */:
                    case 164 /* SyntaxKind.Parameter */:
                    case 254 /* SyntaxKind.VariableDeclaration */:
                        return node === parent.type;
                    case 256 /* SyntaxKind.FunctionDeclaration */:
                    case 213 /* SyntaxKind.FunctionExpression */:
                    case 214 /* SyntaxKind.ArrowFunction */:
                    case 171 /* SyntaxKind.Constructor */:
                    case 169 /* SyntaxKind.MethodDeclaration */:
                    case 168 /* SyntaxKind.MethodSignature */:
                    case 172 /* SyntaxKind.GetAccessor */:
                    case 173 /* SyntaxKind.SetAccessor */:
                        return node === parent.type;
                    case 174 /* SyntaxKind.CallSignature */:
                    case 175 /* SyntaxKind.ConstructSignature */:
                    case 176 /* SyntaxKind.IndexSignature */:
                        return node === parent.type;
                    case 211 /* SyntaxKind.TypeAssertionExpression */:
                        return node === parent.type;
                    case 208 /* SyntaxKind.CallExpression */:
                    case 209 /* SyntaxKind.NewExpression */:
                        return ts.contains(parent.typeArguments, node);
                    case 210 /* SyntaxKind.TaggedTemplateExpression */:
                        // TODO (drosen): TaggedTemplateExpressions may eventually support type arguments.
                        return false;
                }
            }
        }
        return false;
    }
    ts.isPartOfTypeNode = isPartOfTypeNode;
    function isChildOfNodeWithKind(node, kind) {
        while (node) {
            if (node.kind === kind) {
                return true;
            }
            node = node.parent;
        }
        return false;
    }
    ts.isChildOfNodeWithKind = isChildOfNodeWithKind;
    // Warning: This has the same semantics as the forEach family of functions,
    //          in that traversal terminates in the event that 'visitor' supplies a truthy value.
    function forEachReturnStatement(body, visitor) {
        return traverse(body);
        function traverse(node) {
            switch (node.kind) {
                case 247 /* SyntaxKind.ReturnStatement */:
                    return visitor(node);
                case 263 /* SyntaxKind.CaseBlock */:
                case 235 /* SyntaxKind.Block */:
                case 239 /* SyntaxKind.IfStatement */:
                case 240 /* SyntaxKind.DoStatement */:
                case 241 /* SyntaxKind.WhileStatement */:
                case 242 /* SyntaxKind.ForStatement */:
                case 243 /* SyntaxKind.ForInStatement */:
                case 244 /* SyntaxKind.ForOfStatement */:
                case 248 /* SyntaxKind.WithStatement */:
                case 249 /* SyntaxKind.SwitchStatement */:
                case 289 /* SyntaxKind.CaseClause */:
                case 290 /* SyntaxKind.DefaultClause */:
                case 250 /* SyntaxKind.LabeledStatement */:
                case 252 /* SyntaxKind.TryStatement */:
                case 292 /* SyntaxKind.CatchClause */:
                    return ts.forEachChild(node, traverse);
            }
        }
    }
    ts.forEachReturnStatement = forEachReturnStatement;
    function forEachYieldExpression(body, visitor) {
        return traverse(body);
        function traverse(node) {
            switch (node.kind) {
                case 224 /* SyntaxKind.YieldExpression */:
                    visitor(node);
                    var operand = node.expression;
                    if (operand) {
                        traverse(operand);
                    }
                    return;
                case 260 /* SyntaxKind.EnumDeclaration */:
                case 258 /* SyntaxKind.InterfaceDeclaration */:
                case 261 /* SyntaxKind.ModuleDeclaration */:
                case 259 /* SyntaxKind.TypeAliasDeclaration */:
                    // These are not allowed inside a generator now, but eventually they may be allowed
                    // as local types. Regardless, skip them to avoid the work.
                    return;
                default:
                    if (ts.isFunctionLike(node)) {
                        if (node.name && node.name.kind === 162 /* SyntaxKind.ComputedPropertyName */) {
                            // Note that we will not include methods/accessors of a class because they would require
                            // first descending into the class. This is by design.
                            traverse(node.name.expression);
                            return;
                        }
                    }
                    else if (!isPartOfTypeNode(node)) {
                        // This is the general case, which should include mostly expressions and statements.
                        // Also includes NodeArrays.
                        ts.forEachChild(node, traverse);
                    }
            }
        }
    }
    ts.forEachYieldExpression = forEachYieldExpression;
    /**
     * Gets the most likely element type for a TypeNode. This is not an exhaustive test
     * as it assumes a rest argument can only be an array type (either T[], or Array<T>).
     *
     * @param node The type node.
     */
    function getRestParameterElementType(node) {
        if (node && node.kind === 183 /* SyntaxKind.ArrayType */) {
            return node.elementType;
        }
        else if (node && node.kind === 178 /* SyntaxKind.TypeReference */) {
            return ts.singleOrUndefined(node.typeArguments);
        }
        else {
            return undefined;
        }
    }
    ts.getRestParameterElementType = getRestParameterElementType;
    function getMembersOfDeclaration(node) {
        switch (node.kind) {
            case 258 /* SyntaxKind.InterfaceDeclaration */:
            case 257 /* SyntaxKind.ClassDeclaration */:
            case 226 /* SyntaxKind.ClassExpression */:
            case 182 /* SyntaxKind.TypeLiteral */:
                return node.members;
            case 205 /* SyntaxKind.ObjectLiteralExpression */:
                return node.properties;
        }
    }
    ts.getMembersOfDeclaration = getMembersOfDeclaration;
    function isVariableLike(node) {
        if (node) {
            switch (node.kind) {
                case 203 /* SyntaxKind.BindingElement */:
                case 299 /* SyntaxKind.EnumMember */:
                case 164 /* SyntaxKind.Parameter */:
                case 296 /* SyntaxKind.PropertyAssignment */:
                case 167 /* SyntaxKind.PropertyDeclaration */:
                case 166 /* SyntaxKind.PropertySignature */:
                case 297 /* SyntaxKind.ShorthandPropertyAssignment */:
                case 254 /* SyntaxKind.VariableDeclaration */:
                    return true;
            }
        }
        return false;
    }
    ts.isVariableLike = isVariableLike;
    function isVariableLikeOrAccessor(node) {
        return isVariableLike(node) || ts.isAccessor(node);
    }
    ts.isVariableLikeOrAccessor = isVariableLikeOrAccessor;
    function isVariableDeclarationInVariableStatement(node) {
        return node.parent.kind === 255 /* SyntaxKind.VariableDeclarationList */
            && node.parent.parent.kind === 237 /* SyntaxKind.VariableStatement */;
    }
    ts.isVariableDeclarationInVariableStatement = isVariableDeclarationInVariableStatement;
    function isCommonJsExportedExpression(node) {
        if (!isInJSFile(node))
            return false;
        return (ts.isObjectLiteralExpression(node.parent) && ts.isBinaryExpression(node.parent.parent) && getAssignmentDeclarationKind(node.parent.parent) === 2 /* AssignmentDeclarationKind.ModuleExports */) ||
            isCommonJsExportPropertyAssignment(node.parent);
    }
    ts.isCommonJsExportedExpression = isCommonJsExportedExpression;
    function isCommonJsExportPropertyAssignment(node) {
        if (!isInJSFile(node))
            return false;
        return (ts.isBinaryExpression(node) && getAssignmentDeclarationKind(node) === 1 /* AssignmentDeclarationKind.ExportsProperty */);
    }
    ts.isCommonJsExportPropertyAssignment = isCommonJsExportPropertyAssignment;
    function isValidESSymbolDeclaration(node) {
        return (ts.isVariableDeclaration(node) ? isVarConst(node) && ts.isIdentifier(node.name) && isVariableDeclarationInVariableStatement(node) :
            ts.isPropertyDeclaration(node) ? hasEffectiveReadonlyModifier(node) && hasStaticModifier(node) :
                ts.isPropertySignature(node) && hasEffectiveReadonlyModifier(node)) || isCommonJsExportPropertyAssignment(node);
    }
    ts.isValidESSymbolDeclaration = isValidESSymbolDeclaration;
    function introducesArgumentsExoticObject(node) {
        switch (node.kind) {
            case 169 /* SyntaxKind.MethodDeclaration */:
            case 168 /* SyntaxKind.MethodSignature */:
            case 171 /* SyntaxKind.Constructor */:
            case 172 /* SyntaxKind.GetAccessor */:
            case 173 /* SyntaxKind.SetAccessor */:
            case 256 /* SyntaxKind.FunctionDeclaration */:
            case 213 /* SyntaxKind.FunctionExpression */:
                return true;
        }
        return false;
    }
    ts.introducesArgumentsExoticObject = introducesArgumentsExoticObject;
    function unwrapInnermostStatementOfLabel(node, beforeUnwrapLabelCallback) {
        while (true) {
            if (beforeUnwrapLabelCallback) {
                beforeUnwrapLabelCallback(node);
            }
            if (node.statement.kind !== 250 /* SyntaxKind.LabeledStatement */) {
                return node.statement;
            }
            node = node.statement;
        }
    }
    ts.unwrapInnermostStatementOfLabel = unwrapInnermostStatementOfLabel;
    function isFunctionBlock(node) {
        return node && node.kind === 235 /* SyntaxKind.Block */ && ts.isFunctionLike(node.parent);
    }
    ts.isFunctionBlock = isFunctionBlock;
    function isObjectLiteralMethod(node) {
        return node && node.kind === 169 /* SyntaxKind.MethodDeclaration */ && node.parent.kind === 205 /* SyntaxKind.ObjectLiteralExpression */;
    }
    ts.isObjectLiteralMethod = isObjectLiteralMethod;
    function isObjectLiteralOrClassExpressionMethodOrAccessor(node) {
        return (node.kind === 169 /* SyntaxKind.MethodDeclaration */ || node.kind === 172 /* SyntaxKind.GetAccessor */ || node.kind === 173 /* SyntaxKind.SetAccessor */) &&
            (node.parent.kind === 205 /* SyntaxKind.ObjectLiteralExpression */ ||
                node.parent.kind === 226 /* SyntaxKind.ClassExpression */);
    }
    ts.isObjectLiteralOrClassExpressionMethodOrAccessor = isObjectLiteralOrClassExpressionMethodOrAccessor;
    function isIdentifierTypePredicate(predicate) {
        return predicate && predicate.kind === 1 /* TypePredicateKind.Identifier */;
    }
    ts.isIdentifierTypePredicate = isIdentifierTypePredicate;
    function isThisTypePredicate(predicate) {
        return predicate && predicate.kind === 0 /* TypePredicateKind.This */;
    }
    ts.isThisTypePredicate = isThisTypePredicate;
    function getPropertyAssignment(objectLiteral, key, key2) {
        return objectLiteral.properties.filter(function (property) {
            if (property.kind === 296 /* SyntaxKind.PropertyAssignment */) {
                var propName = tryGetTextOfPropertyName(property.name);
                return key === propName || (!!key2 && key2 === propName);
            }
            return false;
        });
    }
    ts.getPropertyAssignment = getPropertyAssignment;
    function getPropertyArrayElementValue(objectLiteral, propKey, elementValue) {
        return ts.firstDefined(getPropertyAssignment(objectLiteral, propKey), function (property) {
            return ts.isArrayLiteralExpression(property.initializer) ?
                ts.find(property.initializer.elements, function (element) { return ts.isStringLiteral(element) && element.text === elementValue; }) :
                undefined;
        });
    }
    ts.getPropertyArrayElementValue = getPropertyArrayElementValue;
    function getTsConfigObjectLiteralExpression(tsConfigSourceFile) {
        if (tsConfigSourceFile && tsConfigSourceFile.statements.length) {
            var expression = tsConfigSourceFile.statements[0].expression;
            return ts.tryCast(expression, ts.isObjectLiteralExpression);
        }
    }
    ts.getTsConfigObjectLiteralExpression = getTsConfigObjectLiteralExpression;
    function getTsConfigPropArrayElementValue(tsConfigSourceFile, propKey, elementValue) {
        return ts.firstDefined(getTsConfigPropArray(tsConfigSourceFile, propKey), function (property) {
            return ts.isArrayLiteralExpression(property.initializer) ?
                ts.find(property.initializer.elements, function (element) { return ts.isStringLiteral(element) && element.text === elementValue; }) :
                undefined;
        });
    }
    ts.getTsConfigPropArrayElementValue = getTsConfigPropArrayElementValue;
    function getTsConfigPropArray(tsConfigSourceFile, propKey) {
        var jsonObjectLiteral = getTsConfigObjectLiteralExpression(tsConfigSourceFile);
        return jsonObjectLiteral ? getPropertyAssignment(jsonObjectLiteral, propKey) : ts.emptyArray;
    }
    ts.getTsConfigPropArray = getTsConfigPropArray;
    function getContainingFunction(node) {
        return ts.findAncestor(node.parent, ts.isFunctionLike);
    }
    ts.getContainingFunction = getContainingFunction;
    function getContainingFunctionDeclaration(node) {
        return ts.findAncestor(node.parent, ts.isFunctionLikeDeclaration);
    }
    ts.getContainingFunctionDeclaration = getContainingFunctionDeclaration;
    function getContainingClass(node) {
        return ts.findAncestor(node.parent, ts.isClassLike);
    }
    ts.getContainingClass = getContainingClass;
    function getContainingClassStaticBlock(node) {
        return ts.findAncestor(node.parent, function (n) {
            if (ts.isClassLike(n) || ts.isFunctionLike(n)) {
                return "quit";
            }
            return ts.isClassStaticBlockDeclaration(n);
        });
    }
    ts.getContainingClassStaticBlock = getContainingClassStaticBlock;
    function getContainingFunctionOrClassStaticBlock(node) {
        return ts.findAncestor(node.parent, ts.isFunctionLikeOrClassStaticBlockDeclaration);
    }
    ts.getContainingFunctionOrClassStaticBlock = getContainingFunctionOrClassStaticBlock;
    function getThisContainer(node, includeArrowFunctions) {
        ts.Debug.assert(node.kind !== 305 /* SyntaxKind.SourceFile */);
        while (true) {
            node = node.parent;
            if (!node) {
                return ts.Debug.fail(); // If we never pass in a SourceFile, this should be unreachable, since we'll stop when we reach that.
            }
            switch (node.kind) {
                case 162 /* SyntaxKind.ComputedPropertyName */:
                    // If the grandparent node is an object literal (as opposed to a class),
                    // then the computed property is not a 'this' container.
                    // A computed property name in a class needs to be a this container
                    // so that we can error on it.
                    if (ts.isClassLike(node.parent.parent)) {
                        return node;
                    }
                    // If this is a computed property, then the parent should not
                    // make it a this container. The parent might be a property
                    // in an object literal, like a method or accessor. But in order for
                    // such a parent to be a this container, the reference must be in
                    // the *body* of the container.
                    node = node.parent;
                    break;
                case 165 /* SyntaxKind.Decorator */:
                    // Decorators are always applied outside of the body of a class or method.
                    if (node.parent.kind === 164 /* SyntaxKind.Parameter */ && ts.isClassElement(node.parent.parent)) {
                        // If the decorator's parent is a Parameter, we resolve the this container from
                        // the grandparent class declaration.
                        node = node.parent.parent;
                    }
                    else if (ts.isClassElement(node.parent)) {
                        // If the decorator's parent is a class element, we resolve the 'this' container
                        // from the parent class declaration.
                        node = node.parent;
                    }
                    break;
                case 214 /* SyntaxKind.ArrowFunction */:
                    if (!includeArrowFunctions) {
                        continue;
                    }
                // falls through
                case 256 /* SyntaxKind.FunctionDeclaration */:
                case 213 /* SyntaxKind.FunctionExpression */:
                case 261 /* SyntaxKind.ModuleDeclaration */:
                case 170 /* SyntaxKind.ClassStaticBlockDeclaration */:
                case 167 /* SyntaxKind.PropertyDeclaration */:
                case 166 /* SyntaxKind.PropertySignature */:
                case 169 /* SyntaxKind.MethodDeclaration */:
                case 168 /* SyntaxKind.MethodSignature */:
                case 171 /* SyntaxKind.Constructor */:
                case 172 /* SyntaxKind.GetAccessor */:
                case 173 /* SyntaxKind.SetAccessor */:
                case 174 /* SyntaxKind.CallSignature */:
                case 175 /* SyntaxKind.ConstructSignature */:
                case 176 /* SyntaxKind.IndexSignature */:
                case 260 /* SyntaxKind.EnumDeclaration */:
                case 305 /* SyntaxKind.SourceFile */:
                    return node;
            }
        }
    }
    ts.getThisContainer = getThisContainer;
    /**
     * @returns Whether the node creates a new 'this' scope for its children.
     */
    function isThisContainerOrFunctionBlock(node) {
        switch (node.kind) {
            // Arrow functions use the same scope, but may do so in a "delayed" manner
            // For example, `const getThis = () => this` may be before a super() call in a derived constructor
            case 214 /* SyntaxKind.ArrowFunction */:
            case 256 /* SyntaxKind.FunctionDeclaration */:
            case 213 /* SyntaxKind.FunctionExpression */:
            case 167 /* SyntaxKind.PropertyDeclaration */:
                return true;
            case 235 /* SyntaxKind.Block */:
                switch (node.parent.kind) {
                    case 171 /* SyntaxKind.Constructor */:
                    case 169 /* SyntaxKind.MethodDeclaration */:
                    case 172 /* SyntaxKind.GetAccessor */:
                    case 173 /* SyntaxKind.SetAccessor */:
                        // Object properties can have computed names; only method-like bodies start a new scope
                        return true;
                    default:
                        return false;
                }
            default:
                return false;
        }
    }
    ts.isThisContainerOrFunctionBlock = isThisContainerOrFunctionBlock;
    function isInTopLevelContext(node) {
        // The name of a class or function declaration is a BindingIdentifier in its surrounding scope.
        if (ts.isIdentifier(node) && (ts.isClassDeclaration(node.parent) || ts.isFunctionDeclaration(node.parent)) && node.parent.name === node) {
            node = node.parent;
        }
        var container = getThisContainer(node, /*includeArrowFunctions*/ true);
        return ts.isSourceFile(container);
    }
    ts.isInTopLevelContext = isInTopLevelContext;
    function getNewTargetContainer(node) {
        var container = getThisContainer(node, /*includeArrowFunctions*/ false);
        if (container) {
            switch (container.kind) {
                case 171 /* SyntaxKind.Constructor */:
                case 256 /* SyntaxKind.FunctionDeclaration */:
                case 213 /* SyntaxKind.FunctionExpression */:
                    return container;
            }
        }
        return undefined;
    }
    ts.getNewTargetContainer = getNewTargetContainer;
    /**
     * Given an super call/property node, returns the closest node where
     * - a super call/property access is legal in the node and not legal in the parent node the node.
     *   i.e. super call is legal in constructor but not legal in the class body.
     * - the container is an arrow function (so caller might need to call getSuperContainer again in case it needs to climb higher)
     * - a super call/property is definitely illegal in the container (but might be legal in some subnode)
     *   i.e. super property access is illegal in function declaration but can be legal in the statement list
     */
    function getSuperContainer(node, stopOnFunctions) {
        while (true) {
            node = node.parent;
            if (!node) {
                return node;
            }
            switch (node.kind) {
                case 162 /* SyntaxKind.ComputedPropertyName */:
                    node = node.parent;
                    break;
                case 256 /* SyntaxKind.FunctionDeclaration */:
                case 213 /* SyntaxKind.FunctionExpression */:
                case 214 /* SyntaxKind.ArrowFunction */:
                    if (!stopOnFunctions) {
                        continue;
                    }
                // falls through
                case 167 /* SyntaxKind.PropertyDeclaration */:
                case 166 /* SyntaxKind.PropertySignature */:
                case 169 /* SyntaxKind.MethodDeclaration */:
                case 168 /* SyntaxKind.MethodSignature */:
                case 171 /* SyntaxKind.Constructor */:
                case 172 /* SyntaxKind.GetAccessor */:
                case 173 /* SyntaxKind.SetAccessor */:
                case 170 /* SyntaxKind.ClassStaticBlockDeclaration */:
                    return node;
                case 165 /* SyntaxKind.Decorator */:
                    // Decorators are always applied outside of the body of a class or method.
                    if (node.parent.kind === 164 /* SyntaxKind.Parameter */ && ts.isClassElement(node.parent.parent)) {
                        // If the decorator's parent is a Parameter, we resolve the this container from
                        // the grandparent class declaration.
                        node = node.parent.parent;
                    }
                    else if (ts.isClassElement(node.parent)) {
                        // If the decorator's parent is a class element, we resolve the 'this' container
                        // from the parent class declaration.
                        node = node.parent;
                    }
                    break;
            }
        }
    }
    ts.getSuperContainer = getSuperContainer;
    function getImmediatelyInvokedFunctionExpression(func) {
        if (func.kind === 213 /* SyntaxKind.FunctionExpression */ || func.kind === 214 /* SyntaxKind.ArrowFunction */) {
            var prev = func;
            var parent = func.parent;
            while (parent.kind === 212 /* SyntaxKind.ParenthesizedExpression */) {
                prev = parent;
                parent = parent.parent;
            }
            if (parent.kind === 208 /* SyntaxKind.CallExpression */ && parent.expression === prev) {
                return parent;
            }
        }
    }
    ts.getImmediatelyInvokedFunctionExpression = getImmediatelyInvokedFunctionExpression;
    function isSuperOrSuperProperty(node) {
        return node.kind === 106 /* SyntaxKind.SuperKeyword */
            || isSuperProperty(node);
    }
    ts.isSuperOrSuperProperty = isSuperOrSuperProperty;
    /**
     * Determines whether a node is a property or element access expression for `super`.
     */
    function isSuperProperty(node) {
        var kind = node.kind;
        return (kind === 206 /* SyntaxKind.PropertyAccessExpression */ || kind === 207 /* SyntaxKind.ElementAccessExpression */)
            && node.expression.kind === 106 /* SyntaxKind.SuperKeyword */;
    }
    ts.isSuperProperty = isSuperProperty;
    /**
     * Determines whether a node is a property or element access expression for `this`.
     */
    function isThisProperty(node) {
        var kind = node.kind;
        return (kind === 206 /* SyntaxKind.PropertyAccessExpression */ || kind === 207 /* SyntaxKind.ElementAccessExpression */)
            && node.expression.kind === 108 /* SyntaxKind.ThisKeyword */;
    }
    ts.isThisProperty = isThisProperty;
    function isThisInitializedDeclaration(node) {
        var _a;
        return !!node && ts.isVariableDeclaration(node) && ((_a = node.initializer) === null || _a === void 0 ? void 0 : _a.kind) === 108 /* SyntaxKind.ThisKeyword */;
    }
    ts.isThisInitializedDeclaration = isThisInitializedDeclaration;
    function isThisInitializedObjectBindingExpression(node) {
        return !!node
            && (ts.isShorthandPropertyAssignment(node) || ts.isPropertyAssignment(node))
            && ts.isBinaryExpression(node.parent.parent)
            && node.parent.parent.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */
            && node.parent.parent.right.kind === 108 /* SyntaxKind.ThisKeyword */;
    }
    ts.isThisInitializedObjectBindingExpression = isThisInitializedObjectBindingExpression;
    function getEntityNameFromTypeNode(node) {
        switch (node.kind) {
            case 178 /* SyntaxKind.TypeReference */:
                return node.typeName;
            case 228 /* SyntaxKind.ExpressionWithTypeArguments */:
                return isEntityNameExpression(node.expression)
                    ? node.expression
                    : undefined;
            // TODO(rbuckton): These aren't valid TypeNodes, but we treat them as such because of `isPartOfTypeNode`, which returns `true` for things that aren't `TypeNode`s.
            case 79 /* SyntaxKind.Identifier */:
            case 161 /* SyntaxKind.QualifiedName */:
                return node;
        }
        return undefined;
    }
    ts.getEntityNameFromTypeNode = getEntityNameFromTypeNode;
    function getInvokedExpression(node) {
        switch (node.kind) {
            case 210 /* SyntaxKind.TaggedTemplateExpression */:
                return node.tag;
            case 280 /* SyntaxKind.JsxOpeningElement */:
            case 279 /* SyntaxKind.JsxSelfClosingElement */:
                return node.tagName;
            default:
                return node.expression;
        }
    }
    ts.getInvokedExpression = getInvokedExpression;
    function nodeCanBeDecorated(node, parent, grandparent) {
        // private names cannot be used with decorators yet
        if (ts.isNamedDeclaration(node) && ts.isPrivateIdentifier(node.name)) {
            return false;
        }
        switch (node.kind) {
            case 257 /* SyntaxKind.ClassDeclaration */:
                // classes are valid targets
                return true;
            case 167 /* SyntaxKind.PropertyDeclaration */:
                // property declarations are valid if their parent is a class declaration.
                return parent.kind === 257 /* SyntaxKind.ClassDeclaration */;
            case 172 /* SyntaxKind.GetAccessor */:
            case 173 /* SyntaxKind.SetAccessor */:
            case 169 /* SyntaxKind.MethodDeclaration */:
                // if this method has a body and its parent is a class declaration, this is a valid target.
                return node.body !== undefined
                    && parent.kind === 257 /* SyntaxKind.ClassDeclaration */;
            case 164 /* SyntaxKind.Parameter */:
                // if the parameter's parent has a body and its grandparent is a class declaration, this is a valid target;
                return parent.body !== undefined
                    && (parent.kind === 171 /* SyntaxKind.Constructor */
                        || parent.kind === 169 /* SyntaxKind.MethodDeclaration */
                        || parent.kind === 173 /* SyntaxKind.SetAccessor */)
                    && grandparent.kind === 257 /* SyntaxKind.ClassDeclaration */;
        }
        return false;
    }
    ts.nodeCanBeDecorated = nodeCanBeDecorated;
    function nodeIsDecorated(node, parent, grandparent) {
        return hasDecorators(node)
            && nodeCanBeDecorated(node, parent, grandparent); // TODO: GH#18217
    }
    ts.nodeIsDecorated = nodeIsDecorated;
    function nodeOrChildIsDecorated(node, parent, grandparent) {
        return nodeIsDecorated(node, parent, grandparent) || childIsDecorated(node, parent); // TODO: GH#18217
    }
    ts.nodeOrChildIsDecorated = nodeOrChildIsDecorated;
    function childIsDecorated(node, parent) {
        switch (node.kind) {
            case 257 /* SyntaxKind.ClassDeclaration */:
                return ts.some(node.members, function (m) { return nodeOrChildIsDecorated(m, node, parent); }); // TODO: GH#18217
            case 169 /* SyntaxKind.MethodDeclaration */:
            case 173 /* SyntaxKind.SetAccessor */:
            case 171 /* SyntaxKind.Constructor */:
                return ts.some(node.parameters, function (p) { return nodeIsDecorated(p, node, parent); }); // TODO: GH#18217
            default:
                return false;
        }
    }
    ts.childIsDecorated = childIsDecorated;
    function classOrConstructorParameterIsDecorated(node) {
        if (nodeIsDecorated(node))
            return true;
        var constructor = getFirstConstructorWithBody(node);
        return !!constructor && childIsDecorated(constructor, node);
    }
    ts.classOrConstructorParameterIsDecorated = classOrConstructorParameterIsDecorated;
    function isJSXTagName(node) {
        var parent = node.parent;
        if (parent.kind === 280 /* SyntaxKind.JsxOpeningElement */ ||
            parent.kind === 279 /* SyntaxKind.JsxSelfClosingElement */ ||
            parent.kind === 281 /* SyntaxKind.JsxClosingElement */) {
            return parent.tagName === node;
        }
        return false;
    }
    ts.isJSXTagName = isJSXTagName;
    function isExpressionNode(node) {
        switch (node.kind) {
            case 106 /* SyntaxKind.SuperKeyword */:
            case 104 /* SyntaxKind.NullKeyword */:
            case 110 /* SyntaxKind.TrueKeyword */:
            case 95 /* SyntaxKind.FalseKeyword */:
            case 13 /* SyntaxKind.RegularExpressionLiteral */:
            case 204 /* SyntaxKind.ArrayLiteralExpression */:
            case 205 /* SyntaxKind.ObjectLiteralExpression */:
            case 206 /* SyntaxKind.PropertyAccessExpression */:
            case 207 /* SyntaxKind.ElementAccessExpression */:
            case 208 /* SyntaxKind.CallExpression */:
            case 209 /* SyntaxKind.NewExpression */:
            case 210 /* SyntaxKind.TaggedTemplateExpression */:
            case 229 /* SyntaxKind.AsExpression */:
            case 211 /* SyntaxKind.TypeAssertionExpression */:
            case 230 /* SyntaxKind.NonNullExpression */:
            case 212 /* SyntaxKind.ParenthesizedExpression */:
            case 213 /* SyntaxKind.FunctionExpression */:
            case 226 /* SyntaxKind.ClassExpression */:
            case 214 /* SyntaxKind.ArrowFunction */:
            case 217 /* SyntaxKind.VoidExpression */:
            case 215 /* SyntaxKind.DeleteExpression */:
            case 216 /* SyntaxKind.TypeOfExpression */:
            case 219 /* SyntaxKind.PrefixUnaryExpression */:
            case 220 /* SyntaxKind.PostfixUnaryExpression */:
            case 221 /* SyntaxKind.BinaryExpression */:
            case 222 /* SyntaxKind.ConditionalExpression */:
            case 225 /* SyntaxKind.SpreadElement */:
            case 223 /* SyntaxKind.TemplateExpression */:
            case 227 /* SyntaxKind.OmittedExpression */:
            case 278 /* SyntaxKind.JsxElement */:
            case 279 /* SyntaxKind.JsxSelfClosingElement */:
            case 282 /* SyntaxKind.JsxFragment */:
            case 224 /* SyntaxKind.YieldExpression */:
            case 218 /* SyntaxKind.AwaitExpression */:
            case 231 /* SyntaxKind.MetaProperty */:
                return true;
            case 228 /* SyntaxKind.ExpressionWithTypeArguments */:
                return !ts.isHeritageClause(node.parent);
            case 161 /* SyntaxKind.QualifiedName */:
                while (node.parent.kind === 161 /* SyntaxKind.QualifiedName */) {
                    node = node.parent;
                }
                return node.parent.kind === 181 /* SyntaxKind.TypeQuery */ || ts.isJSDocLinkLike(node.parent) || ts.isJSDocNameReference(node.parent) || ts.isJSDocMemberName(node.parent) || isJSXTagName(node);
            case 311 /* SyntaxKind.JSDocMemberName */:
                while (ts.isJSDocMemberName(node.parent)) {
                    node = node.parent;
                }
                return node.parent.kind === 181 /* SyntaxKind.TypeQuery */ || ts.isJSDocLinkLike(node.parent) || ts.isJSDocNameReference(node.parent) || ts.isJSDocMemberName(node.parent) || isJSXTagName(node);
            case 80 /* SyntaxKind.PrivateIdentifier */:
                return ts.isBinaryExpression(node.parent) && node.parent.left === node && node.parent.operatorToken.kind === 101 /* SyntaxKind.InKeyword */;
            case 79 /* SyntaxKind.Identifier */:
                if (node.parent.kind === 181 /* SyntaxKind.TypeQuery */ || ts.isJSDocLinkLike(node.parent) || ts.isJSDocNameReference(node.parent) || ts.isJSDocMemberName(node.parent) || isJSXTagName(node)) {
                    return true;
                }
            // falls through
            case 8 /* SyntaxKind.NumericLiteral */:
            case 9 /* SyntaxKind.BigIntLiteral */:
            case 10 /* SyntaxKind.StringLiteral */:
            case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
            case 108 /* SyntaxKind.ThisKeyword */:
                return isInExpressionContext(node);
            default:
                return false;
        }
    }
    ts.isExpressionNode = isExpressionNode;
    function isInExpressionContext(node) {
        var parent = node.parent;
        switch (parent.kind) {
            case 254 /* SyntaxKind.VariableDeclaration */:
            case 164 /* SyntaxKind.Parameter */:
            case 167 /* SyntaxKind.PropertyDeclaration */:
            case 166 /* SyntaxKind.PropertySignature */:
            case 299 /* SyntaxKind.EnumMember */:
            case 296 /* SyntaxKind.PropertyAssignment */:
            case 203 /* SyntaxKind.BindingElement */:
                return parent.initializer === node;
            case 238 /* SyntaxKind.ExpressionStatement */:
            case 239 /* SyntaxKind.IfStatement */:
            case 240 /* SyntaxKind.DoStatement */:
            case 241 /* SyntaxKind.WhileStatement */:
            case 247 /* SyntaxKind.ReturnStatement */:
            case 248 /* SyntaxKind.WithStatement */:
            case 249 /* SyntaxKind.SwitchStatement */:
            case 289 /* SyntaxKind.CaseClause */:
            case 251 /* SyntaxKind.ThrowStatement */:
                return parent.expression === node;
            case 242 /* SyntaxKind.ForStatement */:
                var forStatement = parent;
                return (forStatement.initializer === node && forStatement.initializer.kind !== 255 /* SyntaxKind.VariableDeclarationList */) ||
                    forStatement.condition === node ||
                    forStatement.incrementor === node;
            case 243 /* SyntaxKind.ForInStatement */:
            case 244 /* SyntaxKind.ForOfStatement */:
                var forInStatement = parent;
                return (forInStatement.initializer === node && forInStatement.initializer.kind !== 255 /* SyntaxKind.VariableDeclarationList */) ||
                    forInStatement.expression === node;
            case 211 /* SyntaxKind.TypeAssertionExpression */:
            case 229 /* SyntaxKind.AsExpression */:
                return node === parent.expression;
            case 233 /* SyntaxKind.TemplateSpan */:
                return node === parent.expression;
            case 162 /* SyntaxKind.ComputedPropertyName */:
                return node === parent.expression;
            case 165 /* SyntaxKind.Decorator */:
            case 288 /* SyntaxKind.JsxExpression */:
            case 287 /* SyntaxKind.JsxSpreadAttribute */:
            case 298 /* SyntaxKind.SpreadAssignment */:
                return true;
            case 228 /* SyntaxKind.ExpressionWithTypeArguments */:
                return parent.expression === node && !isPartOfTypeNode(parent);
            case 297 /* SyntaxKind.ShorthandPropertyAssignment */:
                return parent.objectAssignmentInitializer === node;
            default:
                return isExpressionNode(parent);
        }
    }
    ts.isInExpressionContext = isInExpressionContext;
    function isPartOfTypeQuery(node) {
        while (node.kind === 161 /* SyntaxKind.QualifiedName */ || node.kind === 79 /* SyntaxKind.Identifier */) {
            node = node.parent;
        }
        return node.kind === 181 /* SyntaxKind.TypeQuery */;
    }
    ts.isPartOfTypeQuery = isPartOfTypeQuery;
    function isNamespaceReexportDeclaration(node) {
        return ts.isNamespaceExport(node) && !!node.parent.moduleSpecifier;
    }
    ts.isNamespaceReexportDeclaration = isNamespaceReexportDeclaration;
    function isExternalModuleImportEqualsDeclaration(node) {
        return node.kind === 265 /* SyntaxKind.ImportEqualsDeclaration */ && node.moduleReference.kind === 277 /* SyntaxKind.ExternalModuleReference */;
    }
    ts.isExternalModuleImportEqualsDeclaration = isExternalModuleImportEqualsDeclaration;
    function getExternalModuleImportEqualsDeclarationExpression(node) {
        ts.Debug.assert(isExternalModuleImportEqualsDeclaration(node));
        return node.moduleReference.expression;
    }
    ts.getExternalModuleImportEqualsDeclarationExpression = getExternalModuleImportEqualsDeclarationExpression;
    function getExternalModuleRequireArgument(node) {
        return isVariableDeclarationInitializedToBareOrAccessedRequire(node) && getLeftmostAccessExpression(node.initializer).arguments[0];
    }
    ts.getExternalModuleRequireArgument = getExternalModuleRequireArgument;
    function isInternalModuleImportEqualsDeclaration(node) {
        return node.kind === 265 /* SyntaxKind.ImportEqualsDeclaration */ && node.moduleReference.kind !== 277 /* SyntaxKind.ExternalModuleReference */;
    }
    ts.isInternalModuleImportEqualsDeclaration = isInternalModuleImportEqualsDeclaration;
    function isSourceFileJS(file) {
        return isInJSFile(file);
    }
    ts.isSourceFileJS = isSourceFileJS;
    function isSourceFileNotJS(file) {
        return !isInJSFile(file);
    }
    ts.isSourceFileNotJS = isSourceFileNotJS;
    function isInJSFile(node) {
        return !!node && !!(node.flags & 262144 /* NodeFlags.JavaScriptFile */);
    }
    ts.isInJSFile = isInJSFile;
    function isInJsonFile(node) {
        return !!node && !!(node.flags & 67108864 /* NodeFlags.JsonFile */);
    }
    ts.isInJsonFile = isInJsonFile;
    function isSourceFileNotJson(file) {
        return !isJsonSourceFile(file);
    }
    ts.isSourceFileNotJson = isSourceFileNotJson;
    function isInJSDoc(node) {
        return !!node && !!(node.flags & 8388608 /* NodeFlags.JSDoc */);
    }
    ts.isInJSDoc = isInJSDoc;
    function isJSDocIndexSignature(node) {
        return ts.isTypeReferenceNode(node) &&
            ts.isIdentifier(node.typeName) &&
            node.typeName.escapedText === "Object" &&
            node.typeArguments && node.typeArguments.length === 2 &&
            (node.typeArguments[0].kind === 150 /* SyntaxKind.StringKeyword */ || node.typeArguments[0].kind === 147 /* SyntaxKind.NumberKeyword */);
    }
    ts.isJSDocIndexSignature = isJSDocIndexSignature;
    function isRequireCall(callExpression, requireStringLiteralLikeArgument) {
        if (callExpression.kind !== 208 /* SyntaxKind.CallExpression */) {
            return false;
        }
        var _a = callExpression, expression = _a.expression, args = _a.arguments;
        if (expression.kind !== 79 /* SyntaxKind.Identifier */ || expression.escapedText !== "require") {
            return false;
        }
        if (args.length !== 1) {
            return false;
        }
        var arg = args[0];
        return !requireStringLiteralLikeArgument || ts.isStringLiteralLike(arg);
    }
    ts.isRequireCall = isRequireCall;
    /**
     * Returns true if the node is a VariableDeclaration initialized to a require call (see `isRequireCall`).
     * This function does not test if the node is in a JavaScript file or not.
     */
    function isVariableDeclarationInitializedToRequire(node) {
        return isVariableDeclarationInitializedWithRequireHelper(node, /*allowAccessedRequire*/ false);
    }
    ts.isVariableDeclarationInitializedToRequire = isVariableDeclarationInitializedToRequire;
    /**
     * Like {@link isVariableDeclarationInitializedToRequire} but allows things like `require("...").foo.bar` or `require("...")["baz"]`.
     */
    function isVariableDeclarationInitializedToBareOrAccessedRequire(node) {
        return isVariableDeclarationInitializedWithRequireHelper(node, /*allowAccessedRequire*/ true);
    }
    ts.isVariableDeclarationInitializedToBareOrAccessedRequire = isVariableDeclarationInitializedToBareOrAccessedRequire;
    function isVariableDeclarationInitializedWithRequireHelper(node, allowAccessedRequire) {
        return ts.isVariableDeclaration(node) &&
            !!node.initializer &&
            isRequireCall(allowAccessedRequire ? getLeftmostAccessExpression(node.initializer) : node.initializer, /*requireStringLiteralLikeArgument*/ true);
    }
    function isRequireVariableStatement(node) {
        return ts.isVariableStatement(node)
            && node.declarationList.declarations.length > 0
            && ts.every(node.declarationList.declarations, function (decl) { return isVariableDeclarationInitializedToRequire(decl); });
    }
    ts.isRequireVariableStatement = isRequireVariableStatement;
    function isSingleOrDoubleQuote(charCode) {
        return charCode === 39 /* CharacterCodes.singleQuote */ || charCode === 34 /* CharacterCodes.doubleQuote */;
    }
    ts.isSingleOrDoubleQuote = isSingleOrDoubleQuote;
    function isStringDoubleQuoted(str, sourceFile) {
        return getSourceTextOfNodeFromSourceFile(sourceFile, str).charCodeAt(0) === 34 /* CharacterCodes.doubleQuote */;
    }
    ts.isStringDoubleQuoted = isStringDoubleQuoted;
    function isAssignmentDeclaration(decl) {
        return ts.isBinaryExpression(decl) || isAccessExpression(decl) || ts.isIdentifier(decl) || ts.isCallExpression(decl);
    }
    ts.isAssignmentDeclaration = isAssignmentDeclaration;
    /** Get the initializer, taking into account defaulted Javascript initializers */
    function getEffectiveInitializer(node) {
        if (isInJSFile(node) && node.initializer &&
            ts.isBinaryExpression(node.initializer) &&
            (node.initializer.operatorToken.kind === 56 /* SyntaxKind.BarBarToken */ || node.initializer.operatorToken.kind === 60 /* SyntaxKind.QuestionQuestionToken */) &&
            node.name && isEntityNameExpression(node.name) && isSameEntityName(node.name, node.initializer.left)) {
            return node.initializer.right;
        }
        return node.initializer;
    }
    ts.getEffectiveInitializer = getEffectiveInitializer;
    /** Get the declaration initializer when it is container-like (See getExpandoInitializer). */
    function getDeclaredExpandoInitializer(node) {
        var init = getEffectiveInitializer(node);
        return init && getExpandoInitializer(init, isPrototypeAccess(node.name));
    }
    ts.getDeclaredExpandoInitializer = getDeclaredExpandoInitializer;
    function hasExpandoValueProperty(node, isPrototypeAssignment) {
        return ts.forEach(node.properties, function (p) {
            return ts.isPropertyAssignment(p) &&
                ts.isIdentifier(p.name) &&
                p.name.escapedText === "value" &&
                p.initializer &&
                getExpandoInitializer(p.initializer, isPrototypeAssignment);
        });
    }
    /**
     * Get the assignment 'initializer' -- the righthand side-- when the initializer is container-like (See getExpandoInitializer).
     * We treat the right hand side of assignments with container-like initializers as declarations.
     */
    function getAssignedExpandoInitializer(node) {
        if (node && node.parent && ts.isBinaryExpression(node.parent) && node.parent.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */) {
            var isPrototypeAssignment = isPrototypeAccess(node.parent.left);
            return getExpandoInitializer(node.parent.right, isPrototypeAssignment) ||
                getDefaultedExpandoInitializer(node.parent.left, node.parent.right, isPrototypeAssignment);
        }
        if (node && ts.isCallExpression(node) && isBindableObjectDefinePropertyCall(node)) {
            var result = hasExpandoValueProperty(node.arguments[2], node.arguments[1].text === "prototype");
            if (result) {
                return result;
            }
        }
    }
    ts.getAssignedExpandoInitializer = getAssignedExpandoInitializer;
    /**
     * Recognized expando initializers are:
     * 1. (function() {})() -- IIFEs
     * 2. function() { } -- Function expressions
     * 3. class { } -- Class expressions
     * 4. {} -- Empty object literals
     * 5. { ... } -- Non-empty object literals, when used to initialize a prototype, like `C.prototype = { m() { } }`
     *
     * This function returns the provided initializer, or undefined if it is not valid.
     */
    function getExpandoInitializer(initializer, isPrototypeAssignment) {
        if (ts.isCallExpression(initializer)) {
            var e = skipParentheses(initializer.expression);
            return e.kind === 213 /* SyntaxKind.FunctionExpression */ || e.kind === 214 /* SyntaxKind.ArrowFunction */ ? initializer : undefined;
        }
        if (initializer.kind === 213 /* SyntaxKind.FunctionExpression */ ||
            initializer.kind === 226 /* SyntaxKind.ClassExpression */ ||
            initializer.kind === 214 /* SyntaxKind.ArrowFunction */) {
            return initializer;
        }
        if (ts.isObjectLiteralExpression(initializer) && (initializer.properties.length === 0 || isPrototypeAssignment)) {
            return initializer;
        }
    }
    ts.getExpandoInitializer = getExpandoInitializer;
    /**
     * A defaulted expando initializer matches the pattern
     * `Lhs = Lhs || ExpandoInitializer`
     * or `var Lhs = Lhs || ExpandoInitializer`
     *
     * The second Lhs is required to be the same as the first except that it may be prefixed with
     * 'window.', 'global.' or 'self.' The second Lhs is otherwise ignored by the binder and checker.
     */
    function getDefaultedExpandoInitializer(name, initializer, isPrototypeAssignment) {
        var e = ts.isBinaryExpression(initializer)
            && (initializer.operatorToken.kind === 56 /* SyntaxKind.BarBarToken */ || initializer.operatorToken.kind === 60 /* SyntaxKind.QuestionQuestionToken */)
            && getExpandoInitializer(initializer.right, isPrototypeAssignment);
        if (e && isSameEntityName(name, initializer.left)) {
            return e;
        }
    }
    function isDefaultedExpandoInitializer(node) {
        var name = ts.isVariableDeclaration(node.parent) ? node.parent.name :
            ts.isBinaryExpression(node.parent) && node.parent.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */ ? node.parent.left :
                undefined;
        return name && getExpandoInitializer(node.right, isPrototypeAccess(name)) && isEntityNameExpression(name) && isSameEntityName(name, node.left);
    }
    ts.isDefaultedExpandoInitializer = isDefaultedExpandoInitializer;
    /** Given an expando initializer, return its declaration name, or the left-hand side of the assignment if it's part of an assignment declaration. */
    function getNameOfExpando(node) {
        if (ts.isBinaryExpression(node.parent)) {
            var parent = ((node.parent.operatorToken.kind === 56 /* SyntaxKind.BarBarToken */ || node.parent.operatorToken.kind === 60 /* SyntaxKind.QuestionQuestionToken */) && ts.isBinaryExpression(node.parent.parent)) ? node.parent.parent : node.parent;
            if (parent.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */ && ts.isIdentifier(parent.left)) {
                return parent.left;
            }
        }
        else if (ts.isVariableDeclaration(node.parent)) {
            return node.parent.name;
        }
    }
    ts.getNameOfExpando = getNameOfExpando;
    /**
     * Is the 'declared' name the same as the one in the initializer?
     * @return true for identical entity names, as well as ones where the initializer is prefixed with
     * 'window', 'self' or 'global'. For example:
     *
     * var my = my || {}
     * var min = window.min || {}
     * my.app = self.my.app || class { }
     */
    function isSameEntityName(name, initializer) {
        if (isPropertyNameLiteral(name) && isPropertyNameLiteral(initializer)) {
            return getTextOfIdentifierOrLiteral(name) === getTextOfIdentifierOrLiteral(initializer);
        }
        if (ts.isMemberName(name) && isLiteralLikeAccess(initializer) &&
            (initializer.expression.kind === 108 /* SyntaxKind.ThisKeyword */ ||
                ts.isIdentifier(initializer.expression) &&
                    (initializer.expression.escapedText === "window" ||
                        initializer.expression.escapedText === "self" ||
                        initializer.expression.escapedText === "global"))) {
            return isSameEntityName(name, getNameOrArgument(initializer));
        }
        if (isLiteralLikeAccess(name) && isLiteralLikeAccess(initializer)) {
            return getElementOrPropertyAccessName(name) === getElementOrPropertyAccessName(initializer)
                && isSameEntityName(name.expression, initializer.expression);
        }
        return false;
    }
    ts.isSameEntityName = isSameEntityName;
    function getRightMostAssignedExpression(node) {
        while (isAssignmentExpression(node, /*excludeCompoundAssignments*/ true)) {
            node = node.right;
        }
        return node;
    }
    ts.getRightMostAssignedExpression = getRightMostAssignedExpression;
    function isExportsIdentifier(node) {
        return ts.isIdentifier(node) && node.escapedText === "exports";
    }
    ts.isExportsIdentifier = isExportsIdentifier;
    function isModuleIdentifier(node) {
        return ts.isIdentifier(node) && node.escapedText === "module";
    }
    ts.isModuleIdentifier = isModuleIdentifier;
    function isModuleExportsAccessExpression(node) {
        return (ts.isPropertyAccessExpression(node) || isLiteralLikeElementAccess(node))
            && isModuleIdentifier(node.expression)
            && getElementOrPropertyAccessName(node) === "exports";
    }
    ts.isModuleExportsAccessExpression = isModuleExportsAccessExpression;
    /// Given a BinaryExpression, returns SpecialPropertyAssignmentKind for the various kinds of property
    /// assignments we treat as special in the binder
    function getAssignmentDeclarationKind(expr) {
        var special = getAssignmentDeclarationKindWorker(expr);
        return special === 5 /* AssignmentDeclarationKind.Property */ || isInJSFile(expr) ? special : 0 /* AssignmentDeclarationKind.None */;
    }
    ts.getAssignmentDeclarationKind = getAssignmentDeclarationKind;
    function isBindableObjectDefinePropertyCall(expr) {
        return ts.length(expr.arguments) === 3 &&
            ts.isPropertyAccessExpression(expr.expression) &&
            ts.isIdentifier(expr.expression.expression) &&
            ts.idText(expr.expression.expression) === "Object" &&
            ts.idText(expr.expression.name) === "defineProperty" &&
            isStringOrNumericLiteralLike(expr.arguments[1]) &&
            isBindableStaticNameExpression(expr.arguments[0], /*excludeThisKeyword*/ true);
    }
    ts.isBindableObjectDefinePropertyCall = isBindableObjectDefinePropertyCall;
    /** x.y OR x[0] */
    function isLiteralLikeAccess(node) {
        return ts.isPropertyAccessExpression(node) || isLiteralLikeElementAccess(node);
    }
    ts.isLiteralLikeAccess = isLiteralLikeAccess;
    /** x[0] OR x['a'] OR x[Symbol.y] */
    function isLiteralLikeElementAccess(node) {
        return ts.isElementAccessExpression(node) && isStringOrNumericLiteralLike(node.argumentExpression);
    }
    ts.isLiteralLikeElementAccess = isLiteralLikeElementAccess;
    /** Any series of property and element accesses. */
    function isBindableStaticAccessExpression(node, excludeThisKeyword) {
        return ts.isPropertyAccessExpression(node) && (!excludeThisKeyword && node.expression.kind === 108 /* SyntaxKind.ThisKeyword */ || ts.isIdentifier(node.name) && isBindableStaticNameExpression(node.expression, /*excludeThisKeyword*/ true))
            || isBindableStaticElementAccessExpression(node, excludeThisKeyword);
    }
    ts.isBindableStaticAccessExpression = isBindableStaticAccessExpression;
    /** Any series of property and element accesses, ending in a literal element access */
    function isBindableStaticElementAccessExpression(node, excludeThisKeyword) {
        return isLiteralLikeElementAccess(node)
            && ((!excludeThisKeyword && node.expression.kind === 108 /* SyntaxKind.ThisKeyword */) ||
                isEntityNameExpression(node.expression) ||
                isBindableStaticAccessExpression(node.expression, /*excludeThisKeyword*/ true));
    }
    ts.isBindableStaticElementAccessExpression = isBindableStaticElementAccessExpression;
    function isBindableStaticNameExpression(node, excludeThisKeyword) {
        return isEntityNameExpression(node) || isBindableStaticAccessExpression(node, excludeThisKeyword);
    }
    ts.isBindableStaticNameExpression = isBindableStaticNameExpression;
    function getNameOrArgument(expr) {
        if (ts.isPropertyAccessExpression(expr)) {
            return expr.name;
        }
        return expr.argumentExpression;
    }
    ts.getNameOrArgument = getNameOrArgument;
    function getAssignmentDeclarationKindWorker(expr) {
        if (ts.isCallExpression(expr)) {
            if (!isBindableObjectDefinePropertyCall(expr)) {
                return 0 /* AssignmentDeclarationKind.None */;
            }
            var entityName = expr.arguments[0];
            if (isExportsIdentifier(entityName) || isModuleExportsAccessExpression(entityName)) {
                return 8 /* AssignmentDeclarationKind.ObjectDefinePropertyExports */;
            }
            if (isBindableStaticAccessExpression(entityName) && getElementOrPropertyAccessName(entityName) === "prototype") {
                return 9 /* AssignmentDeclarationKind.ObjectDefinePrototypeProperty */;
            }
            return 7 /* AssignmentDeclarationKind.ObjectDefinePropertyValue */;
        }
        if (expr.operatorToken.kind !== 63 /* SyntaxKind.EqualsToken */ || !isAccessExpression(expr.left) || isVoidZero(getRightMostAssignedExpression(expr))) {
            return 0 /* AssignmentDeclarationKind.None */;
        }
        if (isBindableStaticNameExpression(expr.left.expression, /*excludeThisKeyword*/ true) && getElementOrPropertyAccessName(expr.left) === "prototype" && ts.isObjectLiteralExpression(getInitializerOfBinaryExpression(expr))) {
            // F.prototype = { ... }
            return 6 /* AssignmentDeclarationKind.Prototype */;
        }
        return getAssignmentDeclarationPropertyAccessKind(expr.left);
    }
    function isVoidZero(node) {
        return ts.isVoidExpression(node) && ts.isNumericLiteral(node.expression) && node.expression.text === "0";
    }
    /**
     * Does not handle signed numeric names like `a[+0]` - handling those would require handling prefix unary expressions
     * throughout late binding handling as well, which is awkward (but ultimately probably doable if there is demand)
     */
    /* @internal */
    function getElementOrPropertyAccessArgumentExpressionOrName(node) {
        if (ts.isPropertyAccessExpression(node)) {
            return node.name;
        }
        var arg = skipParentheses(node.argumentExpression);
        if (ts.isNumericLiteral(arg) || ts.isStringLiteralLike(arg)) {
            return arg;
        }
        return node;
    }
    ts.getElementOrPropertyAccessArgumentExpressionOrName = getElementOrPropertyAccessArgumentExpressionOrName;
    function getElementOrPropertyAccessName(node) {
        var name = getElementOrPropertyAccessArgumentExpressionOrName(node);
        if (name) {
            if (ts.isIdentifier(name)) {
                return name.escapedText;
            }
            if (ts.isStringLiteralLike(name) || ts.isNumericLiteral(name)) {
                return ts.escapeLeadingUnderscores(name.text);
            }
        }
        return undefined;
    }
    ts.getElementOrPropertyAccessName = getElementOrPropertyAccessName;
    function getAssignmentDeclarationPropertyAccessKind(lhs) {
        if (lhs.expression.kind === 108 /* SyntaxKind.ThisKeyword */) {
            return 4 /* AssignmentDeclarationKind.ThisProperty */;
        }
        else if (isModuleExportsAccessExpression(lhs)) {
            // module.exports = expr
            return 2 /* AssignmentDeclarationKind.ModuleExports */;
        }
        else if (isBindableStaticNameExpression(lhs.expression, /*excludeThisKeyword*/ true)) {
            if (isPrototypeAccess(lhs.expression)) {
                // F.G....prototype.x = expr
                return 3 /* AssignmentDeclarationKind.PrototypeProperty */;
            }
            var nextToLast = lhs;
            while (!ts.isIdentifier(nextToLast.expression)) {
                nextToLast = nextToLast.expression;
            }
            var id = nextToLast.expression;
            if ((id.escapedText === "exports" ||
                id.escapedText === "module" && getElementOrPropertyAccessName(nextToLast) === "exports") &&
                // ExportsProperty does not support binding with computed names
                isBindableStaticAccessExpression(lhs)) {
                // exports.name = expr OR module.exports.name = expr OR exports["name"] = expr ...
                return 1 /* AssignmentDeclarationKind.ExportsProperty */;
            }
            if (isBindableStaticNameExpression(lhs, /*excludeThisKeyword*/ true) || (ts.isElementAccessExpression(lhs) && isDynamicName(lhs))) {
                // F.G...x = expr
                return 5 /* AssignmentDeclarationKind.Property */;
            }
        }
        return 0 /* AssignmentDeclarationKind.None */;
    }
    ts.getAssignmentDeclarationPropertyAccessKind = getAssignmentDeclarationPropertyAccessKind;
    function getInitializerOfBinaryExpression(expr) {
        while (ts.isBinaryExpression(expr.right)) {
            expr = expr.right;
        }
        return expr.right;
    }
    ts.getInitializerOfBinaryExpression = getInitializerOfBinaryExpression;
    function isPrototypePropertyAssignment(node) {
        return ts.isBinaryExpression(node) && getAssignmentDeclarationKind(node) === 3 /* AssignmentDeclarationKind.PrototypeProperty */;
    }
    ts.isPrototypePropertyAssignment = isPrototypePropertyAssignment;
    function isSpecialPropertyDeclaration(expr) {
        return isInJSFile(expr) &&
            expr.parent && expr.parent.kind === 238 /* SyntaxKind.ExpressionStatement */ &&
            (!ts.isElementAccessExpression(expr) || isLiteralLikeElementAccess(expr)) &&
            !!ts.getJSDocTypeTag(expr.parent);
    }
    ts.isSpecialPropertyDeclaration = isSpecialPropertyDeclaration;
    function setValueDeclaration(symbol, node) {
        var valueDeclaration = symbol.valueDeclaration;
        if (!valueDeclaration ||
            !(node.flags & 16777216 /* NodeFlags.Ambient */ && !(valueDeclaration.flags & 16777216 /* NodeFlags.Ambient */)) &&
                (isAssignmentDeclaration(valueDeclaration) && !isAssignmentDeclaration(node)) ||
            (valueDeclaration.kind !== node.kind && isEffectiveModuleDeclaration(valueDeclaration))) {
            // other kinds of value declarations take precedence over modules and assignment declarations
            symbol.valueDeclaration = node;
        }
    }
    ts.setValueDeclaration = setValueDeclaration;
    function isFunctionSymbol(symbol) {
        if (!symbol || !symbol.valueDeclaration) {
            return false;
        }
        var decl = symbol.valueDeclaration;
        return decl.kind === 256 /* SyntaxKind.FunctionDeclaration */ || ts.isVariableDeclaration(decl) && decl.initializer && ts.isFunctionLike(decl.initializer);
    }
    ts.isFunctionSymbol = isFunctionSymbol;
    function tryGetModuleSpecifierFromDeclaration(node) {
        var _a, _b;
        switch (node.kind) {
            case 254 /* SyntaxKind.VariableDeclaration */:
                return (_a = ts.findAncestor(node.initializer, function (node) { return isRequireCall(node, /*requireStringLiteralLikeArgument*/ true); })) === null || _a === void 0 ? void 0 : _a.arguments[0];
            case 266 /* SyntaxKind.ImportDeclaration */:
                return ts.tryCast(node.moduleSpecifier, ts.isStringLiteralLike);
            case 265 /* SyntaxKind.ImportEqualsDeclaration */:
                return ts.tryCast((_b = ts.tryCast(node.moduleReference, ts.isExternalModuleReference)) === null || _b === void 0 ? void 0 : _b.expression, ts.isStringLiteralLike);
            default:
                ts.Debug.assertNever(node);
        }
    }
    ts.tryGetModuleSpecifierFromDeclaration = tryGetModuleSpecifierFromDeclaration;
    function importFromModuleSpecifier(node) {
        return tryGetImportFromModuleSpecifier(node) || ts.Debug.failBadSyntaxKind(node.parent);
    }
    ts.importFromModuleSpecifier = importFromModuleSpecifier;
    function tryGetImportFromModuleSpecifier(node) {
        switch (node.parent.kind) {
            case 266 /* SyntaxKind.ImportDeclaration */:
            case 272 /* SyntaxKind.ExportDeclaration */:
                return node.parent;
            case 277 /* SyntaxKind.ExternalModuleReference */:
                return node.parent.parent;
            case 208 /* SyntaxKind.CallExpression */:
                return isImportCall(node.parent) || isRequireCall(node.parent, /*checkArg*/ false) ? node.parent : undefined;
            case 196 /* SyntaxKind.LiteralType */:
                ts.Debug.assert(ts.isStringLiteral(node));
                return ts.tryCast(node.parent.parent, ts.isImportTypeNode);
            default:
                return undefined;
        }
    }
    ts.tryGetImportFromModuleSpecifier = tryGetImportFromModuleSpecifier;
    function getExternalModuleName(node) {
        switch (node.kind) {
            case 266 /* SyntaxKind.ImportDeclaration */:
            case 272 /* SyntaxKind.ExportDeclaration */:
                return node.moduleSpecifier;
            case 265 /* SyntaxKind.ImportEqualsDeclaration */:
                return node.moduleReference.kind === 277 /* SyntaxKind.ExternalModuleReference */ ? node.moduleReference.expression : undefined;
            case 200 /* SyntaxKind.ImportType */:
                return isLiteralImportTypeNode(node) ? node.argument.literal : undefined;
            case 208 /* SyntaxKind.CallExpression */:
                return node.arguments[0];
            case 261 /* SyntaxKind.ModuleDeclaration */:
                return node.name.kind === 10 /* SyntaxKind.StringLiteral */ ? node.name : undefined;
            default:
                return ts.Debug.assertNever(node);
        }
    }
    ts.getExternalModuleName = getExternalModuleName;
    function getNamespaceDeclarationNode(node) {
        switch (node.kind) {
            case 266 /* SyntaxKind.ImportDeclaration */:
                return node.importClause && ts.tryCast(node.importClause.namedBindings, ts.isNamespaceImport);
            case 265 /* SyntaxKind.ImportEqualsDeclaration */:
                return node;
            case 272 /* SyntaxKind.ExportDeclaration */:
                return node.exportClause && ts.tryCast(node.exportClause, ts.isNamespaceExport);
            default:
                return ts.Debug.assertNever(node);
        }
    }
    ts.getNamespaceDeclarationNode = getNamespaceDeclarationNode;
    function isDefaultImport(node) {
        return node.kind === 266 /* SyntaxKind.ImportDeclaration */ && !!node.importClause && !!node.importClause.name;
    }
    ts.isDefaultImport = isDefaultImport;
    function forEachImportClauseDeclaration(node, action) {
        if (node.name) {
            var result = action(node);
            if (result)
                return result;
        }
        if (node.namedBindings) {
            var result = ts.isNamespaceImport(node.namedBindings)
                ? action(node.namedBindings)
                : ts.forEach(node.namedBindings.elements, action);
            if (result)
                return result;
        }
    }
    ts.forEachImportClauseDeclaration = forEachImportClauseDeclaration;
    function hasQuestionToken(node) {
        if (node) {
            switch (node.kind) {
                case 164 /* SyntaxKind.Parameter */:
                case 169 /* SyntaxKind.MethodDeclaration */:
                case 168 /* SyntaxKind.MethodSignature */:
                case 297 /* SyntaxKind.ShorthandPropertyAssignment */:
                case 296 /* SyntaxKind.PropertyAssignment */:
                case 167 /* SyntaxKind.PropertyDeclaration */:
                case 166 /* SyntaxKind.PropertySignature */:
                    return node.questionToken !== undefined;
            }
        }
        return false;
    }
    ts.hasQuestionToken = hasQuestionToken;
    function isJSDocConstructSignature(node) {
        var param = ts.isJSDocFunctionType(node) ? ts.firstOrUndefined(node.parameters) : undefined;
        var name = ts.tryCast(param && param.name, ts.isIdentifier);
        return !!name && name.escapedText === "new";
    }
    ts.isJSDocConstructSignature = isJSDocConstructSignature;
    function isJSDocTypeAlias(node) {
        return node.kind === 345 /* SyntaxKind.JSDocTypedefTag */ || node.kind === 338 /* SyntaxKind.JSDocCallbackTag */ || node.kind === 339 /* SyntaxKind.JSDocEnumTag */;
    }
    ts.isJSDocTypeAlias = isJSDocTypeAlias;
    function isTypeAlias(node) {
        return isJSDocTypeAlias(node) || ts.isTypeAliasDeclaration(node);
    }
    ts.isTypeAlias = isTypeAlias;
    function getSourceOfAssignment(node) {
        return ts.isExpressionStatement(node) &&
            ts.isBinaryExpression(node.expression) &&
            node.expression.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */
            ? getRightMostAssignedExpression(node.expression)
            : undefined;
    }
    function getSourceOfDefaultedAssignment(node) {
        return ts.isExpressionStatement(node) &&
            ts.isBinaryExpression(node.expression) &&
            getAssignmentDeclarationKind(node.expression) !== 0 /* AssignmentDeclarationKind.None */ &&
            ts.isBinaryExpression(node.expression.right) &&
            (node.expression.right.operatorToken.kind === 56 /* SyntaxKind.BarBarToken */ || node.expression.right.operatorToken.kind === 60 /* SyntaxKind.QuestionQuestionToken */)
            ? node.expression.right.right
            : undefined;
    }
    function getSingleInitializerOfVariableStatementOrPropertyDeclaration(node) {
        switch (node.kind) {
            case 237 /* SyntaxKind.VariableStatement */:
                var v = getSingleVariableOfVariableStatement(node);
                return v && v.initializer;
            case 167 /* SyntaxKind.PropertyDeclaration */:
                return node.initializer;
            case 296 /* SyntaxKind.PropertyAssignment */:
                return node.initializer;
        }
    }
    ts.getSingleInitializerOfVariableStatementOrPropertyDeclaration = getSingleInitializerOfVariableStatementOrPropertyDeclaration;
    function getSingleVariableOfVariableStatement(node) {
        return ts.isVariableStatement(node) ? ts.firstOrUndefined(node.declarationList.declarations) : undefined;
    }
    ts.getSingleVariableOfVariableStatement = getSingleVariableOfVariableStatement;
    function getNestedModuleDeclaration(node) {
        return ts.isModuleDeclaration(node) &&
            node.body &&
            node.body.kind === 261 /* SyntaxKind.ModuleDeclaration */
            ? node.body
            : undefined;
    }
    function getJSDocCommentsAndTags(hostNode, noCache) {
        var result;
        // Pull parameter comments from declaring function as well
        if (isVariableLike(hostNode) && ts.hasInitializer(hostNode) && ts.hasJSDocNodes(hostNode.initializer)) {
            result = ts.addRange(result, filterOwnedJSDocTags(hostNode, ts.last(hostNode.initializer.jsDoc)));
        }
        var node = hostNode;
        while (node && node.parent) {
            if (ts.hasJSDocNodes(node)) {
                result = ts.addRange(result, filterOwnedJSDocTags(hostNode, ts.last(node.jsDoc)));
            }
            if (node.kind === 164 /* SyntaxKind.Parameter */) {
                result = ts.addRange(result, (noCache ? ts.getJSDocParameterTagsNoCache : ts.getJSDocParameterTags)(node));
                break;
            }
            if (node.kind === 163 /* SyntaxKind.TypeParameter */) {
                result = ts.addRange(result, (noCache ? ts.getJSDocTypeParameterTagsNoCache : ts.getJSDocTypeParameterTags)(node));
                break;
            }
            node = getNextJSDocCommentLocation(node);
        }
        return result || ts.emptyArray;
    }
    ts.getJSDocCommentsAndTags = getJSDocCommentsAndTags;
    function filterOwnedJSDocTags(hostNode, jsDoc) {
        if (ts.isJSDoc(jsDoc)) {
            var ownedTags = ts.filter(jsDoc.tags, function (tag) { return ownsJSDocTag(hostNode, tag); });
            return jsDoc.tags === ownedTags ? [jsDoc] : ownedTags;
        }
        return ownsJSDocTag(hostNode, jsDoc) ? [jsDoc] : undefined;
    }
    /**
     * Determines whether a host node owns a jsDoc tag. A `@type` tag attached to a
     * a ParenthesizedExpression belongs only to the ParenthesizedExpression.
     */
    function ownsJSDocTag(hostNode, tag) {
        return !ts.isJSDocTypeTag(tag)
            || !tag.parent
            || !ts.isJSDoc(tag.parent)
            || !ts.isParenthesizedExpression(tag.parent.parent)
            || tag.parent.parent === hostNode;
    }
    function getNextJSDocCommentLocation(node) {
        var parent = node.parent;
        if (parent.kind === 296 /* SyntaxKind.PropertyAssignment */ ||
            parent.kind === 271 /* SyntaxKind.ExportAssignment */ ||
            parent.kind === 167 /* SyntaxKind.PropertyDeclaration */ ||
            parent.kind === 238 /* SyntaxKind.ExpressionStatement */ && node.kind === 206 /* SyntaxKind.PropertyAccessExpression */ ||
            parent.kind === 247 /* SyntaxKind.ReturnStatement */ ||
            getNestedModuleDeclaration(parent) ||
            ts.isBinaryExpression(node) && node.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */) {
            return parent;
        }
        // Try to recognize this pattern when node is initializer of variable declaration and JSDoc comments are on containing variable statement.
        // /**
        //   * @param {number} name
        //   * @returns {number}
        //   */
        // var x = function(name) { return name.length; }
        else if (parent.parent &&
            (getSingleVariableOfVariableStatement(parent.parent) === node ||
                ts.isBinaryExpression(parent) && parent.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */)) {
            return parent.parent;
        }
        else if (parent.parent && parent.parent.parent &&
            (getSingleVariableOfVariableStatement(parent.parent.parent) ||
                getSingleInitializerOfVariableStatementOrPropertyDeclaration(parent.parent.parent) === node ||
                getSourceOfDefaultedAssignment(parent.parent.parent))) {
            return parent.parent.parent;
        }
    }
    ts.getNextJSDocCommentLocation = getNextJSDocCommentLocation;
    /** Does the opposite of `getJSDocParameterTags`: given a JSDoc parameter, finds the parameter corresponding to it. */
    function getParameterSymbolFromJSDoc(node) {
        if (node.symbol) {
            return node.symbol;
        }
        if (!ts.isIdentifier(node.name)) {
            return undefined;
        }
        var name = node.name.escapedText;
        var decl = getHostSignatureFromJSDoc(node);
        if (!decl) {
            return undefined;
        }
        var parameter = ts.find(decl.parameters, function (p) { return p.name.kind === 79 /* SyntaxKind.Identifier */ && p.name.escapedText === name; });
        return parameter && parameter.symbol;
    }
    ts.getParameterSymbolFromJSDoc = getParameterSymbolFromJSDoc;
    function getEffectiveContainerForJSDocTemplateTag(node) {
        if (ts.isJSDoc(node.parent) && node.parent.tags) {
            // A @template tag belongs to any @typedef, @callback, or @enum tags in the same comment block, if they exist.
            var typeAlias = ts.find(node.parent.tags, isJSDocTypeAlias);
            if (typeAlias) {
                return typeAlias;
            }
        }
        // otherwise it belongs to the host it annotates
        return getHostSignatureFromJSDoc(node);
    }
    ts.getEffectiveContainerForJSDocTemplateTag = getEffectiveContainerForJSDocTemplateTag;
    function getHostSignatureFromJSDoc(node) {
        var host = getEffectiveJSDocHost(node);
        if (host) {
            return ts.isPropertySignature(host) && host.type && ts.isFunctionLike(host.type) ? host.type :
                ts.isFunctionLike(host) ? host : undefined;
        }
        return undefined;
    }
    ts.getHostSignatureFromJSDoc = getHostSignatureFromJSDoc;
    function getEffectiveJSDocHost(node) {
        var host = getJSDocHost(node);
        if (host) {
            return getSourceOfDefaultedAssignment(host)
                || getSourceOfAssignment(host)
                || getSingleInitializerOfVariableStatementOrPropertyDeclaration(host)
                || getSingleVariableOfVariableStatement(host)
                || getNestedModuleDeclaration(host)
                || host;
        }
    }
    ts.getEffectiveJSDocHost = getEffectiveJSDocHost;
    /** Use getEffectiveJSDocHost if you additionally need to look for jsdoc on parent nodes, like assignments. */
    function getJSDocHost(node) {
        var jsDoc = getJSDocRoot(node);
        if (!jsDoc) {
            return undefined;
        }
        var host = jsDoc.parent;
        if (host && host.jsDoc && jsDoc === ts.lastOrUndefined(host.jsDoc)) {
            return host;
        }
    }
    ts.getJSDocHost = getJSDocHost;
    function getJSDocRoot(node) {
        return ts.findAncestor(node.parent, ts.isJSDoc);
    }
    ts.getJSDocRoot = getJSDocRoot;
    function getTypeParameterFromJsDoc(node) {
        var name = node.name.escapedText;
        var typeParameters = node.parent.parent.parent.typeParameters;
        return typeParameters && ts.find(typeParameters, function (p) { return p.name.escapedText === name; });
    }
    ts.getTypeParameterFromJsDoc = getTypeParameterFromJsDoc;
    function hasTypeArguments(node) {
        return !!node.typeArguments;
    }
    ts.hasTypeArguments = hasTypeArguments;
    var AssignmentKind;
    (function (AssignmentKind) {
        AssignmentKind[AssignmentKind["None"] = 0] = "None";
        AssignmentKind[AssignmentKind["Definite"] = 1] = "Definite";
        AssignmentKind[AssignmentKind["Compound"] = 2] = "Compound";
    })(AssignmentKind = ts.AssignmentKind || (ts.AssignmentKind = {}));
    function getAssignmentTargetKind(node) {
        var parent = node.parent;
        while (true) {
            switch (parent.kind) {
                case 221 /* SyntaxKind.BinaryExpression */:
                    var binaryOperator = parent.operatorToken.kind;
                    return isAssignmentOperator(binaryOperator) && parent.left === node ?
                        binaryOperator === 63 /* SyntaxKind.EqualsToken */ || isLogicalOrCoalescingAssignmentOperator(binaryOperator) ? 1 /* AssignmentKind.Definite */ : 2 /* AssignmentKind.Compound */ :
                        0 /* AssignmentKind.None */;
                case 219 /* SyntaxKind.PrefixUnaryExpression */:
                case 220 /* SyntaxKind.PostfixUnaryExpression */:
                    var unaryOperator = parent.operator;
                    return unaryOperator === 45 /* SyntaxKind.PlusPlusToken */ || unaryOperator === 46 /* SyntaxKind.MinusMinusToken */ ? 2 /* AssignmentKind.Compound */ : 0 /* AssignmentKind.None */;
                case 243 /* SyntaxKind.ForInStatement */:
                case 244 /* SyntaxKind.ForOfStatement */:
                    return parent.initializer === node ? 1 /* AssignmentKind.Definite */ : 0 /* AssignmentKind.None */;
                case 212 /* SyntaxKind.ParenthesizedExpression */:
                case 204 /* SyntaxKind.ArrayLiteralExpression */:
                case 225 /* SyntaxKind.SpreadElement */:
                case 230 /* SyntaxKind.NonNullExpression */:
                    node = parent;
                    break;
                case 298 /* SyntaxKind.SpreadAssignment */:
                    node = parent.parent;
                    break;
                case 297 /* SyntaxKind.ShorthandPropertyAssignment */:
                    if (parent.name !== node) {
                        return 0 /* AssignmentKind.None */;
                    }
                    node = parent.parent;
                    break;
                case 296 /* SyntaxKind.PropertyAssignment */:
                    if (parent.name === node) {
                        return 0 /* AssignmentKind.None */;
                    }
                    node = parent.parent;
                    break;
                default:
                    return 0 /* AssignmentKind.None */;
            }
            parent = node.parent;
        }
    }
    ts.getAssignmentTargetKind = getAssignmentTargetKind;
    // A node is an assignment target if it is on the left hand side of an '=' token, if it is parented by a property
    // assignment in an object literal that is an assignment target, or if it is parented by an array literal that is
    // an assignment target. Examples include 'a = xxx', '{ p: a } = xxx', '[{ a }] = xxx'.
    // (Note that `p` is not a target in the above examples, only `a`.)
    function isAssignmentTarget(node) {
        return getAssignmentTargetKind(node) !== 0 /* AssignmentKind.None */;
    }
    ts.isAssignmentTarget = isAssignmentTarget;
    /**
     * Indicates whether a node could contain a `var` VariableDeclarationList that contributes to
     * the same `var` declaration scope as the node's parent.
     */
    function isNodeWithPossibleHoistedDeclaration(node) {
        switch (node.kind) {
            case 235 /* SyntaxKind.Block */:
            case 237 /* SyntaxKind.VariableStatement */:
            case 248 /* SyntaxKind.WithStatement */:
            case 239 /* SyntaxKind.IfStatement */:
            case 249 /* SyntaxKind.SwitchStatement */:
            case 263 /* SyntaxKind.CaseBlock */:
            case 289 /* SyntaxKind.CaseClause */:
            case 290 /* SyntaxKind.DefaultClause */:
            case 250 /* SyntaxKind.LabeledStatement */:
            case 242 /* SyntaxKind.ForStatement */:
            case 243 /* SyntaxKind.ForInStatement */:
            case 244 /* SyntaxKind.ForOfStatement */:
            case 240 /* SyntaxKind.DoStatement */:
            case 241 /* SyntaxKind.WhileStatement */:
            case 252 /* SyntaxKind.TryStatement */:
            case 292 /* SyntaxKind.CatchClause */:
                return true;
        }
        return false;
    }
    ts.isNodeWithPossibleHoistedDeclaration = isNodeWithPossibleHoistedDeclaration;
    function isValueSignatureDeclaration(node) {
        return ts.isFunctionExpression(node) || ts.isArrowFunction(node) || ts.isMethodOrAccessor(node) || ts.isFunctionDeclaration(node) || ts.isConstructorDeclaration(node);
    }
    ts.isValueSignatureDeclaration = isValueSignatureDeclaration;
    function walkUp(node, kind) {
        while (node && node.kind === kind) {
            node = node.parent;
        }
        return node;
    }
    function walkUpParenthesizedTypes(node) {
        return walkUp(node, 191 /* SyntaxKind.ParenthesizedType */);
    }
    ts.walkUpParenthesizedTypes = walkUpParenthesizedTypes;
    function walkUpParenthesizedExpressions(node) {
        return walkUp(node, 212 /* SyntaxKind.ParenthesizedExpression */);
    }
    ts.walkUpParenthesizedExpressions = walkUpParenthesizedExpressions;
    /**
     * Walks up parenthesized types.
     * It returns both the outermost parenthesized type and its parent.
     * If given node is not a parenthesiezd type, undefined is return as the former.
     */
    function walkUpParenthesizedTypesAndGetParentAndChild(node) {
        var child;
        while (node && node.kind === 191 /* SyntaxKind.ParenthesizedType */) {
            child = node;
            node = node.parent;
        }
        return [child, node];
    }
    ts.walkUpParenthesizedTypesAndGetParentAndChild = walkUpParenthesizedTypesAndGetParentAndChild;
    function skipTypeParentheses(node) {
        while (ts.isParenthesizedTypeNode(node))
            node = node.type;
        return node;
    }
    ts.skipTypeParentheses = skipTypeParentheses;
    function skipParentheses(node, excludeJSDocTypeAssertions) {
        var flags = excludeJSDocTypeAssertions ?
            1 /* OuterExpressionKinds.Parentheses */ | 16 /* OuterExpressionKinds.ExcludeJSDocTypeAssertion */ :
            1 /* OuterExpressionKinds.Parentheses */;
        return ts.skipOuterExpressions(node, flags);
    }
    ts.skipParentheses = skipParentheses;
    // a node is delete target iff. it is PropertyAccessExpression/ElementAccessExpression with parentheses skipped
    function isDeleteTarget(node) {
        if (node.kind !== 206 /* SyntaxKind.PropertyAccessExpression */ && node.kind !== 207 /* SyntaxKind.ElementAccessExpression */) {
            return false;
        }
        node = walkUpParenthesizedExpressions(node.parent);
        return node && node.kind === 215 /* SyntaxKind.DeleteExpression */;
    }
    ts.isDeleteTarget = isDeleteTarget;
    function isNodeDescendantOf(node, ancestor) {
        while (node) {
            if (node === ancestor)
                return true;
            node = node.parent;
        }
        return false;
    }
    ts.isNodeDescendantOf = isNodeDescendantOf;
    // True if `name` is the name of a declaration node
    function isDeclarationName(name) {
        return !ts.isSourceFile(name) && !ts.isBindingPattern(name) && ts.isDeclaration(name.parent) && name.parent.name === name;
    }
    ts.isDeclarationName = isDeclarationName;
    // See GH#16030
    function getDeclarationFromName(name) {
        var parent = name.parent;
        switch (name.kind) {
            case 10 /* SyntaxKind.StringLiteral */:
            case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
            case 8 /* SyntaxKind.NumericLiteral */:
                if (ts.isComputedPropertyName(parent))
                    return parent.parent;
            // falls through
            case 79 /* SyntaxKind.Identifier */:
                if (ts.isDeclaration(parent)) {
                    return parent.name === name ? parent : undefined;
                }
                else if (ts.isQualifiedName(parent)) {
                    var tag = parent.parent;
                    return ts.isJSDocParameterTag(tag) && tag.name === parent ? tag : undefined;
                }
                else {
                    var binExp = parent.parent;
                    return ts.isBinaryExpression(binExp) &&
                        getAssignmentDeclarationKind(binExp) !== 0 /* AssignmentDeclarationKind.None */ &&
                        (binExp.left.symbol || binExp.symbol) &&
                        ts.getNameOfDeclaration(binExp) === name
                        ? binExp
                        : undefined;
                }
            case 80 /* SyntaxKind.PrivateIdentifier */:
                return ts.isDeclaration(parent) && parent.name === name ? parent : undefined;
            default:
                return undefined;
        }
    }
    ts.getDeclarationFromName = getDeclarationFromName;
    function isLiteralComputedPropertyDeclarationName(node) {
        return isStringOrNumericLiteralLike(node) &&
            node.parent.kind === 162 /* SyntaxKind.ComputedPropertyName */ &&
            ts.isDeclaration(node.parent.parent);
    }
    ts.isLiteralComputedPropertyDeclarationName = isLiteralComputedPropertyDeclarationName;
    // Return true if the given identifier is classified as an IdentifierName
    function isIdentifierName(node) {
        var parent = node.parent;
        switch (parent.kind) {
            case 167 /* SyntaxKind.PropertyDeclaration */:
            case 166 /* SyntaxKind.PropertySignature */:
            case 169 /* SyntaxKind.MethodDeclaration */:
            case 168 /* SyntaxKind.MethodSignature */:
            case 172 /* SyntaxKind.GetAccessor */:
            case 173 /* SyntaxKind.SetAccessor */:
            case 299 /* SyntaxKind.EnumMember */:
            case 296 /* SyntaxKind.PropertyAssignment */:
            case 206 /* SyntaxKind.PropertyAccessExpression */:
                // Name in member declaration or property name in property access
                return parent.name === node;
            case 161 /* SyntaxKind.QualifiedName */:
                // Name on right hand side of dot in a type query or type reference
                return parent.right === node;
            case 203 /* SyntaxKind.BindingElement */:
            case 270 /* SyntaxKind.ImportSpecifier */:
                // Property name in binding element or import specifier
                return parent.propertyName === node;
            case 275 /* SyntaxKind.ExportSpecifier */:
            case 285 /* SyntaxKind.JsxAttribute */:
            case 279 /* SyntaxKind.JsxSelfClosingElement */:
            case 280 /* SyntaxKind.JsxOpeningElement */:
            case 281 /* SyntaxKind.JsxClosingElement */:
                // Any name in an export specifier or JSX Attribute or Jsx Element
                return true;
        }
        return false;
    }
    ts.isIdentifierName = isIdentifierName;
    // An alias symbol is created by one of the following declarations:
    // import <symbol> = ...
    // import <symbol> from ...
    // import * as <symbol> from ...
    // import { x as <symbol> } from ...
    // export { x as <symbol> } from ...
    // export * as ns <symbol> from ...
    // export = <EntityNameExpression>
    // export default <EntityNameExpression>
    // module.exports = <EntityNameExpression>
    // module.exports.x = <EntityNameExpression>
    // const x = require("...")
    // const { x } = require("...")
    // const x = require("...").y
    // const { x } = require("...").y
    function isAliasSymbolDeclaration(node) {
        if (node.kind === 265 /* SyntaxKind.ImportEqualsDeclaration */ ||
            node.kind === 264 /* SyntaxKind.NamespaceExportDeclaration */ ||
            node.kind === 267 /* SyntaxKind.ImportClause */ && !!node.name ||
            node.kind === 268 /* SyntaxKind.NamespaceImport */ ||
            node.kind === 274 /* SyntaxKind.NamespaceExport */ ||
            node.kind === 270 /* SyntaxKind.ImportSpecifier */ ||
            node.kind === 275 /* SyntaxKind.ExportSpecifier */ ||
            node.kind === 271 /* SyntaxKind.ExportAssignment */ && exportAssignmentIsAlias(node)) {
            return true;
        }
        return isInJSFile(node) && (ts.isBinaryExpression(node) && getAssignmentDeclarationKind(node) === 2 /* AssignmentDeclarationKind.ModuleExports */ && exportAssignmentIsAlias(node) ||
            ts.isPropertyAccessExpression(node)
                && ts.isBinaryExpression(node.parent)
                && node.parent.left === node
                && node.parent.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */
                && isAliasableExpression(node.parent.right));
    }
    ts.isAliasSymbolDeclaration = isAliasSymbolDeclaration;
    function getAliasDeclarationFromName(node) {
        switch (node.parent.kind) {
            case 267 /* SyntaxKind.ImportClause */:
            case 270 /* SyntaxKind.ImportSpecifier */:
            case 268 /* SyntaxKind.NamespaceImport */:
            case 275 /* SyntaxKind.ExportSpecifier */:
            case 271 /* SyntaxKind.ExportAssignment */:
            case 265 /* SyntaxKind.ImportEqualsDeclaration */:
            case 274 /* SyntaxKind.NamespaceExport */:
                return node.parent;
            case 161 /* SyntaxKind.QualifiedName */:
                do {
                    node = node.parent;
                } while (node.parent.kind === 161 /* SyntaxKind.QualifiedName */);
                return getAliasDeclarationFromName(node);
        }
    }
    ts.getAliasDeclarationFromName = getAliasDeclarationFromName;
    function isAliasableExpression(e) {
        return isEntityNameExpression(e) || ts.isClassExpression(e);
    }
    ts.isAliasableExpression = isAliasableExpression;
    function exportAssignmentIsAlias(node) {
        var e = getExportAssignmentExpression(node);
        return isAliasableExpression(e);
    }
    ts.exportAssignmentIsAlias = exportAssignmentIsAlias;
    function getExportAssignmentExpression(node) {
        return ts.isExportAssignment(node) ? node.expression : node.right;
    }
    ts.getExportAssignmentExpression = getExportAssignmentExpression;
    function getPropertyAssignmentAliasLikeExpression(node) {
        return node.kind === 297 /* SyntaxKind.ShorthandPropertyAssignment */ ? node.name : node.kind === 296 /* SyntaxKind.PropertyAssignment */ ? node.initializer :
            node.parent.right;
    }
    ts.getPropertyAssignmentAliasLikeExpression = getPropertyAssignmentAliasLikeExpression;
    function getEffectiveBaseTypeNode(node) {
        var baseType = getClassExtendsHeritageElement(node);
        if (baseType && isInJSFile(node)) {
            // Prefer an @augments tag because it may have type parameters.
            var tag = ts.getJSDocAugmentsTag(node);
            if (tag) {
                return tag.class;
            }
        }
        return baseType;
    }
    ts.getEffectiveBaseTypeNode = getEffectiveBaseTypeNode;
    function getClassExtendsHeritageElement(node) {
        var heritageClause = getHeritageClause(node.heritageClauses, 94 /* SyntaxKind.ExtendsKeyword */);
        return heritageClause && heritageClause.types.length > 0 ? heritageClause.types[0] : undefined;
    }
    ts.getClassExtendsHeritageElement = getClassExtendsHeritageElement;
    function getEffectiveImplementsTypeNodes(node) {
        if (isInJSFile(node)) {
            return ts.getJSDocImplementsTags(node).map(function (n) { return n.class; });
        }
        else {
            var heritageClause = getHeritageClause(node.heritageClauses, 117 /* SyntaxKind.ImplementsKeyword */);
            return heritageClause === null || heritageClause === void 0 ? void 0 : heritageClause.types;
        }
    }
    ts.getEffectiveImplementsTypeNodes = getEffectiveImplementsTypeNodes;
    /** Returns the node in an `extends` or `implements` clause of a class or interface. */
    function getAllSuperTypeNodes(node) {
        return ts.isInterfaceDeclaration(node) ? getInterfaceBaseTypeNodes(node) || ts.emptyArray :
            ts.isClassLike(node) ? ts.concatenate(ts.singleElementArray(getEffectiveBaseTypeNode(node)), getEffectiveImplementsTypeNodes(node)) || ts.emptyArray :
                ts.emptyArray;
    }
    ts.getAllSuperTypeNodes = getAllSuperTypeNodes;
    function getInterfaceBaseTypeNodes(node) {
        var heritageClause = getHeritageClause(node.heritageClauses, 94 /* SyntaxKind.ExtendsKeyword */);
        return heritageClause ? heritageClause.types : undefined;
    }
    ts.getInterfaceBaseTypeNodes = getInterfaceBaseTypeNodes;
    function getHeritageClause(clauses, kind) {
        if (clauses) {
            for (var _i = 0, clauses_1 = clauses; _i < clauses_1.length; _i++) {
                var clause = clauses_1[_i];
                if (clause.token === kind) {
                    return clause;
                }
            }
        }
        return undefined;
    }
    ts.getHeritageClause = getHeritageClause;
    function getAncestor(node, kind) {
        while (node) {
            if (node.kind === kind) {
                return node;
            }
            node = node.parent;
        }
        return undefined;
    }
    ts.getAncestor = getAncestor;
    function isKeyword(token) {
        return 81 /* SyntaxKind.FirstKeyword */ <= token && token <= 160 /* SyntaxKind.LastKeyword */;
    }
    ts.isKeyword = isKeyword;
    function isContextualKeyword(token) {
        return 126 /* SyntaxKind.FirstContextualKeyword */ <= token && token <= 160 /* SyntaxKind.LastContextualKeyword */;
    }
    ts.isContextualKeyword = isContextualKeyword;
    function isNonContextualKeyword(token) {
        return isKeyword(token) && !isContextualKeyword(token);
    }
    ts.isNonContextualKeyword = isNonContextualKeyword;
    function isFutureReservedKeyword(token) {
        return 117 /* SyntaxKind.FirstFutureReservedWord */ <= token && token <= 125 /* SyntaxKind.LastFutureReservedWord */;
    }
    ts.isFutureReservedKeyword = isFutureReservedKeyword;
    function isStringANonContextualKeyword(name) {
        var token = ts.stringToToken(name);
        return token !== undefined && isNonContextualKeyword(token);
    }
    ts.isStringANonContextualKeyword = isStringANonContextualKeyword;
    function isStringAKeyword(name) {
        var token = ts.stringToToken(name);
        return token !== undefined && isKeyword(token);
    }
    ts.isStringAKeyword = isStringAKeyword;
    function isIdentifierANonContextualKeyword(_a) {
        var originalKeywordKind = _a.originalKeywordKind;
        return !!originalKeywordKind && !isContextualKeyword(originalKeywordKind);
    }
    ts.isIdentifierANonContextualKeyword = isIdentifierANonContextualKeyword;
    function isTrivia(token) {
        return 2 /* SyntaxKind.FirstTriviaToken */ <= token && token <= 7 /* SyntaxKind.LastTriviaToken */;
    }
    ts.isTrivia = isTrivia;
    var FunctionFlags;
    (function (FunctionFlags) {
        FunctionFlags[FunctionFlags["Normal"] = 0] = "Normal";
        FunctionFlags[FunctionFlags["Generator"] = 1] = "Generator";
        FunctionFlags[FunctionFlags["Async"] = 2] = "Async";
        FunctionFlags[FunctionFlags["Invalid"] = 4] = "Invalid";
        FunctionFlags[FunctionFlags["AsyncGenerator"] = 3] = "AsyncGenerator";
    })(FunctionFlags = ts.FunctionFlags || (ts.FunctionFlags = {}));
    function getFunctionFlags(node) {
        if (!node) {
            return 4 /* FunctionFlags.Invalid */;
        }
        var flags = 0 /* FunctionFlags.Normal */;
        switch (node.kind) {
            case 256 /* SyntaxKind.FunctionDeclaration */:
            case 213 /* SyntaxKind.FunctionExpression */:
            case 169 /* SyntaxKind.MethodDeclaration */:
                if (node.asteriskToken) {
                    flags |= 1 /* FunctionFlags.Generator */;
                }
            // falls through
            case 214 /* SyntaxKind.ArrowFunction */:
                if (hasSyntacticModifier(node, 256 /* ModifierFlags.Async */)) {
                    flags |= 2 /* FunctionFlags.Async */;
                }
                break;
        }
        if (!node.body) {
            flags |= 4 /* FunctionFlags.Invalid */;
        }
        return flags;
    }
    ts.getFunctionFlags = getFunctionFlags;
    function isAsyncFunction(node) {
        switch (node.kind) {
            case 256 /* SyntaxKind.FunctionDeclaration */:
            case 213 /* SyntaxKind.FunctionExpression */:
            case 214 /* SyntaxKind.ArrowFunction */:
            case 169 /* SyntaxKind.MethodDeclaration */:
                return node.body !== undefined
                    && node.asteriskToken === undefined
                    && hasSyntacticModifier(node, 256 /* ModifierFlags.Async */);
        }
        return false;
    }
    ts.isAsyncFunction = isAsyncFunction;
    function isStringOrNumericLiteralLike(node) {
        return ts.isStringLiteralLike(node) || ts.isNumericLiteral(node);
    }
    ts.isStringOrNumericLiteralLike = isStringOrNumericLiteralLike;
    function isSignedNumericLiteral(node) {
        return ts.isPrefixUnaryExpression(node) && (node.operator === 39 /* SyntaxKind.PlusToken */ || node.operator === 40 /* SyntaxKind.MinusToken */) && ts.isNumericLiteral(node.operand);
    }
    ts.isSignedNumericLiteral = isSignedNumericLiteral;
    /**
     * A declaration has a dynamic name if all of the following are true:
     *   1. The declaration has a computed property name.
     *   2. The computed name is *not* expressed as a StringLiteral.
     *   3. The computed name is *not* expressed as a NumericLiteral.
     *   4. The computed name is *not* expressed as a PlusToken or MinusToken
     *      immediately followed by a NumericLiteral.
     */
    function hasDynamicName(declaration) {
        var name = ts.getNameOfDeclaration(declaration);
        return !!name && isDynamicName(name);
    }
    ts.hasDynamicName = hasDynamicName;
    function isDynamicName(name) {
        if (!(name.kind === 162 /* SyntaxKind.ComputedPropertyName */ || name.kind === 207 /* SyntaxKind.ElementAccessExpression */)) {
            return false;
        }
        var expr = ts.isElementAccessExpression(name) ? skipParentheses(name.argumentExpression) : name.expression;
        return !isStringOrNumericLiteralLike(expr) &&
            !isSignedNumericLiteral(expr);
    }
    ts.isDynamicName = isDynamicName;
    function getPropertyNameForPropertyNameNode(name) {
        switch (name.kind) {
            case 79 /* SyntaxKind.Identifier */:
            case 80 /* SyntaxKind.PrivateIdentifier */:
                return name.escapedText;
            case 10 /* SyntaxKind.StringLiteral */:
            case 8 /* SyntaxKind.NumericLiteral */:
                return ts.escapeLeadingUnderscores(name.text);
            case 162 /* SyntaxKind.ComputedPropertyName */:
                var nameExpression = name.expression;
                if (isStringOrNumericLiteralLike(nameExpression)) {
                    return ts.escapeLeadingUnderscores(nameExpression.text);
                }
                else if (isSignedNumericLiteral(nameExpression)) {
                    if (nameExpression.operator === 40 /* SyntaxKind.MinusToken */) {
                        return ts.tokenToString(nameExpression.operator) + nameExpression.operand.text;
                    }
                    return nameExpression.operand.text;
                }
                return undefined;
            default:
                return ts.Debug.assertNever(name);
        }
    }
    ts.getPropertyNameForPropertyNameNode = getPropertyNameForPropertyNameNode;
    function isPropertyNameLiteral(node) {
        switch (node.kind) {
            case 79 /* SyntaxKind.Identifier */:
            case 10 /* SyntaxKind.StringLiteral */:
            case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
            case 8 /* SyntaxKind.NumericLiteral */:
                return true;
            default:
                return false;
        }
    }
    ts.isPropertyNameLiteral = isPropertyNameLiteral;
    function getTextOfIdentifierOrLiteral(node) {
        return ts.isMemberName(node) ? ts.idText(node) : node.text;
    }
    ts.getTextOfIdentifierOrLiteral = getTextOfIdentifierOrLiteral;
    function getEscapedTextOfIdentifierOrLiteral(node) {
        return ts.isMemberName(node) ? node.escapedText : ts.escapeLeadingUnderscores(node.text);
    }
    ts.getEscapedTextOfIdentifierOrLiteral = getEscapedTextOfIdentifierOrLiteral;
    function getPropertyNameForUniqueESSymbol(symbol) {
        return "__@".concat(ts.getSymbolId(symbol), "@").concat(symbol.escapedName);
    }
    ts.getPropertyNameForUniqueESSymbol = getPropertyNameForUniqueESSymbol;
    function getSymbolNameForPrivateIdentifier(containingClassSymbol, description) {
        return "__#".concat(ts.getSymbolId(containingClassSymbol), "@").concat(description);
    }
    ts.getSymbolNameForPrivateIdentifier = getSymbolNameForPrivateIdentifier;
    function isKnownSymbol(symbol) {
        return ts.startsWith(symbol.escapedName, "__@");
    }
    ts.isKnownSymbol = isKnownSymbol;
    function isPrivateIdentifierSymbol(symbol) {
        return ts.startsWith(symbol.escapedName, "__#");
    }
    ts.isPrivateIdentifierSymbol = isPrivateIdentifierSymbol;
    /**
     * Includes the word "Symbol" with unicode escapes
     */
    function isESSymbolIdentifier(node) {
        return node.kind === 79 /* SyntaxKind.Identifier */ && node.escapedText === "Symbol";
    }
    ts.isESSymbolIdentifier = isESSymbolIdentifier;
    function isPushOrUnshiftIdentifier(node) {
        return node.escapedText === "push" || node.escapedText === "unshift";
    }
    ts.isPushOrUnshiftIdentifier = isPushOrUnshiftIdentifier;
    function isParameterDeclaration(node) {
        var root = getRootDeclaration(node);
        return root.kind === 164 /* SyntaxKind.Parameter */;
    }
    ts.isParameterDeclaration = isParameterDeclaration;
    function getRootDeclaration(node) {
        while (node.kind === 203 /* SyntaxKind.BindingElement */) {
            node = node.parent.parent;
        }
        return node;
    }
    ts.getRootDeclaration = getRootDeclaration;
    function nodeStartsNewLexicalEnvironment(node) {
        var kind = node.kind;
        return kind === 171 /* SyntaxKind.Constructor */
            || kind === 213 /* SyntaxKind.FunctionExpression */
            || kind === 256 /* SyntaxKind.FunctionDeclaration */
            || kind === 214 /* SyntaxKind.ArrowFunction */
            || kind === 169 /* SyntaxKind.MethodDeclaration */
            || kind === 172 /* SyntaxKind.GetAccessor */
            || kind === 173 /* SyntaxKind.SetAccessor */
            || kind === 261 /* SyntaxKind.ModuleDeclaration */
            || kind === 305 /* SyntaxKind.SourceFile */;
    }
    ts.nodeStartsNewLexicalEnvironment = nodeStartsNewLexicalEnvironment;
    function nodeIsSynthesized(range) {
        return positionIsSynthesized(range.pos)
            || positionIsSynthesized(range.end);
    }
    ts.nodeIsSynthesized = nodeIsSynthesized;
    function getOriginalSourceFile(sourceFile) {
        return ts.getParseTreeNode(sourceFile, ts.isSourceFile) || sourceFile;
    }
    ts.getOriginalSourceFile = getOriginalSourceFile;
    var Associativity;
    (function (Associativity) {
        Associativity[Associativity["Left"] = 0] = "Left";
        Associativity[Associativity["Right"] = 1] = "Right";
    })(Associativity = ts.Associativity || (ts.Associativity = {}));
    function getExpressionAssociativity(expression) {
        var operator = getOperator(expression);
        var hasArguments = expression.kind === 209 /* SyntaxKind.NewExpression */ && expression.arguments !== undefined;
        return getOperatorAssociativity(expression.kind, operator, hasArguments);
    }
    ts.getExpressionAssociativity = getExpressionAssociativity;
    function getOperatorAssociativity(kind, operator, hasArguments) {
        switch (kind) {
            case 209 /* SyntaxKind.NewExpression */:
                return hasArguments ? 0 /* Associativity.Left */ : 1 /* Associativity.Right */;
            case 219 /* SyntaxKind.PrefixUnaryExpression */:
            case 216 /* SyntaxKind.TypeOfExpression */:
            case 217 /* SyntaxKind.VoidExpression */:
            case 215 /* SyntaxKind.DeleteExpression */:
            case 218 /* SyntaxKind.AwaitExpression */:
            case 222 /* SyntaxKind.ConditionalExpression */:
            case 224 /* SyntaxKind.YieldExpression */:
                return 1 /* Associativity.Right */;
            case 221 /* SyntaxKind.BinaryExpression */:
                switch (operator) {
                    case 42 /* SyntaxKind.AsteriskAsteriskToken */:
                    case 63 /* SyntaxKind.EqualsToken */:
                    case 64 /* SyntaxKind.PlusEqualsToken */:
                    case 65 /* SyntaxKind.MinusEqualsToken */:
                    case 67 /* SyntaxKind.AsteriskAsteriskEqualsToken */:
                    case 66 /* SyntaxKind.AsteriskEqualsToken */:
                    case 68 /* SyntaxKind.SlashEqualsToken */:
                    case 69 /* SyntaxKind.PercentEqualsToken */:
                    case 70 /* SyntaxKind.LessThanLessThanEqualsToken */:
                    case 71 /* SyntaxKind.GreaterThanGreaterThanEqualsToken */:
                    case 72 /* SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken */:
                    case 73 /* SyntaxKind.AmpersandEqualsToken */:
                    case 78 /* SyntaxKind.CaretEqualsToken */:
                    case 74 /* SyntaxKind.BarEqualsToken */:
                    case 75 /* SyntaxKind.BarBarEqualsToken */:
                    case 76 /* SyntaxKind.AmpersandAmpersandEqualsToken */:
                    case 77 /* SyntaxKind.QuestionQuestionEqualsToken */:
                        return 1 /* Associativity.Right */;
                }
        }
        return 0 /* Associativity.Left */;
    }
    ts.getOperatorAssociativity = getOperatorAssociativity;
    function getExpressionPrecedence(expression) {
        var operator = getOperator(expression);
        var hasArguments = expression.kind === 209 /* SyntaxKind.NewExpression */ && expression.arguments !== undefined;
        return getOperatorPrecedence(expression.kind, operator, hasArguments);
    }
    ts.getExpressionPrecedence = getExpressionPrecedence;
    function getOperator(expression) {
        if (expression.kind === 221 /* SyntaxKind.BinaryExpression */) {
            return expression.operatorToken.kind;
        }
        else if (expression.kind === 219 /* SyntaxKind.PrefixUnaryExpression */ || expression.kind === 220 /* SyntaxKind.PostfixUnaryExpression */) {
            return expression.operator;
        }
        else {
            return expression.kind;
        }
    }
    ts.getOperator = getOperator;
    var OperatorPrecedence;
    (function (OperatorPrecedence) {
        // Expression:
        //     AssignmentExpression
        //     Expression `,` AssignmentExpression
        OperatorPrecedence[OperatorPrecedence["Comma"] = 0] = "Comma";
        // NOTE: `Spread` is higher than `Comma` due to how it is parsed in |ElementList|
        // SpreadElement:
        //     `...` AssignmentExpression
        OperatorPrecedence[OperatorPrecedence["Spread"] = 1] = "Spread";
        // AssignmentExpression:
        //     ConditionalExpression
        //     YieldExpression
        //     ArrowFunction
        //     AsyncArrowFunction
        //     LeftHandSideExpression `=` AssignmentExpression
        //     LeftHandSideExpression AssignmentOperator AssignmentExpression
        //
        // NOTE: AssignmentExpression is broken down into several precedences due to the requirements
        //       of the parenthesizer rules.
        // AssignmentExpression: YieldExpression
        // YieldExpression:
        //     `yield`
        //     `yield` AssignmentExpression
        //     `yield` `*` AssignmentExpression
        OperatorPrecedence[OperatorPrecedence["Yield"] = 2] = "Yield";
        // AssignmentExpression: LeftHandSideExpression `=` AssignmentExpression
        // AssignmentExpression: LeftHandSideExpression AssignmentOperator AssignmentExpression
        // AssignmentOperator: one of
        //     `*=` `/=` `%=` `+=` `-=` `<<=` `>>=` `>>>=` `&=` `^=` `|=` `**=`
        OperatorPrecedence[OperatorPrecedence["Assignment"] = 3] = "Assignment";
        // NOTE: `Conditional` is considered higher than `Assignment` here, but in reality they have
        //       the same precedence.
        // AssignmentExpression: ConditionalExpression
        // ConditionalExpression:
        //     ShortCircuitExpression
        //     ShortCircuitExpression `?` AssignmentExpression `:` AssignmentExpression
        // ShortCircuitExpression:
        //     LogicalORExpression
        //     CoalesceExpression
        OperatorPrecedence[OperatorPrecedence["Conditional"] = 4] = "Conditional";
        // CoalesceExpression:
        //     CoalesceExpressionHead `??` BitwiseORExpression
        // CoalesceExpressionHead:
        //     CoalesceExpression
        //     BitwiseORExpression
        OperatorPrecedence[OperatorPrecedence["Coalesce"] = 4] = "Coalesce";
        // LogicalORExpression:
        //     LogicalANDExpression
        //     LogicalORExpression `||` LogicalANDExpression
        OperatorPrecedence[OperatorPrecedence["LogicalOR"] = 5] = "LogicalOR";
        // LogicalANDExpression:
        //     BitwiseORExpression
        //     LogicalANDExprerssion `&&` BitwiseORExpression
        OperatorPrecedence[OperatorPrecedence["LogicalAND"] = 6] = "LogicalAND";
        // BitwiseORExpression:
        //     BitwiseXORExpression
        //     BitwiseORExpression `^` BitwiseXORExpression
        OperatorPrecedence[OperatorPrecedence["BitwiseOR"] = 7] = "BitwiseOR";
        // BitwiseXORExpression:
        //     BitwiseANDExpression
        //     BitwiseXORExpression `^` BitwiseANDExpression
        OperatorPrecedence[OperatorPrecedence["BitwiseXOR"] = 8] = "BitwiseXOR";
        // BitwiseANDExpression:
        //     EqualityExpression
        //     BitwiseANDExpression `^` EqualityExpression
        OperatorPrecedence[OperatorPrecedence["BitwiseAND"] = 9] = "BitwiseAND";
        // EqualityExpression:
        //     RelationalExpression
        //     EqualityExpression `==` RelationalExpression
        //     EqualityExpression `!=` RelationalExpression
        //     EqualityExpression `===` RelationalExpression
        //     EqualityExpression `!==` RelationalExpression
        OperatorPrecedence[OperatorPrecedence["Equality"] = 10] = "Equality";
        // RelationalExpression:
        //     ShiftExpression
        //     RelationalExpression `<` ShiftExpression
        //     RelationalExpression `>` ShiftExpression
        //     RelationalExpression `<=` ShiftExpression
        //     RelationalExpression `>=` ShiftExpression
        //     RelationalExpression `instanceof` ShiftExpression
        //     RelationalExpression `in` ShiftExpression
        //     [+TypeScript] RelationalExpression `as` Type
        OperatorPrecedence[OperatorPrecedence["Relational"] = 11] = "Relational";
        // ShiftExpression:
        //     AdditiveExpression
        //     ShiftExpression `<<` AdditiveExpression
        //     ShiftExpression `>>` AdditiveExpression
        //     ShiftExpression `>>>` AdditiveExpression
        OperatorPrecedence[OperatorPrecedence["Shift"] = 12] = "Shift";
        // AdditiveExpression:
        //     MultiplicativeExpression
        //     AdditiveExpression `+` MultiplicativeExpression
        //     AdditiveExpression `-` MultiplicativeExpression
        OperatorPrecedence[OperatorPrecedence["Additive"] = 13] = "Additive";
        // MultiplicativeExpression:
        //     ExponentiationExpression
        //     MultiplicativeExpression MultiplicativeOperator ExponentiationExpression
        // MultiplicativeOperator: one of `*`, `/`, `%`
        OperatorPrecedence[OperatorPrecedence["Multiplicative"] = 14] = "Multiplicative";
        // ExponentiationExpression:
        //     UnaryExpression
        //     UpdateExpression `**` ExponentiationExpression
        OperatorPrecedence[OperatorPrecedence["Exponentiation"] = 15] = "Exponentiation";
        // UnaryExpression:
        //     UpdateExpression
        //     `delete` UnaryExpression
        //     `void` UnaryExpression
        //     `typeof` UnaryExpression
        //     `+` UnaryExpression
        //     `-` UnaryExpression
        //     `~` UnaryExpression
        //     `!` UnaryExpression
        //     AwaitExpression
        // UpdateExpression:            // TODO: Do we need to investigate the precedence here?
        //     `++` UnaryExpression
        //     `--` UnaryExpression
        OperatorPrecedence[OperatorPrecedence["Unary"] = 16] = "Unary";
        // UpdateExpression:
        //     LeftHandSideExpression
        //     LeftHandSideExpression `++`
        //     LeftHandSideExpression `--`
        OperatorPrecedence[OperatorPrecedence["Update"] = 17] = "Update";
        // LeftHandSideExpression:
        //     NewExpression
        //     CallExpression
        // NewExpression:
        //     MemberExpression
        //     `new` NewExpression
        OperatorPrecedence[OperatorPrecedence["LeftHandSide"] = 18] = "LeftHandSide";
        // CallExpression:
        //     CoverCallExpressionAndAsyncArrowHead
        //     SuperCall
        //     ImportCall
        //     CallExpression Arguments
        //     CallExpression `[` Expression `]`
        //     CallExpression `.` IdentifierName
        //     CallExpression TemplateLiteral
        // MemberExpression:
        //     PrimaryExpression
        //     MemberExpression `[` Expression `]`
        //     MemberExpression `.` IdentifierName
        //     MemberExpression TemplateLiteral
        //     SuperProperty
        //     MetaProperty
        //     `new` MemberExpression Arguments
        OperatorPrecedence[OperatorPrecedence["Member"] = 19] = "Member";
        // TODO: JSXElement?
        // PrimaryExpression:
        //     `this`
        //     IdentifierReference
        //     Literal
        //     ArrayLiteral
        //     ObjectLiteral
        //     FunctionExpression
        //     ClassExpression
        //     GeneratorExpression
        //     AsyncFunctionExpression
        //     AsyncGeneratorExpression
        //     RegularExpressionLiteral
        //     TemplateLiteral
        //     CoverParenthesizedExpressionAndArrowParameterList
        OperatorPrecedence[OperatorPrecedence["Primary"] = 20] = "Primary";
        OperatorPrecedence[OperatorPrecedence["Highest"] = 20] = "Highest";
        OperatorPrecedence[OperatorPrecedence["Lowest"] = 0] = "Lowest";
        // -1 is lower than all other precedences. Returning it will cause binary expression
        // parsing to stop.
        OperatorPrecedence[OperatorPrecedence["Invalid"] = -1] = "Invalid";
    })(OperatorPrecedence = ts.OperatorPrecedence || (ts.OperatorPrecedence = {}));
    function getOperatorPrecedence(nodeKind, operatorKind, hasArguments) {
        switch (nodeKind) {
            case 351 /* SyntaxKind.CommaListExpression */:
                return 0 /* OperatorPrecedence.Comma */;
            case 225 /* SyntaxKind.SpreadElement */:
                return 1 /* OperatorPrecedence.Spread */;
            case 224 /* SyntaxKind.YieldExpression */:
                return 2 /* OperatorPrecedence.Yield */;
            case 222 /* SyntaxKind.ConditionalExpression */:
                return 4 /* OperatorPrecedence.Conditional */;
            case 221 /* SyntaxKind.BinaryExpression */:
                switch (operatorKind) {
                    case 27 /* SyntaxKind.CommaToken */:
                        return 0 /* OperatorPrecedence.Comma */;
                    case 63 /* SyntaxKind.EqualsToken */:
                    case 64 /* SyntaxKind.PlusEqualsToken */:
                    case 65 /* SyntaxKind.MinusEqualsToken */:
                    case 67 /* SyntaxKind.AsteriskAsteriskEqualsToken */:
                    case 66 /* SyntaxKind.AsteriskEqualsToken */:
                    case 68 /* SyntaxKind.SlashEqualsToken */:
                    case 69 /* SyntaxKind.PercentEqualsToken */:
                    case 70 /* SyntaxKind.LessThanLessThanEqualsToken */:
                    case 71 /* SyntaxKind.GreaterThanGreaterThanEqualsToken */:
                    case 72 /* SyntaxKind.GreaterThanGreaterThanGreaterThanEqualsToken */:
                    case 73 /* SyntaxKind.AmpersandEqualsToken */:
                    case 78 /* SyntaxKind.CaretEqualsToken */:
                    case 74 /* SyntaxKind.BarEqualsToken */:
                    case 75 /* SyntaxKind.BarBarEqualsToken */:
                    case 76 /* SyntaxKind.AmpersandAmpersandEqualsToken */:
                    case 77 /* SyntaxKind.QuestionQuestionEqualsToken */:
                        return 3 /* OperatorPrecedence.Assignment */;
                    default:
                        return getBinaryOperatorPrecedence(operatorKind);
                }
            // TODO: Should prefix `++` and `--` be moved to the `Update` precedence?
            case 211 /* SyntaxKind.TypeAssertionExpression */:
            case 230 /* SyntaxKind.NonNullExpression */:
            case 219 /* SyntaxKind.PrefixUnaryExpression */:
            case 216 /* SyntaxKind.TypeOfExpression */:
            case 217 /* SyntaxKind.VoidExpression */:
            case 215 /* SyntaxKind.DeleteExpression */:
            case 218 /* SyntaxKind.AwaitExpression */:
                return 16 /* OperatorPrecedence.Unary */;
            case 220 /* SyntaxKind.PostfixUnaryExpression */:
                return 17 /* OperatorPrecedence.Update */;
            case 208 /* SyntaxKind.CallExpression */:
                return 18 /* OperatorPrecedence.LeftHandSide */;
            case 209 /* SyntaxKind.NewExpression */:
                return hasArguments ? 19 /* OperatorPrecedence.Member */ : 18 /* OperatorPrecedence.LeftHandSide */;
            case 210 /* SyntaxKind.TaggedTemplateExpression */:
            case 206 /* SyntaxKind.PropertyAccessExpression */:
            case 207 /* SyntaxKind.ElementAccessExpression */:
            case 231 /* SyntaxKind.MetaProperty */:
                return 19 /* OperatorPrecedence.Member */;
            case 229 /* SyntaxKind.AsExpression */:
                return 11 /* OperatorPrecedence.Relational */;
            case 108 /* SyntaxKind.ThisKeyword */:
            case 106 /* SyntaxKind.SuperKeyword */:
            case 79 /* SyntaxKind.Identifier */:
            case 80 /* SyntaxKind.PrivateIdentifier */:
            case 104 /* SyntaxKind.NullKeyword */:
            case 110 /* SyntaxKind.TrueKeyword */:
            case 95 /* SyntaxKind.FalseKeyword */:
            case 8 /* SyntaxKind.NumericLiteral */:
            case 9 /* SyntaxKind.BigIntLiteral */:
            case 10 /* SyntaxKind.StringLiteral */:
            case 204 /* SyntaxKind.ArrayLiteralExpression */:
            case 205 /* SyntaxKind.ObjectLiteralExpression */:
            case 213 /* SyntaxKind.FunctionExpression */:
            case 214 /* SyntaxKind.ArrowFunction */:
            case 226 /* SyntaxKind.ClassExpression */:
            case 13 /* SyntaxKind.RegularExpressionLiteral */:
            case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
            case 223 /* SyntaxKind.TemplateExpression */:
            case 212 /* SyntaxKind.ParenthesizedExpression */:
            case 227 /* SyntaxKind.OmittedExpression */:
            case 278 /* SyntaxKind.JsxElement */:
            case 279 /* SyntaxKind.JsxSelfClosingElement */:
            case 282 /* SyntaxKind.JsxFragment */:
                return 20 /* OperatorPrecedence.Primary */;
            default:
                return -1 /* OperatorPrecedence.Invalid */;
        }
    }
    ts.getOperatorPrecedence = getOperatorPrecedence;
    function getBinaryOperatorPrecedence(kind) {
        switch (kind) {
            case 60 /* SyntaxKind.QuestionQuestionToken */:
                return 4 /* OperatorPrecedence.Coalesce */;
            case 56 /* SyntaxKind.BarBarToken */:
                return 5 /* OperatorPrecedence.LogicalOR */;
            case 55 /* SyntaxKind.AmpersandAmpersandToken */:
                return 6 /* OperatorPrecedence.LogicalAND */;
            case 51 /* SyntaxKind.BarToken */:
                return 7 /* OperatorPrecedence.BitwiseOR */;
            case 52 /* SyntaxKind.CaretToken */:
                return 8 /* OperatorPrecedence.BitwiseXOR */;
            case 50 /* SyntaxKind.AmpersandToken */:
                return 9 /* OperatorPrecedence.BitwiseAND */;
            case 34 /* SyntaxKind.EqualsEqualsToken */:
            case 35 /* SyntaxKind.ExclamationEqualsToken */:
            case 36 /* SyntaxKind.EqualsEqualsEqualsToken */:
            case 37 /* SyntaxKind.ExclamationEqualsEqualsToken */:
                return 10 /* OperatorPrecedence.Equality */;
            case 29 /* SyntaxKind.LessThanToken */:
            case 31 /* SyntaxKind.GreaterThanToken */:
            case 32 /* SyntaxKind.LessThanEqualsToken */:
            case 33 /* SyntaxKind.GreaterThanEqualsToken */:
            case 102 /* SyntaxKind.InstanceOfKeyword */:
            case 101 /* SyntaxKind.InKeyword */:
            case 127 /* SyntaxKind.AsKeyword */:
                return 11 /* OperatorPrecedence.Relational */;
            case 47 /* SyntaxKind.LessThanLessThanToken */:
            case 48 /* SyntaxKind.GreaterThanGreaterThanToken */:
            case 49 /* SyntaxKind.GreaterThanGreaterThanGreaterThanToken */:
                return 12 /* OperatorPrecedence.Shift */;
            case 39 /* SyntaxKind.PlusToken */:
            case 40 /* SyntaxKind.MinusToken */:
                return 13 /* OperatorPrecedence.Additive */;
            case 41 /* SyntaxKind.AsteriskToken */:
            case 43 /* SyntaxKind.SlashToken */:
            case 44 /* SyntaxKind.PercentToken */:
                return 14 /* OperatorPrecedence.Multiplicative */;
            case 42 /* SyntaxKind.AsteriskAsteriskToken */:
                return 15 /* OperatorPrecedence.Exponentiation */;
        }
        // -1 is lower than all other precedences.  Returning it will cause binary expression
        // parsing to stop.
        return -1;
    }
    ts.getBinaryOperatorPrecedence = getBinaryOperatorPrecedence;
    function getSemanticJsxChildren(children) {
        return ts.filter(children, function (i) {
            switch (i.kind) {
                case 288 /* SyntaxKind.JsxExpression */:
                    return !!i.expression;
                case 11 /* SyntaxKind.JsxText */:
                    return !i.containsOnlyTriviaWhiteSpaces;
                default:
                    return true;
            }
        });
    }
    ts.getSemanticJsxChildren = getSemanticJsxChildren;
    function createDiagnosticCollection() {
        var nonFileDiagnostics = []; // See GH#19873
        var filesWithDiagnostics = [];
        var fileDiagnostics = new ts.Map();
        var hasReadNonFileDiagnostics = false;
        return {
            add: add,
            lookup: lookup,
            getGlobalDiagnostics: getGlobalDiagnostics,
            getDiagnostics: getDiagnostics,
        };
        function lookup(diagnostic) {
            var diagnostics;
            if (diagnostic.file) {
                diagnostics = fileDiagnostics.get(diagnostic.file.fileName);
            }
            else {
                diagnostics = nonFileDiagnostics;
            }
            if (!diagnostics) {
                return undefined;
            }
            var result = ts.binarySearch(diagnostics, diagnostic, ts.identity, compareDiagnosticsSkipRelatedInformation);
            if (result >= 0) {
                return diagnostics[result];
            }
            return undefined;
        }
        function add(diagnostic) {
            var diagnostics;
            if (diagnostic.file) {
                diagnostics = fileDiagnostics.get(diagnostic.file.fileName);
                if (!diagnostics) {
                    diagnostics = []; // See GH#19873
                    fileDiagnostics.set(diagnostic.file.fileName, diagnostics);
                    ts.insertSorted(filesWithDiagnostics, diagnostic.file.fileName, ts.compareStringsCaseSensitive);
                }
            }
            else {
                // If we've already read the non-file diagnostics, do not modify the existing array.
                if (hasReadNonFileDiagnostics) {
                    hasReadNonFileDiagnostics = false;
                    nonFileDiagnostics = nonFileDiagnostics.slice();
                }
                diagnostics = nonFileDiagnostics;
            }
            ts.insertSorted(diagnostics, diagnostic, compareDiagnostics);
        }
        function getGlobalDiagnostics() {
            hasReadNonFileDiagnostics = true;
            return nonFileDiagnostics;
        }
        function getDiagnostics(fileName) {
            if (fileName) {
                return fileDiagnostics.get(fileName) || [];
            }
            var fileDiags = ts.flatMapToMutable(filesWithDiagnostics, function (f) { return fileDiagnostics.get(f); });
            if (!nonFileDiagnostics.length) {
                return fileDiags;
            }
            fileDiags.unshift.apply(fileDiags, nonFileDiagnostics);
            return fileDiags;
        }
    }
    ts.createDiagnosticCollection = createDiagnosticCollection;
    var templateSubstitutionRegExp = /\$\{/g;
    function escapeTemplateSubstitution(str) {
        return str.replace(templateSubstitutionRegExp, "\\${");
    }
    /** @internal */
    function hasInvalidEscape(template) {
        return template && !!(ts.isNoSubstitutionTemplateLiteral(template)
            ? template.templateFlags
            : (template.head.templateFlags || ts.some(template.templateSpans, function (span) { return !!span.literal.templateFlags; })));
    }
    ts.hasInvalidEscape = hasInvalidEscape;
    // This consists of the first 19 unprintable ASCII characters, canonical escapes, lineSeparator,
    // paragraphSeparator, and nextLine. The latter three are just desirable to suppress new lines in
    // the language service. These characters should be escaped when printing, and if any characters are added,
    // the map below must be updated. Note that this regexp *does not* include the 'delete' character.
    // There is no reason for this other than that JSON.stringify does not handle it either.
    var doubleQuoteEscapedCharsRegExp = /[\\\"\u0000-\u001f\t\v\f\b\r\n\u2028\u2029\u0085]/g;
    var singleQuoteEscapedCharsRegExp = /[\\\'\u0000-\u001f\t\v\f\b\r\n\u2028\u2029\u0085]/g;
    // Template strings preserve simple LF newlines, still encode CRLF (or CR)
    var backtickQuoteEscapedCharsRegExp = /\r\n|[\\\`\u0000-\u001f\t\v\f\b\r\u2028\u2029\u0085]/g;
    var escapedCharsMap = new ts.Map(ts.getEntries({
        "\t": "\\t",
        "\v": "\\v",
        "\f": "\\f",
        "\b": "\\b",
        "\r": "\\r",
        "\n": "\\n",
        "\\": "\\\\",
        "\"": "\\\"",
        "\'": "\\\'",
        "\`": "\\\`",
        "\u2028": "\\u2028",
        "\u2029": "\\u2029",
        "\u0085": "\\u0085",
        "\r\n": "\\r\\n", // special case for CRLFs in backticks
    }));
    function encodeUtf16EscapeSequence(charCode) {
        var hexCharCode = charCode.toString(16).toUpperCase();
        var paddedHexCode = ("0000" + hexCharCode).slice(-4);
        return "\\u" + paddedHexCode;
    }
    function getReplacement(c, offset, input) {
        if (c.charCodeAt(0) === 0 /* CharacterCodes.nullCharacter */) {
            var lookAhead = input.charCodeAt(offset + c.length);
            if (lookAhead >= 48 /* CharacterCodes._0 */ && lookAhead <= 57 /* CharacterCodes._9 */) {
                // If the null character is followed by digits, print as a hex escape to prevent the result from parsing as an octal (which is forbidden in strict mode)
                return "\\x00";
            }
            // Otherwise, keep printing a literal \0 for the null character
            return "\\0";
        }
        return escapedCharsMap.get(c) || encodeUtf16EscapeSequence(c.charCodeAt(0));
    }
    /**
     * Based heavily on the abstract 'Quote'/'QuoteJSONString' operation from ECMA-262 (24.3.2.2),
     * but augmented for a few select characters (e.g. lineSeparator, paragraphSeparator, nextLine)
     * Note that this doesn't actually wrap the input in double quotes.
     */
    function escapeString(s, quoteChar) {
        var escapedCharsRegExp = quoteChar === 96 /* CharacterCodes.backtick */ ? backtickQuoteEscapedCharsRegExp :
            quoteChar === 39 /* CharacterCodes.singleQuote */ ? singleQuoteEscapedCharsRegExp :
                doubleQuoteEscapedCharsRegExp;
        return s.replace(escapedCharsRegExp, getReplacement);
    }
    ts.escapeString = escapeString;
    var nonAsciiCharacters = /[^\u0000-\u007F]/g;
    function escapeNonAsciiString(s, quoteChar) {
        s = escapeString(s, quoteChar);
        // Replace non-ASCII characters with '\uNNNN' escapes if any exist.
        // Otherwise just return the original string.
        return nonAsciiCharacters.test(s) ?
            s.replace(nonAsciiCharacters, function (c) { return encodeUtf16EscapeSequence(c.charCodeAt(0)); }) :
            s;
    }
    ts.escapeNonAsciiString = escapeNonAsciiString;
    // This consists of the first 19 unprintable ASCII characters, JSX canonical escapes, lineSeparator,
    // paragraphSeparator, and nextLine. The latter three are just desirable to suppress new lines in
    // the language service. These characters should be escaped when printing, and if any characters are added,
    // the map below must be updated.
    var jsxDoubleQuoteEscapedCharsRegExp = /[\"\u0000-\u001f\u2028\u2029\u0085]/g;
    var jsxSingleQuoteEscapedCharsRegExp = /[\'\u0000-\u001f\u2028\u2029\u0085]/g;
    var jsxEscapedCharsMap = new ts.Map(ts.getEntries({
        "\"": "&quot;",
        "\'": "&apos;"
    }));
    function encodeJsxCharacterEntity(charCode) {
        var hexCharCode = charCode.toString(16).toUpperCase();
        return "&#x" + hexCharCode + ";";
    }
    function getJsxAttributeStringReplacement(c) {
        if (c.charCodeAt(0) === 0 /* CharacterCodes.nullCharacter */) {
            return "&#0;";
        }
        return jsxEscapedCharsMap.get(c) || encodeJsxCharacterEntity(c.charCodeAt(0));
    }
    function escapeJsxAttributeString(s, quoteChar) {
        var escapedCharsRegExp = quoteChar === 39 /* CharacterCodes.singleQuote */ ? jsxSingleQuoteEscapedCharsRegExp :
            jsxDoubleQuoteEscapedCharsRegExp;
        return s.replace(escapedCharsRegExp, getJsxAttributeStringReplacement);
    }
    ts.escapeJsxAttributeString = escapeJsxAttributeString;
    /**
     * Strip off existed surrounding single quotes, double quotes, or backticks from a given string
     *
     * @return non-quoted string
     */
    function stripQuotes(name) {
        var length = name.length;
        if (length >= 2 && name.charCodeAt(0) === name.charCodeAt(length - 1) && isQuoteOrBacktick(name.charCodeAt(0))) {
            return name.substring(1, length - 1);
        }
        return name;
    }
    ts.stripQuotes = stripQuotes;
    function isQuoteOrBacktick(charCode) {
        return charCode === 39 /* CharacterCodes.singleQuote */ ||
            charCode === 34 /* CharacterCodes.doubleQuote */ ||
            charCode === 96 /* CharacterCodes.backtick */;
    }
    function isIntrinsicJsxName(name) {
        var ch = name.charCodeAt(0);
        return (ch >= 97 /* CharacterCodes.a */ && ch <= 122 /* CharacterCodes.z */) || ts.stringContains(name, "-") || ts.stringContains(name, ":");
    }
    ts.isIntrinsicJsxName = isIntrinsicJsxName;
    var indentStrings = ["", "    "];
    function getIndentString(level) {
        // prepopulate cache
        var singleLevel = indentStrings[1];
        for (var current = indentStrings.length; current <= level; current++) {
            indentStrings.push(indentStrings[current - 1] + singleLevel);
        }
        return indentStrings[level];
    }
    ts.getIndentString = getIndentString;
    function getIndentSize() {
        return indentStrings[1].length;
    }
    ts.getIndentSize = getIndentSize;
    function isNightly() {
        return ts.stringContains(ts.version, "-dev") || ts.stringContains(ts.version, "-insiders");
    }
    ts.isNightly = isNightly;
    function createTextWriter(newLine) {
        var output;
        var indent;
        var lineStart;
        var lineCount;
        var linePos;
        var hasTrailingComment = false;
        function updateLineCountAndPosFor(s) {
            var lineStartsOfS = ts.computeLineStarts(s);
            if (lineStartsOfS.length > 1) {
                lineCount = lineCount + lineStartsOfS.length - 1;
                linePos = output.length - s.length + ts.last(lineStartsOfS);
                lineStart = (linePos - output.length) === 0;
            }
            else {
                lineStart = false;
            }
        }
        function writeText(s) {
            if (s && s.length) {
                if (lineStart) {
                    s = getIndentString(indent) + s;
                    lineStart = false;
                }
                output += s;
                updateLineCountAndPosFor(s);
            }
        }
        function write(s) {
            if (s)
                hasTrailingComment = false;
            writeText(s);
        }
        function writeComment(s) {
            if (s)
                hasTrailingComment = true;
            writeText(s);
        }
        function reset() {
            output = "";
            indent = 0;
            lineStart = true;
            lineCount = 0;
            linePos = 0;
            hasTrailingComment = false;
        }
        function rawWrite(s) {
            if (s !== undefined) {
                output += s;
                updateLineCountAndPosFor(s);
                hasTrailingComment = false;
            }
        }
        function writeLiteral(s) {
            if (s && s.length) {
                write(s);
            }
        }
        function writeLine(force) {
            if (!lineStart || force) {
                output += newLine;
                lineCount++;
                linePos = output.length;
                lineStart = true;
                hasTrailingComment = false;
            }
        }
        function getTextPosWithWriteLine() {
            return lineStart ? output.length : (output.length + newLine.length);
        }
        reset();
        return {
            write: write,
            rawWrite: rawWrite,
            writeLiteral: writeLiteral,
            writeLine: writeLine,
            increaseIndent: function () { indent++; },
            decreaseIndent: function () { indent--; },
            getIndent: function () { return indent; },
            getTextPos: function () { return output.length; },
            getLine: function () { return lineCount; },
            getColumn: function () { return lineStart ? indent * getIndentSize() : output.length - linePos; },
            getText: function () { return output; },
            isAtStartOfLine: function () { return lineStart; },
            hasTrailingComment: function () { return hasTrailingComment; },
            hasTrailingWhitespace: function () { return !!output.length && ts.isWhiteSpaceLike(output.charCodeAt(output.length - 1)); },
            clear: reset,
            reportInaccessibleThisError: ts.noop,
            reportPrivateInBaseOfClassExpression: ts.noop,
            reportInaccessibleUniqueSymbolError: ts.noop,
            trackSymbol: function () { return false; },
            writeKeyword: write,
            writeOperator: write,
            writeParameter: write,
            writeProperty: write,
            writePunctuation: write,
            writeSpace: write,
            writeStringLiteral: write,
            writeSymbol: function (s, _) { return write(s); },
            writeTrailingSemicolon: write,
            writeComment: writeComment,
            getTextPosWithWriteLine: getTextPosWithWriteLine
        };
    }
    ts.createTextWriter = createTextWriter;
    function getTrailingSemicolonDeferringWriter(writer) {
        var pendingTrailingSemicolon = false;
        function commitPendingTrailingSemicolon() {
            if (pendingTrailingSemicolon) {
                writer.writeTrailingSemicolon(";");
                pendingTrailingSemicolon = false;
            }
        }
        return __assign(__assign({}, writer), { writeTrailingSemicolon: function () {
                pendingTrailingSemicolon = true;
            }, writeLiteral: function (s) {
                commitPendingTrailingSemicolon();
                writer.writeLiteral(s);
            }, writeStringLiteral: function (s) {
                commitPendingTrailingSemicolon();
                writer.writeStringLiteral(s);
            }, writeSymbol: function (s, sym) {
                commitPendingTrailingSemicolon();
                writer.writeSymbol(s, sym);
            }, writePunctuation: function (s) {
                commitPendingTrailingSemicolon();
                writer.writePunctuation(s);
            }, writeKeyword: function (s) {
                commitPendingTrailingSemicolon();
                writer.writeKeyword(s);
            }, writeOperator: function (s) {
                commitPendingTrailingSemicolon();
                writer.writeOperator(s);
            }, writeParameter: function (s) {
                commitPendingTrailingSemicolon();
                writer.writeParameter(s);
            }, writeSpace: function (s) {
                commitPendingTrailingSemicolon();
                writer.writeSpace(s);
            }, writeProperty: function (s) {
                commitPendingTrailingSemicolon();
                writer.writeProperty(s);
            }, writeComment: function (s) {
                commitPendingTrailingSemicolon();
                writer.writeComment(s);
            }, writeLine: function () {
                commitPendingTrailingSemicolon();
                writer.writeLine();
            }, increaseIndent: function () {
                commitPendingTrailingSemicolon();
                writer.increaseIndent();
            }, decreaseIndent: function () {
                commitPendingTrailingSemicolon();
                writer.decreaseIndent();
            } });
    }
    ts.getTrailingSemicolonDeferringWriter = getTrailingSemicolonDeferringWriter;
    function hostUsesCaseSensitiveFileNames(host) {
        return host.useCaseSensitiveFileNames ? host.useCaseSensitiveFileNames() : false;
    }
    ts.hostUsesCaseSensitiveFileNames = hostUsesCaseSensitiveFileNames;
    function hostGetCanonicalFileName(host) {
        return ts.createGetCanonicalFileName(hostUsesCaseSensitiveFileNames(host));
    }
    ts.hostGetCanonicalFileName = hostGetCanonicalFileName;
    function getResolvedExternalModuleName(host, file, referenceFile) {
        return file.moduleName || getExternalModuleNameFromPath(host, file.fileName, referenceFile && referenceFile.fileName);
    }
    ts.getResolvedExternalModuleName = getResolvedExternalModuleName;
    function getCanonicalAbsolutePath(host, path) {
        return host.getCanonicalFileName(ts.getNormalizedAbsolutePath(path, host.getCurrentDirectory()));
    }
    function getExternalModuleNameFromDeclaration(host, resolver, declaration) {
        var file = resolver.getExternalModuleFileFromDeclaration(declaration);
        if (!file || file.isDeclarationFile) {
            return undefined;
        }
        // If the declaration already uses a non-relative name, and is outside the common source directory, continue to use it
        var specifier = getExternalModuleName(declaration);
        if (specifier && ts.isStringLiteralLike(specifier) && !ts.pathIsRelative(specifier.text) &&
            getCanonicalAbsolutePath(host, file.path).indexOf(getCanonicalAbsolutePath(host, ts.ensureTrailingDirectorySeparator(host.getCommonSourceDirectory()))) === -1) {
            return undefined;
        }
        return getResolvedExternalModuleName(host, file);
    }
    ts.getExternalModuleNameFromDeclaration = getExternalModuleNameFromDeclaration;
    /**
     * Resolves a local path to a path which is absolute to the base of the emit
     */
    function getExternalModuleNameFromPath(host, fileName, referencePath) {
        var getCanonicalFileName = function (f) { return host.getCanonicalFileName(f); };
        var dir = ts.toPath(referencePath ? ts.getDirectoryPath(referencePath) : host.getCommonSourceDirectory(), host.getCurrentDirectory(), getCanonicalFileName);
        var filePath = ts.getNormalizedAbsolutePath(fileName, host.getCurrentDirectory());
        var relativePath = ts.getRelativePathToDirectoryOrUrl(dir, filePath, dir, getCanonicalFileName, /*isAbsolutePathAnUrl*/ false);
        var extensionless = removeFileExtension(relativePath);
        return referencePath ? ts.ensurePathIsNonModuleName(extensionless) : extensionless;
    }
    ts.getExternalModuleNameFromPath = getExternalModuleNameFromPath;
    function getOwnEmitOutputFilePath(fileName, host, extension) {
        var compilerOptions = host.getCompilerOptions();
        var emitOutputFilePathWithoutExtension;
        if (compilerOptions.outDir) {
            emitOutputFilePathWithoutExtension = removeFileExtension(getSourceFilePathInNewDir(fileName, host, compilerOptions.outDir));
        }
        else {
            emitOutputFilePathWithoutExtension = removeFileExtension(fileName);
        }
        return emitOutputFilePathWithoutExtension + extension;
    }
    ts.getOwnEmitOutputFilePath = getOwnEmitOutputFilePath;
    function getDeclarationEmitOutputFilePath(fileName, host) {
        return getDeclarationEmitOutputFilePathWorker(fileName, host.getCompilerOptions(), host.getCurrentDirectory(), host.getCommonSourceDirectory(), function (f) { return host.getCanonicalFileName(f); });
    }
    ts.getDeclarationEmitOutputFilePath = getDeclarationEmitOutputFilePath;
    function getDeclarationEmitOutputFilePathWorker(fileName, options, currentDirectory, commonSourceDirectory, getCanonicalFileName) {
        var outputDir = options.declarationDir || options.outDir; // Prefer declaration folder if specified
        var path = outputDir
            ? getSourceFilePathInNewDirWorker(fileName, outputDir, currentDirectory, commonSourceDirectory, getCanonicalFileName)
            : fileName;
        var declarationExtension = getDeclarationEmitExtensionForPath(path);
        return removeFileExtension(path) + declarationExtension;
    }
    ts.getDeclarationEmitOutputFilePathWorker = getDeclarationEmitOutputFilePathWorker;
    function getDeclarationEmitExtensionForPath(path) {
        return ts.fileExtensionIsOneOf(path, [".mjs" /* Extension.Mjs */, ".mts" /* Extension.Mts */]) ? ".d.mts" /* Extension.Dmts */ :
            ts.fileExtensionIsOneOf(path, [".cjs" /* Extension.Cjs */, ".cts" /* Extension.Cts */]) ? ".d.cts" /* Extension.Dcts */ :
                ts.fileExtensionIsOneOf(path, [".json" /* Extension.Json */]) ? ".json.d.ts" : // Drive-by redefinition of json declaration file output name so if it's ever enabled, it behaves well
                    ".d.ts" /* Extension.Dts */;
    }
    ts.getDeclarationEmitExtensionForPath = getDeclarationEmitExtensionForPath;
    /**
     * This function is an inverse of `getDeclarationEmitExtensionForPath`.
     */
    function getPossibleOriginalInputExtensionForExtension(path) {
        return ts.fileExtensionIsOneOf(path, [".d.mts" /* Extension.Dmts */, ".mjs" /* Extension.Mjs */, ".mts" /* Extension.Mts */]) ? [".mts" /* Extension.Mts */, ".mjs" /* Extension.Mjs */] :
            ts.fileExtensionIsOneOf(path, [".d.cts" /* Extension.Dcts */, ".cjs" /* Extension.Cjs */, ".cts" /* Extension.Cts */]) ? [".cts" /* Extension.Cts */, ".cjs" /* Extension.Cjs */] :
                ts.fileExtensionIsOneOf(path, [".json.d.ts"]) ? [".json" /* Extension.Json */] :
                    [".tsx" /* Extension.Tsx */, ".ts" /* Extension.Ts */, ".jsx" /* Extension.Jsx */, ".js" /* Extension.Js */];
    }
    ts.getPossibleOriginalInputExtensionForExtension = getPossibleOriginalInputExtensionForExtension;
    function outFile(options) {
        return options.outFile || options.out;
    }
    ts.outFile = outFile;
    /** Returns 'undefined' if and only if 'options.paths' is undefined. */
    function getPathsBasePath(options, host) {
        var _a, _b;
        if (!options.paths)
            return undefined;
        return (_a = options.baseUrl) !== null && _a !== void 0 ? _a : ts.Debug.checkDefined(options.pathsBasePath || ((_b = host.getCurrentDirectory) === null || _b === void 0 ? void 0 : _b.call(host)), "Encountered 'paths' without a 'baseUrl', config file, or host 'getCurrentDirectory'.");
    }
    ts.getPathsBasePath = getPathsBasePath;
    /**
     * Gets the source files that are expected to have an emit output.
     *
     * Originally part of `forEachExpectedEmitFile`, this functionality was extracted to support
     * transformations.
     *
     * @param host An EmitHost.
     * @param targetSourceFile An optional target source file to emit.
     */
    function getSourceFilesToEmit(host, targetSourceFile, forceDtsEmit) {
        var options = host.getCompilerOptions();
        if (outFile(options)) {
            var moduleKind = getEmitModuleKind(options);
            var moduleEmitEnabled_1 = options.emitDeclarationOnly || moduleKind === ts.ModuleKind.AMD || moduleKind === ts.ModuleKind.System;
            // Can emit only sources that are not declaration file and are either non module code or module with --module or --target es6 specified
            return ts.filter(host.getSourceFiles(), function (sourceFile) {
                return (moduleEmitEnabled_1 || !ts.isExternalModule(sourceFile)) &&
                    sourceFileMayBeEmitted(sourceFile, host, forceDtsEmit);
            });
        }
        else {
            var sourceFiles = targetSourceFile === undefined ? host.getSourceFiles() : [targetSourceFile];
            return ts.filter(sourceFiles, function (sourceFile) { return sourceFileMayBeEmitted(sourceFile, host, forceDtsEmit); });
        }
    }
    ts.getSourceFilesToEmit = getSourceFilesToEmit;
    /** Don't call this for `--outFile`, just for `--outDir` or plain emit. `--outFile` needs additional checks. */
    function sourceFileMayBeEmitted(sourceFile, host, forceDtsEmit) {
        var options = host.getCompilerOptions();
        return !(options.noEmitForJsFiles && isSourceFileJS(sourceFile)) &&
            !sourceFile.isDeclarationFile &&
            !host.isSourceFileFromExternalLibrary(sourceFile) &&
            (forceDtsEmit || (!(isJsonSourceFile(sourceFile) && host.getResolvedProjectReferenceToRedirect(sourceFile.fileName)) &&
                !host.isSourceOfProjectReferenceRedirect(sourceFile.fileName)));
    }
    ts.sourceFileMayBeEmitted = sourceFileMayBeEmitted;
    function getSourceFilePathInNewDir(fileName, host, newDirPath) {
        return getSourceFilePathInNewDirWorker(fileName, newDirPath, host.getCurrentDirectory(), host.getCommonSourceDirectory(), function (f) { return host.getCanonicalFileName(f); });
    }
    ts.getSourceFilePathInNewDir = getSourceFilePathInNewDir;
    function getSourceFilePathInNewDirWorker(fileName, newDirPath, currentDirectory, commonSourceDirectory, getCanonicalFileName) {
        var sourceFilePath = ts.getNormalizedAbsolutePath(fileName, currentDirectory);
        var isSourceFileInCommonSourceDirectory = getCanonicalFileName(sourceFilePath).indexOf(getCanonicalFileName(commonSourceDirectory)) === 0;
        sourceFilePath = isSourceFileInCommonSourceDirectory ? sourceFilePath.substring(commonSourceDirectory.length) : sourceFilePath;
        return ts.combinePaths(newDirPath, sourceFilePath);
    }
    ts.getSourceFilePathInNewDirWorker = getSourceFilePathInNewDirWorker;
    function writeFile(host, diagnostics, fileName, text, writeByteOrderMark, sourceFiles, data) {
        host.writeFile(fileName, text, writeByteOrderMark, function (hostErrorMessage) {
            diagnostics.add(createCompilerDiagnostic(ts.Diagnostics.Could_not_write_file_0_Colon_1, fileName, hostErrorMessage));
        }, sourceFiles, data);
    }
    ts.writeFile = writeFile;
    function ensureDirectoriesExist(directoryPath, createDirectory, directoryExists) {
        if (directoryPath.length > ts.getRootLength(directoryPath) && !directoryExists(directoryPath)) {
            var parentDirectory = ts.getDirectoryPath(directoryPath);
            ensureDirectoriesExist(parentDirectory, createDirectory, directoryExists);
            createDirectory(directoryPath);
        }
    }
    function writeFileEnsuringDirectories(path, data, writeByteOrderMark, writeFile, createDirectory, directoryExists) {
        // PERF: Checking for directory existence is expensive.  Instead, assume the directory exists
        // and fall back to creating it if the file write fails.
        try {
            writeFile(path, data, writeByteOrderMark);
        }
        catch (_a) {
            ensureDirectoriesExist(ts.getDirectoryPath(ts.normalizePath(path)), createDirectory, directoryExists);
            writeFile(path, data, writeByteOrderMark);
        }
    }
    ts.writeFileEnsuringDirectories = writeFileEnsuringDirectories;
    function getLineOfLocalPosition(sourceFile, pos) {
        var lineStarts = ts.getLineStarts(sourceFile);
        return ts.computeLineOfPosition(lineStarts, pos);
    }
    ts.getLineOfLocalPosition = getLineOfLocalPosition;
    function getLineOfLocalPositionFromLineMap(lineMap, pos) {
        return ts.computeLineOfPosition(lineMap, pos);
    }
    ts.getLineOfLocalPositionFromLineMap = getLineOfLocalPositionFromLineMap;
    function getFirstConstructorWithBody(node) {
        return ts.find(node.members, function (member) { return ts.isConstructorDeclaration(member) && nodeIsPresent(member.body); });
    }
    ts.getFirstConstructorWithBody = getFirstConstructorWithBody;
    function getSetAccessorValueParameter(accessor) {
        if (accessor && accessor.parameters.length > 0) {
            var hasThis = accessor.parameters.length === 2 && parameterIsThisKeyword(accessor.parameters[0]);
            return accessor.parameters[hasThis ? 1 : 0];
        }
    }
    ts.getSetAccessorValueParameter = getSetAccessorValueParameter;
    /** Get the type annotation for the value parameter. */
    function getSetAccessorTypeAnnotationNode(accessor) {
        var parameter = getSetAccessorValueParameter(accessor);
        return parameter && parameter.type;
    }
    ts.getSetAccessorTypeAnnotationNode = getSetAccessorTypeAnnotationNode;
    function getThisParameter(signature) {
        // callback tags do not currently support this parameters
        if (signature.parameters.length && !ts.isJSDocSignature(signature)) {
            var thisParameter = signature.parameters[0];
            if (parameterIsThisKeyword(thisParameter)) {
                return thisParameter;
            }
        }
    }
    ts.getThisParameter = getThisParameter;
    function parameterIsThisKeyword(parameter) {
        return isThisIdentifier(parameter.name);
    }
    ts.parameterIsThisKeyword = parameterIsThisKeyword;
    function isThisIdentifier(node) {
        return !!node && node.kind === 79 /* SyntaxKind.Identifier */ && identifierIsThisKeyword(node);
    }
    ts.isThisIdentifier = isThisIdentifier;
    function isThisInTypeQuery(node) {
        if (!isThisIdentifier(node)) {
            return false;
        }
        while (ts.isQualifiedName(node.parent) && node.parent.left === node) {
            node = node.parent;
        }
        return node.parent.kind === 181 /* SyntaxKind.TypeQuery */;
    }
    ts.isThisInTypeQuery = isThisInTypeQuery;
    function identifierIsThisKeyword(id) {
        return id.originalKeywordKind === 108 /* SyntaxKind.ThisKeyword */;
    }
    ts.identifierIsThisKeyword = identifierIsThisKeyword;
    function getAllAccessorDeclarations(declarations, accessor) {
        // TODO: GH#18217
        var firstAccessor;
        var secondAccessor;
        var getAccessor;
        var setAccessor;
        if (hasDynamicName(accessor)) {
            firstAccessor = accessor;
            if (accessor.kind === 172 /* SyntaxKind.GetAccessor */) {
                getAccessor = accessor;
            }
            else if (accessor.kind === 173 /* SyntaxKind.SetAccessor */) {
                setAccessor = accessor;
            }
            else {
                ts.Debug.fail("Accessor has wrong kind");
            }
        }
        else {
            ts.forEach(declarations, function (member) {
                if (ts.isAccessor(member)
                    && isStatic(member) === isStatic(accessor)) {
                    var memberName = getPropertyNameForPropertyNameNode(member.name);
                    var accessorName = getPropertyNameForPropertyNameNode(accessor.name);
                    if (memberName === accessorName) {
                        if (!firstAccessor) {
                            firstAccessor = member;
                        }
                        else if (!secondAccessor) {
                            secondAccessor = member;
                        }
                        if (member.kind === 172 /* SyntaxKind.GetAccessor */ && !getAccessor) {
                            getAccessor = member;
                        }
                        if (member.kind === 173 /* SyntaxKind.SetAccessor */ && !setAccessor) {
                            setAccessor = member;
                        }
                    }
                }
            });
        }
        return {
            firstAccessor: firstAccessor,
            secondAccessor: secondAccessor,
            getAccessor: getAccessor,
            setAccessor: setAccessor
        };
    }
    ts.getAllAccessorDeclarations = getAllAccessorDeclarations;
    /**
     * Gets the effective type annotation of a variable, parameter, or property. If the node was
     * parsed in a JavaScript file, gets the type annotation from JSDoc.  Also gets the type of
     * functions only the JSDoc case.
     */
    function getEffectiveTypeAnnotationNode(node) {
        if (!isInJSFile(node) && ts.isFunctionDeclaration(node))
            return undefined;
        var type = node.type;
        if (type || !isInJSFile(node))
            return type;
        return ts.isJSDocPropertyLikeTag(node) ? node.typeExpression && node.typeExpression.type : ts.getJSDocType(node);
    }
    ts.getEffectiveTypeAnnotationNode = getEffectiveTypeAnnotationNode;
    function getTypeAnnotationNode(node) {
        return node.type;
    }
    ts.getTypeAnnotationNode = getTypeAnnotationNode;
    /**
     * Gets the effective return type annotation of a signature. If the node was parsed in a
     * JavaScript file, gets the return type annotation from JSDoc.
     */
    function getEffectiveReturnTypeNode(node) {
        return ts.isJSDocSignature(node) ?
            node.type && node.type.typeExpression && node.type.typeExpression.type :
            node.type || (isInJSFile(node) ? ts.getJSDocReturnType(node) : undefined);
    }
    ts.getEffectiveReturnTypeNode = getEffectiveReturnTypeNode;
    function getJSDocTypeParameterDeclarations(node) {
        return ts.flatMap(ts.getJSDocTags(node), function (tag) { return isNonTypeAliasTemplate(tag) ? tag.typeParameters : undefined; });
    }
    ts.getJSDocTypeParameterDeclarations = getJSDocTypeParameterDeclarations;
    /** template tags are only available when a typedef isn't already using them */
    function isNonTypeAliasTemplate(tag) {
        return ts.isJSDocTemplateTag(tag) && !(tag.parent.kind === 320 /* SyntaxKind.JSDoc */ && tag.parent.tags.some(isJSDocTypeAlias));
    }
    /**
     * Gets the effective type annotation of the value parameter of a set accessor. If the node
     * was parsed in a JavaScript file, gets the type annotation from JSDoc.
     */
    function getEffectiveSetAccessorTypeAnnotationNode(node) {
        var parameter = getSetAccessorValueParameter(node);
        return parameter && getEffectiveTypeAnnotationNode(parameter);
    }
    ts.getEffectiveSetAccessorTypeAnnotationNode = getEffectiveSetAccessorTypeAnnotationNode;
    function emitNewLineBeforeLeadingComments(lineMap, writer, node, leadingComments) {
        emitNewLineBeforeLeadingCommentsOfPosition(lineMap, writer, node.pos, leadingComments);
    }
    ts.emitNewLineBeforeLeadingComments = emitNewLineBeforeLeadingComments;
    function emitNewLineBeforeLeadingCommentsOfPosition(lineMap, writer, pos, leadingComments) {
        // If the leading comments start on different line than the start of node, write new line
        if (leadingComments && leadingComments.length && pos !== leadingComments[0].pos &&
            getLineOfLocalPositionFromLineMap(lineMap, pos) !== getLineOfLocalPositionFromLineMap(lineMap, leadingComments[0].pos)) {
            writer.writeLine();
        }
    }
    ts.emitNewLineBeforeLeadingCommentsOfPosition = emitNewLineBeforeLeadingCommentsOfPosition;
    function emitNewLineBeforeLeadingCommentOfPosition(lineMap, writer, pos, commentPos) {
        // If the leading comments start on different line than the start of node, write new line
        if (pos !== commentPos &&
            getLineOfLocalPositionFromLineMap(lineMap, pos) !== getLineOfLocalPositionFromLineMap(lineMap, commentPos)) {
            writer.writeLine();
        }
    }
    ts.emitNewLineBeforeLeadingCommentOfPosition = emitNewLineBeforeLeadingCommentOfPosition;
    function emitComments(text, lineMap, writer, comments, leadingSeparator, trailingSeparator, newLine, writeComment) {
        if (comments && comments.length > 0) {
            if (leadingSeparator) {
                writer.writeSpace(" ");
            }
            var emitInterveningSeparator = false;
            for (var _i = 0, comments_1 = comments; _i < comments_1.length; _i++) {
                var comment = comments_1[_i];
                if (emitInterveningSeparator) {
                    writer.writeSpace(" ");
                    emitInterveningSeparator = false;
                }
                writeComment(text, lineMap, writer, comment.pos, comment.end, newLine);
                if (comment.hasTrailingNewLine) {
                    writer.writeLine();
                }
                else {
                    emitInterveningSeparator = true;
                }
            }
            if (emitInterveningSeparator && trailingSeparator) {
                writer.writeSpace(" ");
            }
        }
    }
    ts.emitComments = emitComments;
    /**
     * Detached comment is a comment at the top of file or function body that is separated from
     * the next statement by space.
     */
    function emitDetachedComments(text, lineMap, writer, writeComment, node, newLine, removeComments) {
        var leadingComments;
        var currentDetachedCommentInfo;
        if (removeComments) {
            // removeComments is true, only reserve pinned comment at the top of file
            // For example:
            //      /*! Pinned Comment */
            //
            //      var x = 10;
            if (node.pos === 0) {
                leadingComments = ts.filter(ts.getLeadingCommentRanges(text, node.pos), isPinnedCommentLocal);
            }
        }
        else {
            // removeComments is false, just get detached as normal and bypass the process to filter comment
            leadingComments = ts.getLeadingCommentRanges(text, node.pos);
        }
        if (leadingComments) {
            var detachedComments = [];
            var lastComment = void 0;
            for (var _i = 0, leadingComments_1 = leadingComments; _i < leadingComments_1.length; _i++) {
                var comment = leadingComments_1[_i];
                if (lastComment) {
                    var lastCommentLine = getLineOfLocalPositionFromLineMap(lineMap, lastComment.end);
                    var commentLine = getLineOfLocalPositionFromLineMap(lineMap, comment.pos);
                    if (commentLine >= lastCommentLine + 2) {
                        // There was a blank line between the last comment and this comment.  This
                        // comment is not part of the copyright comments.  Return what we have so
                        // far.
                        break;
                    }
                }
                detachedComments.push(comment);
                lastComment = comment;
            }
            if (detachedComments.length) {
                // All comments look like they could have been part of the copyright header.  Make
                // sure there is at least one blank line between it and the node.  If not, it's not
                // a copyright header.
                var lastCommentLine = getLineOfLocalPositionFromLineMap(lineMap, ts.last(detachedComments).end);
                var nodeLine = getLineOfLocalPositionFromLineMap(lineMap, ts.skipTrivia(text, node.pos));
                if (nodeLine >= lastCommentLine + 2) {
                    // Valid detachedComments
                    emitNewLineBeforeLeadingComments(lineMap, writer, node, leadingComments);
                    emitComments(text, lineMap, writer, detachedComments, /*leadingSeparator*/ false, /*trailingSeparator*/ true, newLine, writeComment);
                    currentDetachedCommentInfo = { nodePos: node.pos, detachedCommentEndPos: ts.last(detachedComments).end };
                }
            }
        }
        return currentDetachedCommentInfo;
        function isPinnedCommentLocal(comment) {
            return isPinnedComment(text, comment.pos);
        }
    }
    ts.emitDetachedComments = emitDetachedComments;
    function writeCommentRange(text, lineMap, writer, commentPos, commentEnd, newLine) {
        if (text.charCodeAt(commentPos + 1) === 42 /* CharacterCodes.asterisk */) {
            var firstCommentLineAndCharacter = ts.computeLineAndCharacterOfPosition(lineMap, commentPos);
            var lineCount = lineMap.length;
            var firstCommentLineIndent = void 0;
            for (var pos = commentPos, currentLine = firstCommentLineAndCharacter.line; pos < commentEnd; currentLine++) {
                var nextLineStart = (currentLine + 1) === lineCount
                    ? text.length + 1
                    : lineMap[currentLine + 1];
                if (pos !== commentPos) {
                    // If we are not emitting first line, we need to write the spaces to adjust the alignment
                    if (firstCommentLineIndent === undefined) {
                        firstCommentLineIndent = calculateIndent(text, lineMap[firstCommentLineAndCharacter.line], commentPos);
                    }
                    // These are number of spaces writer is going to write at current indent
                    var currentWriterIndentSpacing = writer.getIndent() * getIndentSize();
                    // Number of spaces we want to be writing
                    // eg: Assume writer indent
                    // module m {
                    //         /* starts at character 9 this is line 1
                    //    * starts at character pos 4 line                        --1  = 8 - 8 + 3
                    //   More left indented comment */                            --2  = 8 - 8 + 2
                    //     class c { }
                    // }
                    // module m {
                    //     /* this is line 1 -- Assume current writer indent 8
                    //      * line                                                --3 = 8 - 4 + 5
                    //            More right indented comment */                  --4 = 8 - 4 + 11
                    //     class c { }
                    // }
                    var spacesToEmit = currentWriterIndentSpacing - firstCommentLineIndent + calculateIndent(text, pos, nextLineStart);
                    if (spacesToEmit > 0) {
                        var numberOfSingleSpacesToEmit = spacesToEmit % getIndentSize();
                        var indentSizeSpaceString = getIndentString((spacesToEmit - numberOfSingleSpacesToEmit) / getIndentSize());
                        // Write indent size string ( in eg 1: = "", 2: "" , 3: string with 8 spaces 4: string with 12 spaces
                        writer.rawWrite(indentSizeSpaceString);
                        // Emit the single spaces (in eg: 1: 3 spaces, 2: 2 spaces, 3: 1 space, 4: 3 spaces)
                        while (numberOfSingleSpacesToEmit) {
                            writer.rawWrite(" ");
                            numberOfSingleSpacesToEmit--;
                        }
                    }
                    else {
                        // No spaces to emit write empty string
                        writer.rawWrite("");
                    }
                }
                // Write the comment line text
                writeTrimmedCurrentLine(text, commentEnd, writer, newLine, pos, nextLineStart);
                pos = nextLineStart;
            }
        }
        else {
            // Single line comment of style //....
            writer.writeComment(text.substring(commentPos, commentEnd));
        }
    }
    ts.writeCommentRange = writeCommentRange;
    function writeTrimmedCurrentLine(text, commentEnd, writer, newLine, pos, nextLineStart) {
        var end = Math.min(commentEnd, nextLineStart - 1);
        var currentLineText = ts.trimString(text.substring(pos, end));
        if (currentLineText) {
            // trimmed forward and ending spaces text
            writer.writeComment(currentLineText);
            if (end !== commentEnd) {
                writer.writeLine();
            }
        }
        else {
            // Empty string - make sure we write empty line
            writer.rawWrite(newLine);
        }
    }
    function calculateIndent(text, pos, end) {
        var currentLineIndent = 0;
        for (; pos < end && ts.isWhiteSpaceSingleLine(text.charCodeAt(pos)); pos++) {
            if (text.charCodeAt(pos) === 9 /* CharacterCodes.tab */) {
                // Tabs = TabSize = indent size and go to next tabStop
                currentLineIndent += getIndentSize() - (currentLineIndent % getIndentSize());
            }
            else {
                // Single space
                currentLineIndent++;
            }
        }
        return currentLineIndent;
    }
    function hasEffectiveModifiers(node) {
        return getEffectiveModifierFlags(node) !== 0 /* ModifierFlags.None */;
    }
    ts.hasEffectiveModifiers = hasEffectiveModifiers;
    function hasSyntacticModifiers(node) {
        return getSyntacticModifierFlags(node) !== 0 /* ModifierFlags.None */;
    }
    ts.hasSyntacticModifiers = hasSyntacticModifiers;
    function hasEffectiveModifier(node, flags) {
        return !!getSelectedEffectiveModifierFlags(node, flags);
    }
    ts.hasEffectiveModifier = hasEffectiveModifier;
    function hasSyntacticModifier(node, flags) {
        return !!getSelectedSyntacticModifierFlags(node, flags);
    }
    ts.hasSyntacticModifier = hasSyntacticModifier;
    function isStatic(node) {
        // https://tc39.es/ecma262/#sec-static-semantics-isstatic
        return ts.isClassElement(node) && hasStaticModifier(node) || ts.isClassStaticBlockDeclaration(node);
    }
    ts.isStatic = isStatic;
    function hasStaticModifier(node) {
        return hasSyntacticModifier(node, 32 /* ModifierFlags.Static */);
    }
    ts.hasStaticModifier = hasStaticModifier;
    function hasOverrideModifier(node) {
        return hasEffectiveModifier(node, 16384 /* ModifierFlags.Override */);
    }
    ts.hasOverrideModifier = hasOverrideModifier;
    function hasAbstractModifier(node) {
        return hasSyntacticModifier(node, 128 /* ModifierFlags.Abstract */);
    }
    ts.hasAbstractModifier = hasAbstractModifier;
    function hasAmbientModifier(node) {
        return hasSyntacticModifier(node, 2 /* ModifierFlags.Ambient */);
    }
    ts.hasAmbientModifier = hasAmbientModifier;
    function hasEffectiveReadonlyModifier(node) {
        return hasEffectiveModifier(node, 64 /* ModifierFlags.Readonly */);
    }
    ts.hasEffectiveReadonlyModifier = hasEffectiveReadonlyModifier;
    function hasDecorators(node) {
        return hasSyntacticModifier(node, 131072 /* ModifierFlags.Decorator */);
    }
    ts.hasDecorators = hasDecorators;
    function getSelectedEffectiveModifierFlags(node, flags) {
        return getEffectiveModifierFlags(node) & flags;
    }
    ts.getSelectedEffectiveModifierFlags = getSelectedEffectiveModifierFlags;
    function getSelectedSyntacticModifierFlags(node, flags) {
        return getSyntacticModifierFlags(node) & flags;
    }
    ts.getSelectedSyntacticModifierFlags = getSelectedSyntacticModifierFlags;
    function getModifierFlagsWorker(node, includeJSDoc, alwaysIncludeJSDoc) {
        if (node.kind >= 0 /* SyntaxKind.FirstToken */ && node.kind <= 160 /* SyntaxKind.LastToken */) {
            return 0 /* ModifierFlags.None */;
        }
        if (!(node.modifierFlagsCache & 536870912 /* ModifierFlags.HasComputedFlags */)) {
            node.modifierFlagsCache = getSyntacticModifierFlagsNoCache(node) | 536870912 /* ModifierFlags.HasComputedFlags */;
        }
        if (includeJSDoc && !(node.modifierFlagsCache & 4096 /* ModifierFlags.HasComputedJSDocModifiers */) && (alwaysIncludeJSDoc || isInJSFile(node)) && node.parent) {
            node.modifierFlagsCache |= getJSDocModifierFlagsNoCache(node) | 4096 /* ModifierFlags.HasComputedJSDocModifiers */;
        }
        return node.modifierFlagsCache & ~(536870912 /* ModifierFlags.HasComputedFlags */ | 4096 /* ModifierFlags.HasComputedJSDocModifiers */);
    }
    /**
     * Gets the effective ModifierFlags for the provided node, including JSDoc modifiers. The modifiers will be cached on the node to improve performance.
     *
     * NOTE: This function may use `parent` pointers.
     */
    function getEffectiveModifierFlags(node) {
        return getModifierFlagsWorker(node, /*includeJSDoc*/ true);
    }
    ts.getEffectiveModifierFlags = getEffectiveModifierFlags;
    function getEffectiveModifierFlagsAlwaysIncludeJSDoc(node) {
        return getModifierFlagsWorker(node, /*includeJSDOc*/ true, /*alwaysIncludeJSDOc*/ true);
    }
    ts.getEffectiveModifierFlagsAlwaysIncludeJSDoc = getEffectiveModifierFlagsAlwaysIncludeJSDoc;
    /**
     * Gets the ModifierFlags for syntactic modifiers on the provided node. The modifiers will be cached on the node to improve performance.
     *
     * NOTE: This function does not use `parent` pointers and will not include modifiers from JSDoc.
     */
    function getSyntacticModifierFlags(node) {
        return getModifierFlagsWorker(node, /*includeJSDoc*/ false);
    }
    ts.getSyntacticModifierFlags = getSyntacticModifierFlags;
    function getJSDocModifierFlagsNoCache(node) {
        var flags = 0 /* ModifierFlags.None */;
        if (!!node.parent && !ts.isParameter(node)) {
            if (isInJSFile(node)) {
                if (ts.getJSDocPublicTagNoCache(node))
                    flags |= 4 /* ModifierFlags.Public */;
                if (ts.getJSDocPrivateTagNoCache(node))
                    flags |= 8 /* ModifierFlags.Private */;
                if (ts.getJSDocProtectedTagNoCache(node))
                    flags |= 16 /* ModifierFlags.Protected */;
                if (ts.getJSDocReadonlyTagNoCache(node))
                    flags |= 64 /* ModifierFlags.Readonly */;
                if (ts.getJSDocOverrideTagNoCache(node))
                    flags |= 16384 /* ModifierFlags.Override */;
            }
            if (ts.getJSDocDeprecatedTagNoCache(node))
                flags |= 8192 /* ModifierFlags.Deprecated */;
        }
        return flags;
    }
    /**
     * Gets the effective ModifierFlags for the provided node, including JSDoc modifiers. The modifier flags cache on the node is ignored.
     *
     * NOTE: This function may use `parent` pointers.
     */
    function getEffectiveModifierFlagsNoCache(node) {
        return getSyntacticModifierFlagsNoCache(node) | getJSDocModifierFlagsNoCache(node);
    }
    ts.getEffectiveModifierFlagsNoCache = getEffectiveModifierFlagsNoCache;
    /**
     * Gets the ModifierFlags for syntactic modifiers on the provided node. The modifier flags cache on the node is ignored.
     *
     * NOTE: This function does not use `parent` pointers and will not include modifiers from JSDoc.
     */
    function getSyntacticModifierFlagsNoCache(node) {
        var flags = ts.canHaveModifiers(node) ? modifiersToFlags(node.modifiers) : 0 /* ModifierFlags.None */;
        if (node.flags & 4 /* NodeFlags.NestedNamespace */ || (node.kind === 79 /* SyntaxKind.Identifier */ && node.isInJSDocNamespace)) {
            flags |= 1 /* ModifierFlags.Export */;
        }
        return flags;
    }
    ts.getSyntacticModifierFlagsNoCache = getSyntacticModifierFlagsNoCache;
    function modifiersToFlags(modifiers) {
        var flags = 0 /* ModifierFlags.None */;
        if (modifiers) {
            for (var _i = 0, modifiers_1 = modifiers; _i < modifiers_1.length; _i++) {
                var modifier = modifiers_1[_i];
                flags |= modifierToFlag(modifier.kind);
            }
        }
        return flags;
    }
    ts.modifiersToFlags = modifiersToFlags;
    function modifierToFlag(token) {
        switch (token) {
            case 124 /* SyntaxKind.StaticKeyword */: return 32 /* ModifierFlags.Static */;
            case 123 /* SyntaxKind.PublicKeyword */: return 4 /* ModifierFlags.Public */;
            case 122 /* SyntaxKind.ProtectedKeyword */: return 16 /* ModifierFlags.Protected */;
            case 121 /* SyntaxKind.PrivateKeyword */: return 8 /* ModifierFlags.Private */;
            case 126 /* SyntaxKind.AbstractKeyword */: return 128 /* ModifierFlags.Abstract */;
            case 93 /* SyntaxKind.ExportKeyword */: return 1 /* ModifierFlags.Export */;
            case 135 /* SyntaxKind.DeclareKeyword */: return 2 /* ModifierFlags.Ambient */;
            case 85 /* SyntaxKind.ConstKeyword */: return 2048 /* ModifierFlags.Const */;
            case 88 /* SyntaxKind.DefaultKeyword */: return 512 /* ModifierFlags.Default */;
            case 131 /* SyntaxKind.AsyncKeyword */: return 256 /* ModifierFlags.Async */;
            case 145 /* SyntaxKind.ReadonlyKeyword */: return 64 /* ModifierFlags.Readonly */;
            case 159 /* SyntaxKind.OverrideKeyword */: return 16384 /* ModifierFlags.Override */;
            case 101 /* SyntaxKind.InKeyword */: return 32768 /* ModifierFlags.In */;
            case 144 /* SyntaxKind.OutKeyword */: return 65536 /* ModifierFlags.Out */;
            case 165 /* SyntaxKind.Decorator */: return 131072 /* ModifierFlags.Decorator */;
        }
        return 0 /* ModifierFlags.None */;
    }
    ts.modifierToFlag = modifierToFlag;
    function createModifiers(modifierFlags) {
        return modifierFlags ? ts.factory.createNodeArray(ts.factory.createModifiersFromModifierFlags(modifierFlags)) : undefined;
    }
    ts.createModifiers = createModifiers;
    function isLogicalOperator(token) {
        return token === 56 /* SyntaxKind.BarBarToken */
            || token === 55 /* SyntaxKind.AmpersandAmpersandToken */
            || token === 53 /* SyntaxKind.ExclamationToken */;
    }
    ts.isLogicalOperator = isLogicalOperator;
    function isLogicalOrCoalescingAssignmentOperator(token) {
        return token === 75 /* SyntaxKind.BarBarEqualsToken */
            || token === 76 /* SyntaxKind.AmpersandAmpersandEqualsToken */
            || token === 77 /* SyntaxKind.QuestionQuestionEqualsToken */;
    }
    ts.isLogicalOrCoalescingAssignmentOperator = isLogicalOrCoalescingAssignmentOperator;
    function isLogicalOrCoalescingAssignmentExpression(expr) {
        return isLogicalOrCoalescingAssignmentOperator(expr.operatorToken.kind);
    }
    ts.isLogicalOrCoalescingAssignmentExpression = isLogicalOrCoalescingAssignmentExpression;
    function isAssignmentOperator(token) {
        return token >= 63 /* SyntaxKind.FirstAssignment */ && token <= 78 /* SyntaxKind.LastAssignment */;
    }
    ts.isAssignmentOperator = isAssignmentOperator;
    /** Get `C` given `N` if `N` is in the position `class C extends N` where `N` is an ExpressionWithTypeArguments. */
    function tryGetClassExtendingExpressionWithTypeArguments(node) {
        var cls = tryGetClassImplementingOrExtendingExpressionWithTypeArguments(node);
        return cls && !cls.isImplements ? cls.class : undefined;
    }
    ts.tryGetClassExtendingExpressionWithTypeArguments = tryGetClassExtendingExpressionWithTypeArguments;
    function tryGetClassImplementingOrExtendingExpressionWithTypeArguments(node) {
        return ts.isExpressionWithTypeArguments(node)
            && ts.isHeritageClause(node.parent)
            && ts.isClassLike(node.parent.parent)
            ? { class: node.parent.parent, isImplements: node.parent.token === 117 /* SyntaxKind.ImplementsKeyword */ }
            : undefined;
    }
    ts.tryGetClassImplementingOrExtendingExpressionWithTypeArguments = tryGetClassImplementingOrExtendingExpressionWithTypeArguments;
    function isAssignmentExpression(node, excludeCompoundAssignment) {
        return ts.isBinaryExpression(node)
            && (excludeCompoundAssignment
                ? node.operatorToken.kind === 63 /* SyntaxKind.EqualsToken */
                : isAssignmentOperator(node.operatorToken.kind))
            && ts.isLeftHandSideExpression(node.left);
    }
    ts.isAssignmentExpression = isAssignmentExpression;
    function isLeftHandSideOfAssignment(node) {
        return isAssignmentExpression(node.parent) && node.parent.left === node;
    }
    ts.isLeftHandSideOfAssignment = isLeftHandSideOfAssignment;
    function isDestructuringAssignment(node) {
        if (isAssignmentExpression(node, /*excludeCompoundAssignment*/ true)) {
            var kind = node.left.kind;
            return kind === 205 /* SyntaxKind.ObjectLiteralExpression */
                || kind === 204 /* SyntaxKind.ArrayLiteralExpression */;
        }
        return false;
    }
    ts.isDestructuringAssignment = isDestructuringAssignment;
    function isExpressionWithTypeArgumentsInClassExtendsClause(node) {
        return tryGetClassExtendingExpressionWithTypeArguments(node) !== undefined;
    }
    ts.isExpressionWithTypeArgumentsInClassExtendsClause = isExpressionWithTypeArgumentsInClassExtendsClause;
    function isEntityNameExpression(node) {
        return node.kind === 79 /* SyntaxKind.Identifier */ || isPropertyAccessEntityNameExpression(node);
    }
    ts.isEntityNameExpression = isEntityNameExpression;
    function getFirstIdentifier(node) {
        switch (node.kind) {
            case 79 /* SyntaxKind.Identifier */:
                return node;
            case 161 /* SyntaxKind.QualifiedName */:
                do {
                    node = node.left;
                } while (node.kind !== 79 /* SyntaxKind.Identifier */);
                return node;
            case 206 /* SyntaxKind.PropertyAccessExpression */:
                do {
                    node = node.expression;
                } while (node.kind !== 79 /* SyntaxKind.Identifier */);
                return node;
        }
    }
    ts.getFirstIdentifier = getFirstIdentifier;
    function isDottedName(node) {
        return node.kind === 79 /* SyntaxKind.Identifier */
            || node.kind === 108 /* SyntaxKind.ThisKeyword */
            || node.kind === 106 /* SyntaxKind.SuperKeyword */
            || node.kind === 231 /* SyntaxKind.MetaProperty */
            || node.kind === 206 /* SyntaxKind.PropertyAccessExpression */ && isDottedName(node.expression)
            || node.kind === 212 /* SyntaxKind.ParenthesizedExpression */ && isDottedName(node.expression);
    }
    ts.isDottedName = isDottedName;
    function isPropertyAccessEntityNameExpression(node) {
        return ts.isPropertyAccessExpression(node) && ts.isIdentifier(node.name) && isEntityNameExpression(node.expression);
    }
    ts.isPropertyAccessEntityNameExpression = isPropertyAccessEntityNameExpression;
    function tryGetPropertyAccessOrIdentifierToString(expr) {
        if (ts.isPropertyAccessExpression(expr)) {
            var baseStr = tryGetPropertyAccessOrIdentifierToString(expr.expression);
            if (baseStr !== undefined) {
                return baseStr + "." + entityNameToString(expr.name);
            }
        }
        else if (ts.isElementAccessExpression(expr)) {
            var baseStr = tryGetPropertyAccessOrIdentifierToString(expr.expression);
            if (baseStr !== undefined && ts.isPropertyName(expr.argumentExpression)) {
                return baseStr + "." + getPropertyNameForPropertyNameNode(expr.argumentExpression);
            }
        }
        else if (ts.isIdentifier(expr)) {
            return ts.unescapeLeadingUnderscores(expr.escapedText);
        }
        return undefined;
    }
    ts.tryGetPropertyAccessOrIdentifierToString = tryGetPropertyAccessOrIdentifierToString;
    function isPrototypeAccess(node) {
        return isBindableStaticAccessExpression(node) && getElementOrPropertyAccessName(node) === "prototype";
    }
    ts.isPrototypeAccess = isPrototypeAccess;
    function isRightSideOfQualifiedNameOrPropertyAccess(node) {
        return (node.parent.kind === 161 /* SyntaxKind.QualifiedName */ && node.parent.right === node) ||
            (node.parent.kind === 206 /* SyntaxKind.PropertyAccessExpression */ && node.parent.name === node);
    }
    ts.isRightSideOfQualifiedNameOrPropertyAccess = isRightSideOfQualifiedNameOrPropertyAccess;
    function isRightSideOfAccessExpression(node) {
        return ts.isPropertyAccessExpression(node.parent) && node.parent.name === node
            || ts.isElementAccessExpression(node.parent) && node.parent.argumentExpression === node;
    }
    ts.isRightSideOfAccessExpression = isRightSideOfAccessExpression;
    function isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName(node) {
        return ts.isQualifiedName(node.parent) && node.parent.right === node
            || ts.isPropertyAccessExpression(node.parent) && node.parent.name === node
            || ts.isJSDocMemberName(node.parent) && node.parent.right === node;
    }
    ts.isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName = isRightSideOfQualifiedNameOrPropertyAccessOrJSDocMemberName;
    function isEmptyObjectLiteral(expression) {
        return expression.kind === 205 /* SyntaxKind.ObjectLiteralExpression */ &&
            expression.properties.length === 0;
    }
    ts.isEmptyObjectLiteral = isEmptyObjectLiteral;
    function isEmptyArrayLiteral(expression) {
        return expression.kind === 204 /* SyntaxKind.ArrayLiteralExpression */ &&
            expression.elements.length === 0;
    }
    ts.isEmptyArrayLiteral = isEmptyArrayLiteral;
    function getLocalSymbolForExportDefault(symbol) {
        if (!isExportDefaultSymbol(symbol) || !symbol.declarations)
            return undefined;
        for (var _i = 0, _a = symbol.declarations; _i < _a.length; _i++) {
            var decl = _a[_i];
            if (decl.localSymbol)
                return decl.localSymbol;
        }
        return undefined;
    }
    ts.getLocalSymbolForExportDefault = getLocalSymbolForExportDefault;
    function isExportDefaultSymbol(symbol) {
        return symbol && ts.length(symbol.declarations) > 0 && hasSyntacticModifier(symbol.declarations[0], 512 /* ModifierFlags.Default */);
    }
    /** Return ".ts", ".d.ts", or ".tsx", if that is the extension. */
    function tryExtractTSExtension(fileName) {
        return ts.find(supportedTSExtensionsForExtractExtension, function (extension) { return ts.fileExtensionIs(fileName, extension); });
    }
    ts.tryExtractTSExtension = tryExtractTSExtension;
    /**
     * Replace each instance of non-ascii characters by one, two, three, or four escape sequences
     * representing the UTF-8 encoding of the character, and return the expanded char code list.
     */
    function getExpandedCharCodes(input) {
        var output = [];
        var length = input.length;
        for (var i = 0; i < length; i++) {
            var charCode = input.charCodeAt(i);
            // handle utf8
            if (charCode < 0x80) {
                output.push(charCode);
            }
            else if (charCode < 0x800) {
                output.push((charCode >> 6) | 192);
                output.push((charCode & 63) | 128);
            }
            else if (charCode < 0x10000) {
                output.push((charCode >> 12) | 224);
                output.push(((charCode >> 6) & 63) | 128);
                output.push((charCode & 63) | 128);
            }
            else if (charCode < 0x20000) {
                output.push((charCode >> 18) | 240);
                output.push(((charCode >> 12) & 63) | 128);
                output.push(((charCode >> 6) & 63) | 128);
                output.push((charCode & 63) | 128);
            }
            else {
                ts.Debug.assert(false, "Unexpected code point");
            }
        }
        return output;
    }
    var base64Digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    /**
     * Converts a string to a base-64 encoded ASCII string.
     */
    function convertToBase64(input) {
        var result = "";
        var charCodes = getExpandedCharCodes(input);
        var i = 0;
        var length = charCodes.length;
        var byte1, byte2, byte3, byte4;
        while (i < length) {
            // Convert every 6-bits in the input 3 character points
            // into a base64 digit
            byte1 = charCodes[i] >> 2;
            byte2 = (charCodes[i] & 3) << 4 | charCodes[i + 1] >> 4;
            byte3 = (charCodes[i + 1] & 15) << 2 | charCodes[i + 2] >> 6;
            byte4 = charCodes[i + 2] & 63;
            // We are out of characters in the input, set the extra
            // digits to 64 (padding character).
            if (i + 1 >= length) {
                byte3 = byte4 = 64;
            }
            else if (i + 2 >= length) {
                byte4 = 64;
            }
            // Write to the output
            result += base64Digits.charAt(byte1) + base64Digits.charAt(byte2) + base64Digits.charAt(byte3) + base64Digits.charAt(byte4);
            i += 3;
        }
        return result;
    }
    ts.convertToBase64 = convertToBase64;
    function getStringFromExpandedCharCodes(codes) {
        var output = "";
        var i = 0;
        var length = codes.length;
        while (i < length) {
            var charCode = codes[i];
            if (charCode < 0x80) {
                output += String.fromCharCode(charCode);
                i++;
            }
            else if ((charCode & 192) === 192) {
                var value = charCode & 63;
                i++;
                var nextCode = codes[i];
                while ((nextCode & 192) === 128) {
                    value = (value << 6) | (nextCode & 63);
                    i++;
                    nextCode = codes[i];
                }
                // `value` may be greater than 10FFFF (the maximum unicode codepoint) - JS will just make this into an invalid character for us
                output += String.fromCharCode(value);
            }
            else {
                // We don't want to kill the process when decoding fails (due to a following char byte not
                // following a leading char), so we just print the (bad) value
                output += String.fromCharCode(charCode);
                i++;
            }
        }
        return output;
    }
    function base64encode(host, input) {
        if (host && host.base64encode) {
            return host.base64encode(input);
        }
        return convertToBase64(input);
    }
    ts.base64encode = base64encode;
    function base64decode(host, input) {
        if (host && host.base64decode) {
            return host.base64decode(input);
        }
        var length = input.length;
        var expandedCharCodes = [];
        var i = 0;
        while (i < length) {
            // Stop decoding once padding characters are present
            if (input.charCodeAt(i) === base64Digits.charCodeAt(64)) {
                break;
            }
            // convert 4 input digits into three characters, ignoring padding characters at the end
            var ch1 = base64Digits.indexOf(input[i]);
            var ch2 = base64Digits.indexOf(input[i + 1]);
            var ch3 = base64Digits.indexOf(input[i + 2]);
            var ch4 = base64Digits.indexOf(input[i + 3]);
            var code1 = ((ch1 & 63) << 2) | ((ch2 >> 4) & 3);
            var code2 = ((ch2 & 15) << 4) | ((ch3 >> 2) & 15);
            var code3 = ((ch3 & 3) << 6) | (ch4 & 63);
            if (code2 === 0 && ch3 !== 0) { // code2 decoded to zero, but ch3 was padding - elide code2 and code3
                expandedCharCodes.push(code1);
            }
            else if (code3 === 0 && ch4 !== 0) { // code3 decoded to zero, but ch4 was padding, elide code3
                expandedCharCodes.push(code1, code2);
            }
            else {
                expandedCharCodes.push(code1, code2, code3);
            }
            i += 4;
        }
        return getStringFromExpandedCharCodes(expandedCharCodes);
    }
    ts.base64decode = base64decode;
    function readJson(path, host) {
        try {
            var jsonText = host.readFile(path);
            if (!jsonText)
                return {};
            var result = ts.parseConfigFileTextToJson(path, jsonText);
            if (result.error) {
                return {};
            }
            return result.config;
        }
        catch (e) {
            // gracefully handle if readFile fails or returns not JSON
            return {};
        }
    }
    ts.readJson = readJson;
    function directoryProbablyExists(directoryName, host) {
        // if host does not support 'directoryExists' assume that directory will exist
        return !host.directoryExists || host.directoryExists(directoryName);
    }
    ts.directoryProbablyExists = directoryProbablyExists;
    var carriageReturnLineFeed = "\r\n";
    var lineFeed = "\n";
    function getNewLineCharacter(options, getNewLine) {
        switch (options.newLine) {
            case 0 /* NewLineKind.CarriageReturnLineFeed */:
                return carriageReturnLineFeed;
            case 1 /* NewLineKind.LineFeed */:
                return lineFeed;
        }
        return getNewLine ? getNewLine() : ts.sys ? ts.sys.newLine : carriageReturnLineFeed;
    }
    ts.getNewLineCharacter = getNewLineCharacter;
    /**
     * Creates a new TextRange from the provided pos and end.
     *
     * @param pos The start position.
     * @param end The end position.
     */
    function createRange(pos, end) {
        if (end === void 0) { end = pos; }
        ts.Debug.assert(end >= pos || end === -1);
        return { pos: pos, end: end };
    }
    ts.createRange = createRange;
    /**
     * Creates a new TextRange from a provided range with a new end position.
     *
     * @param range A TextRange.
     * @param end The new end position.
     */
    function moveRangeEnd(range, end) {
        return createRange(range.pos, end);
    }
    ts.moveRangeEnd = moveRangeEnd;
    /**
     * Creates a new TextRange from a provided range with a new start position.
     *
     * @param range A TextRange.
     * @param pos The new Start position.
     */
    function moveRangePos(range, pos) {
        return createRange(pos, range.end);
    }
    ts.moveRangePos = moveRangePos;
    /**
     * Moves the start position of a range past any decorators.
     */
    function moveRangePastDecorators(node) {
        var lastDecorator = ts.canHaveModifiers(node) ? ts.findLast(node.modifiers, ts.isDecorator) : undefined;
        return lastDecorator && !positionIsSynthesized(lastDecorator.end)
            ? moveRangePos(node, lastDecorator.end)
            : node;
    }
    ts.moveRangePastDecorators = moveRangePastDecorators;
    /**
     * Moves the start position of a range past any decorators or modifiers.
     */
    function moveRangePastModifiers(node) {
        var lastModifier = ts.canHaveModifiers(node) ? ts.lastOrUndefined(node.modifiers) : undefined;
        return lastModifier && !positionIsSynthesized(lastModifier.end)
            ? moveRangePos(node, lastModifier.end)
            : moveRangePastDecorators(node);
    }
    ts.moveRangePastModifiers = moveRangePastModifiers;
    /**
     * Determines whether a TextRange has the same start and end positions.
     *
     * @param range A TextRange.
     */
    function isCollapsedRange(range) {
        return range.pos === range.end;
    }
    ts.isCollapsedRange = isCollapsedRange;
    /**
     * Creates a new TextRange for a token at the provides start position.
     *
     * @param pos The start position.
     * @param token The token.
     */
    function createTokenRange(pos, token) {
        return createRange(pos, pos + ts.tokenToString(token).length);
    }
    ts.createTokenRange = createTokenRange;
    function rangeIsOnSingleLine(range, sourceFile) {
        return rangeStartIsOnSameLineAsRangeEnd(range, range, sourceFile);
    }
    ts.rangeIsOnSingleLine = rangeIsOnSingleLine;
    function rangeStartPositionsAreOnSameLine(range1, range2, sourceFile) {
        return positionsAreOnSameLine(getStartPositionOfRange(range1, sourceFile, /*includeComments*/ false), getStartPositionOfRange(range2, sourceFile, /*includeComments*/ false), sourceFile);
    }
    ts.rangeStartPositionsAreOnSameLine = rangeStartPositionsAreOnSameLine;
    function rangeEndPositionsAreOnSameLine(range1, range2, sourceFile) {
        return positionsAreOnSameLine(range1.end, range2.end, sourceFile);
    }
    ts.rangeEndPositionsAreOnSameLine = rangeEndPositionsAreOnSameLine;
    function rangeStartIsOnSameLineAsRangeEnd(range1, range2, sourceFile) {
        return positionsAreOnSameLine(getStartPositionOfRange(range1, sourceFile, /*includeComments*/ false), range2.end, sourceFile);
    }
    ts.rangeStartIsOnSameLineAsRangeEnd = rangeStartIsOnSameLineAsRangeEnd;
    function rangeEndIsOnSameLineAsRangeStart(range1, range2, sourceFile) {
        return positionsAreOnSameLine(range1.end, getStartPositionOfRange(range2, sourceFile, /*includeComments*/ false), sourceFile);
    }
    ts.rangeEndIsOnSameLineAsRangeStart = rangeEndIsOnSameLineAsRangeStart;
    function getLinesBetweenRangeEndAndRangeStart(range1, range2, sourceFile, includeSecondRangeComments) {
        var range2Start = getStartPositionOfRange(range2, sourceFile, includeSecondRangeComments);
        return ts.getLinesBetweenPositions(sourceFile, range1.end, range2Start);
    }
    ts.getLinesBetweenRangeEndAndRangeStart = getLinesBetweenRangeEndAndRangeStart;
    function getLinesBetweenRangeEndPositions(range1, range2, sourceFile) {
        return ts.getLinesBetweenPositions(sourceFile, range1.end, range2.end);
    }
    ts.getLinesBetweenRangeEndPositions = getLinesBetweenRangeEndPositions;
    function isNodeArrayMultiLine(list, sourceFile) {
        return !positionsAreOnSameLine(list.pos, list.end, sourceFile);
    }
    ts.isNodeArrayMultiLine = isNodeArrayMultiLine;
    function positionsAreOnSameLine(pos1, pos2, sourceFile) {
        return ts.getLinesBetweenPositions(sourceFile, pos1, pos2) === 0;
    }
    ts.positionsAreOnSameLine = positionsAreOnSameLine;
    function getStartPositionOfRange(range, sourceFile, includeComments) {
        return positionIsSynthesized(range.pos) ? -1 : ts.skipTrivia(sourceFile.text, range.pos, /*stopAfterLineBreak*/ false, includeComments);
    }
    ts.getStartPositionOfRange = getStartPositionOfRange;
    function getLinesBetweenPositionAndPrecedingNonWhitespaceCharacter(pos, stopPos, sourceFile, includeComments) {
        var startPos = ts.skipTrivia(sourceFile.text, pos, /*stopAfterLineBreak*/ false, includeComments);
        var prevPos = getPreviousNonWhitespacePosition(startPos, stopPos, sourceFile);
        return ts.getLinesBetweenPositions(sourceFile, prevPos !== null && prevPos !== void 0 ? prevPos : stopPos, startPos);
    }
    ts.getLinesBetweenPositionAndPrecedingNonWhitespaceCharacter = getLinesBetweenPositionAndPrecedingNonWhitespaceCharacter;
    function getLinesBetweenPositionAndNextNonWhitespaceCharacter(pos, stopPos, sourceFile, includeComments) {
        var nextPos = ts.skipTrivia(sourceFile.text, pos, /*stopAfterLineBreak*/ false, includeComments);
        return ts.getLinesBetweenPositions(sourceFile, pos, Math.min(stopPos, nextPos));
    }
    ts.getLinesBetweenPositionAndNextNonWhitespaceCharacter = getLinesBetweenPositionAndNextNonWhitespaceCharacter;
    function getPreviousNonWhitespacePosition(pos, stopPos, sourceFile) {
        if (stopPos === void 0) { stopPos = 0; }
        while (pos-- > stopPos) {
            if (!ts.isWhiteSpaceLike(sourceFile.text.charCodeAt(pos))) {
                return pos;
            }
        }
    }
    /**
     * Determines whether a name was originally the declaration name of an enum or namespace
     * declaration.
     */
    function isDeclarationNameOfEnumOrNamespace(node) {
        var parseNode = ts.getParseTreeNode(node);
        if (parseNode) {
            switch (parseNode.parent.kind) {
                case 260 /* SyntaxKind.EnumDeclaration */:
                case 261 /* SyntaxKind.ModuleDeclaration */:
                    return parseNode === parseNode.parent.name;
            }
        }
        return false;
    }
    ts.isDeclarationNameOfEnumOrNamespace = isDeclarationNameOfEnumOrNamespace;
    function getInitializedVariables(node) {
        return ts.filter(node.declarations, isInitializedVariable);
    }
    ts.getInitializedVariables = getInitializedVariables;
    function isInitializedVariable(node) {
        return node.initializer !== undefined;
    }
    function isWatchSet(options) {
        // Firefox has Object.prototype.watch
        return options.watch && options.hasOwnProperty("watch");
    }
    ts.isWatchSet = isWatchSet;
    function closeFileWatcher(watcher) {
        watcher.close();
    }
    ts.closeFileWatcher = closeFileWatcher;
    function getCheckFlags(symbol) {
        return symbol.flags & 33554432 /* SymbolFlags.Transient */ ? symbol.checkFlags : 0;
    }
    ts.getCheckFlags = getCheckFlags;
    function getDeclarationModifierFlagsFromSymbol(s, isWrite) {
        if (isWrite === void 0) { isWrite = false; }
        if (s.valueDeclaration) {
            var declaration = (isWrite && s.declarations && ts.find(s.declarations, ts.isSetAccessorDeclaration))
                || (s.flags & 32768 /* SymbolFlags.GetAccessor */ && ts.find(s.declarations, ts.isGetAccessorDeclaration)) || s.valueDeclaration;
            var flags = ts.getCombinedModifierFlags(declaration);
            return s.parent && s.parent.flags & 32 /* SymbolFlags.Class */ ? flags : flags & ~28 /* ModifierFlags.AccessibilityModifier */;
        }
        if (getCheckFlags(s) & 6 /* CheckFlags.Synthetic */) {
            var checkFlags = s.checkFlags;
            var accessModifier = checkFlags & 1024 /* CheckFlags.ContainsPrivate */ ? 8 /* ModifierFlags.Private */ :
                checkFlags & 256 /* CheckFlags.ContainsPublic */ ? 4 /* ModifierFlags.Public */ :
                    16 /* ModifierFlags.Protected */;
            var staticModifier = checkFlags & 2048 /* CheckFlags.ContainsStatic */ ? 32 /* ModifierFlags.Static */ : 0;
            return accessModifier | staticModifier;
        }
        if (s.flags & 4194304 /* SymbolFlags.Prototype */) {
            return 4 /* ModifierFlags.Public */ | 32 /* ModifierFlags.Static */;
        }
        return 0;
    }
    ts.getDeclarationModifierFlagsFromSymbol = getDeclarationModifierFlagsFromSymbol;
    function skipAlias(symbol, checker) {
        return symbol.flags & 2097152 /* SymbolFlags.Alias */ ? checker.getAliasedSymbol(symbol) : symbol;
    }
    ts.skipAlias = skipAlias;
    /** See comment on `declareModuleMember` in `binder.ts`. */
    function getCombinedLocalAndExportSymbolFlags(symbol) {
        return symbol.exportSymbol ? symbol.exportSymbol.flags | symbol.flags : symbol.flags;
    }
    ts.getCombinedLocalAndExportSymbolFlags = getCombinedLocalAndExportSymbolFlags;
    function isWriteOnlyAccess(node) {
        return accessKind(node) === 1 /* AccessKind.Write */;
    }
    ts.isWriteOnlyAccess = isWriteOnlyAccess;
    function isWriteAccess(node) {
        return accessKind(node) !== 0 /* AccessKind.Read */;
    }
    ts.isWriteAccess = isWriteAccess;
    var AccessKind;
    (function (AccessKind) {
        /** Only reads from a variable. */
        AccessKind[AccessKind["Read"] = 0] = "Read";
        /** Only writes to a variable without using the result. E.g.: `x++;`. */
        AccessKind[AccessKind["Write"] = 1] = "Write";
        /** Writes to a variable and uses the result as an expression. E.g.: `f(x++);`. */
        AccessKind[AccessKind["ReadWrite"] = 2] = "ReadWrite";
    })(AccessKind || (AccessKind = {}));
    function accessKind(node) {
        var parent = node.parent;
        if (!parent)
            return 0 /* AccessKind.Read */;
        switch (parent.kind) {
            case 212 /* SyntaxKind.ParenthesizedExpression */:
                return accessKind(parent);
            case 220 /* SyntaxKind.PostfixUnaryExpression */:
            case 219 /* SyntaxKind.PrefixUnaryExpression */:
                var operator = parent.operator;
                return operator === 45 /* SyntaxKind.PlusPlusToken */ || operator === 46 /* SyntaxKind.MinusMinusToken */ ? writeOrReadWrite() : 0 /* AccessKind.Read */;
            case 221 /* SyntaxKind.BinaryExpression */:
                var _a = parent, left = _a.left, operatorToken = _a.operatorToken;
                return left === node && isAssignmentOperator(operatorToken.kind) ?
                    operatorToken.kind === 63 /* SyntaxKind.EqualsToken */ ? 1 /* AccessKind.Write */ : writeOrReadWrite()
                    : 0 /* AccessKind.Read */;
            case 206 /* SyntaxKind.PropertyAccessExpression */:
                return parent.name !== node ? 0 /* AccessKind.Read */ : accessKind(parent);
            case 296 /* SyntaxKind.PropertyAssignment */: {
                var parentAccess = accessKind(parent.parent);
                // In `({ x: varname }) = { x: 1 }`, the left `x` is a read, the right `x` is a write.
                return node === parent.name ? reverseAccessKind(parentAccess) : parentAccess;
            }
            case 297 /* SyntaxKind.ShorthandPropertyAssignment */:
                // Assume it's the local variable being accessed, since we don't check public properties for --noUnusedLocals.
                return node === parent.objectAssignmentInitializer ? 0 /* AccessKind.Read */ : accessKind(parent.parent);
            case 204 /* SyntaxKind.ArrayLiteralExpression */:
                return accessKind(parent);
            default:
                return 0 /* AccessKind.Read */;
        }
        function writeOrReadWrite() {
            // If grandparent is not an ExpressionStatement, this is used as an expression in addition to having a side effect.
            return parent.parent && walkUpParenthesizedExpressions(parent.parent).kind === 238 /* SyntaxKind.ExpressionStatement */ ? 1 /* AccessKind.Write */ : 2 /* AccessKind.ReadWrite */;
        }
    }
    function reverseAccessKind(a) {
        switch (a) {
            case 0 /* AccessKind.Read */:
                return 1 /* AccessKind.Write */;
            case 1 /* AccessKind.Write */:
                return 0 /* AccessKind.Read */;
            case 2 /* AccessKind.ReadWrite */:
                return 2 /* AccessKind.ReadWrite */;
            default:
                return ts.Debug.assertNever(a);
        }
    }
    function compareDataObjects(dst, src) {
        if (!dst || !src || Object.keys(dst).length !== Object.keys(src).length) {
            return false;
        }
        for (var e in dst) {
            if (typeof dst[e] === "object") {
                if (!compareDataObjects(dst[e], src[e])) {
                    return false;
                }
            }
            else if (typeof dst[e] !== "function") {
                if (dst[e] !== src[e]) {
                    return false;
                }
            }
        }
        return true;
    }
    ts.compareDataObjects = compareDataObjects;
    /**
     * clears already present map by calling onDeleteExistingValue callback before deleting that key/value
     */
    function clearMap(map, onDeleteValue) {
        // Remove all
        map.forEach(onDeleteValue);
        map.clear();
    }
    ts.clearMap = clearMap;
    /**
     * Mutates the map with newMap such that keys in map will be same as newMap.
     */
    function mutateMapSkippingNewValues(map, newMap, options) {
        var onDeleteValue = options.onDeleteValue, onExistingValue = options.onExistingValue;
        // Needs update
        map.forEach(function (existingValue, key) {
            var valueInNewMap = newMap.get(key);
            // Not present any more in new map, remove it
            if (valueInNewMap === undefined) {
                map.delete(key);
                onDeleteValue(existingValue, key);
            }
            // If present notify about existing values
            else if (onExistingValue) {
                onExistingValue(existingValue, valueInNewMap, key);
            }
        });
    }
    ts.mutateMapSkippingNewValues = mutateMapSkippingNewValues;
    /**
     * Mutates the map with newMap such that keys in map will be same as newMap.
     */
    function mutateMap(map, newMap, options) {
        // Needs update
        mutateMapSkippingNewValues(map, newMap, options);
        var createNewValue = options.createNewValue;
        // Add new values that are not already present
        newMap.forEach(function (valueInNewMap, key) {
            if (!map.has(key)) {
                // New values
                map.set(key, createNewValue(key, valueInNewMap));
            }
        });
    }
    ts.mutateMap = mutateMap;
    function isAbstractConstructorSymbol(symbol) {
        if (symbol.flags & 32 /* SymbolFlags.Class */) {
            var declaration = getClassLikeDeclarationOfSymbol(symbol);
            return !!declaration && hasSyntacticModifier(declaration, 128 /* ModifierFlags.Abstract */);
        }
        return false;
    }
    ts.isAbstractConstructorSymbol = isAbstractConstructorSymbol;
    function getClassLikeDeclarationOfSymbol(symbol) {
        var _a;
        return (_a = symbol.declarations) === null || _a === void 0 ? void 0 : _a.find(ts.isClassLike);
    }
    ts.getClassLikeDeclarationOfSymbol = getClassLikeDeclarationOfSymbol;
    function getObjectFlags(type) {
        return type.flags & 3899393 /* TypeFlags.ObjectFlagsType */ ? type.objectFlags : 0;
    }
    ts.getObjectFlags = getObjectFlags;
    function typeHasCallOrConstructSignatures(type, checker) {
        return checker.getSignaturesOfType(type, 0 /* SignatureKind.Call */).length !== 0 || checker.getSignaturesOfType(type, 1 /* SignatureKind.Construct */).length !== 0;
    }
    ts.typeHasCallOrConstructSignatures = typeHasCallOrConstructSignatures;
    function forSomeAncestorDirectory(directory, callback) {
        return !!ts.forEachAncestorDirectory(directory, function (d) { return callback(d) ? true : undefined; });
    }
    ts.forSomeAncestorDirectory = forSomeAncestorDirectory;
    function isUMDExportSymbol(symbol) {
        return !!symbol && !!symbol.declarations && !!symbol.declarations[0] && ts.isNamespaceExportDeclaration(symbol.declarations[0]);
    }
    ts.isUMDExportSymbol = isUMDExportSymbol;
    function showModuleSpecifier(_a) {
        var moduleSpecifier = _a.moduleSpecifier;
        return ts.isStringLiteral(moduleSpecifier) ? moduleSpecifier.text : getTextOfNode(moduleSpecifier);
    }
    ts.showModuleSpecifier = showModuleSpecifier;
    function getLastChild(node) {
        var lastChild;
        ts.forEachChild(node, function (child) {
            if (nodeIsPresent(child))
                lastChild = child;
        }, function (children) {
            // As an optimization, jump straight to the end of the list.
            for (var i = children.length - 1; i >= 0; i--) {
                if (nodeIsPresent(children[i])) {
                    lastChild = children[i];
                    break;
                }
            }
        });
        return lastChild;
    }
    ts.getLastChild = getLastChild;
    function addToSeen(seen, key, value) {
        if (value === void 0) { value = true; }
        if (seen.has(key)) {
            return false;
        }
        seen.set(key, value);
        return true;
    }
    ts.addToSeen = addToSeen;
    function isObjectTypeDeclaration(node) {
        return ts.isClassLike(node) || ts.isInterfaceDeclaration(node) || ts.isTypeLiteralNode(node);
    }
    ts.isObjectTypeDeclaration = isObjectTypeDeclaration;
    function isTypeNodeKind(kind) {
        return (kind >= 177 /* SyntaxKind.FirstTypeNode */ && kind <= 200 /* SyntaxKind.LastTypeNode */)
            || kind === 130 /* SyntaxKind.AnyKeyword */
            || kind === 155 /* SyntaxKind.UnknownKeyword */
            || kind === 147 /* SyntaxKind.NumberKeyword */
            || kind === 158 /* SyntaxKind.BigIntKeyword */
            || kind === 148 /* SyntaxKind.ObjectKeyword */
            || kind === 133 /* SyntaxKind.BooleanKeyword */
            || kind === 150 /* SyntaxKind.StringKeyword */
            || kind === 151 /* SyntaxKind.SymbolKeyword */
            || kind === 114 /* SyntaxKind.VoidKeyword */
            || kind === 153 /* SyntaxKind.UndefinedKeyword */
            || kind === 143 /* SyntaxKind.NeverKeyword */
            || kind === 228 /* SyntaxKind.ExpressionWithTypeArguments */
            || kind === 312 /* SyntaxKind.JSDocAllType */
            || kind === 313 /* SyntaxKind.JSDocUnknownType */
            || kind === 314 /* SyntaxKind.JSDocNullableType */
            || kind === 315 /* SyntaxKind.JSDocNonNullableType */
            || kind === 316 /* SyntaxKind.JSDocOptionalType */
            || kind === 317 /* SyntaxKind.JSDocFunctionType */
            || kind === 318 /* SyntaxKind.JSDocVariadicType */;
    }
    ts.isTypeNodeKind = isTypeNodeKind;
    function isAccessExpression(node) {
        return node.kind === 206 /* SyntaxKind.PropertyAccessExpression */ || node.kind === 207 /* SyntaxKind.ElementAccessExpression */;
    }
    ts.isAccessExpression = isAccessExpression;
    function getNameOfAccessExpression(node) {
        if (node.kind === 206 /* SyntaxKind.PropertyAccessExpression */) {
            return node.name;
        }
        ts.Debug.assert(node.kind === 207 /* SyntaxKind.ElementAccessExpression */);
        return node.argumentExpression;
    }
    ts.getNameOfAccessExpression = getNameOfAccessExpression;
    function isBundleFileTextLike(section) {
        switch (section.kind) {
            case "text" /* BundleFileSectionKind.Text */:
            case "internal" /* BundleFileSectionKind.Internal */:
                return true;
            default:
                return false;
        }
    }
    ts.isBundleFileTextLike = isBundleFileTextLike;
    function isNamedImportsOrExports(node) {
        return node.kind === 269 /* SyntaxKind.NamedImports */ || node.kind === 273 /* SyntaxKind.NamedExports */;
    }
    ts.isNamedImportsOrExports = isNamedImportsOrExports;
    function getLeftmostAccessExpression(expr) {
        while (isAccessExpression(expr)) {
            expr = expr.expression;
        }
        return expr;
    }
    ts.getLeftmostAccessExpression = getLeftmostAccessExpression;
    function forEachNameInAccessChainWalkingLeft(name, action) {
        if (isAccessExpression(name.parent) && isRightSideOfAccessExpression(name)) {
            return walkAccessExpression(name.parent);
        }
        function walkAccessExpression(access) {
            if (access.kind === 206 /* SyntaxKind.PropertyAccessExpression */) {
                var res = action(access.name);
                if (res !== undefined) {
                    return res;
                }
            }
            else if (access.kind === 207 /* SyntaxKind.ElementAccessExpression */) {
                if (ts.isIdentifier(access.argumentExpression) || ts.isStringLiteralLike(access.argumentExpression)) {
                    var res = action(access.argumentExpression);
                    if (res !== undefined) {
                        return res;
                    }
                }
                else {
                    // Chain interrupted by non-static-name access 'x[expr()].y.z'
                    return undefined;
                }
            }
            if (isAccessExpression(access.expression)) {
                return walkAccessExpression(access.expression);
            }
            if (ts.isIdentifier(access.expression)) {
                // End of chain at Identifier 'x.y.z'
                return action(access.expression);
            }
            // End of chain at non-Identifier 'x().y.z'
            return undefined;
        }
    }
    ts.forEachNameInAccessChainWalkingLeft = forEachNameInAccessChainWalkingLeft;
    function getLeftmostExpression(node, stopAtCallExpressions) {
        while (true) {
            switch (node.kind) {
                case 220 /* SyntaxKind.PostfixUnaryExpression */:
                    node = node.operand;
                    continue;
                case 221 /* SyntaxKind.BinaryExpression */:
                    node = node.left;
                    continue;
                case 222 /* SyntaxKind.ConditionalExpression */:
                    node = node.condition;
                    continue;
                case 210 /* SyntaxKind.TaggedTemplateExpression */:
                    node = node.tag;
                    continue;
                case 208 /* SyntaxKind.CallExpression */:
                    if (stopAtCallExpressions) {
                        return node;
                    }
                // falls through
                case 229 /* SyntaxKind.AsExpression */:
                case 207 /* SyntaxKind.ElementAccessExpression */:
                case 206 /* SyntaxKind.PropertyAccessExpression */:
                case 230 /* SyntaxKind.NonNullExpression */:
                case 350 /* SyntaxKind.PartiallyEmittedExpression */:
                    node = node.expression;
                    continue;
            }
            return node;
        }
    }
    ts.getLeftmostExpression = getLeftmostExpression;
    function Symbol(flags, name) {
        this.flags = flags;
        this.escapedName = name;
        this.declarations = undefined;
        this.valueDeclaration = undefined;
        this.id = undefined;
        this.mergeId = undefined;
        this.parent = undefined;
    }
    function Type(checker, flags) {
        this.flags = flags;
        if (ts.Debug.isDebugging || ts.tracing) {
            this.checker = checker;
        }
    }
    function Signature(checker, flags) {
        this.flags = flags;
        if (ts.Debug.isDebugging) {
            this.checker = checker;
        }
    }
    function Node(kind, pos, end) {
        this.pos = pos;
        this.end = end;
        this.kind = kind;
        this.id = 0;
        this.flags = 0 /* NodeFlags.None */;
        this.modifierFlagsCache = 0 /* ModifierFlags.None */;
        this.transformFlags = 0 /* TransformFlags.None */;
        this.parent = undefined;
        this.original = undefined;
    }
    function Token(kind, pos, end) {
        this.pos = pos;
        this.end = end;
        this.kind = kind;
        this.id = 0;
        this.flags = 0 /* NodeFlags.None */;
        this.transformFlags = 0 /* TransformFlags.None */;
        this.parent = undefined;
    }
    function Identifier(kind, pos, end) {
        this.pos = pos;
        this.end = end;
        this.kind = kind;
        this.id = 0;
        this.flags = 0 /* NodeFlags.None */;
        this.transformFlags = 0 /* TransformFlags.None */;
        this.parent = undefined;
        this.original = undefined;
        this.flowNode = undefined;
    }
    function SourceMapSource(fileName, text, skipTrivia) {
        this.fileName = fileName;
        this.text = text;
        this.skipTrivia = skipTrivia || (function (pos) { return pos; });
    }
    // eslint-disable-next-line prefer-const
    ts.objectAllocator = {
        getNodeConstructor: function () { return Node; },
        getTokenConstructor: function () { return Token; },
        getIdentifierConstructor: function () { return Identifier; },
        getPrivateIdentifierConstructor: function () { return Node; },
        getSourceFileConstructor: function () { return Node; },
        getSymbolConstructor: function () { return Symbol; },
        getTypeConstructor: function () { return Type; },
        getSignatureConstructor: function () { return Signature; },
        getSourceMapSourceConstructor: function () { return SourceMapSource; },
    };
    function setObjectAllocator(alloc) {
        Object.assign(ts.objectAllocator, alloc);
    }
    ts.setObjectAllocator = setObjectAllocator;
    function formatStringFromArgs(text, args, baseIndex) {
        if (baseIndex === void 0) { baseIndex = 0; }
        return text.replace(/{(\d+)}/g, function (_match, index) { return "" + ts.Debug.checkDefined(args[+index + baseIndex]); });
    }
    ts.formatStringFromArgs = formatStringFromArgs;
    var localizedDiagnosticMessages;
    /* @internal */
    function setLocalizedDiagnosticMessages(messages) {
        localizedDiagnosticMessages = messages;
    }
    ts.setLocalizedDiagnosticMessages = setLocalizedDiagnosticMessages;
    /* @internal */
    // If the localized messages json is unset, and if given function use it to set the json
    function maybeSetLocalizedDiagnosticMessages(getMessages) {
        if (!localizedDiagnosticMessages && getMessages) {
            localizedDiagnosticMessages = getMessages();
        }
    }
    ts.maybeSetLocalizedDiagnosticMessages = maybeSetLocalizedDiagnosticMessages;
    function getLocaleSpecificMessage(message) {
        return localizedDiagnosticMessages && localizedDiagnosticMessages[message.key] || message.message;
    }
    ts.getLocaleSpecificMessage = getLocaleSpecificMessage;
    function createDetachedDiagnostic(fileName, start, length, message) {
        assertDiagnosticLocation(/*file*/ undefined, start, length);
        var text = getLocaleSpecificMessage(message);
        if (arguments.length > 4) {
            text = formatStringFromArgs(text, arguments, 4);
        }
        return {
            file: undefined,
            start: start,
            length: length,
            messageText: text,
            category: message.category,
            code: message.code,
            reportsUnnecessary: message.reportsUnnecessary,
            fileName: fileName,
        };
    }
    ts.createDetachedDiagnostic = createDetachedDiagnostic;
    function isDiagnosticWithDetachedLocation(diagnostic) {
        return diagnostic.file === undefined
            && diagnostic.start !== undefined
            && diagnostic.length !== undefined
            && typeof diagnostic.fileName === "string";
    }
    function attachFileToDiagnostic(diagnostic, file) {
        var fileName = file.fileName || "";
        var length = file.text.length;
        ts.Debug.assertEqual(diagnostic.fileName, fileName);
        ts.Debug.assertLessThanOrEqual(diagnostic.start, length);
        ts.Debug.assertLessThanOrEqual(diagnostic.start + diagnostic.length, length);
        var diagnosticWithLocation = {
            file: file,
            start: diagnostic.start,
            length: diagnostic.length,
            messageText: diagnostic.messageText,
            category: diagnostic.category,
            code: diagnostic.code,
            reportsUnnecessary: diagnostic.reportsUnnecessary
        };
        if (diagnostic.relatedInformation) {
            diagnosticWithLocation.relatedInformation = [];
            for (var _i = 0, _a = diagnostic.relatedInformation; _i < _a.length; _i++) {
                var related = _a[_i];
                if (isDiagnosticWithDetachedLocation(related) && related.fileName === fileName) {
                    ts.Debug.assertLessThanOrEqual(related.start, length);
                    ts.Debug.assertLessThanOrEqual(related.start + related.length, length);
                    diagnosticWithLocation.relatedInformation.push(attachFileToDiagnostic(related, file));
                }
                else {
                    diagnosticWithLocation.relatedInformation.push(related);
                }
            }
        }
        return diagnosticWithLocation;
    }
    function attachFileToDiagnostics(diagnostics, file) {
        var diagnosticsWithLocation = [];
        for (var _i = 0, diagnostics_1 = diagnostics; _i < diagnostics_1.length; _i++) {
            var diagnostic = diagnostics_1[_i];
            diagnosticsWithLocation.push(attachFileToDiagnostic(diagnostic, file));
        }
        return diagnosticsWithLocation;
    }
    ts.attachFileToDiagnostics = attachFileToDiagnostics;
    function createFileDiagnostic(file, start, length, message) {
        assertDiagnosticLocation(file, start, length);
        var text = getLocaleSpecificMessage(message);
        if (arguments.length > 4) {
            text = formatStringFromArgs(text, arguments, 4);
        }
        return {
            file: file,
            start: start,
            length: length,
            messageText: text,
            category: message.category,
            code: message.code,
            reportsUnnecessary: message.reportsUnnecessary,
            reportsDeprecated: message.reportsDeprecated
        };
    }
    ts.createFileDiagnostic = createFileDiagnostic;
    function formatMessage(_dummy, message) {
        var text = getLocaleSpecificMessage(message);
        if (arguments.length > 2) {
            text = formatStringFromArgs(text, arguments, 2);
        }
        return text;
    }
    ts.formatMessage = formatMessage;
    function createCompilerDiagnostic(message) {
        var text = getLocaleSpecificMessage(message);
        if (arguments.length > 1) {
            text = formatStringFromArgs(text, arguments, 1);
        }
        return {
            file: undefined,
            start: undefined,
            length: undefined,
            messageText: text,
            category: message.category,
            code: message.code,
            reportsUnnecessary: message.reportsUnnecessary,
            reportsDeprecated: message.reportsDeprecated
        };
    }
    ts.createCompilerDiagnostic = createCompilerDiagnostic;
    function createCompilerDiagnosticFromMessageChain(chain, relatedInformation) {
        return {
            file: undefined,
            start: undefined,
            length: undefined,
            code: chain.code,
            category: chain.category,
            messageText: chain.next ? chain : chain.messageText,
            relatedInformation: relatedInformation
        };
    }
    ts.createCompilerDiagnosticFromMessageChain = createCompilerDiagnosticFromMessageChain;
    function chainDiagnosticMessages(details, message) {
        var text = getLocaleSpecificMessage(message);
        if (arguments.length > 2) {
            text = formatStringFromArgs(text, arguments, 2);
        }
        return {
            messageText: text,
            category: message.category,
            code: message.code,
            next: details === undefined || Array.isArray(details) ? details : [details]
        };
    }
    ts.chainDiagnosticMessages = chainDiagnosticMessages;
    function concatenateDiagnosticMessageChains(headChain, tailChain) {
        var lastChain = headChain;
        while (lastChain.next) {
            lastChain = lastChain.next[0];
        }
        lastChain.next = [tailChain];
    }
    ts.concatenateDiagnosticMessageChains = concatenateDiagnosticMessageChains;
    function getDiagnosticFilePath(diagnostic) {
        return diagnostic.file ? diagnostic.file.path : undefined;
    }
    function compareDiagnostics(d1, d2) {
        return compareDiagnosticsSkipRelatedInformation(d1, d2) ||
            compareRelatedInformation(d1, d2) ||
            0 /* Comparison.EqualTo */;
    }
    ts.compareDiagnostics = compareDiagnostics;
    function compareDiagnosticsSkipRelatedInformation(d1, d2) {
        return ts.compareStringsCaseSensitive(getDiagnosticFilePath(d1), getDiagnosticFilePath(d2)) ||
            ts.compareValues(d1.start, d2.start) ||
            ts.compareValues(d1.length, d2.length) ||
            ts.compareValues(d1.code, d2.code) ||
            compareMessageText(d1.messageText, d2.messageText) ||
            0 /* Comparison.EqualTo */;
    }
    ts.compareDiagnosticsSkipRelatedInformation = compareDiagnosticsSkipRelatedInformation;
    function compareRelatedInformation(d1, d2) {
        if (!d1.relatedInformation && !d2.relatedInformation) {
            return 0 /* Comparison.EqualTo */;
        }
        if (d1.relatedInformation && d2.relatedInformation) {
            return ts.compareValues(d1.relatedInformation.length, d2.relatedInformation.length) || ts.forEach(d1.relatedInformation, function (d1i, index) {
                var d2i = d2.relatedInformation[index];
                return compareDiagnostics(d1i, d2i); // EqualTo is 0, so falsy, and will cause the next item to be compared
            }) || 0 /* Comparison.EqualTo */;
        }
        return d1.relatedInformation ? -1 /* Comparison.LessThan */ : 1 /* Comparison.GreaterThan */;
    }
    function compareMessageText(t1, t2) {
        if (typeof t1 === "string" && typeof t2 === "string") {
            return ts.compareStringsCaseSensitive(t1, t2);
        }
        else if (typeof t1 === "string") {
            return -1 /* Comparison.LessThan */;
        }
        else if (typeof t2 === "string") {
            return 1 /* Comparison.GreaterThan */;
        }
        var res = ts.compareStringsCaseSensitive(t1.messageText, t2.messageText);
        if (res) {
            return res;
        }
        if (!t1.next && !t2.next) {
            return 0 /* Comparison.EqualTo */;
        }
        if (!t1.next) {
            return -1 /* Comparison.LessThan */;
        }
        if (!t2.next) {
            return 1 /* Comparison.GreaterThan */;
        }
        var len = Math.min(t1.next.length, t2.next.length);
        for (var i = 0; i < len; i++) {
            res = compareMessageText(t1.next[i], t2.next[i]);
            if (res) {
                return res;
            }
        }
        if (t1.next.length < t2.next.length) {
            return -1 /* Comparison.LessThan */;
        }
        else if (t1.next.length > t2.next.length) {
            return 1 /* Comparison.GreaterThan */;
        }
        return 0 /* Comparison.EqualTo */;
    }
    function getLanguageVariant(scriptKind) {
        // .tsx and .jsx files are treated as jsx language variant.
        return scriptKind === 4 /* ScriptKind.TSX */ || scriptKind === 2 /* ScriptKind.JSX */ || scriptKind === 1 /* ScriptKind.JS */ || scriptKind === 6 /* ScriptKind.JSON */ ? 1 /* LanguageVariant.JSX */ : 0 /* LanguageVariant.Standard */;
    }
    ts.getLanguageVariant = getLanguageVariant;
    /**
     * This is a somewhat unavoidable full tree walk to locate a JSX tag - `import.meta` requires the same,
     * but we avoid that walk (or parts of it) if at all possible using the `PossiblyContainsImportMeta` node flag.
     * Unfortunately, there's no `NodeFlag` space to do the same for JSX.
     */
    function walkTreeForJSXTags(node) {
        if (!(node.transformFlags & 2 /* TransformFlags.ContainsJsx */))
            return undefined;
        return ts.isJsxOpeningLikeElement(node) || ts.isJsxFragment(node) ? node : ts.forEachChild(node, walkTreeForJSXTags);
    }
    function isFileModuleFromUsingJSXTag(file) {
        // Excludes declaration files - they still require an explicit `export {}` or the like
        // for back compat purposes. (not that declaration files should contain JSX tags!)
        return !file.isDeclarationFile ? walkTreeForJSXTags(file) : undefined;
    }
    /**
     * Note that this requires file.impliedNodeFormat be set already; meaning it must be set very early on
     * in SourceFile construction.
     */
    function isFileForcedToBeModuleByFormat(file) {
        // Excludes declaration files - they still require an explicit `export {}` or the like
        // for back compat purposes. The only non-declaration files _not_ forced to be a module are `.js` files
        // that aren't esm-mode (meaning not in a `type: module` scope).
        return (file.impliedNodeFormat === ts.ModuleKind.ESNext || (ts.fileExtensionIsOneOf(file.fileName, [".cjs" /* Extension.Cjs */, ".cts" /* Extension.Cts */, ".mjs" /* Extension.Mjs */, ".mts" /* Extension.Mts */]))) && !file.isDeclarationFile ? true : undefined;
    }
    function getSetExternalModuleIndicator(options) {
        // TODO: Should this callback be cached?
        switch (getEmitModuleDetectionKind(options)) {
            case ts.ModuleDetectionKind.Force:
                // All non-declaration files are modules, declaration files still do the usual isFileProbablyExternalModule
                return function (file) {
                    file.externalModuleIndicator = ts.isFileProbablyExternalModule(file) || !file.isDeclarationFile || undefined;
                };
            case ts.ModuleDetectionKind.Legacy:
                // Files are modules if they have imports, exports, or import.meta
                return function (file) {
                    file.externalModuleIndicator = ts.isFileProbablyExternalModule(file);
                };
            case ts.ModuleDetectionKind.Auto:
                // If module is nodenext or node16, all esm format files are modules
                // If jsx is react-jsx or react-jsxdev then jsx tags force module-ness
                // otherwise, the presence of import or export statments (or import.meta) implies module-ness
                var checks = [ts.isFileProbablyExternalModule];
                if (options.jsx === 4 /* JsxEmit.ReactJSX */ || options.jsx === 5 /* JsxEmit.ReactJSXDev */) {
                    checks.push(isFileModuleFromUsingJSXTag);
                }
                checks.push(isFileForcedToBeModuleByFormat);
                var combined_1 = ts.or.apply(void 0, checks);
                var callback = function (file) { return void (file.externalModuleIndicator = combined_1(file)); };
                return callback;
        }
    }
    ts.getSetExternalModuleIndicator = getSetExternalModuleIndicator;
    function getEmitScriptTarget(compilerOptions) {
        return compilerOptions.target ||
            (compilerOptions.module === ts.ModuleKind.Node16 && 9 /* ScriptTarget.ES2022 */) ||
            (compilerOptions.module === ts.ModuleKind.NodeNext && 99 /* ScriptTarget.ESNext */) ||
            0 /* ScriptTarget.ES3 */;
    }
    ts.getEmitScriptTarget = getEmitScriptTarget;
    function getEmitModuleKind(compilerOptions) {
        return typeof compilerOptions.module === "number" ?
            compilerOptions.module :
            getEmitScriptTarget(compilerOptions) >= 2 /* ScriptTarget.ES2015 */ ? ts.ModuleKind.ES2015 : ts.ModuleKind.CommonJS;
    }
    ts.getEmitModuleKind = getEmitModuleKind;
    function getEmitModuleResolutionKind(compilerOptions) {
        var moduleResolution = compilerOptions.moduleResolution;
        if (moduleResolution === undefined) {
            switch (getEmitModuleKind(compilerOptions)) {
                case ts.ModuleKind.CommonJS:
                    moduleResolution = ts.ModuleResolutionKind.NodeJs;
                    break;
                case ts.ModuleKind.Node16:
                    moduleResolution = ts.ModuleResolutionKind.Node16;
                    break;
                case ts.ModuleKind.NodeNext:
                    moduleResolution = ts.ModuleResolutionKind.NodeNext;
                    break;
                default:
                    moduleResolution = ts.ModuleResolutionKind.Classic;
                    break;
            }
        }
        return moduleResolution;
    }
    ts.getEmitModuleResolutionKind = getEmitModuleResolutionKind;
    function getEmitModuleDetectionKind(options) {
        return options.moduleDetection ||
            (getEmitModuleKind(options) === ts.ModuleKind.Node16 || getEmitModuleKind(options) === ts.ModuleKind.NodeNext ? ts.ModuleDetectionKind.Force : ts.ModuleDetectionKind.Auto);
    }
    ts.getEmitModuleDetectionKind = getEmitModuleDetectionKind;
    function hasJsonModuleEmitEnabled(options) {
        switch (getEmitModuleKind(options)) {
            case ts.ModuleKind.CommonJS:
            case ts.ModuleKind.AMD:
            case ts.ModuleKind.ES2015:
            case ts.ModuleKind.ES2020:
            case ts.ModuleKind.ES2022:
            case ts.ModuleKind.ESNext:
            case ts.ModuleKind.Node16:
            case ts.ModuleKind.NodeNext:
                return true;
            default:
                return false;
        }
    }
    ts.hasJsonModuleEmitEnabled = hasJsonModuleEmitEnabled;
    function unreachableCodeIsError(options) {
        return options.allowUnreachableCode === false;
    }
    ts.unreachableCodeIsError = unreachableCodeIsError;
    function unusedLabelIsError(options) {
        return options.allowUnusedLabels === false;
    }
    ts.unusedLabelIsError = unusedLabelIsError;
    function getAreDeclarationMapsEnabled(options) {
        return !!(getEmitDeclarations(options) && options.declarationMap);
    }
    ts.getAreDeclarationMapsEnabled = getAreDeclarationMapsEnabled;
    function getESModuleInterop(compilerOptions) {
        if (compilerOptions.esModuleInterop !== undefined) {
            return compilerOptions.esModuleInterop;
        }
        switch (getEmitModuleKind(compilerOptions)) {
            case ts.ModuleKind.Node16:
            case ts.ModuleKind.NodeNext:
                return true;
        }
        return undefined;
    }
    ts.getESModuleInterop = getESModuleInterop;
    function getAllowSyntheticDefaultImports(compilerOptions) {
        var moduleKind = getEmitModuleKind(compilerOptions);
        return compilerOptions.allowSyntheticDefaultImports !== undefined
            ? compilerOptions.allowSyntheticDefaultImports
            : getESModuleInterop(compilerOptions) ||
                moduleKind === ts.ModuleKind.System;
    }
    ts.getAllowSyntheticDefaultImports = getAllowSyntheticDefaultImports;
    function getEmitDeclarations(compilerOptions) {
        return !!(compilerOptions.declaration || compilerOptions.composite);
    }
    ts.getEmitDeclarations = getEmitDeclarations;
    function shouldPreserveConstEnums(compilerOptions) {
        return !!(compilerOptions.preserveConstEnums || compilerOptions.isolatedModules);
    }
    ts.shouldPreserveConstEnums = shouldPreserveConstEnums;
    function isIncrementalCompilation(options) {
        return !!(options.incremental || options.composite);
    }
    ts.isIncrementalCompilation = isIncrementalCompilation;
    function getStrictOptionValue(compilerOptions, flag) {
        return compilerOptions[flag] === undefined ? !!compilerOptions.strict : !!compilerOptions[flag];
    }
    ts.getStrictOptionValue = getStrictOptionValue;
    function getAllowJSCompilerOption(compilerOptions) {
        return compilerOptions.allowJs === undefined ? !!compilerOptions.checkJs : compilerOptions.allowJs;
    }
    ts.getAllowJSCompilerOption = getAllowJSCompilerOption;
    function getUseDefineForClassFields(compilerOptions) {
        return compilerOptions.useDefineForClassFields === undefined ? getEmitScriptTarget(compilerOptions) >= 9 /* ScriptTarget.ES2022 */ : compilerOptions.useDefineForClassFields;
    }
    ts.getUseDefineForClassFields = getUseDefineForClassFields;
    function compilerOptionsAffectSemanticDiagnostics(newOptions, oldOptions) {
        return optionsHaveChanges(oldOptions, newOptions, ts.semanticDiagnosticsOptionDeclarations);
    }
    ts.compilerOptionsAffectSemanticDiagnostics = compilerOptionsAffectSemanticDiagnostics;
    function compilerOptionsAffectEmit(newOptions, oldOptions) {
        return optionsHaveChanges(oldOptions, newOptions, ts.affectsEmitOptionDeclarations);
    }
    ts.compilerOptionsAffectEmit = compilerOptionsAffectEmit;
    function compilerOptionsAffectDeclarationPath(newOptions, oldOptions) {
        return optionsHaveChanges(oldOptions, newOptions, ts.affectsDeclarationPathOptionDeclarations);
    }
    ts.compilerOptionsAffectDeclarationPath = compilerOptionsAffectDeclarationPath;
    function getCompilerOptionValue(options, option) {
        return option.strictFlag ? getStrictOptionValue(options, option.name) : options[option.name];
    }
    ts.getCompilerOptionValue = getCompilerOptionValue;
    function getJSXTransformEnabled(options) {
        var jsx = options.jsx;
        return jsx === 2 /* JsxEmit.React */ || jsx === 4 /* JsxEmit.ReactJSX */ || jsx === 5 /* JsxEmit.ReactJSXDev */;
    }
    ts.getJSXTransformEnabled = getJSXTransformEnabled;
    function getJSXImplicitImportBase(compilerOptions, file) {
        var jsxImportSourcePragmas = file === null || file === void 0 ? void 0 : file.pragmas.get("jsximportsource");
        var jsxImportSourcePragma = ts.isArray(jsxImportSourcePragmas) ? jsxImportSourcePragmas[jsxImportSourcePragmas.length - 1] : jsxImportSourcePragmas;
        return compilerOptions.jsx === 4 /* JsxEmit.ReactJSX */ ||
            compilerOptions.jsx === 5 /* JsxEmit.ReactJSXDev */ ||
            compilerOptions.jsxImportSource ||
            jsxImportSourcePragma ?
            (jsxImportSourcePragma === null || jsxImportSourcePragma === void 0 ? void 0 : jsxImportSourcePragma.arguments.factory) || compilerOptions.jsxImportSource || "react" :
            undefined;
    }
    ts.getJSXImplicitImportBase = getJSXImplicitImportBase;
    function getJSXRuntimeImport(base, options) {
        return base ? "".concat(base, "/").concat(options.jsx === 5 /* JsxEmit.ReactJSXDev */ ? "jsx-dev-runtime" : "jsx-runtime") : undefined;
    }
    ts.getJSXRuntimeImport = getJSXRuntimeImport;
    function hasZeroOrOneAsteriskCharacter(str) {
        var seenAsterisk = false;
        for (var i = 0; i < str.length; i++) {
            if (str.charCodeAt(i) === 42 /* CharacterCodes.asterisk */) {
                if (!seenAsterisk) {
                    seenAsterisk = true;
                }
                else {
                    // have already seen asterisk
                    return false;
                }
            }
        }
        return true;
    }
    ts.hasZeroOrOneAsteriskCharacter = hasZeroOrOneAsteriskCharacter;
    function createSymlinkCache(cwd, getCanonicalFileName) {
        var symlinkedDirectories;
        var symlinkedDirectoriesByRealpath;
        var symlinkedFiles;
        var hasProcessedResolutions = false;
        return {
            getSymlinkedFiles: function () { return symlinkedFiles; },
            getSymlinkedDirectories: function () { return symlinkedDirectories; },
            getSymlinkedDirectoriesByRealpath: function () { return symlinkedDirectoriesByRealpath; },
            setSymlinkedFile: function (path, real) { return (symlinkedFiles || (symlinkedFiles = new ts.Map())).set(path, real); },
            setSymlinkedDirectory: function (symlink, real) {
                // Large, interconnected dependency graphs in pnpm will have a huge number of symlinks
                // where both the realpath and the symlink path are inside node_modules/.pnpm. Since
                // this path is never a candidate for a module specifier, we can ignore it entirely.
                var symlinkPath = ts.toPath(symlink, cwd, getCanonicalFileName);
                if (!containsIgnoredPath(symlinkPath)) {
                    symlinkPath = ts.ensureTrailingDirectorySeparator(symlinkPath);
                    if (real !== false && !(symlinkedDirectories === null || symlinkedDirectories === void 0 ? void 0 : symlinkedDirectories.has(symlinkPath))) {
                        (symlinkedDirectoriesByRealpath || (symlinkedDirectoriesByRealpath = ts.createMultiMap())).add(ts.ensureTrailingDirectorySeparator(real.realPath), symlink);
                    }
                    (symlinkedDirectories || (symlinkedDirectories = new ts.Map())).set(symlinkPath, real);
                }
            },
            setSymlinksFromResolutions: function (files, typeReferenceDirectives) {
                var _this = this;
                var _a;
                ts.Debug.assert(!hasProcessedResolutions);
                hasProcessedResolutions = true;
                for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
                    var file = files_1[_i];
                    (_a = file.resolvedModules) === null || _a === void 0 ? void 0 : _a.forEach(function (resolution) { return processResolution(_this, resolution); });
                }
                typeReferenceDirectives === null || typeReferenceDirectives === void 0 ? void 0 : typeReferenceDirectives.forEach(function (resolution) { return processResolution(_this, resolution); });
            },
            hasProcessedResolutions: function () { return hasProcessedResolutions; },
        };
        function processResolution(cache, resolution) {
            if (!resolution || !resolution.originalPath || !resolution.resolvedFileName)
                return;
            var resolvedFileName = resolution.resolvedFileName, originalPath = resolution.originalPath;
            cache.setSymlinkedFile(ts.toPath(originalPath, cwd, getCanonicalFileName), resolvedFileName);
            var _a = guessDirectorySymlink(resolvedFileName, originalPath, cwd, getCanonicalFileName) || ts.emptyArray, commonResolved = _a[0], commonOriginal = _a[1];
            if (commonResolved && commonOriginal) {
                cache.setSymlinkedDirectory(commonOriginal, { real: commonResolved, realPath: ts.toPath(commonResolved, cwd, getCanonicalFileName) });
            }
        }
    }
    ts.createSymlinkCache = createSymlinkCache;
    function guessDirectorySymlink(a, b, cwd, getCanonicalFileName) {
        var aParts = ts.getPathComponents(ts.getNormalizedAbsolutePath(a, cwd));
        var bParts = ts.getPathComponents(ts.getNormalizedAbsolutePath(b, cwd));
        var isDirectory = false;
        while (aParts.length >= 2 && bParts.length >= 2 &&
            !isNodeModulesOrScopedPackageDirectory(aParts[aParts.length - 2], getCanonicalFileName) &&
            !isNodeModulesOrScopedPackageDirectory(bParts[bParts.length - 2], getCanonicalFileName) &&
            getCanonicalFileName(aParts[aParts.length - 1]) === getCanonicalFileName(bParts[bParts.length - 1])) {
            aParts.pop();
            bParts.pop();
            isDirectory = true;
        }
        return isDirectory ? [ts.getPathFromPathComponents(aParts), ts.getPathFromPathComponents(bParts)] : undefined;
    }
    // KLUDGE: Don't assume one 'node_modules' links to another. More likely a single directory inside the node_modules is the symlink.
    // ALso, don't assume that an `@foo` directory is linked. More likely the contents of that are linked.
    function isNodeModulesOrScopedPackageDirectory(s, getCanonicalFileName) {
        return s !== undefined && (getCanonicalFileName(s) === "node_modules" || ts.startsWith(s, "@"));
    }
    function stripLeadingDirectorySeparator(s) {
        return ts.isAnyDirectorySeparator(s.charCodeAt(0)) ? s.slice(1) : undefined;
    }
    function tryRemoveDirectoryPrefix(path, dirPath, getCanonicalFileName) {
        var withoutPrefix = ts.tryRemovePrefix(path, dirPath, getCanonicalFileName);
        return withoutPrefix === undefined ? undefined : stripLeadingDirectorySeparator(withoutPrefix);
    }
    ts.tryRemoveDirectoryPrefix = tryRemoveDirectoryPrefix;
    // Reserved characters, forces escaping of any non-word (or digit), non-whitespace character.
    // It may be inefficient (we could just match (/[-[\]{}()*+?.,\\^$|#\s]/g), but this is future
    // proof.
    var reservedCharacterPattern = /[^\w\s\/]/g;
    function regExpEscape(text) {
        return text.replace(reservedCharacterPattern, escapeRegExpCharacter);
    }
    ts.regExpEscape = regExpEscape;
    function escapeRegExpCharacter(match) {
        return "\\" + match;
    }
    var wildcardCharCodes = [42 /* CharacterCodes.asterisk */, 63 /* CharacterCodes.question */];
    ts.commonPackageFolders = ["node_modules", "bower_components", "jspm_packages"];
    var implicitExcludePathRegexPattern = "(?!(".concat(ts.commonPackageFolders.join("|"), ")(/|$))");
    var filesMatcher = {
        /**
         * Matches any single directory segment unless it is the last segment and a .min.js file
         * Breakdown:
         *  [^./]                   # matches everything up to the first . character (excluding directory separators)
         *  (\\.(?!min\\.js$))?     # matches . characters but not if they are part of the .min.js file extension
         */
        singleAsteriskRegexFragment: "([^./]|(\\.(?!min\\.js$))?)*",
        /**
         * Regex for the ** wildcard. Matches any number of subdirectories. When used for including
         * files or directories, does not match subdirectories that start with a . character
         */
        doubleAsteriskRegexFragment: "(/".concat(implicitExcludePathRegexPattern, "[^/.][^/]*)*?"),
        replaceWildcardCharacter: function (match) { return replaceWildcardCharacter(match, filesMatcher.singleAsteriskRegexFragment); }
    };
    var directoriesMatcher = {
        singleAsteriskRegexFragment: "[^/]*",
        /**
         * Regex for the ** wildcard. Matches any number of subdirectories. When used for including
         * files or directories, does not match subdirectories that start with a . character
         */
        doubleAsteriskRegexFragment: "(/".concat(implicitExcludePathRegexPattern, "[^/.][^/]*)*?"),
        replaceWildcardCharacter: function (match) { return replaceWildcardCharacter(match, directoriesMatcher.singleAsteriskRegexFragment); }
    };
    var excludeMatcher = {
        singleAsteriskRegexFragment: "[^/]*",
        doubleAsteriskRegexFragment: "(/.+?)?",
        replaceWildcardCharacter: function (match) { return replaceWildcardCharacter(match, excludeMatcher.singleAsteriskRegexFragment); }
    };
    var wildcardMatchers = {
        files: filesMatcher,
        directories: directoriesMatcher,
        exclude: excludeMatcher
    };
    function getRegularExpressionForWildcard(specs, basePath, usage) {
        var patterns = getRegularExpressionsForWildcards(specs, basePath, usage);
        if (!patterns || !patterns.length) {
            return undefined;
        }
        var pattern = patterns.map(function (pattern) { return "(".concat(pattern, ")"); }).join("|");
        // If excluding, match "foo/bar/baz...", but if including, only allow "foo".
        var terminator = usage === "exclude" ? "($|/)" : "$";
        return "^(".concat(pattern, ")").concat(terminator);
    }
    ts.getRegularExpressionForWildcard = getRegularExpressionForWildcard;
    function getRegularExpressionsForWildcards(specs, basePath, usage) {
        if (specs === undefined || specs.length === 0) {
            return undefined;
        }
        return ts.flatMap(specs, function (spec) {
            return spec && getSubPatternFromSpec(spec, basePath, usage, wildcardMatchers[usage]);
        });
    }
    ts.getRegularExpressionsForWildcards = getRegularExpressionsForWildcards;
    /**
     * An "includes" path "foo" is implicitly a glob "foo/** /*" (without the space) if its last component has no extension,
     * and does not contain any glob characters itself.
     */
    function isImplicitGlob(lastPathComponent) {
        return !/[.*?]/.test(lastPathComponent);
    }
    ts.isImplicitGlob = isImplicitGlob;
    function getPatternFromSpec(spec, basePath, usage) {
        var pattern = spec && getSubPatternFromSpec(spec, basePath, usage, wildcardMatchers[usage]);
        return pattern && "^(".concat(pattern, ")").concat(usage === "exclude" ? "($|/)" : "$");
    }
    ts.getPatternFromSpec = getPatternFromSpec;
    function getSubPatternFromSpec(spec, basePath, usage, _a) {
        var singleAsteriskRegexFragment = _a.singleAsteriskRegexFragment, doubleAsteriskRegexFragment = _a.doubleAsteriskRegexFragment, replaceWildcardCharacter = _a.replaceWildcardCharacter;
        var subpattern = "";
        var hasWrittenComponent = false;
        var components = ts.getNormalizedPathComponents(spec, basePath);
        var lastComponent = ts.last(components);
        if (usage !== "exclude" && lastComponent === "**") {
            return undefined;
        }
        // getNormalizedPathComponents includes the separator for the root component.
        // We need to remove to create our regex correctly.
        components[0] = ts.removeTrailingDirectorySeparator(components[0]);
        if (isImplicitGlob(lastComponent)) {
            components.push("**", "*");
        }
        var optionalCount = 0;
        for (var _i = 0, components_1 = components; _i < components_1.length; _i++) {
            var component = components_1[_i];
            if (component === "**") {
                subpattern += doubleAsteriskRegexFragment;
            }
            else {
                if (usage === "directories") {
                    subpattern += "(";
                    optionalCount++;
                }
                if (hasWrittenComponent) {
                    subpattern += ts.directorySeparator;
                }
                if (usage !== "exclude") {
                    var componentPattern = "";
                    // The * and ? wildcards should not match directories or files that start with . if they
                    // appear first in a component. Dotted directories and files can be included explicitly
                    // like so: **/.*/.*
                    if (component.charCodeAt(0) === 42 /* CharacterCodes.asterisk */) {
                        componentPattern += "([^./]" + singleAsteriskRegexFragment + ")?";
                        component = component.substr(1);
                    }
                    else if (component.charCodeAt(0) === 63 /* CharacterCodes.question */) {
                        componentPattern += "[^./]";
                        component = component.substr(1);
                    }
                    componentPattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter);
                    // Patterns should not include subfolders like node_modules unless they are
                    // explicitly included as part of the path.
                    //
                    // As an optimization, if the component pattern is the same as the component,
                    // then there definitely were no wildcard characters and we do not need to
                    // add the exclusion pattern.
                    if (componentPattern !== component) {
                        subpattern += implicitExcludePathRegexPattern;
                    }
                    subpattern += componentPattern;
                }
                else {
                    subpattern += component.replace(reservedCharacterPattern, replaceWildcardCharacter);
                }
            }
            hasWrittenComponent = true;
        }
        while (optionalCount > 0) {
            subpattern += ")?";
            optionalCount--;
        }
        return subpattern;
    }
    function replaceWildcardCharacter(match, singleAsteriskRegexFragment) {
        return match === "*" ? singleAsteriskRegexFragment : match === "?" ? "[^/]" : "\\" + match;
    }
    /** @param path directory of the tsconfig.json */
    function getFileMatcherPatterns(path, excludes, includes, useCaseSensitiveFileNames, currentDirectory) {
        path = ts.normalizePath(path);
        currentDirectory = ts.normalizePath(currentDirectory);
        var absolutePath = ts.combinePaths(currentDirectory, path);
        return {
            includeFilePatterns: ts.map(getRegularExpressionsForWildcards(includes, absolutePath, "files"), function (pattern) { return "^".concat(pattern, "$"); }),
            includeFilePattern: getRegularExpressionForWildcard(includes, absolutePath, "files"),
            includeDirectoryPattern: getRegularExpressionForWildcard(includes, absolutePath, "directories"),
            excludePattern: getRegularExpressionForWildcard(excludes, absolutePath, "exclude"),
            basePaths: getBasePaths(path, includes, useCaseSensitiveFileNames)
        };
    }
    ts.getFileMatcherPatterns = getFileMatcherPatterns;
    function getRegexFromPattern(pattern, useCaseSensitiveFileNames) {
        return new RegExp(pattern, useCaseSensitiveFileNames ? "" : "i");
    }
    ts.getRegexFromPattern = getRegexFromPattern;
    /** @param path directory of the tsconfig.json */
    function matchFiles(path, extensions, excludes, includes, useCaseSensitiveFileNames, currentDirectory, depth, getFileSystemEntries, realpath) {
        path = ts.normalizePath(path);
        currentDirectory = ts.normalizePath(currentDirectory);
        var patterns = getFileMatcherPatterns(path, excludes, includes, useCaseSensitiveFileNames, currentDirectory);
        var includeFileRegexes = patterns.includeFilePatterns && patterns.includeFilePatterns.map(function (pattern) { return getRegexFromPattern(pattern, useCaseSensitiveFileNames); });
        var includeDirectoryRegex = patterns.includeDirectoryPattern && getRegexFromPattern(patterns.includeDirectoryPattern, useCaseSensitiveFileNames);
        var excludeRegex = patterns.excludePattern && getRegexFromPattern(patterns.excludePattern, useCaseSensitiveFileNames);
        // Associate an array of results with each include regex. This keeps results in order of the "include" order.
        // If there are no "includes", then just put everything in results[0].
        var results = includeFileRegexes ? includeFileRegexes.map(function () { return []; }) : [[]];
        var visited = new ts.Map();
        var toCanonical = ts.createGetCanonicalFileName(useCaseSensitiveFileNames);
        for (var _i = 0, _a = patterns.basePaths; _i < _a.length; _i++) {
            var basePath = _a[_i];
            visitDirectory(basePath, ts.combinePaths(currentDirectory, basePath), depth);
        }
        return ts.flatten(results);
        function visitDirectory(path, absolutePath, depth) {
            var canonicalPath = toCanonical(realpath(absolutePath));
            if (visited.has(canonicalPath))
                return;
            visited.set(canonicalPath, true);
            var _a = getFileSystemEntries(path), files = _a.files, directories = _a.directories;
            var _loop_1 = function (current) {
                var name = ts.combinePaths(path, current);
                var absoluteName = ts.combinePaths(absolutePath, current);
                if (extensions && !ts.fileExtensionIsOneOf(name, extensions))
                    return "continue";
                if (excludeRegex && excludeRegex.test(absoluteName))
                    return "continue";
                if (!includeFileRegexes) {
                    results[0].push(name);
                }
                else {
                    var includeIndex = ts.findIndex(includeFileRegexes, function (re) { return re.test(absoluteName); });
                    if (includeIndex !== -1) {
                        results[includeIndex].push(name);
                    }
                }
            };
            for (var _i = 0, _b = ts.sort(files, ts.compareStringsCaseSensitive); _i < _b.length; _i++) {
                var current = _b[_i];
                _loop_1(current);
            }
            if (depth !== undefined) {
                depth--;
                if (depth === 0) {
                    return;
                }
            }
            for (var _c = 0, _d = ts.sort(directories, ts.compareStringsCaseSensitive); _c < _d.length; _c++) {
                var current = _d[_c];
                var name = ts.combinePaths(path, current);
                var absoluteName = ts.combinePaths(absolutePath, current);
                if ((!includeDirectoryRegex || includeDirectoryRegex.test(absoluteName)) &&
                    (!excludeRegex || !excludeRegex.test(absoluteName))) {
                    visitDirectory(name, absoluteName, depth);
                }
            }
        }
    }
    ts.matchFiles = matchFiles;
    /**
     * Computes the unique non-wildcard base paths amongst the provided include patterns.
     */
    function getBasePaths(path, includes, useCaseSensitiveFileNames) {
        // Storage for our results in the form of literal paths (e.g. the paths as written by the user).
        var basePaths = [path];
        if (includes) {
            // Storage for literal base paths amongst the include patterns.
            var includeBasePaths = [];
            for (var _i = 0, includes_1 = includes; _i < includes_1.length; _i++) {
                var include = includes_1[_i];
                // We also need to check the relative paths by converting them to absolute and normalizing
                // in case they escape the base path (e.g "..\somedirectory")
                var absolute = ts.isRootedDiskPath(include) ? include : ts.normalizePath(ts.combinePaths(path, include));
                // Append the literal and canonical candidate base paths.
                includeBasePaths.push(getIncludeBasePath(absolute));
            }
            // Sort the offsets array using either the literal or canonical path representations.
            includeBasePaths.sort(ts.getStringComparer(!useCaseSensitiveFileNames));
            var _loop_2 = function (includeBasePath) {
                if (ts.every(basePaths, function (basePath) { return !ts.containsPath(basePath, includeBasePath, path, !useCaseSensitiveFileNames); })) {
                    basePaths.push(includeBasePath);
                }
            };
            // Iterate over each include base path and include unique base paths that are not a
            // subpath of an existing base path
            for (var _a = 0, includeBasePaths_1 = includeBasePaths; _a < includeBasePaths_1.length; _a++) {
                var includeBasePath = includeBasePaths_1[_a];
                _loop_2(includeBasePath);
            }
        }
        return basePaths;
    }
    function getIncludeBasePath(absolute) {
        var wildcardOffset = ts.indexOfAnyCharCode(absolute, wildcardCharCodes);
        if (wildcardOffset < 0) {
            // No "*" or "?" in the path
            return !ts.hasExtension(absolute)
                ? absolute
                : ts.removeTrailingDirectorySeparator(ts.getDirectoryPath(absolute));
        }
        return absolute.substring(0, absolute.lastIndexOf(ts.directorySeparator, wildcardOffset));
    }
    function ensureScriptKind(fileName, scriptKind) {
        // Using scriptKind as a condition handles both:
        // - 'scriptKind' is unspecified and thus it is `undefined`
        // - 'scriptKind' is set and it is `Unknown` (0)
        // If the 'scriptKind' is 'undefined' or 'Unknown' then we attempt
        // to get the ScriptKind from the file name. If it cannot be resolved
        // from the file name then the default 'TS' script kind is returned.
        return scriptKind || getScriptKindFromFileName(fileName) || 3 /* ScriptKind.TS */;
    }
    ts.ensureScriptKind = ensureScriptKind;
    function getScriptKindFromFileName(fileName) {
        var ext = fileName.substr(fileName.lastIndexOf("."));
        switch (ext.toLowerCase()) {
            case ".js" /* Extension.Js */:
            case ".cjs" /* Extension.Cjs */:
            case ".mjs" /* Extension.Mjs */:
                return 1 /* ScriptKind.JS */;
            case ".jsx" /* Extension.Jsx */:
                return 2 /* ScriptKind.JSX */;
            case ".ts" /* Extension.Ts */:
            case ".cts" /* Extension.Cts */:
            case ".mts" /* Extension.Mts */:
                return 3 /* ScriptKind.TS */;
            case ".tsx" /* Extension.Tsx */:
                return 4 /* ScriptKind.TSX */;
            case ".json" /* Extension.Json */:
                return 6 /* ScriptKind.JSON */;
            default:
                return 0 /* ScriptKind.Unknown */;
        }
    }
    ts.getScriptKindFromFileName = getScriptKindFromFileName;
    /**
     *  Groups of supported extensions in order of file resolution precedence. (eg, TS > TSX > DTS and seperately, CTS > DCTS)
     */
    ts.supportedTSExtensions = [[".ts" /* Extension.Ts */, ".tsx" /* Extension.Tsx */, ".d.ts" /* Extension.Dts */], [".cts" /* Extension.Cts */, ".d.cts" /* Extension.Dcts */], [".mts" /* Extension.Mts */, ".d.mts" /* Extension.Dmts */]];
    ts.supportedTSExtensionsFlat = ts.flatten(ts.supportedTSExtensions);
    var supportedTSExtensionsWithJson = __spreadArray(__spreadArray([], ts.supportedTSExtensions, true), [[".json" /* Extension.Json */]], false);
    /** Must have ".d.ts" first because if ".ts" goes first, that will be detected as the extension instead of ".d.ts". */
    var supportedTSExtensionsForExtractExtension = [".d.ts" /* Extension.Dts */, ".d.cts" /* Extension.Dcts */, ".d.mts" /* Extension.Dmts */, ".cts" /* Extension.Cts */, ".mts" /* Extension.Mts */, ".ts" /* Extension.Ts */, ".tsx" /* Extension.Tsx */, ".cts" /* Extension.Cts */, ".mts" /* Extension.Mts */];
    ts.supportedJSExtensions = [[".js" /* Extension.Js */, ".jsx" /* Extension.Jsx */], [".mjs" /* Extension.Mjs */], [".cjs" /* Extension.Cjs */]];
    ts.supportedJSExtensionsFlat = ts.flatten(ts.supportedJSExtensions);
    var allSupportedExtensions = [[".ts" /* Extension.Ts */, ".tsx" /* Extension.Tsx */, ".d.ts" /* Extension.Dts */, ".js" /* Extension.Js */, ".jsx" /* Extension.Jsx */], [".cts" /* Extension.Cts */, ".d.cts" /* Extension.Dcts */, ".cjs" /* Extension.Cjs */], [".mts" /* Extension.Mts */, ".d.mts" /* Extension.Dmts */, ".mjs" /* Extension.Mjs */]];
    var allSupportedExtensionsWithJson = __spreadArray(__spreadArray([], allSupportedExtensions, true), [[".json" /* Extension.Json */]], false);
    ts.supportedDeclarationExtensions = [".d.ts" /* Extension.Dts */, ".d.cts" /* Extension.Dcts */, ".d.mts" /* Extension.Dmts */];
    function getSupportedExtensions(options, extraFileExtensions) {
        var needJsExtensions = options && getAllowJSCompilerOption(options);
        if (!extraFileExtensions || extraFileExtensions.length === 0) {
            return needJsExtensions ? allSupportedExtensions : ts.supportedTSExtensions;
        }
        var builtins = needJsExtensions ? allSupportedExtensions : ts.supportedTSExtensions;
        var flatBuiltins = ts.flatten(builtins);
        var extensions = __spreadArray(__spreadArray([], builtins, true), ts.mapDefined(extraFileExtensions, function (x) { return x.scriptKind === 7 /* ScriptKind.Deferred */ || needJsExtensions && isJSLike(x.scriptKind) && flatBuiltins.indexOf(x.extension) === -1 ? [x.extension] : undefined; }), true);
        return extensions;
    }
    ts.getSupportedExtensions = getSupportedExtensions;
    function getSupportedExtensionsWithJsonIfResolveJsonModule(options, supportedExtensions) {
        if (!options || !options.resolveJsonModule)
            return supportedExtensions;
        if (supportedExtensions === allSupportedExtensions)
            return allSupportedExtensionsWithJson;
        if (supportedExtensions === ts.supportedTSExtensions)
            return supportedTSExtensionsWithJson;
        return __spreadArray(__spreadArray([], supportedExtensions, true), [[".json" /* Extension.Json */]], false);
    }
    ts.getSupportedExtensionsWithJsonIfResolveJsonModule = getSupportedExtensionsWithJsonIfResolveJsonModule;
    function isJSLike(scriptKind) {
        return scriptKind === 1 /* ScriptKind.JS */ || scriptKind === 2 /* ScriptKind.JSX */;
    }
    function hasJSFileExtension(fileName) {
        return ts.some(ts.supportedJSExtensionsFlat, function (extension) { return ts.fileExtensionIs(fileName, extension); });
    }
    ts.hasJSFileExtension = hasJSFileExtension;
    function hasTSFileExtension(fileName) {
        return ts.some(ts.supportedTSExtensionsFlat, function (extension) { return ts.fileExtensionIs(fileName, extension); });
    }
    ts.hasTSFileExtension = hasTSFileExtension;
    function isSupportedSourceFileName(fileName, compilerOptions, extraFileExtensions) {
        if (!fileName)
            return false;
        var supportedExtensions = getSupportedExtensions(compilerOptions, extraFileExtensions);
        for (var _i = 0, _a = ts.flatten(getSupportedExtensionsWithJsonIfResolveJsonModule(compilerOptions, supportedExtensions)); _i < _a.length; _i++) {
            var extension = _a[_i];
            if (ts.fileExtensionIs(fileName, extension)) {
                return true;
            }
        }
        return false;
    }
    ts.isSupportedSourceFileName = isSupportedSourceFileName;
    function numberOfDirectorySeparators(str) {
        var match = str.match(/\//g);
        return match ? match.length : 0;
    }
    function compareNumberOfDirectorySeparators(path1, path2) {
        return ts.compareValues(numberOfDirectorySeparators(path1), numberOfDirectorySeparators(path2));
    }
    ts.compareNumberOfDirectorySeparators = compareNumberOfDirectorySeparators;
    var extensionsToRemove = [".d.ts" /* Extension.Dts */, ".d.mts" /* Extension.Dmts */, ".d.cts" /* Extension.Dcts */, ".mjs" /* Extension.Mjs */, ".mts" /* Extension.Mts */, ".cjs" /* Extension.Cjs */, ".cts" /* Extension.Cts */, ".ts" /* Extension.Ts */, ".js" /* Extension.Js */, ".tsx" /* Extension.Tsx */, ".jsx" /* Extension.Jsx */, ".json" /* Extension.Json */];
    function removeFileExtension(path) {
        for (var _i = 0, extensionsToRemove_1 = extensionsToRemove; _i < extensionsToRemove_1.length; _i++) {
            var ext = extensionsToRemove_1[_i];
            var extensionless = tryRemoveExtension(path, ext);
            if (extensionless !== undefined) {
                return extensionless;
            }
        }
        return path;
    }
    ts.removeFileExtension = removeFileExtension;
    function tryRemoveExtension(path, extension) {
        return ts.fileExtensionIs(path, extension) ? removeExtension(path, extension) : undefined;
    }
    ts.tryRemoveExtension = tryRemoveExtension;
    function removeExtension(path, extension) {
        return path.substring(0, path.length - extension.length);
    }
    ts.removeExtension = removeExtension;
    function changeExtension(path, newExtension) {
        return ts.changeAnyExtension(path, newExtension, extensionsToRemove, /*ignoreCase*/ false);
    }
    ts.changeExtension = changeExtension;
    /**
     * Returns the input if there are no stars, a pattern if there is exactly one,
     * and undefined if there are more.
     */
    function tryParsePattern(pattern) {
        var indexOfStar = pattern.indexOf("*");
        if (indexOfStar === -1) {
            return pattern;
        }
        return pattern.indexOf("*", indexOfStar + 1) !== -1
            ? undefined
            : {
                prefix: pattern.substr(0, indexOfStar),
                suffix: pattern.substr(indexOfStar + 1)
            };
    }
    ts.tryParsePattern = tryParsePattern;
    function tryParsePatterns(paths) {
        return ts.mapDefined(ts.getOwnKeys(paths), function (path) { return tryParsePattern(path); });
    }
    ts.tryParsePatterns = tryParsePatterns;
    function positionIsSynthesized(pos) {
        // This is a fast way of testing the following conditions:
        //  pos === undefined || pos === null || isNaN(pos) || pos < 0;
        return !(pos >= 0);
    }
    ts.positionIsSynthesized = positionIsSynthesized;
    /** True if an extension is one of the supported TypeScript extensions. */
    function extensionIsTS(ext) {
        return ext === ".ts" /* Extension.Ts */ || ext === ".tsx" /* Extension.Tsx */ || ext === ".d.ts" /* Extension.Dts */ || ext === ".cts" /* Extension.Cts */ || ext === ".mts" /* Extension.Mts */ || ext === ".d.mts" /* Extension.Dmts */ || ext === ".d.cts" /* Extension.Dcts */;
    }
    ts.extensionIsTS = extensionIsTS;
    function resolutionExtensionIsTSOrJson(ext) {
        return extensionIsTS(ext) || ext === ".json" /* Extension.Json */;
    }
    ts.resolutionExtensionIsTSOrJson = resolutionExtensionIsTSOrJson;
    /**
     * Gets the extension from a path.
     * Path must have a valid extension.
     */
    function extensionFromPath(path) {
        var ext = tryGetExtensionFromPath(path);
        return ext !== undefined ? ext : ts.Debug.fail("File ".concat(path, " has unknown extension."));
    }
    ts.extensionFromPath = extensionFromPath;
    function isAnySupportedFileExtension(path) {
        return tryGetExtensionFromPath(path) !== undefined;
    }
    ts.isAnySupportedFileExtension = isAnySupportedFileExtension;
    function tryGetExtensionFromPath(path) {
        return ts.find(extensionsToRemove, function (e) { return ts.fileExtensionIs(path, e); });
    }
    ts.tryGetExtensionFromPath = tryGetExtensionFromPath;
    function isCheckJsEnabledForFile(sourceFile, compilerOptions) {
        return sourceFile.checkJsDirective ? sourceFile.checkJsDirective.enabled : compilerOptions.checkJs;
    }
    ts.isCheckJsEnabledForFile = isCheckJsEnabledForFile;
    ts.emptyFileSystemEntries = {
        files: ts.emptyArray,
        directories: ts.emptyArray
    };
    /**
     * patternOrStrings contains both patterns (containing "*") and regular strings.
     * Return an exact match if possible, or a pattern match, or undefined.
     * (These are verified by verifyCompilerOptions to have 0 or 1 "*" characters.)
     */
    function matchPatternOrExact(patternOrStrings, candidate) {
        var patterns = [];
        for (var _i = 0, patternOrStrings_1 = patternOrStrings; _i < patternOrStrings_1.length; _i++) {
            var patternOrString = patternOrStrings_1[_i];
            if (patternOrString === candidate) {
                return candidate;
            }
            if (!ts.isString(patternOrString)) {
                patterns.push(patternOrString);
            }
        }
        return ts.findBestPatternMatch(patterns, function (_) { return _; }, candidate);
    }
    ts.matchPatternOrExact = matchPatternOrExact;
    function sliceAfter(arr, value) {
        var index = arr.indexOf(value);
        ts.Debug.assert(index !== -1);
        return arr.slice(index);
    }
    ts.sliceAfter = sliceAfter;
    function addRelatedInfo(diagnostic) {
        var _a;
        var relatedInformation = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            relatedInformation[_i - 1] = arguments[_i];
        }
        if (!relatedInformation.length) {
            return diagnostic;
        }
        if (!diagnostic.relatedInformation) {
            diagnostic.relatedInformation = [];
        }
        ts.Debug.assert(diagnostic.relatedInformation !== ts.emptyArray, "Diagnostic had empty array singleton for related info, but is still being constructed!");
        (_a = diagnostic.relatedInformation).push.apply(_a, relatedInformation);
        return diagnostic;
    }
    ts.addRelatedInfo = addRelatedInfo;
    function minAndMax(arr, getValue) {
        ts.Debug.assert(arr.length !== 0);
        var min = getValue(arr[0]);
        var max = min;
        for (var i = 1; i < arr.length; i++) {
            var value = getValue(arr[i]);
            if (value < min) {
                min = value;
            }
            else if (value > max) {
                max = value;
            }
        }
        return { min: min, max: max };
    }
    ts.minAndMax = minAndMax;
    function rangeOfNode(node) {
        return { pos: getTokenPosOfNode(node), end: node.end };
    }
    ts.rangeOfNode = rangeOfNode;
    function rangeOfTypeParameters(sourceFile, typeParameters) {
        // Include the `<>`
        var pos = typeParameters.pos - 1;
        var end = ts.skipTrivia(sourceFile.text, typeParameters.end) + 1;
        return { pos: pos, end: end };
    }
    ts.rangeOfTypeParameters = rangeOfTypeParameters;
    function skipTypeChecking(sourceFile, options, host) {
        // If skipLibCheck is enabled, skip reporting errors if file is a declaration file.
        // If skipDefaultLibCheck is enabled, skip reporting errors if file contains a
        // '/// <reference no-default-lib="true"/>' directive.
        return (options.skipLibCheck && sourceFile.isDeclarationFile ||
            options.skipDefaultLibCheck && sourceFile.hasNoDefaultLib) ||
            host.isSourceOfProjectReferenceRedirect(sourceFile.fileName);
    }
    ts.skipTypeChecking = skipTypeChecking;
    function isJsonEqual(a, b) {
        // eslint-disable-next-line no-null/no-null
        return a === b || typeof a === "object" && a !== null && typeof b === "object" && b !== null && ts.equalOwnProperties(a, b, isJsonEqual);
    }
    ts.isJsonEqual = isJsonEqual;
    /**
     * Converts a bigint literal string, e.g. `0x1234n`,
     * to its decimal string representation, e.g. `4660`.
     */
    function parsePseudoBigInt(stringValue) {
        var log2Base;
        switch (stringValue.charCodeAt(1)) { // "x" in "0x123"
            case 98 /* CharacterCodes.b */:
            case 66 /* CharacterCodes.B */: // 0b or 0B
                log2Base = 1;
                break;
            case 111 /* CharacterCodes.o */:
            case 79 /* CharacterCodes.O */: // 0o or 0O
                log2Base = 3;
                break;
            case 120 /* CharacterCodes.x */:
            case 88 /* CharacterCodes.X */: // 0x or 0X
                log2Base = 4;
                break;
            default: // already in decimal; omit trailing "n"
                var nIndex = stringValue.length - 1;
                // Skip leading 0s
                var nonZeroStart = 0;
                while (stringValue.charCodeAt(nonZeroStart) === 48 /* CharacterCodes._0 */) {
                    nonZeroStart++;
                }
                return stringValue.slice(nonZeroStart, nIndex) || "0";
        }
        // Omit leading "0b", "0o", or "0x", and trailing "n"
        var startIndex = 2, endIndex = stringValue.length - 1;
        var bitsNeeded = (endIndex - startIndex) * log2Base;
        // Stores the value specified by the string as a LE array of 16-bit integers
        // using Uint16 instead of Uint32 so combining steps can use bitwise operators
        var segments = new Uint16Array((bitsNeeded >>> 4) + (bitsNeeded & 15 ? 1 : 0));
        // Add the digits, one at a time
        for (var i = endIndex - 1, bitOffset = 0; i >= startIndex; i--, bitOffset += log2Base) {
            var segment = bitOffset >>> 4;
            var digitChar = stringValue.charCodeAt(i);
            // Find character range: 0-9 < A-F < a-f
            var digit = digitChar <= 57 /* CharacterCodes._9 */
                ? digitChar - 48 /* CharacterCodes._0 */
                : 10 + digitChar -
                    (digitChar <= 70 /* CharacterCodes.F */ ? 65 /* CharacterCodes.A */ : 97 /* CharacterCodes.a */);
            var shiftedDigit = digit << (bitOffset & 15);
            segments[segment] |= shiftedDigit;
            var residual = shiftedDigit >>> 16;
            if (residual)
                segments[segment + 1] |= residual; // overflows segment
        }
        // Repeatedly divide segments by 10 and add remainder to base10Value
        var base10Value = "";
        var firstNonzeroSegment = segments.length - 1;
        var segmentsRemaining = true;
        while (segmentsRemaining) {
            var mod10 = 0;
            segmentsRemaining = false;
            for (var segment = firstNonzeroSegment; segment >= 0; segment--) {
                var newSegment = mod10 << 16 | segments[segment];
                var segmentValue = (newSegment / 10) | 0;
                segments[segment] = segmentValue;
                mod10 = newSegment - segmentValue * 10;
                if (segmentValue && !segmentsRemaining) {
                    firstNonzeroSegment = segment;
                    segmentsRemaining = true;
                }
            }
            base10Value = mod10 + base10Value;
        }
        return base10Value;
    }
    ts.parsePseudoBigInt = parsePseudoBigInt;
    function pseudoBigIntToString(_a) {
        var negative = _a.negative, base10Value = _a.base10Value;
        return (negative && base10Value !== "0" ? "-" : "") + base10Value;
    }
    ts.pseudoBigIntToString = pseudoBigIntToString;
    function isValidTypeOnlyAliasUseSite(useSite) {
        return !!(useSite.flags & 16777216 /* NodeFlags.Ambient */)
            || isPartOfTypeQuery(useSite)
            || isIdentifierInNonEmittingHeritageClause(useSite)
            || isPartOfPossiblyValidTypeOrAbstractComputedPropertyName(useSite)
            || !(isExpressionNode(useSite) || isShorthandPropertyNameUseSite(useSite));
    }
    ts.isValidTypeOnlyAliasUseSite = isValidTypeOnlyAliasUseSite;
    function isShorthandPropertyNameUseSite(useSite) {
        return ts.isIdentifier(useSite) && ts.isShorthandPropertyAssignment(useSite.parent) && useSite.parent.name === useSite;
    }
    function isPartOfPossiblyValidTypeOrAbstractComputedPropertyName(node) {
        while (node.kind === 79 /* SyntaxKind.Identifier */ || node.kind === 206 /* SyntaxKind.PropertyAccessExpression */) {
            node = node.parent;
        }
        if (node.kind !== 162 /* SyntaxKind.ComputedPropertyName */) {
            return false;
        }
        if (hasSyntacticModifier(node.parent, 128 /* ModifierFlags.Abstract */)) {
            return true;
        }
        var containerKind = node.parent.parent.kind;
        return containerKind === 258 /* SyntaxKind.InterfaceDeclaration */ || containerKind === 182 /* SyntaxKind.TypeLiteral */;
    }
    /** Returns true for an identifier in 1) an `implements` clause, and 2) an `extends` clause of an interface. */
    function isIdentifierInNonEmittingHeritageClause(node) {
        if (node.kind !== 79 /* SyntaxKind.Identifier */)
            return false;
        var heritageClause = ts.findAncestor(node.parent, function (parent) {
            switch (parent.kind) {
                case 291 /* SyntaxKind.HeritageClause */:
                    return true;
                case 206 /* SyntaxKind.PropertyAccessExpression */:
                case 228 /* SyntaxKind.ExpressionWithTypeArguments */:
                    return false;
                default:
                    return "quit";
            }
        });
        return (heritageClause === null || heritageClause === void 0 ? void 0 : heritageClause.token) === 117 /* SyntaxKind.ImplementsKeyword */ || (heritageClause === null || heritageClause === void 0 ? void 0 : heritageClause.parent.kind) === 258 /* SyntaxKind.InterfaceDeclaration */;
    }
    function isIdentifierTypeReference(node) {
        return ts.isTypeReferenceNode(node) && ts.isIdentifier(node.typeName);
    }
    ts.isIdentifierTypeReference = isIdentifierTypeReference;
    function arrayIsHomogeneous(array, comparer) {
        if (comparer === void 0) { comparer = ts.equateValues; }
        if (array.length < 2)
            return true;
        var first = array[0];
        for (var i = 1, length_1 = array.length; i < length_1; i++) {
            var target = array[i];
            if (!comparer(first, target))
                return false;
        }
        return true;
    }
    ts.arrayIsHomogeneous = arrayIsHomogeneous;
    /**
     * Bypasses immutability and directly sets the `pos` property of a `TextRange` or `Node`.
     */
    /* @internal */
    function setTextRangePos(range, pos) {
        range.pos = pos;
        return range;
    }
    ts.setTextRangePos = setTextRangePos;
    /**
     * Bypasses immutability and directly sets the `end` property of a `TextRange` or `Node`.
     */
    /* @internal */
    function setTextRangeEnd(range, end) {
        range.end = end;
        return range;
    }
    ts.setTextRangeEnd = setTextRangeEnd;
    /**
     * Bypasses immutability and directly sets the `pos` and `end` properties of a `TextRange` or `Node`.
     */
    /* @internal */
    function setTextRangePosEnd(range, pos, end) {
        return setTextRangeEnd(setTextRangePos(range, pos), end);
    }
    ts.setTextRangePosEnd = setTextRangePosEnd;
    /**
     * Bypasses immutability and directly sets the `pos` and `end` properties of a `TextRange` or `Node` from the
     * provided position and width.
     */
    /* @internal */
    function setTextRangePosWidth(range, pos, width) {
        return setTextRangePosEnd(range, pos, pos + width);
    }
    ts.setTextRangePosWidth = setTextRangePosWidth;
    function setNodeFlags(node, newFlags) {
        if (node) {
            node.flags = newFlags;
        }
        return node;
    }
    ts.setNodeFlags = setNodeFlags;
    function setParent(child, parent) {
        if (child && parent) {
            child.parent = parent;
        }
        return child;
    }
    ts.setParent = setParent;
    function setEachParent(children, parent) {
        if (children) {
            for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
                var child = children_1[_i];
                setParent(child, parent);
            }
        }
        return children;
    }
    ts.setEachParent = setEachParent;
    function setParentRecursive(rootNode, incremental) {
        if (!rootNode)
            return rootNode;
        ts.forEachChildRecursively(rootNode, ts.isJSDocNode(rootNode) ? bindParentToChildIgnoringJSDoc : bindParentToChild);
        return rootNode;
        function bindParentToChildIgnoringJSDoc(child, parent) {
            if (incremental && child.parent === parent) {
                return "skip";
            }
            setParent(child, parent);
        }
        function bindJSDoc(child) {
            if (ts.hasJSDocNodes(child)) {
                for (var _i = 0, _a = child.jsDoc; _i < _a.length; _i++) {
                    var doc = _a[_i];
                    bindParentToChildIgnoringJSDoc(doc, child);
                    ts.forEachChildRecursively(doc, bindParentToChildIgnoringJSDoc);
                }
            }
        }
        function bindParentToChild(child, parent) {
            return bindParentToChildIgnoringJSDoc(child, parent) || bindJSDoc(child);
        }
    }
    ts.setParentRecursive = setParentRecursive;
    function isPackedElement(node) {
        return !ts.isOmittedExpression(node);
    }
    /**
     * Determines whether the provided node is an ArrayLiteralExpression that contains no missing elements.
     */
    function isPackedArrayLiteral(node) {
        return ts.isArrayLiteralExpression(node) && ts.every(node.elements, isPackedElement);
    }
    ts.isPackedArrayLiteral = isPackedArrayLiteral;
    /**
     * Indicates whether the result of an `Expression` will be unused.
     *
     * NOTE: This requires a node with a valid `parent` pointer.
     */
    function expressionResultIsUnused(node) {
        ts.Debug.assertIsDefined(node.parent);
        while (true) {
            var parent = node.parent;
            // walk up parenthesized expressions, but keep a pointer to the top-most parenthesized expression
            if (ts.isParenthesizedExpression(parent)) {
                node = parent;
                continue;
            }
            // result is unused in an expression statement, `void` expression, or the initializer or incrementer of a `for` loop
            if (ts.isExpressionStatement(parent) ||
                ts.isVoidExpression(parent) ||
                ts.isForStatement(parent) && (parent.initializer === node || parent.incrementor === node)) {
                return true;
            }
            if (ts.isCommaListExpression(parent)) {
                // left side of comma is always unused
                if (node !== ts.last(parent.elements))
                    return true;
                // right side of comma is unused if parent is unused
                node = parent;
                continue;
            }
            if (ts.isBinaryExpression(parent) && parent.operatorToken.kind === 27 /* SyntaxKind.CommaToken */) {
                // left side of comma is always unused
                if (node === parent.left)
                    return true;
                // right side of comma is unused if parent is unused
                node = parent;
                continue;
            }
            return false;
        }
    }
    ts.expressionResultIsUnused = expressionResultIsUnused;
    function containsIgnoredPath(path) {
        return ts.some(ts.ignoredPaths, function (p) { return ts.stringContains(path, p); });
    }
    ts.containsIgnoredPath = containsIgnoredPath;
    function getContainingNodeArray(node) {
        if (!node.parent)
            return undefined;
        switch (node.kind) {
            case 163 /* SyntaxKind.TypeParameter */:
                var parent_1 = node.parent;
                return parent_1.kind === 190 /* SyntaxKind.InferType */ ? undefined : parent_1.typeParameters;
            case 164 /* SyntaxKind.Parameter */:
                return node.parent.parameters;
            case 199 /* SyntaxKind.TemplateLiteralTypeSpan */:
                return node.parent.templateSpans;
            case 233 /* SyntaxKind.TemplateSpan */:
                return node.parent.templateSpans;
            case 165 /* SyntaxKind.Decorator */: {
                var parent_2 = node.parent;
                return ts.canHaveDecorators(parent_2) ? parent_2.modifiers :
                    ts.canHaveIllegalDecorators(parent_2) ? parent_2.illegalDecorators :
                        undefined;
            }
            case 291 /* SyntaxKind.HeritageClause */:
                return node.parent.heritageClauses;
        }
        var parent = node.parent;
        if (ts.isJSDocTag(node)) {
            return ts.isJSDocTypeLiteral(node.parent) ? undefined : node.parent.tags;
        }
        switch (parent.kind) {
            case 182 /* SyntaxKind.TypeLiteral */:
            case 258 /* SyntaxKind.InterfaceDeclaration */:
                return ts.isTypeElement(node) ? parent.members : undefined;
            case 187 /* SyntaxKind.UnionType */:
            case 188 /* SyntaxKind.IntersectionType */:
                return parent.types;
            case 184 /* SyntaxKind.TupleType */:
            case 204 /* SyntaxKind.ArrayLiteralExpression */:
            case 351 /* SyntaxKind.CommaListExpression */:
            case 269 /* SyntaxKind.NamedImports */:
            case 273 /* SyntaxKind.NamedExports */:
                return parent.elements;
            case 205 /* SyntaxKind.ObjectLiteralExpression */:
            case 286 /* SyntaxKind.JsxAttributes */:
                return parent.properties;
            case 208 /* SyntaxKind.CallExpression */:
            case 209 /* SyntaxKind.NewExpression */:
                return ts.isTypeNode(node) ? parent.typeArguments :
                    parent.expression === node ? undefined :
                        parent.arguments;
            case 278 /* SyntaxKind.JsxElement */:
            case 282 /* SyntaxKind.JsxFragment */:
                return ts.isJsxChild(node) ? parent.children : undefined;
            case 280 /* SyntaxKind.JsxOpeningElement */:
            case 279 /* SyntaxKind.JsxSelfClosingElement */:
                return ts.isTypeNode(node) ? parent.typeArguments : undefined;
            case 235 /* SyntaxKind.Block */:
            case 289 /* SyntaxKind.CaseClause */:
            case 290 /* SyntaxKind.DefaultClause */:
            case 262 /* SyntaxKind.ModuleBlock */:
                return parent.statements;
            case 263 /* SyntaxKind.CaseBlock */:
                return parent.clauses;
            case 257 /* SyntaxKind.ClassDeclaration */:
            case 226 /* SyntaxKind.ClassExpression */:
                return ts.isClassElement(node) ? parent.members : undefined;
            case 260 /* SyntaxKind.EnumDeclaration */:
                return ts.isEnumMember(node) ? parent.members : undefined;
            case 305 /* SyntaxKind.SourceFile */:
                return parent.statements;
        }
    }
    ts.getContainingNodeArray = getContainingNodeArray;
    function hasContextSensitiveParameters(node) {
        // Functions with type parameters are not context sensitive.
        if (!node.typeParameters) {
            // Functions with any parameters that lack type annotations are context sensitive.
            if (ts.some(node.parameters, function (p) { return !getEffectiveTypeAnnotationNode(p); })) {
                return true;
            }
            if (node.kind !== 214 /* SyntaxKind.ArrowFunction */) {
                // If the first parameter is not an explicit 'this' parameter, then the function has
                // an implicit 'this' parameter which is subject to contextual typing.
                var parameter = ts.firstOrUndefined(node.parameters);
                if (!(parameter && parameterIsThisKeyword(parameter))) {
                    return true;
                }
            }
        }
        return false;
    }
    ts.hasContextSensitiveParameters = hasContextSensitiveParameters;
    /* @internal */
    function isInfinityOrNaNString(name) {
        return name === "Infinity" || name === "-Infinity" || name === "NaN";
    }
    ts.isInfinityOrNaNString = isInfinityOrNaNString;
    function isCatchClauseVariableDeclaration(node) {
        return node.kind === 254 /* SyntaxKind.VariableDeclaration */ && node.parent.kind === 292 /* SyntaxKind.CatchClause */;
    }
    ts.isCatchClauseVariableDeclaration = isCatchClauseVariableDeclaration;
    function isParameterOrCatchClauseVariable(symbol) {
        var declaration = symbol.valueDeclaration && getRootDeclaration(symbol.valueDeclaration);
        return !!declaration && (ts.isParameter(declaration) || isCatchClauseVariableDeclaration(declaration));
    }
    ts.isParameterOrCatchClauseVariable = isParameterOrCatchClauseVariable;
    function isFunctionExpressionOrArrowFunction(node) {
        return node.kind === 213 /* SyntaxKind.FunctionExpression */ || node.kind === 214 /* SyntaxKind.ArrowFunction */;
    }
    ts.isFunctionExpressionOrArrowFunction = isFunctionExpressionOrArrowFunction;
    function escapeSnippetText(text) {
        return text.replace(/\$/gm, function () { return "\\$"; });
    }
    ts.escapeSnippetText = escapeSnippetText;
    function isNumericLiteralName(name) {
        // The intent of numeric names is that
        //     - they are names with text in a numeric form, and that
        //     - setting properties/indexing with them is always equivalent to doing so with the numeric literal 'numLit',
        //         acquired by applying the abstract 'ToNumber' operation on the name's text.
        //
        // The subtlety is in the latter portion, as we cannot reliably say that anything that looks like a numeric literal is a numeric name.
        // In fact, it is the case that the text of the name must be equal to 'ToString(numLit)' for this to hold.
        //
        // Consider the property name '"0xF00D"'. When one indexes with '0xF00D', they are actually indexing with the value of 'ToString(0xF00D)'
        // according to the ECMAScript specification, so it is actually as if the user indexed with the string '"61453"'.
        // Thus, the text of all numeric literals equivalent to '61543' such as '0xF00D', '0xf00D', '0170015', etc. are not valid numeric names
        // because their 'ToString' representation is not equal to their original text.
        // This is motivated by ECMA-262 sections 9.3.1, 9.8.1, 11.1.5, and 11.2.1.
        //
        // Here, we test whether 'ToString(ToNumber(name))' is exactly equal to 'name'.
        // The '+' prefix operator is equivalent here to applying the abstract ToNumber operation.
        // Applying the 'toString()' method on a number gives us the abstract ToString operation on a number.
        //
        // Note that this accepts the values 'Infinity', '-Infinity', and 'NaN', and that this is intentional.
        // This is desired behavior, because when indexing with them as numeric entities, you are indexing
        // with the strings '"Infinity"', '"-Infinity"', and '"NaN"' respectively.
        return (+name).toString() === name;
    }
    ts.isNumericLiteralName = isNumericLiteralName;
    function createPropertyNameNodeForIdentifierOrLiteral(name, target, singleQuote, stringNamed) {
        return ts.isIdentifierText(name, target) ? ts.factory.createIdentifier(name) :
            !stringNamed && isNumericLiteralName(name) && +name >= 0 ? ts.factory.createNumericLiteral(+name) :
                ts.factory.createStringLiteral(name, !!singleQuote);
    }
    ts.createPropertyNameNodeForIdentifierOrLiteral = createPropertyNameNodeForIdentifierOrLiteral;
    function isThisTypeParameter(type) {
        return !!(type.flags & 262144 /* TypeFlags.TypeParameter */ && type.isThisType);
    }
    ts.isThisTypeParameter = isThisTypeParameter;
    function getNodeModulePathParts(fullPath) {
        // If fullPath can't be valid module file within node_modules, returns undefined.
        // Example of expected pattern: /base/path/node_modules/[@scope/otherpackage/@otherscope/node_modules/]package/[subdirectory/]file.js
        // Returns indices:                       ^            ^                                                      ^             ^
        var topLevelNodeModulesIndex = 0;
        var topLevelPackageNameIndex = 0;
        var packageRootIndex = 0;
        var fileNameIndex = 0;
        var States;
        (function (States) {
            States[States["BeforeNodeModules"] = 0] = "BeforeNodeModules";
            States[States["NodeModules"] = 1] = "NodeModules";
            States[States["Scope"] = 2] = "Scope";
            States[States["PackageContent"] = 3] = "PackageContent";
        })(States || (States = {}));
        var partStart = 0;
        var partEnd = 0;
        var state = 0 /* States.BeforeNodeModules */;
        while (partEnd >= 0) {
            partStart = partEnd;
            partEnd = fullPath.indexOf("/", partStart + 1);
            switch (state) {
                case 0 /* States.BeforeNodeModules */:
                    if (fullPath.indexOf(ts.nodeModulesPathPart, partStart) === partStart) {
                        topLevelNodeModulesIndex = partStart;
                        topLevelPackageNameIndex = partEnd;
                        state = 1 /* States.NodeModules */;
                    }
                    break;
                case 1 /* States.NodeModules */:
                case 2 /* States.Scope */:
                    if (state === 1 /* States.NodeModules */ && fullPath.charAt(partStart + 1) === "@") {
                        state = 2 /* States.Scope */;
                    }
                    else {
                        packageRootIndex = partEnd;
                        state = 3 /* States.PackageContent */;
                    }
                    break;
                case 3 /* States.PackageContent */:
                    if (fullPath.indexOf(ts.nodeModulesPathPart, partStart) === partStart) {
                        state = 1 /* States.NodeModules */;
                    }
                    else {
                        state = 3 /* States.PackageContent */;
                    }
                    break;
            }
        }
        fileNameIndex = partStart;
        return state > 1 /* States.NodeModules */ ? { topLevelNodeModulesIndex: topLevelNodeModulesIndex, topLevelPackageNameIndex: topLevelPackageNameIndex, packageRootIndex: packageRootIndex, fileNameIndex: fileNameIndex } : undefined;
    }
    ts.getNodeModulePathParts = getNodeModulePathParts;
    function getParameterTypeNode(parameter) {
        var _a;
        return parameter.kind === 340 /* SyntaxKind.JSDocParameterTag */ ? (_a = parameter.typeExpression) === null || _a === void 0 ? void 0 : _a.type : parameter.type;
    }
    ts.getParameterTypeNode = getParameterTypeNode;
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    /**
     * Creates a `BaseNodeFactory` which can be used to create `Node` instances from the constructors provided by the object allocator.
     */
    function createBaseNodeFactory() {
        // tslint:disable variable-name
        var NodeConstructor;
        var TokenConstructor;
        var IdentifierConstructor;
        var PrivateIdentifierConstructor;
        var SourceFileConstructor;
        // tslint:enable variable-name
        return {
            createBaseSourceFileNode: createBaseSourceFileNode,
            createBaseIdentifierNode: createBaseIdentifierNode,
            createBasePrivateIdentifierNode: createBasePrivateIdentifierNode,
            createBaseTokenNode: createBaseTokenNode,
            createBaseNode: createBaseNode
        };
        function createBaseSourceFileNode(kind) {
            return new (SourceFileConstructor || (SourceFileConstructor = ts.objectAllocator.getSourceFileConstructor()))(kind, /*pos*/ -1, /*end*/ -1);
        }
        function createBaseIdentifierNode(kind) {
            return new (IdentifierConstructor || (IdentifierConstructor = ts.objectAllocator.getIdentifierConstructor()))(kind, /*pos*/ -1, /*end*/ -1);
        }
        function createBasePrivateIdentifierNode(kind) {
            return new (PrivateIdentifierConstructor || (PrivateIdentifierConstructor = ts.objectAllocator.getPrivateIdentifierConstructor()))(kind, /*pos*/ -1, /*end*/ -1);
        }
        function createBaseTokenNode(kind) {
            return new (TokenConstructor || (TokenConstructor = ts.objectAllocator.getTokenConstructor()))(kind, /*pos*/ -1, /*end*/ -1);
        }
        function createBaseNode(kind) {
            return new (NodeConstructor || (NodeConstructor = ts.objectAllocator.getNodeConstructor()))(kind, /*pos*/ -1, /*end*/ -1);
        }
    }
    ts.createBaseNodeFactory = createBaseNodeFactory;
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    function createParenthesizerRules(factory) {
        var binaryLeftOperandParenthesizerCache;
        var binaryRightOperandParenthesizerCache;
        return {
            getParenthesizeLeftSideOfBinaryForOperator: getParenthesizeLeftSideOfBinaryForOperator,
            getParenthesizeRightSideOfBinaryForOperator: getParenthesizeRightSideOfBinaryForOperator,
            parenthesizeLeftSideOfBinary: parenthesizeLeftSideOfBinary,
            parenthesizeRightSideOfBinary: parenthesizeRightSideOfBinary,
            parenthesizeExpressionOfComputedPropertyName: parenthesizeExpressionOfComputedPropertyName,
            parenthesizeConditionOfConditionalExpression: parenthesizeConditionOfConditionalExpression,
            parenthesizeBranchOfConditionalExpression: parenthesizeBranchOfConditionalExpression,
            parenthesizeExpressionOfExportDefault: parenthesizeExpressionOfExportDefault,
            parenthesizeExpressionOfNew: parenthesizeExpressionOfNew,
            parenthesizeLeftSideOfAccess: parenthesizeLeftSideOfAccess,
            parenthesizeOperandOfPostfixUnary: parenthesizeOperandOfPostfixUnary,
            parenthesizeOperandOfPrefixUnary: parenthesizeOperandOfPrefixUnary,
            parenthesizeExpressionsOfCommaDelimitedList: parenthesizeExpressionsOfCommaDelimitedList,
            parenthesizeExpressionForDisallowedComma: parenthesizeExpressionForDisallowedComma,
            parenthesizeExpressionOfExpressionStatement: parenthesizeExpressionOfExpressionStatement,
            parenthesizeConciseBodyOfArrowFunction: parenthesizeConciseBodyOfArrowFunction,
            parenthesizeCheckTypeOfConditionalType: parenthesizeCheckTypeOfConditionalType,
            parenthesizeExtendsTypeOfConditionalType: parenthesizeExtendsTypeOfConditionalType,
            parenthesizeConstituentTypesOfUnionType: parenthesizeConstituentTypesOfUnionType,
            parenthesizeConstituentTypeOfUnionType: parenthesizeConstituentTypeOfUnionType,
            parenthesizeConstituentTypesOfIntersectionType: parenthesizeConstituentTypesOfIntersectionType,
            parenthesizeConstituentTypeOfIntersectionType: parenthesizeConstituentTypeOfIntersectionType,
            parenthesizeOperandOfTypeOperator: parenthesizeOperandOfTypeOperator,
            parenthesizeOperandOfReadonlyTypeOperator: parenthesizeOperandOfReadonlyTypeOperator,
            parenthesizeNonArrayTypeOfPostfixType: parenthesizeNonArrayTypeOfPostfixType,
            parenthesizeElementTypesOfTupleType: parenthesizeElementTypesOfTupleType,
            parenthesizeElementTypeOfTupleType: parenthesizeElementTypeOfTupleType,
            parenthesizeTypeOfOptionalType: parenthesizeTypeOfOptionalType,
            parenthesizeTypeArguments: parenthesizeTypeArguments,
            parenthesizeLeadingTypeArgument: parenthesizeLeadingTypeArgument,
        };
        function getParenthesizeLeftSideOfBinaryForOperator(operatorKind) {
            binaryLeftOperandParenthesizerCache || (binaryLeftOperandParenthesizerCache = new ts.Map());
            var parenthesizerRule = binaryLeftOperandParenthesizerCache.get(operatorKind);
            if (!parenthesizerRule) {
                parenthesizerRule = function (node) { return parenthesizeLeftSideOfBinary(operatorKind, node); };
                binaryLeftOperandParenthesizerCache.set(operatorKind, parenthesizerRule);
            }
            return parenthesizerRule;
        }
        function getParenthesizeRightSideOfBinaryForOperator(operatorKind) {
            binaryRightOperandParenthesizerCache || (binaryRightOperandParenthesizerCache = new ts.Map());
            var parenthesizerRule = binaryRightOperandParenthesizerCache.get(operatorKind);
            if (!parenthesizerRule) {
                parenthesizerRule = function (node) { return parenthesizeRightSideOfBinary(operatorKind, /*leftSide*/ undefined, node); };
                binaryRightOperandParenthesizerCache.set(operatorKind, parenthesizerRule);
            }
            return parenthesizerRule;
        }
        /**
         * Determines whether the operand to a BinaryExpression needs to be parenthesized.
         *
         * @param binaryOperator The operator for the BinaryExpression.
         * @param operand The operand for the BinaryExpression.
         * @param isLeftSideOfBinary A value indicating whether the operand is the left side of the
         *                           BinaryExpression.
         */
        function binaryOperandNeedsParentheses(binaryOperator, operand, isLeftSideOfBinary, leftOperand) {
            // If the operand has lower precedence, then it needs to be parenthesized to preserve the
            // intent of the expression. For example, if the operand is `a + b` and the operator is
            // `*`, then we need to parenthesize the operand to preserve the intended order of
            // operations: `(a + b) * x`.
            //
            // If the operand has higher precedence, then it does not need to be parenthesized. For
            // example, if the operand is `a * b` and the operator is `+`, then we do not need to
            // parenthesize to preserve the intended order of operations: `a * b + x`.
            //
            // If the operand has the same precedence, then we need to check the associativity of
            // the operator based on whether this is the left or right operand of the expression.
            //
            // For example, if `a / d` is on the right of operator `*`, we need to parenthesize
            // to preserve the intended order of operations: `x * (a / d)`
            //
            // If `a ** d` is on the left of operator `**`, we need to parenthesize to preserve
            // the intended order of operations: `(a ** b) ** c`
            var binaryOperatorPrecedence = ts.getOperatorPrecedence(221 /* SyntaxKind.BinaryExpression */, binaryOperator);
            var binaryOperatorAssociativity = ts.getOperatorAssociativity(221 /* SyntaxKind.BinaryExpression */, binaryOperator);
            var emittedOperand = ts.skipPartiallyEmittedExpressions(operand);
            if (!isLeftSideOfBinary && operand.kind === 214 /* SyntaxKind.ArrowFunction */ && binaryOperatorPrecedence > 3 /* OperatorPrecedence.Assignment */) {
                // We need to parenthesize arrow functions on the right side to avoid it being
                // parsed as parenthesized expression: `a && (() => {})`
                return true;
            }
            var operandPrecedence = ts.getExpressionPrecedence(emittedOperand);
            switch (ts.compareValues(operandPrecedence, binaryOperatorPrecedence)) {
                case -1 /* Comparison.LessThan */:
                    // If the operand is the right side of a right-associative binary operation
                    // and is a yield expression, then we do not need parentheses.
                    if (!isLeftSideOfBinary
                        && binaryOperatorAssociativity === 1 /* Associativity.Right */
                        && operand.kind === 224 /* SyntaxKind.YieldExpression */) {
                        return false;
                    }
                    return true;
                case 1 /* Comparison.GreaterThan */:
                    return false;
                case 0 /* Comparison.EqualTo */:
                    if (isLeftSideOfBinary) {
                        // No need to parenthesize the left operand when the binary operator is
                        // left associative:
                        //  (a*b)/x    -> a*b/x
                        //  (a**b)/x   -> a**b/x
                        //
                        // Parentheses are needed for the left operand when the binary operator is
                        // right associative:
                        //  (a/b)**x   -> (a/b)**x
                        //  (a**b)**x  -> (a**b)**x
                        return binaryOperatorAssociativity === 1 /* Associativity.Right */;
                    }
                    else {
                        if (ts.isBinaryExpression(emittedOperand)
                            && emittedOperand.operatorToken.kind === binaryOperator) {
                            // No need to parenthesize the right operand when the binary operator and
                            // operand are the same and one of the following:
                            //  x*(a*b)     => x*a*b
                            //  x|(a|b)     => x|a|b
                            //  x&(a&b)     => x&a&b
                            //  x^(a^b)     => x^a^b
                            if (operatorHasAssociativeProperty(binaryOperator)) {
                                return false;
                            }
                            // No need to parenthesize the right operand when the binary operator
                            // is plus (+) if both the left and right operands consist solely of either
                            // literals of the same kind or binary plus (+) expressions for literals of
                            // the same kind (recursively).
                            //  "a"+(1+2)       => "a"+(1+2)
                            //  "a"+("b"+"c")   => "a"+"b"+"c"
                            if (binaryOperator === 39 /* SyntaxKind.PlusToken */) {
                                var leftKind = leftOperand ? getLiteralKindOfBinaryPlusOperand(leftOperand) : 0 /* SyntaxKind.Unknown */;
                                if (ts.isLiteralKind(leftKind) && leftKind === getLiteralKindOfBinaryPlusOperand(emittedOperand)) {
                                    return false;
                                }
                            }
                        }
                        // No need to parenthesize the right operand when the operand is right
                        // associative:
                        //  x/(a**b)    -> x/a**b
                        //  x**(a**b)   -> x**a**b
                        //
                        // Parentheses are needed for the right operand when the operand is left
                        // associative:
                        //  x/(a*b)     -> x/(a*b)
                        //  x**(a/b)    -> x**(a/b)
                        var operandAssociativity = ts.getExpressionAssociativity(emittedOperand);
                        return operandAssociativity === 0 /* Associativity.Left */;
                    }
            }
        }
        /**
         * Determines whether a binary operator is mathematically associative.
         *
         * @param binaryOperator The binary operator.
         */
        function operatorHasAssociativeProperty(binaryOperator) {
            // The following operators are associative in JavaScript:
            //  (a*b)*c     -> a*(b*c)  -> a*b*c
            //  (a|b)|c     -> a|(b|c)  -> a|b|c
            //  (a&b)&c     -> a&(b&c)  -> a&b&c
            //  (a^b)^c     -> a^(b^c)  -> a^b^c
            //
            // While addition is associative in mathematics, JavaScript's `+` is not
            // guaranteed to be associative as it is overloaded with string concatenation.
            return binaryOperator === 41 /* SyntaxKind.AsteriskToken */
                || binaryOperator === 51 /* SyntaxKind.BarToken */
                || binaryOperator === 50 /* SyntaxKind.AmpersandToken */
                || binaryOperator === 52 /* SyntaxKind.CaretToken */;
        }
        /**
         * This function determines whether an expression consists of a homogeneous set of
         * literal expressions or binary plus expressions that all share the same literal kind.
         * It is used to determine whether the right-hand operand of a binary plus expression can be
         * emitted without parentheses.
         */
        function getLiteralKindOfBinaryPlusOperand(node) {
            node = ts.skipPartiallyEmittedExpressions(node);
            if (ts.isLiteralKind(node.kind)) {
                return node.kind;
            }
            if (node.kind === 221 /* SyntaxKind.BinaryExpression */ && node.operatorToken.kind === 39 /* SyntaxKind.PlusToken */) {
                if (node.cachedLiteralKind !== undefined) {
                    return node.cachedLiteralKind;
                }
                var leftKind = getLiteralKindOfBinaryPlusOperand(node.left);
                var literalKind = ts.isLiteralKind(leftKind)
                    && leftKind === getLiteralKindOfBinaryPlusOperand(node.right)
                    ? leftKind
                    : 0 /* SyntaxKind.Unknown */;
                node.cachedLiteralKind = literalKind;
                return literalKind;
            }
            return 0 /* SyntaxKind.Unknown */;
        }
        /**
         * Wraps the operand to a BinaryExpression in parentheses if they are needed to preserve the intended
         * order of operations.
         *
         * @param binaryOperator The operator for the BinaryExpression.
         * @param operand The operand for the BinaryExpression.
         * @param isLeftSideOfBinary A value indicating whether the operand is the left side of the
         *                           BinaryExpression.
         */
        function parenthesizeBinaryOperand(binaryOperator, operand, isLeftSideOfBinary, leftOperand) {
            var skipped = ts.skipPartiallyEmittedExpressions(operand);
            // If the resulting expression is already parenthesized, we do not need to do any further processing.
            if (skipped.kind === 212 /* SyntaxKind.ParenthesizedExpression */) {
                return operand;
            }
            return binaryOperandNeedsParentheses(binaryOperator, operand, isLeftSideOfBinary, leftOperand)
                ? factory.createParenthesizedExpression(operand)
                : operand;
        }
        function parenthesizeLeftSideOfBinary(binaryOperator, leftSide) {
            return parenthesizeBinaryOperand(binaryOperator, leftSide, /*isLeftSideOfBinary*/ true);
        }
        function parenthesizeRightSideOfBinary(binaryOperator, leftSide, rightSide) {
            return parenthesizeBinaryOperand(binaryOperator, rightSide, /*isLeftSideOfBinary*/ false, leftSide);
        }
        function parenthesizeExpressionOfComputedPropertyName(expression) {
            return ts.isCommaSequence(expression) ? factory.createParenthesizedExpression(expression) : expression;
        }
        function parenthesizeConditionOfConditionalExpression(condition) {
            var conditionalPrecedence = ts.getOperatorPrecedence(222 /* SyntaxKind.ConditionalExpression */, 57 /* SyntaxKind.QuestionToken */);
            var emittedCondition = ts.skipPartiallyEmittedExpressions(condition);
            var conditionPrecedence = ts.getExpressionPrecedence(emittedCondition);
            if (ts.compareValues(conditionPrecedence, conditionalPrecedence) !== 1 /* Comparison.GreaterThan */) {
                return factory.createParenthesizedExpression(condition);
            }
            return condition;
        }
        function parenthesizeBranchOfConditionalExpression(branch) {
            // per ES grammar both 'whenTrue' and 'whenFalse' parts of conditional expression are assignment expressions
            // so in case when comma expression is introduced as a part of previous transformations
            // if should be wrapped in parens since comma operator has the lowest precedence
            var emittedExpression = ts.skipPartiallyEmittedExpressions(branch);
            return ts.isCommaSequence(emittedExpression)
                ? factory.createParenthesizedExpression(branch)
                : branch;
        }
        /**
         *  [Per the spec](https://tc39.github.io/ecma262/#prod-ExportDeclaration), `export default` accepts _AssigmentExpression_ but
         *  has a lookahead restriction for `function`, `async function`, and `class`.
         *
         * Basically, that means we need to parenthesize in the following cases:
         *
         * - BinaryExpression of CommaToken
         * - CommaList (synthetic list of multiple comma expressions)
         * - FunctionExpression
         * - ClassExpression
         */
        function parenthesizeExpressionOfExportDefault(expression) {
            var check = ts.skipPartiallyEmittedExpressions(expression);
            var needsParens = ts.isCommaSequence(check);
            if (!needsParens) {
                switch (ts.getLeftmostExpression(check, /*stopAtCallExpression*/ false).kind) {
                    case 226 /* SyntaxKind.ClassExpression */:
                    case 213 /* SyntaxKind.FunctionExpression */:
                        needsParens = true;
                }
            }
            return needsParens ? factory.createParenthesizedExpression(expression) : expression;
        }
        /**
         * Wraps an expression in parentheses if it is needed in order to use the expression
         * as the expression of a `NewExpression` node.
         */
        function parenthesizeExpressionOfNew(expression) {
            var leftmostExpr = ts.getLeftmostExpression(expression, /*stopAtCallExpressions*/ true);
            switch (leftmostExpr.kind) {
                case 208 /* SyntaxKind.CallExpression */:
                    return factory.createParenthesizedExpression(expression);
                case 209 /* SyntaxKind.NewExpression */:
                    return !leftmostExpr.arguments
                        ? factory.createParenthesizedExpression(expression)
                        : expression; // TODO(rbuckton): Verify this assertion holds
            }
            return parenthesizeLeftSideOfAccess(expression);
        }
        /**
         * Wraps an expression in parentheses if it is needed in order to use the expression for
         * property or element access.
         */
        function parenthesizeLeftSideOfAccess(expression, optionalChain) {
            // isLeftHandSideExpression is almost the correct criterion for when it is not necessary
            // to parenthesize the expression before a dot. The known exception is:
            //
            //    NewExpression:
            //       new C.x        -> not the same as (new C).x
            //
            var emittedExpression = ts.skipPartiallyEmittedExpressions(expression);
            if (ts.isLeftHandSideExpression(emittedExpression)
                && (emittedExpression.kind !== 209 /* SyntaxKind.NewExpression */ || emittedExpression.arguments)
                && (optionalChain || !ts.isOptionalChain(emittedExpression))) {
                // TODO(rbuckton): Verify whether this assertion holds.
                return expression;
            }
            // TODO(rbuckton): Verifiy whether `setTextRange` is needed.
            return ts.setTextRange(factory.createParenthesizedExpression(expression), expression);
        }
        function parenthesizeOperandOfPostfixUnary(operand) {
            // TODO(rbuckton): Verifiy whether `setTextRange` is needed.
            return ts.isLeftHandSideExpression(operand) ? operand : ts.setTextRange(factory.createParenthesizedExpression(operand), operand);
        }
        function parenthesizeOperandOfPrefixUnary(operand) {
            // TODO(rbuckton): Verifiy whether `setTextRange` is needed.
            return ts.isUnaryExpression(operand) ? operand : ts.setTextRange(factory.createParenthesizedExpression(operand), operand);
        }
        function parenthesizeExpressionsOfCommaDelimitedList(elements) {
            var result = ts.sameMap(elements, parenthesizeExpressionForDisallowedComma);
            return ts.setTextRange(factory.createNodeArray(result, elements.hasTrailingComma), elements);
        }
        function parenthesizeExpressionForDisallowedComma(expression) {
            var emittedExpression = ts.skipPartiallyEmittedExpressions(expression);
            var expressionPrecedence = ts.getExpressionPrecedence(emittedExpression);
            var commaPrecedence = ts.getOperatorPrecedence(221 /* SyntaxKind.BinaryExpression */, 27 /* SyntaxKind.CommaToken */);
            // TODO(rbuckton): Verifiy whether `setTextRange` is needed.
            return expressionPrecedence > commaPrecedence ? expression : ts.setTextRange(factory.createParenthesizedExpression(expression), expression);
        }
        function parenthesizeExpressionOfExpressionStatement(expression) {
            var emittedExpression = ts.skipPartiallyEmittedExpressions(expression);
            if (ts.isCallExpression(emittedExpression)) {
                var callee = emittedExpression.expression;
                var kind = ts.skipPartiallyEmittedExpressions(callee).kind;
                if (kind === 213 /* SyntaxKind.FunctionExpression */ || kind === 214 /* SyntaxKind.ArrowFunction */) {
                    // TODO(rbuckton): Verifiy whether `setTextRange` is needed.
                    var updated = factory.updateCallExpression(emittedExpression, ts.setTextRange(factory.createParenthesizedExpression(callee), callee), emittedExpression.typeArguments, emittedExpression.arguments);
                    return factory.restoreOuterExpressions(expression, updated, 8 /* OuterExpressionKinds.PartiallyEmittedExpressions */);
                }
            }
            var leftmostExpressionKind = ts.getLeftmostExpression(emittedExpression, /*stopAtCallExpressions*/ false).kind;
            if (leftmostExpressionKind === 205 /* SyntaxKind.ObjectLiteralExpression */ || leftmostExpressionKind === 213 /* SyntaxKind.FunctionExpression */) {
                // TODO(rbuckton): Verifiy whether `setTextRange` is needed.
                return ts.setTextRange(factory.createParenthesizedExpression(expression), expression);
            }
            return expression;
        }
        function parenthesizeConciseBodyOfArrowFunction(body) {
            if (!ts.isBlock(body) && (ts.isCommaSequence(body) || ts.getLeftmostExpression(body, /*stopAtCallExpressions*/ false).kind === 205 /* SyntaxKind.ObjectLiteralExpression */)) {
                // TODO(rbuckton): Verifiy whether `setTextRange` is needed.
                return ts.setTextRange(factory.createParenthesizedExpression(body), body);
            }
            return body;
        }
        // Type[Extends] :
        //     FunctionOrConstructorType
        //     ConditionalType[?Extends]
        // ConditionalType[Extends] :
        //     UnionType[?Extends]
        //     [~Extends] UnionType[~Extends] `extends` Type[+Extends] `?` Type[~Extends] `:` Type[~Extends]
        //
        // - The check type (the `UnionType`, above) does not allow function, constructor, or conditional types (they must be parenthesized)
        // - The extends type (the first `Type`, above) does not allow conditional types (they must be parenthesized). Function and constructor types are fine.
        // - The true and false branch types (the second and third `Type` non-terminals, above) allow any type
        function parenthesizeCheckTypeOfConditionalType(checkType) {
            switch (checkType.kind) {
                case 179 /* SyntaxKind.FunctionType */:
                case 180 /* SyntaxKind.ConstructorType */:
                case 189 /* SyntaxKind.ConditionalType */:
                    return factory.createParenthesizedType(checkType);
            }
            return checkType;
        }
        function parenthesizeExtendsTypeOfConditionalType(extendsType) {
            switch (extendsType.kind) {
                case 189 /* SyntaxKind.ConditionalType */:
                    return factory.createParenthesizedType(extendsType);
            }
            return extendsType;
        }
        // UnionType[Extends] :
        //     `|`? IntersectionType[?Extends]
        //     UnionType[?Extends] `|` IntersectionType[?Extends]
        //
        // - A union type constituent has the same precedence as the check type of a conditional type
        function parenthesizeConstituentTypeOfUnionType(type) {
            switch (type.kind) {
                case 187 /* SyntaxKind.UnionType */: // Not strictly necessary, but a union containing a union should have been flattened
                case 188 /* SyntaxKind.IntersectionType */: // Not strictly necessary, but makes generated output more readable and avoids breaks in DT tests
                    return factory.createParenthesizedType(type);
            }
            return parenthesizeCheckTypeOfConditionalType(type);
        }
        function parenthesizeConstituentTypesOfUnionType(members) {
            return factory.createNodeArray(ts.sameMap(members, parenthesizeConstituentTypeOfUnionType));
        }
        // IntersectionType[Extends] :
        //     `&`? TypeOperator[?Extends]
        //     IntersectionType[?Extends] `&` TypeOperator[?Extends]
        //
        // - An intersection type constituent does not allow function, constructor, conditional, or union types (they must be parenthesized)
        function parenthesizeConstituentTypeOfIntersectionType(type) {
            switch (type.kind) {
                case 187 /* SyntaxKind.UnionType */:
                case 188 /* SyntaxKind.IntersectionType */: // Not strictly necessary, but an intersection containing an intersection should have been flattened
                    return factory.createParenthesizedType(type);
            }
            return parenthesizeConstituentTypeOfUnionType(type);
        }
        function parenthesizeConstituentTypesOfIntersectionType(members) {
            return factory.createNodeArray(ts.sameMap(members, parenthesizeConstituentTypeOfIntersectionType));
        }
        // TypeOperator[Extends] :
        //     PostfixType
        //     InferType[?Extends]
        //     `keyof` TypeOperator[?Extends]
        //     `unique` TypeOperator[?Extends]
        //     `readonly` TypeOperator[?Extends]
        //
        function parenthesizeOperandOfTypeOperator(type) {
            switch (type.kind) {
                case 188 /* SyntaxKind.IntersectionType */:
                    return factory.createParenthesizedType(type);
            }
            return parenthesizeConstituentTypeOfIntersectionType(type);
        }
        function parenthesizeOperandOfReadonlyTypeOperator(type) {
            switch (type.kind) {
                case 193 /* SyntaxKind.TypeOperator */:
                    return factory.createParenthesizedType(type);
            }
            return parenthesizeOperandOfTypeOperator(type);
        }
        // PostfixType :
        //     NonArrayType
        //     NonArrayType [no LineTerminator here] `!` // JSDoc
        //     NonArrayType [no LineTerminator here] `?` // JSDoc
        //     IndexedAccessType
        //     ArrayType
        //
        // IndexedAccessType :
        //     NonArrayType `[` Type[~Extends] `]`
        //
        // ArrayType :
        //     NonArrayType `[` `]`
        //
        function parenthesizeNonArrayTypeOfPostfixType(type) {
            switch (type.kind) {
                case 190 /* SyntaxKind.InferType */:
                case 193 /* SyntaxKind.TypeOperator */:
                case 181 /* SyntaxKind.TypeQuery */: // Not strictly necessary, but makes generated output more readable and avoids breaks in DT tests
                    return factory.createParenthesizedType(type);
            }
            return parenthesizeOperandOfTypeOperator(type);
        }
        // TupleType :
        //     `[` Elision? `]`
        //     `[` NamedTupleElementTypes `]`
        //     `[` NamedTupleElementTypes `,` Elision? `]`
        //     `[` TupleElementTypes `]`
        //     `[` TupleElementTypes `,` Elision? `]`
        //
        // NamedTupleElementTypes :
        //     Elision? NamedTupleMember
        //     NamedTupleElementTypes `,` Elision? NamedTupleMember
        //
        // NamedTupleMember :
        //     Identifier `?`? `:` Type[~Extends]
        //     `...` Identifier `:` Type[~Extends]
        //
        // TupleElementTypes :
        //     Elision? TupleElementType
        //     TupleElementTypes `,` Elision? TupleElementType
        //
        // TupleElementType :
        //     Type[~Extends] // NOTE: Needs cover grammar to disallow JSDoc postfix-optional
        //     OptionalType
        //     RestType
        //
        // OptionalType :
        //     Type[~Extends] `?` // NOTE: Needs cover grammar to disallow JSDoc postfix-optional
        //
        // RestType :
        //     `...` Type[~Extends]
        //
        function parenthesizeElementTypesOfTupleType(types) {
            return factory.createNodeArray(ts.sameMap(types, parenthesizeElementTypeOfTupleType));
        }
        function parenthesizeElementTypeOfTupleType(type) {
            if (hasJSDocPostfixQuestion(type))
                return factory.createParenthesizedType(type);
            return type;
        }
        function hasJSDocPostfixQuestion(type) {
            if (ts.isJSDocNullableType(type))
                return type.postfix;
            if (ts.isNamedTupleMember(type))
                return hasJSDocPostfixQuestion(type.type);
            if (ts.isFunctionTypeNode(type) || ts.isConstructorTypeNode(type) || ts.isTypeOperatorNode(type))
                return hasJSDocPostfixQuestion(type.type);
            if (ts.isConditionalTypeNode(type))
                return hasJSDocPostfixQuestion(type.falseType);
            if (ts.isUnionTypeNode(type))
                return hasJSDocPostfixQuestion(ts.last(type.types));
            if (ts.isIntersectionTypeNode(type))
                return hasJSDocPostfixQuestion(ts.last(type.types));
            if (ts.isInferTypeNode(type))
                return !!type.typeParameter.constraint && hasJSDocPostfixQuestion(type.typeParameter.constraint);
            return false;
        }
        function parenthesizeTypeOfOptionalType(type) {
            if (hasJSDocPostfixQuestion(type))
                return factory.createParenthesizedType(type);
            return parenthesizeNonArrayTypeOfPostfixType(type);
        }
        // function parenthesizeMemberOfElementType(member: TypeNode): TypeNode {
        //     switch (member.kind) {
        //         case SyntaxKind.UnionType:
        //         case SyntaxKind.IntersectionType:
        //         case SyntaxKind.FunctionType:
        //         case SyntaxKind.ConstructorType:
        //             return factory.createParenthesizedType(member);
        //     }
        //     return parenthesizeMemberOfConditionalType(member);
        // }
        // function parenthesizeElementTypeOfArrayType(member: TypeNode): TypeNode {
        //     switch (member.kind) {
        //         case SyntaxKind.TypeQuery:
        //         case SyntaxKind.TypeOperator:
        //         case SyntaxKind.InferType:
        //             return factory.createParenthesizedType(member);
        //     }
        //     return parenthesizeMemberOfElementType(member);
        // }
        function parenthesizeLeadingTypeArgument(node) {
            return ts.isFunctionOrConstructorTypeNode(node) && node.typeParameters ? factory.createParenthesizedType(node) : node;
        }
        function parenthesizeOrdinalTypeArgument(node, i) {
            return i === 0 ? parenthesizeLeadingTypeArgument(node) : node;
        }
        function parenthesizeTypeArguments(typeArguments) {
            if (ts.some(typeArguments)) {
                return factory.createNodeArray(ts.sameMap(typeArguments, parenthesizeOrdinalTypeArgument));
            }
        }
    }
    ts.createParenthesizerRules = createParenthesizerRules;
    ts.nullParenthesizerRules = {
        getParenthesizeLeftSideOfBinaryForOperator: function (_) { return ts.identity; },
        getParenthesizeRightSideOfBinaryForOperator: function (_) { return ts.identity; },
        parenthesizeLeftSideOfBinary: function (_binaryOperator, leftSide) { return leftSide; },
        parenthesizeRightSideOfBinary: function (_binaryOperator, _leftSide, rightSide) { return rightSide; },
        parenthesizeExpressionOfComputedPropertyName: ts.identity,
        parenthesizeConditionOfConditionalExpression: ts.identity,
        parenthesizeBranchOfConditionalExpression: ts.identity,
        parenthesizeExpressionOfExportDefault: ts.identity,
        parenthesizeExpressionOfNew: function (expression) { return ts.cast(expression, ts.isLeftHandSideExpression); },
        parenthesizeLeftSideOfAccess: function (expression) { return ts.cast(expression, ts.isLeftHandSideExpression); },
        parenthesizeOperandOfPostfixUnary: function (operand) { return ts.cast(operand, ts.isLeftHandSideExpression); },
        parenthesizeOperandOfPrefixUnary: function (operand) { return ts.cast(operand, ts.isUnaryExpression); },
        parenthesizeExpressionsOfCommaDelimitedList: function (nodes) { return ts.cast(nodes, ts.isNodeArray); },
        parenthesizeExpressionForDisallowedComma: ts.identity,
        parenthesizeExpressionOfExpressionStatement: ts.identity,
        parenthesizeConciseBodyOfArrowFunction: ts.identity,
        parenthesizeCheckTypeOfConditionalType: ts.identity,
        parenthesizeExtendsTypeOfConditionalType: ts.identity,
        parenthesizeConstituentTypesOfUnionType: function (nodes) { return ts.cast(nodes, ts.isNodeArray); },
        parenthesizeConstituentTypeOfUnionType: ts.identity,
        parenthesizeConstituentTypesOfIntersectionType: function (nodes) { return ts.cast(nodes, ts.isNodeArray); },
        parenthesizeConstituentTypeOfIntersectionType: ts.identity,
        parenthesizeOperandOfTypeOperator: ts.identity,
        parenthesizeOperandOfReadonlyTypeOperator: ts.identity,
        parenthesizeNonArrayTypeOfPostfixType: ts.identity,
        parenthesizeElementTypesOfTupleType: function (nodes) { return ts.cast(nodes, ts.isNodeArray); },
        parenthesizeElementTypeOfTupleType: ts.identity,
        parenthesizeTypeOfOptionalType: ts.identity,
        parenthesizeTypeArguments: function (nodes) { return nodes && ts.cast(nodes, ts.isNodeArray); },
        parenthesizeLeadingTypeArgument: ts.identity,
    };
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    function createNodeConverters(factory) {
        return {
            convertToFunctionBlock: convertToFunctionBlock,
            convertToFunctionExpression: convertToFunctionExpression,
            convertToArrayAssignmentElement: convertToArrayAssignmentElement,
            convertToObjectAssignmentElement: convertToObjectAssignmentElement,
            convertToAssignmentPattern: convertToAssignmentPattern,
            convertToObjectAssignmentPattern: convertToObjectAssignmentPattern,
            convertToArrayAssignmentPattern: convertToArrayAssignmentPattern,
            convertToAssignmentElementTarget: convertToAssignmentElementTarget,
        };
        function convertToFunctionBlock(node, multiLine) {
            if (ts.isBlock(node))
                return node;
            var returnStatement = factory.createReturnStatement(node);
            ts.setTextRange(returnStatement, node);
            var body = factory.createBlock([returnStatement], multiLine);
            ts.setTextRange(body, node);
            return body;
        }
        function convertToFunctionExpression(node) {
            if (!node.body)
                return ts.Debug.fail("Cannot convert a FunctionDeclaration without a body");
            var updated = factory.createFunctionExpression(node.modifiers, node.asteriskToken, node.name, node.typeParameters, node.parameters, node.type, node.body);
            ts.setOriginalNode(updated, node);
            ts.setTextRange(updated, node);
            if (ts.getStartsOnNewLine(node)) {
                ts.setStartsOnNewLine(updated, /*newLine*/ true);
            }
            return updated;
        }
        function convertToArrayAssignmentElement(element) {
            if (ts.isBindingElement(element)) {
                if (element.dotDotDotToken) {
                    ts.Debug.assertNode(element.name, ts.isIdentifier);
                    return ts.setOriginalNode(ts.setTextRange(factory.createSpreadElement(element.name), element), element);
                }
                var expression = convertToAssignmentElementTarget(element.name);
                return element.initializer
                    ? ts.setOriginalNode(ts.setTextRange(factory.createAssignment(expression, element.initializer), element), element)
                    : expression;
            }
            return ts.cast(element, ts.isExpression);
        }
        function convertToObjectAssignmentElement(element) {
            if (ts.isBindingElement(element)) {
                if (element.dotDotDotToken) {
                    ts.Debug.assertNode(element.name, ts.isIdentifier);
                    return ts.setOriginalNode(ts.setTextRange(factory.createSpreadAssignment(element.name), element), element);
                }
                if (element.propertyName) {
                    var expression = convertToAssignmentElementTarget(element.name);
                    return ts.setOriginalNode(ts.setTextRange(factory.createPropertyAssignment(element.propertyName, element.initializer ? factory.createAssignment(expression, element.initializer) : expression), element), element);
                }
                ts.Debug.assertNode(element.name, ts.isIdentifier);
                return ts.setOriginalNode(ts.setTextRange(factory.createShorthandPropertyAssignment(element.name, element.initializer), element), element);
            }
            return ts.cast(element, ts.isObjectLiteralElementLike);
        }
        function convertToAssignmentPattern(node) {
            switch (node.kind) {
                case 202 /* SyntaxKind.ArrayBindingPattern */:
                case 204 /* SyntaxKind.ArrayLiteralExpression */:
                    return convertToArrayAssignmentPattern(node);
                case 201 /* SyntaxKind.ObjectBindingPattern */:
                case 205 /* SyntaxKind.ObjectLiteralExpression */:
                    return convertToObjectAssignmentPattern(node);
            }
        }
        function convertToObjectAssignmentPattern(node) {
            if (ts.isObjectBindingPattern(node)) {
                return ts.setOriginalNode(ts.setTextRange(factory.createObjectLiteralExpression(ts.map(node.elements, convertToObjectAssignmentElement)), node), node);
            }
            return ts.cast(node, ts.isObjectLiteralExpression);
        }
        function convertToArrayAssignmentPattern(node) {
            if (ts.isArrayBindingPattern(node)) {
                return ts.setOriginalNode(ts.setTextRange(factory.createArrayLiteralExpression(ts.map(node.elements, convertToArrayAssignmentElement)), node), node);
            }
            return ts.cast(node, ts.isArrayLiteralExpression);
        }
        function convertToAssignmentElementTarget(node) {
            if (ts.isBindingPattern(node)) {
                return convertToAssignmentPattern(node);
            }
            return ts.cast(node, ts.isExpression);
        }
    }
    ts.createNodeConverters = createNodeConverters;
    ts.nullNodeConverters = {
        convertToFunctionBlock: ts.notImplemented,
        convertToFunctionExpression: ts.notImplemented,
        convertToArrayAssignmentElement: ts.notImplemented,
        convertToObjectAssignmentElement: ts.notImplemented,
        convertToAssignmentPattern: ts.notImplemented,
        convertToObjectAssignmentPattern: ts.notImplemented,
        convertToArrayAssignmentPattern: ts.notImplemented,
        convertToAssignmentElementTarget: ts.notImplemented,
    };
})(ts || (ts = {}));
var ts;
(function (ts) {
    var nextAutoGenerateId = 0;
    /* @internal */
    var NodeFactoryFlags;
    (function (NodeFactoryFlags) {
        NodeFactoryFlags[NodeFactoryFlags["None"] = 0] = "None";
        // Disables the parenthesizer rules for the factory.
        NodeFactoryFlags[NodeFactoryFlags["NoParenthesizerRules"] = 1] = "NoParenthesizerRules";
        // Disables the node converters for the factory.
        NodeFactoryFlags[NodeFactoryFlags["NoNodeConverters"] = 2] = "NoNodeConverters";
        // Ensures new `PropertyAccessExpression` nodes are created with the `NoIndentation` emit flag set.
        NodeFactoryFlags[NodeFactoryFlags["NoIndentationOnFreshPropertyAccess"] = 4] = "NoIndentationOnFreshPropertyAccess";
        // Do not set an `original` pointer when updating a node.
        NodeFactoryFlags[NodeFactoryFlags["NoOriginalNode"] = 8] = "NoOriginalNode";
    })(NodeFactoryFlags = ts.NodeFactoryFlags || (ts.NodeFactoryFlags = {}));
    /**
     * Creates a `NodeFactory` that can be used to create and update a syntax tree.
     * @param flags Flags that control factory behavior.
     * @param baseFactory A `BaseNodeFactory` used to create the base `Node` objects.
     */
    /* @internal */
    function createNodeFactory(flags, baseFactory) {
        var update = flags & 8 /* NodeFactoryFlags.NoOriginalNode */ ? updateWithoutOriginal : updateWithOriginal;
        // Lazily load the parenthesizer, node converters, and some factory methods until they are used.
        var parenthesizerRules = ts.memoize(function () { return flags & 1 /* NodeFactoryFlags.NoParenthesizerRules */ ? ts.nullParenthesizerRules : ts.createParenthesizerRules(factory); });
        var converters = ts.memoize(function () { return flags & 2 /* NodeFactoryFlags.NoNodeConverters */ ? ts.nullNodeConverters : ts.createNodeConverters(factory); });
        // lazy initializaton of common operator factories
        var getBinaryCreateFunction = ts.memoizeOne(function (operator) { return function (left, right) { return createBinaryExpression(left, operator, right); }; });
        var getPrefixUnaryCreateFunction = ts.memoizeOne(function (operator) { return function (operand) { return createPrefixUnaryExpression(operator, operand); }; });
        var getPostfixUnaryCreateFunction = ts.memoizeOne(function (operator) { return function (operand) { return createPostfixUnaryExpression(operand, operator); }; });
        var getJSDocPrimaryTypeCreateFunction = ts.memoizeOne(function (kind) { return function () { return createJSDocPrimaryTypeWorker(kind); }; });
        var getJSDocUnaryTypeCreateFunction = ts.memoizeOne(function (kind) { return function (type) { return createJSDocUnaryTypeWorker(kind, type); }; });
        var getJSDocUnaryTypeUpdateFunction = ts.memoizeOne(function (kind) { return function (node, type) { return updateJSDocUnaryTypeWorker(kind, node, type); }; });
        var getJSDocPrePostfixUnaryTypeCreateFunction = ts.memoizeOne(function (kind) { return function (type, postfix) { return createJSDocPrePostfixUnaryTypeWorker(kind, type, postfix); }; });
        var getJSDocPrePostfixUnaryTypeUpdateFunction = ts.memoizeOne(function (kind) { return function (node, type) { return updateJSDocPrePostfixUnaryTypeWorker(kind, node, type); }; });
        var getJSDocSimpleTagCreateFunction = ts.memoizeOne(function (kind) { return function (tagName, comment) { return createJSDocSimpleTagWorker(kind, tagName, comment); }; });
        var getJSDocSimpleTagUpdateFunction = ts.memoizeOne(function (kind) { return function (node, tagName, comment) { return updateJSDocSimpleTagWorker(kind, node, tagName, comment); }; });
        var getJSDocTypeLikeTagCreateFunction = ts.memoizeOne(function (kind) { return function (tagName, typeExpression, comment) { return createJSDocTypeLikeTagWorker(kind, tagName, typeExpression, comment); }; });
        var getJSDocTypeLikeTagUpdateFunction = ts.memoizeOne(function (kind) { return function (node, tagName, typeExpression, comment) { return updateJSDocTypeLikeTagWorker(kind, node, tagName, typeExpression, comment); }; });
        var factory = {
            get parenthesizer() { return parenthesizerRules(); },
            get converters() { return converters(); },
            baseFactory: baseFactory,
            flags: flags,
            createNodeArray: createNodeArray,
            createNumericLiteral: createNumericLiteral,
            createBigIntLiteral: createBigIntLiteral,
            createStringLiteral: createStringLiteral,
            createStringLiteralFromNode: createStringLiteralFromNode,
            createRegularExpressionLiteral: createRegularExpressionLiteral,
            createLiteralLikeNode: createLiteralLikeNode,
            createIdentifier: createIdentifier,
            updateIdentifier: updateIdentifier,
            createTempVariable: createTempVariable,
            createLoopVariable: createLoopVariable,
            createUniqueName: createUniqueName,
            getGeneratedNameForNode: getGeneratedNameForNode,
            createPrivateIdentifier: createPrivateIdentifier,
            createToken: createToken,
            createSuper: createSuper,
            createThis: createThis,
            createNull: createNull,
            createTrue: createTrue,
            createFalse: createFalse,
            createModifier: createModifier,
            createModifiersFromModifierFlags: createModifiersFromModifierFlags,
            createQualifiedName: createQualifiedName,
            updateQualifiedName: updateQualifiedName,
            createComputedPropertyName: createComputedPropertyName,
            updateComputedPropertyName: updateComputedPropertyName,
            createTypeParameterDeclaration: createTypeParameterDeclaration,
            updateTypeParameterDeclaration: updateTypeParameterDeclaration,
            createParameterDeclaration: createParameterDeclaration,
            updateParameterDeclaration: updateParameterDeclaration,
            createDecorator: createDecorator,
            updateDecorator: updateDecorator,
            createPropertySignature: createPropertySignature,
            updatePropertySignature: updatePropertySignature,
            createPropertyDeclaration: createPropertyDeclaration,
            updatePropertyDeclaration: updatePropertyDeclaration,
            createMethodSignature: createMethodSignature,
            updateMethodSignature: updateMethodSignature,
            createMethodDeclaration: createMethodDeclaration,
            updateMethodDeclaration: updateMethodDeclaration,
            createConstructorDeclaration: createConstructorDeclaration,
            updateConstructorDeclaration: updateConstructorDeclaration,
            createGetAccessorDeclaration: createGetAccessorDeclaration,
            updateGetAccessorDeclaration: updateGetAccessorDeclaration,
            createSetAccessorDeclaration: createSetAccessorDeclaration,
            updateSetAccessorDeclaration: updateSetAccessorDeclaration,
            createCallSignature: createCallSignature,
            updateCallSignature: updateCallSignature,
            createConstructSignature: createConstructSignature,
            updateConstructSignature: updateConstructSignature,
            createIndexSignature: createIndexSignature,
            updateIndexSignature: updateIndexSignature,
            createClassStaticBlockDeclaration: createClassStaticBlockDeclaration,
            updateClassStaticBlockDeclaration: updateClassStaticBlockDeclaration,
            createTemplateLiteralTypeSpan: createTemplateLiteralTypeSpan,
            updateTemplateLiteralTypeSpan: updateTemplateLiteralTypeSpan,
            createKeywordTypeNode: createKeywordTypeNode,
            createTypePredicateNode: createTypePredicateNode,
            updateTypePredicateNode: updateTypePredicateNode,
            createTypeReferenceNode: createTypeReferenceNode,
            updateTypeReferenceNode: updateTypeReferenceNode,
            createFunctionTypeNode: createFunctionTypeNode,
            updateFunctionTypeNode: updateFunctionTypeNode,
            createConstructorTypeNode: createConstructorTypeNode,
            updateConstructorTypeNode: updateConstructorTypeNode,
            createTypeQueryNode: createTypeQueryNode,
            updateTypeQueryNode: updateTypeQueryNode,
            createTypeLiteralNode: createTypeLiteralNode,
            updateTypeLiteralNode: updateTypeLiteralNode,
            createArrayTypeNode: createArrayTypeNode,
            updateArrayTypeNode: updateArrayTypeNode,
            createTupleTypeNode: createTupleTypeNode,
            updateTupleTypeNode: updateTupleTypeNode,
            createNamedTupleMember: createNamedTupleMember,
            updateNamedTupleMember: updateNamedTupleMember,
            createOptionalTypeNode: createOptionalTypeNode,
            updateOptionalTypeNode: updateOptionalTypeNode,
            createRestTypeNode: createRestTypeNode,
            updateRestTypeNode: updateRestTypeNode,
            createUnionTypeNode: createUnionTypeNode,
            updateUnionTypeNode: updateUnionTypeNode,
            createIntersectionTypeNode: createIntersectionTypeNode,
            updateIntersectionTypeNode: updateIntersectionTypeNode,
            createConditionalTypeNode: createConditionalTypeNode,
            updateConditionalTypeNode: updateConditionalTypeNode,
            createInferTypeNode: createInferTypeNode,
            updateInferTypeNode: updateInferTypeNode,
            createImportTypeNode: createImportTypeNode,
            updateImportTypeNode: updateImportTypeNode,
            createParenthesizedType: createParenthesizedType,
            updateParenthesizedType: updateParenthesizedType,
            createThisTypeNode: createThisTypeNode,
            createTypeOperatorNode: createTypeOperatorNode,
            updateTypeOperatorNode: updateTypeOperatorNode,
            createIndexedAccessTypeNode: createIndexedAccessTypeNode,
            updateIndexedAccessTypeNode: updateIndexedAccessTypeNode,
            createMappedTypeNode: createMappedTypeNode,
            updateMappedTypeNode: updateMappedTypeNode,
            createLiteralTypeNode: createLiteralTypeNode,
            updateLiteralTypeNode: updateLiteralTypeNode,
            createTemplateLiteralType: createTemplateLiteralType,
            updateTemplateLiteralType: updateTemplateLiteralType,
            createObjectBindingPattern: createObjectBindingPattern,
            updateObjectBindingPattern: updateObjectBindingPattern,
            createArrayBindingPattern: createArrayBindingPattern,
            updateArrayBindingPattern: updateArrayBindingPattern,
            createBindingElement: createBindingElement,
            updateBindingElement: updateBindingElement,
            createArrayLiteralExpression: createArrayLiteralExpression,
            updateArrayLiteralExpression: updateArrayLiteralExpression,
            createObjectLiteralExpression: createObjectLiteralExpression,
            updateObjectLiteralExpression: updateObjectLiteralExpression,
            createPropertyAccessExpression: flags & 4 /* NodeFactoryFlags.NoIndentationOnFreshPropertyAccess */ ?
                function (expression, name) { return ts.setEmitFlags(createPropertyAccessExpression(expression, name), 131072 /* EmitFlags.NoIndentation */); } :
                createPropertyAccessExpression,
            updatePropertyAccessExpression: updatePropertyAccessExpression,
            createPropertyAccessChain: flags & 4 /* NodeFactoryFlags.NoIndentationOnFreshPropertyAccess */ ?
                function (expression, questionDotToken, name) { return ts.setEmitFlags(createPropertyAccessChain(expression, questionDotToken, name), 131072 /* EmitFlags.NoIndentation */); } :
                createPropertyAccessChain,
            updatePropertyAccessChain: updatePropertyAccessChain,
            createElementAccessExpression: createElementAccessExpression,
            updateElementAccessExpression: updateElementAccessExpression,
            createElementAccessChain: createElementAccessChain,
            updateElementAccessChain: updateElementAccessChain,
            createCallExpression: createCallExpression,
            updateCallExpression: updateCallExpression,
            createCallChain: createCallChain,
            updateCallChain: updateCallChain,
            createNewExpression: createNewExpression,
            updateNewExpression: updateNewExpression,
            createTaggedTemplateExpression: createTaggedTemplateExpression,
            updateTaggedTemplateExpression: updateTaggedTemplateExpression,
            createTypeAssertion: createTypeAssertion,
            updateTypeAssertion: updateTypeAssertion,
            createParenthesizedExpression: createParenthesizedExpression,
            updateParenthesizedExpression: updateParenthesizedExpression,
            createFunctionExpression: createFunctionExpression,
            updateFunctionExpression: updateFunctionExpression,
            createArrowFunction: createArrowFunction,
            updateArrowFunction: updateArrowFunction,
            createDeleteExpression: createDeleteExpression,
            updateDeleteExpression: updateDeleteExpression,
            createTypeOfExpression: createTypeOfExpression,
            updateTypeOfExpression: updateTypeOfExpression,
            createVoidExpression: createVoidExpression,
            updateVoidExpression: updateVoidExpression,
            createAwaitExpression: createAwaitExpression,
            updateAwaitExpression: updateAwaitExpression,
            createPrefixUnaryExpression: createPrefixUnaryExpression,
            updatePrefixUnaryExpression: updatePrefixUnaryExpression,
            createPostfixUnaryExpression: createPostfixUnaryExpression,
            updatePostfixUnaryExpression: updatePostfixUnaryExpression,
            createBinaryExpression: createBinaryExpression,
            updateBinaryExpression: updateBinaryExpression,
            createConditionalExpression: createConditionalExpression,
            updateConditionalExpression: updateConditionalExpression,
            createTemplateExpression: createTemplateExpression,
            updateTemplateExpression: updateTemplateExpression,
            createTemplateHead: createTemplateHead,
            createTemplateMiddle: createTemplateMiddle,
            createTemplateTail: createTemplateTail,
            createNoSubstitutionTemplateLiteral: createNoSubstitutionTemplateLiteral,
            createTemplateLiteralLikeNode: createTemplateLiteralLikeNode,
            createYieldExpression: createYieldExpression,
            updateYieldExpression: updateYieldExpression,
            createSpreadElement: createSpreadElement,
            updateSpreadElement: updateSpreadElement,
            createClassExpression: createClassExpression,
            updateClassExpression: updateClassExpression,
            createOmittedExpression: createOmittedExpression,
            createExpressionWithTypeArguments: createExpressionWithTypeArguments,
            updateExpressionWithTypeArguments: updateExpressionWithTypeArguments,
            createAsExpression: createAsExpression,
            updateAsExpression: updateAsExpression,
            createNonNullExpression: createNonNullExpression,
            updateNonNullExpression: updateNonNullExpression,
            createNonNullChain: createNonNullChain,
            updateNonNullChain: updateNonNullChain,
            createMetaProperty: createMetaProperty,
            updateMetaProperty: updateMetaProperty,
            createTemplateSpan: createTemplateSpan,
            updateTemplateSpan: updateTemplateSpan,
            createSemicolonClassElement: createSemicolonClassElement,
            createBlock: createBlock,
            updateBlock: updateBlock,
            createVariableStatement: createVariableStatement,
            updateVariableStatement: updateVariableStatement,
            createEmptyStatement: createEmptyStatement,
            createExpressionStatement: createExpressionStatement,
            updateExpressionStatement: updateExpressionStatement,
            createIfStatement: createIfStatement,
            updateIfStatement: updateIfStatement,
            createDoStatement: createDoStatement,
            updateDoStatement: updateDoStatement,
            createWhileStatement: createWhileStatement,
            updateWhileStatement: updateWhileStatement,
            createForStatement: createForStatement,
            updateForStatement: updateForStatement,
            createForInStatement: createForInStatement,
            updateForInStatement: updateForInStatement,
            createForOfStatement: createForOfStatement,
            updateForOfStatement: updateForOfStatement,
            createContinueStatement: createContinueStatement,
            updateContinueStatement: updateContinueStatement,
            createBreakStatement: createBreakStatement,
            updateBreakStatement: updateBreakStatement,
            createReturnStatement: createReturnStatement,
            updateReturnStatement: updateReturnStatement,
            createWithStatement: createWithStatement,
            updateWithStatement: updateWithStatement,
            createSwitchStatement: createSwitchStatement,
            updateSwitchStatement: updateSwitchStatement,
            createLabeledStatement: createLabeledStatement,
            updateLabeledStatement: updateLabeledStatement,
            createThrowStatement: createThrowStatement,
            updateThrowStatement: updateThrowStatement,
            createTryStatement: createTryStatement,
            updateTryStatement: updateTryStatement,
            createDebuggerStatement: createDebuggerStatement,
            createVariableDeclaration: createVariableDeclaration,
            updateVariableDeclaration: updateVariableDeclaration,
            createVariableDeclarationList: createVariableDeclarationList,
            updateVariableDeclarationList: updateVariableDeclarationList,
            createFunctionDeclaration: createFunctionDeclaration,
            updateFunctionDeclaration: updateFunctionDeclaration,
            createClassDeclaration: createClassDeclaration,
            updateClassDeclaration: updateClassDeclaration,
            createInterfaceDeclaration: createInterfaceDeclaration,
            updateInterfaceDeclaration: updateInterfaceDeclaration,
            createTypeAliasDeclaration: createTypeAliasDeclaration,
            updateTypeAliasDeclaration: updateTypeAliasDeclaration,
            createEnumDeclaration: createEnumDeclaration,
            updateEnumDeclaration: updateEnumDeclaration,
            createModuleDeclaration: createModuleDeclaration,
            updateModuleDeclaration: updateModuleDeclaration,
            createModuleBlock: createModuleBlock,
            updateModuleBlock: updateModuleBlock,
            createCaseBlock: createCaseBlock,
            updateCaseBlock: updateCaseBlock,
            createNamespaceExportDeclaration: createNamespaceExportDeclaration,
            updateNamespaceExportDeclaration: updateNamespaceExportDeclaration,
            createImportEqualsDeclaration: createImportEqualsDeclaration,
            updateImportEqualsDeclaration: updateImportEqualsDeclaration,
            createImportDeclaration: createImportDeclaration,
            updateImportDeclaration: updateImportDeclaration,
            createImportClause: createImportClause,
            updateImportClause: updateImportClause,
            createAssertClause: createAssertClause,
            updateAssertClause: updateAssertClause,
            createAssertEntry: createAssertEntry,
            updateAssertEntry: updateAssertEntry,
            createImportTypeAssertionContainer: createImportTypeAssertionContainer,
            updateImportTypeAssertionContainer: updateImportTypeAssertionContainer,
            createNamespaceImport: createNamespaceImport,
            updateNamespaceImport: updateNamespaceImport,
            createNamespaceExport: createNamespaceExport,
            updateNamespaceExport: updateNamespaceExport,
            createNamedImports: createNamedImports,
            updateNamedImports: updateNamedImports,
            createImportSpecifier: createImportSpecifier,
            updateImportSpecifier: updateImportSpecifier,
            createExportAssignment: createExportAssignment,
            updateExportAssignment: updateExportAssignment,
            createExportDeclaration: createExportDeclaration,
            updateExportDeclaration: updateExportDeclaration,
            createNamedExports: createNamedExports,
            updateNamedExports: updateNamedExports,
            createExportSpecifier: createExportSpecifier,
            updateExportSpecifier: updateExportSpecifier,
            createMissingDeclaration: createMissingDeclaration,
            createExternalModuleReference: createExternalModuleReference,
            updateExternalModuleReference: updateExternalModuleReference,
            // lazily load factory members for JSDoc types with similar structure
            get createJSDocAllType() { return getJSDocPrimaryTypeCreateFunction(312 /* SyntaxKind.JSDocAllType */); },
            get createJSDocUnknownType() { return getJSDocPrimaryTypeCreateFunction(313 /* SyntaxKind.JSDocUnknownType */); },
            get createJSDocNonNullableType() { return getJSDocPrePostfixUnaryTypeCreateFunction(315 /* SyntaxKind.JSDocNonNullableType */); },
            get updateJSDocNonNullableType() { return getJSDocPrePostfixUnaryTypeUpdateFunction(315 /* SyntaxKind.JSDocNonNullableType */); },
            get createJSDocNullableType() { return getJSDocPrePostfixUnaryTypeCreateFunction(314 /* SyntaxKind.JSDocNullableType */); },
            get updateJSDocNullableType() { return getJSDocPrePostfixUnaryTypeUpdateFunction(314 /* SyntaxKind.JSDocNullableType */); },
            get createJSDocOptionalType() { return getJSDocUnaryTypeCreateFunction(316 /* SyntaxKind.JSDocOptionalType */); },
            get updateJSDocOptionalType() { return getJSDocUnaryTypeUpdateFunction(316 /* SyntaxKind.JSDocOptionalType */); },
            get createJSDocVariadicType() { return getJSDocUnaryTypeCreateFunction(318 /* SyntaxKind.JSDocVariadicType */); },
            get updateJSDocVariadicType() { return getJSDocUnaryTypeUpdateFunction(318 /* SyntaxKind.JSDocVariadicType */); },
            get createJSDocNamepathType() { return getJSDocUnaryTypeCreateFunction(319 /* SyntaxKind.JSDocNamepathType */); },
            get updateJSDocNamepathType() { return getJSDocUnaryTypeUpdateFunction(319 /* SyntaxKind.JSDocNamepathType */); },
            createJSDocFunctionType: createJSDocFunctionType,
            updateJSDocFunctionType: updateJSDocFunctionType,
            createJSDocTypeLiteral: createJSDocTypeLiteral,
            updateJSDocTypeLiteral: updateJSDocTypeLiteral,
            createJSDocTypeExpression: createJSDocTypeExpression,
            updateJSDocTypeExpression: updateJSDocTypeExpression,
            createJSDocSignature: createJSDocSignature,
            updateJSDocSignature: updateJSDocSignature,
            createJSDocTemplateTag: createJSDocTemplateTag,
            updateJSDocTemplateTag: updateJSDocTemplateTag,
            createJSDocTypedefTag: createJSDocTypedefTag,
            updateJSDocTypedefTag: updateJSDocTypedefTag,
            createJSDocParameterTag: createJSDocParameterTag,
            updateJSDocParameterTag: updateJSDocParameterTag,
            createJSDocPropertyTag: createJSDocPropertyTag,
            updateJSDocPropertyTag: updateJSDocPropertyTag,
            createJSDocCallbackTag: createJSDocCallbackTag,
            updateJSDocCallbackTag: updateJSDocCallbackTag,
            createJSDocAugmentsTag: createJSDocAugmentsTag,
            updateJSDocAugmentsTag: updateJSDocAugmentsTag,
            createJSDocImplementsTag: createJSDocImplementsTag,
            updateJSDocImplementsTag: updateJSDocImplementsTag,
            createJSDocSeeTag: createJSDocSeeTag,
            updateJSDocSeeTag: updateJSDocSeeTag,
            createJSDocNameReference: createJSDocNameReference,
            updateJSDocNameReference: updateJSDocNameReference,
            createJSDocMemberName: createJSDocMemberName,
            updateJSDocMemberName: updateJSDocMemberName,
            createJSDocLink: createJSDocLink,
            updateJSDocLink: updateJSDocLink,
            createJSDocLinkCode: createJSDocLinkCode,
            updateJSDocLinkCode: updateJSDocLinkCode,
            createJSDocLinkPlain: createJSDocLinkPlain,
            updateJSDocLinkPlain: updateJSDocLinkPlain,
            // lazily load factory members for JSDoc tags with similar structure
            get createJSDocTypeTag() { return getJSDocTypeLikeTagCreateFunction(343 /* SyntaxKind.JSDocTypeTag */); },
            get updateJSDocTypeTag() { return getJSDocTypeLikeTagUpdateFunction(343 /* SyntaxKind.JSDocTypeTag */); },
            get createJSDocReturnTag() { return getJSDocTypeLikeTagCreateFunction(341 /* SyntaxKind.JSDocReturnTag */); },
            get updateJSDocReturnTag() { return getJSDocTypeLikeTagUpdateFunction(341 /* SyntaxKind.JSDocReturnTag */); },
            get createJSDocThisTag() { return getJSDocTypeLikeTagCreateFunction(342 /* SyntaxKind.JSDocThisTag */); },
            get updateJSDocThisTag() { return getJSDocTypeLikeTagUpdateFunction(342 /* SyntaxKind.JSDocThisTag */); },
            get createJSDocEnumTag() { return getJSDocTypeLikeTagCreateFunction(339 /* SyntaxKind.JSDocEnumTag */); },
            get updateJSDocEnumTag() { return getJSDocTypeLikeTagUpdateFunction(339 /* SyntaxKind.JSDocEnumTag */); },
            get createJSDocAuthorTag() { return getJSDocSimpleTagCreateFunction(330 /* SyntaxKind.JSDocAuthorTag */); },
            get updateJSDocAuthorTag() { return getJSDocSimpleTagUpdateFunction(330 /* SyntaxKind.JSDocAuthorTag */); },
            get createJSDocClassTag() { return getJSDocSimpleTagCreateFunction(332 /* SyntaxKind.JSDocClassTag */); },
            get updateJSDocClassTag() { return getJSDocSimpleTagUpdateFunction(332 /* SyntaxKind.JSDocClassTag */); },
            get createJSDocPublicTag() { return getJSDocSimpleTagCreateFunction(333 /* SyntaxKind.JSDocPublicTag */); },
            get updateJSDocPublicTag() { return getJSDocSimpleTagUpdateFunction(333 /* SyntaxKind.JSDocPublicTag */); },
            get createJSDocPrivateTag() { return getJSDocSimpleTagCreateFunction(334 /* SyntaxKind.JSDocPrivateTag */); },
            get updateJSDocPrivateTag() { return getJSDocSimpleTagUpdateFunction(334 /* SyntaxKind.JSDocPrivateTag */); },
            get createJSDocProtectedTag() { return getJSDocSimpleTagCreateFunction(335 /* SyntaxKind.JSDocProtectedTag */); },
            get updateJSDocProtectedTag() { return getJSDocSimpleTagUpdateFunction(335 /* SyntaxKind.JSDocProtectedTag */); },
            get createJSDocReadonlyTag() { return getJSDocSimpleTagCreateFunction(336 /* SyntaxKind.JSDocReadonlyTag */); },
            get updateJSDocReadonlyTag() { return getJSDocSimpleTagUpdateFunction(336 /* SyntaxKind.JSDocReadonlyTag */); },
            get createJSDocOverrideTag() { return getJSDocSimpleTagCreateFunction(337 /* SyntaxKind.JSDocOverrideTag */); },
            get updateJSDocOverrideTag() { return getJSDocSimpleTagUpdateFunction(337 /* SyntaxKind.JSDocOverrideTag */); },
            get createJSDocDeprecatedTag() { return getJSDocSimpleTagCreateFunction(331 /* SyntaxKind.JSDocDeprecatedTag */); },
            get updateJSDocDeprecatedTag() { return getJSDocSimpleTagUpdateFunction(331 /* SyntaxKind.JSDocDeprecatedTag */); },
            createJSDocUnknownTag: createJSDocUnknownTag,
            updateJSDocUnknownTag: updateJSDocUnknownTag,
            createJSDocText: createJSDocText,
            updateJSDocText: updateJSDocText,
            createJSDocComment: createJSDocComment,
            updateJSDocComment: updateJSDocComment,
            createJsxElement: createJsxElement,
            updateJsxElement: updateJsxElement,
            createJsxSelfClosingElement: createJsxSelfClosingElement,
            updateJsxSelfClosingElement: updateJsxSelfClosingElement,
            createJsxOpeningElement: createJsxOpeningElement,
            updateJsxOpeningElement: updateJsxOpeningElement,
            createJsxClosingElement: createJsxClosingElement,
            updateJsxClosingElement: updateJsxClosingElement,
            createJsxFragment: createJsxFragment,
            createJsxText: createJsxText,
            updateJsxText: updateJsxText,
            createJsxOpeningFragment: createJsxOpeningFragment,
            createJsxJsxClosingFragment: createJsxJsxClosingFragment,
            updateJsxFragment: updateJsxFragment,
            createJsxAttribute: createJsxAttribute,
            updateJsxAttribute: updateJsxAttribute,
            createJsxAttributes: createJsxAttributes,
            updateJsxAttributes: updateJsxAttributes,
            createJsxSpreadAttribute: createJsxSpreadAttribute,
            updateJsxSpreadAttribute: updateJsxSpreadAttribute,
            createJsxExpression: createJsxExpression,
            updateJsxExpression: updateJsxExpression,
            createCaseClause: createCaseClause,
            updateCaseClause: updateCaseClause,
            createDefaultClause: createDefaultClause,
            updateDefaultClause: updateDefaultClause,
            createHeritageClause: createHeritageClause,
            updateHeritageClause: updateHeritageClause,
            createCatchClause: createCatchClause,
            updateCatchClause: updateCatchClause,
            createPropertyAssignment: createPropertyAssignment,
            updatePropertyAssignment: updatePropertyAssignment,
            createShorthandPropertyAssignment: createShorthandPropertyAssignment,
            updateShorthandPropertyAssignment: updateShorthandPropertyAssignment,
            createSpreadAssignment: createSpreadAssignment,
            updateSpreadAssignment: updateSpreadAssignment,
            createEnumMember: createEnumMember,
            updateEnumMember: updateEnumMember,
            createSourceFile: createSourceFile,
            updateSourceFile: updateSourceFile,
            createBundle: createBundle,
            updateBundle: updateBundle,
            createUnparsedSource: createUnparsedSource,
            createUnparsedPrologue: createUnparsedPrologue,
            createUnparsedPrepend: createUnparsedPrepend,
            createUnparsedTextLike: createUnparsedTextLike,
            createUnparsedSyntheticReference: createUnparsedSyntheticReference,
            createInputFiles: createInputFiles,
            createSyntheticExpression: createSyntheticExpression,
            createSyntaxList: createSyntaxList,
            createNotEmittedStatement: createNotEmittedStatement,
            createPartiallyEmittedExpression: createPartiallyEmittedExpression,
            updatePartiallyEmittedExpression: updatePartiallyEmittedExpression,
            createCommaListExpression: createCommaListExpression,
            updateCommaListExpression: updateCommaListExpression,
            createEndOfDeclarationMarker: createEndOfDeclarationMarker,
            createMergeDeclarationMarker: createMergeDeclarationMarker,
            createSyntheticReferenceExpression: createSyntheticReferenceExpression,
            updateSyntheticReferenceExpression: updateSyntheticReferenceExpression,
            cloneNode: cloneNode,
            // Lazily load factory methods for common operator factories and utilities
            get createComma() { return getBinaryCreateFunction(27 /* SyntaxKind.CommaToken */); },
            get createAssignment() { return getBinaryCreateFunction(63 /* SyntaxKind.EqualsToken */); },
            get createLogicalOr() { return getBinaryCreateFunction(56 /* SyntaxKind.BarBarToken */); },
            get createLogicalAnd() { return getBinaryCreateFunction(55 /* SyntaxKind.AmpersandAmpersandToken */); },
            get createBitwiseOr() { return getBinaryCreateFunction(51 /* SyntaxKind.BarToken */); },
            get createBitwiseXor() { return getBinaryCreateFunction(52 /* SyntaxKind.CaretToken */); },
            get createBitwiseAnd() { return getBinaryCreateFunction(50 /* SyntaxKind.AmpersandToken */); },
            get createStrictEquality() { return getBinaryCreateFunction(36 /* SyntaxKind.EqualsEqualsEqualsToken */); },
            get createStrictInequality() { return getBinaryCreateFunction(37 /* SyntaxKind.ExclamationEqualsEqualsToken */); },
            get createEquality() { return getBinaryCreateFunction(34 /* SyntaxKind.EqualsEqualsToken */); },
            get createInequality() { return getBinaryCreateFunction(35 /* SyntaxKind.ExclamationEqualsToken */); },
            get createLessThan() { return getBinaryCreateFunction(29 /* SyntaxKind.LessThanToken */); },
            get createLessThanEquals() { return getBinaryCreateFunction(32 /* SyntaxKind.LessThanEqualsToken */); },
            get createGreaterThan() { return getBinaryCreateFunction(31 /* SyntaxKind.GreaterThanToken */); },
            get createGreaterThanEquals() { return getBinaryCreateFunction(33 /* SyntaxKind.GreaterThanEqualsToken */); },
            get createLeftShift() { return getBinaryCreateFunction(47 /* SyntaxKind.LessThanLessThanToken */); },
            get createRightShift() { return getBinaryCreateFunction(48 /* SyntaxKind.GreaterThanGreaterThanToken */); },
            get createUnsignedRightShift() { return getBinaryCreateFunction(49 /* SyntaxKind.GreaterThanGreaterThanGreaterThanToken */); },
            get createAdd() { return getBinaryCreateFunction(39 /* SyntaxKind.PlusToken */); },
            get createSubtract() { return getBinaryCreateFunction(40 /* SyntaxKind.MinusToken */); },
            get createMultiply() { return getBinaryCreateFunction(41 /* SyntaxKind.AsteriskToken */); },
            get createDivide() { return getBinaryCreateFunction(43 /* SyntaxKind.SlashToken */); },
            get createModulo() { return getBinaryCreateFunction(44 /* SyntaxKind.PercentToken */); },
            get createExponent() { return getBinaryCreateFunction(42 /* SyntaxKind.AsteriskAsteriskToken */); },
            get createPrefixPlus() { return getPrefixUnaryCreateFunction(39 /* SyntaxKind.PlusToken */); },
            get createPrefixMinus() { return getPrefixUnaryCreateFunction(40 /* SyntaxKind.MinusToken */); },
            get createPrefixIncrement() { return getPrefixUnaryCreateFunction(45 /* SyntaxKind.PlusPlusToken */); },
            get createPrefixDecrement() { return getPrefixUnaryCreateFunction(46 /* SyntaxKind.MinusMinusToken */); },
            get createBitwiseNot() { return getPrefixUnaryCreateFunction(54 /* SyntaxKind.TildeToken */); },
            get createLogicalNot() { return getPrefixUnaryCreateFunction(53 /* SyntaxKind.ExclamationToken */); },
            get createPostfixIncrement() { return getPostfixUnaryCreateFunction(45 /* SyntaxKind.PlusPlusToken */); },
            get createPostfixDecrement() { return getPostfixUnaryCreateFunction(46 /* SyntaxKind.MinusMinusToken */); },
            // Compound nodes
            createImmediatelyInvokedFunctionExpression: createImmediatelyInvokedFunctionExpression,
            createImmediatelyInvokedArrowFunction: createImmediatelyInvokedArrowFunction,
            createVoidZero: createVoidZero,
            createExportDefault: createExportDefault,
            createExternalModuleExport: createExternalModuleExport,
            createTypeCheck: createTypeCheck,
            createMethodCall: createMethodCall,
            createGlobalMethodCall: createGlobalMethodCall,
            createFunctionBindCall: createFunctionBindCall,
            createFunctionCallCall: createFunctionCallCall,
            createFunctionApplyCall: createFunctionApplyCall,
            createArraySliceCall: createArraySliceCall,
            createArrayConcatCall: createArrayConcatCall,
            createObjectDefinePropertyCall: createObjectDefinePropertyCall,
            createReflectGetCall: createReflectGetCall,
            createReflectSetCall: createReflectSetCall,
            createPropertyDescriptor: createPropertyDescriptor,
            createCallBinding: createCallBinding,
            createAssignmentTargetWrapper: createAssignmentTargetWrapper,
            // Utilities
            inlineExpressions: inlineExpressions,
            getInternalName: getInternalName,
            getLocalName: getLocalName,
            getExportName: getExportName,
            getDeclarationName: getDeclarationName,
            getNamespaceMemberName: getNamespaceMemberName,
            getExternalModuleOrNamespaceExportName: getExternalModuleOrNamespaceExportName,
            restoreOuterExpressions: restoreOuterExpressions,
            restoreEnclosingLabel: restoreEnclosingLabel,
            createUseStrictPrologue: createUseStrictPrologue,
            copyPrologue: copyPrologue,
            copyStandardPrologue: copyStandardPrologue,
            copyCustomPrologue: copyCustomPrologue,
            ensureUseStrict: ensureUseStrict,
            liftToBlock: liftToBlock,
            mergeLexicalEnvironment: mergeLexicalEnvironment,
            updateModifiers: updateModifiers,
        };
        return factory;
        // @api
        function createNodeArray(elements, hasTrailingComma) {
            if (elements === undefined || elements === ts.emptyArray) {
                elements = [];
            }
            else if (ts.isNodeArray(elements)) {
                if (hasTrailingComma === undefined || elements.hasTrailingComma === hasTrailingComma) {
                    // Ensure the transform flags have been aggregated for this NodeArray
                    if (elements.transformFlags === undefined) {
                        aggregateChildrenFlags(elements);
                    }
                    ts.Debug.attachNodeArrayDebugInfo(elements);
                    return elements;
                }
                // This *was* a `NodeArray`, but the `hasTrailingComma` option differs. Recreate the
                // array with the same elements, text range, and transform flags but with the updated
                // value for `hasTrailingComma`
                var array_8 = elements.slice();
                array_8.pos = elements.pos;
                array_8.end = elements.end;
                array_8.hasTrailingComma = hasTrailingComma;
                array_8.transformFlags = elements.transformFlags;
                ts.Debug.attachNodeArrayDebugInfo(array_8);
                return array_8;
            }
            // Since the element list of a node array is typically created by starting with an empty array and
            // repeatedly calling push(), the list may not have the optimal memory layout. We invoke slice() for
            // small arrays (1 to 4 elements) to give the VM a chance to allocate an optimal representation.
            var length = elements.length;
            var array = (length >= 1 && length <= 4 ? elements.slice() : elements);
            ts.setTextRangePosEnd(array, -1, -1);
            array.hasTrailingComma = !!hasTrailingComma;
            aggregateChildrenFlags(array);
            ts.Debug.attachNodeArrayDebugInfo(array);
            return array;
        }
        function createBaseNode(kind) {
            return baseFactory.createBaseNode(kind);
        }
        function createBaseDeclaration(kind) {
            var node = createBaseNode(kind);
            // NOTE: The following properties are commonly set by the binder and are added here to
            // ensure declarations have a stable shape.
            node.symbol = undefined; // initialized by binder
            node.localSymbol = undefined; // initialized by binder
            node.locals = undefined; // initialized by binder
            node.nextContainer = undefined; // initialized by binder
            return node;
        }
        function createBaseNamedDeclaration(kind, modifiers, name) {
            var node = createBaseDeclaration(kind);
            name = asName(name);
            node.name = name;
            if (ts.canHaveModifiers(node)) {
                node.modifiers = asNodeArray(modifiers);
                node.transformFlags |= propagateChildrenFlags(node.modifiers);
                // node.decorators = filter(node.modifiers, isDecorator);
            }
            // The PropertyName of a member is allowed to be `await`.
            // We don't need to exclude `await` for type signatures since types
            // don't propagate child flags.
            if (name) {
                switch (node.kind) {
                    case 169 /* SyntaxKind.MethodDeclaration */:
                    case 172 /* SyntaxKind.GetAccessor */:
                    case 173 /* SyntaxKind.SetAccessor */:
                    case 167 /* SyntaxKind.PropertyDeclaration */:
                    case 296 /* SyntaxKind.PropertyAssignment */:
                        if (ts.isIdentifier(name)) {
                            node.transformFlags |= propagateIdentifierNameFlags(name);
                            break;
                        }
                    // fall through
                    default:
                        node.transformFlags |= propagateChildFlags(name);
                        break;
                }
            }
            return node;
        }
        function createBaseGenericNamedDeclaration(kind, modifiers, name, typeParameters) {
            var node = createBaseNamedDeclaration(kind, modifiers, name);
            node.typeParameters = asNodeArray(typeParameters);
            node.transformFlags |= propagateChildrenFlags(node.typeParameters);
            if (typeParameters)
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        function createBaseSignatureDeclaration(kind, modifiers, name, typeParameters, parameters, type) {
            var node = createBaseGenericNamedDeclaration(kind, modifiers, name, typeParameters);
            node.parameters = createNodeArray(parameters);
            node.type = type;
            node.transformFlags |=
                propagateChildrenFlags(node.parameters) |
                    propagateChildFlags(node.type);
            if (type)
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            // The following properties are used for quick info
            node.typeArguments = undefined;
            return node;
        }
        function finishUpdateBaseSignatureDeclaration(updated, original) {
            if (updated !== original) {
                // copy children used for quick info
                updated.typeArguments = original.typeArguments;
            }
            return update(updated, original);
        }
        function createBaseFunctionLikeDeclaration(kind, modifiers, name, typeParameters, parameters, type, body) {
            var node = createBaseSignatureDeclaration(kind, modifiers, name, typeParameters, parameters, type);
            node.body = body;
            node.transformFlags |= propagateChildFlags(node.body) & ~67108864 /* TransformFlags.ContainsPossibleTopLevelAwait */;
            if (!body)
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        function createBaseInterfaceOrClassLikeDeclaration(kind, modifiers, name, typeParameters, heritageClauses) {
            var node = createBaseGenericNamedDeclaration(kind, modifiers, name, typeParameters);
            node.heritageClauses = asNodeArray(heritageClauses);
            node.transformFlags |= propagateChildrenFlags(node.heritageClauses);
            return node;
        }
        function createBaseClassLikeDeclaration(kind, modifiers, name, typeParameters, heritageClauses, members) {
            var node = createBaseInterfaceOrClassLikeDeclaration(kind, modifiers, name, typeParameters, heritageClauses);
            node.members = createNodeArray(members);
            node.transformFlags |= propagateChildrenFlags(node.members);
            return node;
        }
        function createBaseBindingLikeDeclaration(kind, modifiers, name, initializer) {
            var node = createBaseNamedDeclaration(kind, modifiers, name);
            node.initializer = initializer;
            node.transformFlags |= propagateChildFlags(node.initializer);
            return node;
        }
        function createBaseVariableLikeDeclaration(kind, modifiers, name, type, initializer) {
            var node = createBaseBindingLikeDeclaration(kind, modifiers, name, initializer);
            node.type = type;
            node.transformFlags |= propagateChildFlags(type);
            if (type)
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        //
        // Literals
        //
        function createBaseLiteral(kind, text) {
            var node = createBaseToken(kind);
            node.text = text;
            return node;
        }
        // @api
        function createNumericLiteral(value, numericLiteralFlags) {
            if (numericLiteralFlags === void 0) { numericLiteralFlags = 0 /* TokenFlags.None */; }
            var node = createBaseLiteral(8 /* SyntaxKind.NumericLiteral */, typeof value === "number" ? value + "" : value);
            node.numericLiteralFlags = numericLiteralFlags;
            if (numericLiteralFlags & 384 /* TokenFlags.BinaryOrOctalSpecifier */)
                node.transformFlags |= 1024 /* TransformFlags.ContainsES2015 */;
            return node;
        }
        // @api
        function createBigIntLiteral(value) {
            var node = createBaseLiteral(9 /* SyntaxKind.BigIntLiteral */, typeof value === "string" ? value : ts.pseudoBigIntToString(value) + "n");
            node.transformFlags |= 4 /* TransformFlags.ContainsESNext */;
            return node;
        }
        function createBaseStringLiteral(text, isSingleQuote) {
            var node = createBaseLiteral(10 /* SyntaxKind.StringLiteral */, text);
            node.singleQuote = isSingleQuote;
            return node;
        }
        // @api
        function createStringLiteral(text, isSingleQuote, hasExtendedUnicodeEscape) {
            var node = createBaseStringLiteral(text, isSingleQuote);
            node.hasExtendedUnicodeEscape = hasExtendedUnicodeEscape;
            if (hasExtendedUnicodeEscape)
                node.transformFlags |= 1024 /* TransformFlags.ContainsES2015 */;
            return node;
        }
        // @api
        function createStringLiteralFromNode(sourceNode) {
            var node = createBaseStringLiteral(ts.getTextOfIdentifierOrLiteral(sourceNode), /*isSingleQuote*/ undefined);
            node.textSourceNode = sourceNode;
            return node;
        }
        // @api
        function createRegularExpressionLiteral(text) {
            var node = createBaseLiteral(13 /* SyntaxKind.RegularExpressionLiteral */, text);
            return node;
        }
        // @api
        function createLiteralLikeNode(kind, text) {
            switch (kind) {
                case 8 /* SyntaxKind.NumericLiteral */: return createNumericLiteral(text, /*numericLiteralFlags*/ 0);
                case 9 /* SyntaxKind.BigIntLiteral */: return createBigIntLiteral(text);
                case 10 /* SyntaxKind.StringLiteral */: return createStringLiteral(text, /*isSingleQuote*/ undefined);
                case 11 /* SyntaxKind.JsxText */: return createJsxText(text, /*containsOnlyTriviaWhiteSpaces*/ false);
                case 12 /* SyntaxKind.JsxTextAllWhiteSpaces */: return createJsxText(text, /*containsOnlyTriviaWhiteSpaces*/ true);
                case 13 /* SyntaxKind.RegularExpressionLiteral */: return createRegularExpressionLiteral(text);
                case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */: return createTemplateLiteralLikeNode(kind, text, /*rawText*/ undefined, /*templateFlags*/ 0);
            }
        }
        //
        // Identifiers
        //
        function createBaseIdentifier(text, originalKeywordKind) {
            if (originalKeywordKind === undefined && text) {
                originalKeywordKind = ts.stringToToken(text);
            }
            if (originalKeywordKind === 79 /* SyntaxKind.Identifier */) {
                originalKeywordKind = undefined;
            }
            var node = baseFactory.createBaseIdentifierNode(79 /* SyntaxKind.Identifier */);
            node.originalKeywordKind = originalKeywordKind;
            node.escapedText = ts.escapeLeadingUnderscores(text);
            return node;
        }
        function createBaseGeneratedIdentifier(text, autoGenerateFlags) {
            var node = createBaseIdentifier(text, /*originalKeywordKind*/ undefined);
            node.autoGenerateFlags = autoGenerateFlags;
            node.autoGenerateId = nextAutoGenerateId;
            nextAutoGenerateId++;
            return node;
        }
        // @api
        function createIdentifier(text, typeArguments, originalKeywordKind) {
            var node = createBaseIdentifier(text, originalKeywordKind);
            if (typeArguments) {
                // NOTE: we do not use `setChildren` here because typeArguments in an identifier do not contribute to transformations
                node.typeArguments = createNodeArray(typeArguments);
            }
            if (node.originalKeywordKind === 132 /* SyntaxKind.AwaitKeyword */) {
                node.transformFlags |= 67108864 /* TransformFlags.ContainsPossibleTopLevelAwait */;
            }
            return node;
        }
        // @api
        function updateIdentifier(node, typeArguments) {
            return node.typeArguments !== typeArguments
                ? update(createIdentifier(ts.idText(node), typeArguments), node)
                : node;
        }
        // @api
        function createTempVariable(recordTempVariable, reservedInNestedScopes) {
            var flags = 1 /* GeneratedIdentifierFlags.Auto */;
            if (reservedInNestedScopes)
                flags |= 8 /* GeneratedIdentifierFlags.ReservedInNestedScopes */;
            var name = createBaseGeneratedIdentifier("", flags);
            if (recordTempVariable) {
                recordTempVariable(name);
            }
            return name;
        }
        /** Create a unique temporary variable for use in a loop. */
        // @api
        function createLoopVariable(reservedInNestedScopes) {
            var flags = 2 /* GeneratedIdentifierFlags.Loop */;
            if (reservedInNestedScopes)
                flags |= 8 /* GeneratedIdentifierFlags.ReservedInNestedScopes */;
            return createBaseGeneratedIdentifier("", flags);
        }
        /** Create a unique name based on the supplied text. */
        // @api
        function createUniqueName(text, flags) {
            if (flags === void 0) { flags = 0 /* GeneratedIdentifierFlags.None */; }
            ts.Debug.assert(!(flags & 7 /* GeneratedIdentifierFlags.KindMask */), "Argument out of range: flags");
            ts.Debug.assert((flags & (16 /* GeneratedIdentifierFlags.Optimistic */ | 32 /* GeneratedIdentifierFlags.FileLevel */)) !== 32 /* GeneratedIdentifierFlags.FileLevel */, "GeneratedIdentifierFlags.FileLevel cannot be set without also setting GeneratedIdentifierFlags.Optimistic");
            return createBaseGeneratedIdentifier(text, 3 /* GeneratedIdentifierFlags.Unique */ | flags);
        }
        /** Create a unique name generated for a node. */
        // @api
        function getGeneratedNameForNode(node, flags) {
            if (flags === void 0) { flags = 0; }
            ts.Debug.assert(!(flags & 7 /* GeneratedIdentifierFlags.KindMask */), "Argument out of range: flags");
            var name = createBaseGeneratedIdentifier(node && ts.isIdentifier(node) ? ts.idText(node) : "", 4 /* GeneratedIdentifierFlags.Node */ | flags);
            name.original = node;
            return name;
        }
        // @api
        function createPrivateIdentifier(text) {
            if (!ts.startsWith(text, "#"))
                ts.Debug.fail("First character of private identifier must be #: " + text);
            var node = baseFactory.createBasePrivateIdentifierNode(80 /* SyntaxKind.PrivateIdentifier */);
            node.escapedText = ts.escapeLeadingUnderscores(text);
            node.transformFlags |= 16777216 /* TransformFlags.ContainsClassFields */;
            return node;
        }
        //
        // Punctuation
        //
        function createBaseToken(kind) {
            return baseFactory.createBaseTokenNode(kind);
        }
        function createToken(token) {
            ts.Debug.assert(token >= 0 /* SyntaxKind.FirstToken */ && token <= 160 /* SyntaxKind.LastToken */, "Invalid token");
            ts.Debug.assert(token <= 14 /* SyntaxKind.FirstTemplateToken */ || token >= 17 /* SyntaxKind.LastTemplateToken */, "Invalid token. Use 'createTemplateLiteralLikeNode' to create template literals.");
            ts.Debug.assert(token <= 8 /* SyntaxKind.FirstLiteralToken */ || token >= 14 /* SyntaxKind.LastLiteralToken */, "Invalid token. Use 'createLiteralLikeNode' to create literals.");
            ts.Debug.assert(token !== 79 /* SyntaxKind.Identifier */, "Invalid token. Use 'createIdentifier' to create identifiers");
            var node = createBaseToken(token);
            var transformFlags = 0 /* TransformFlags.None */;
            switch (token) {
                case 131 /* SyntaxKind.AsyncKeyword */:
                    // 'async' modifier is ES2017 (async functions) or ES2018 (async generators)
                    transformFlags =
                        256 /* TransformFlags.ContainsES2017 */ |
                            128 /* TransformFlags.ContainsES2018 */;
                    break;
                case 123 /* SyntaxKind.PublicKeyword */:
                case 121 /* SyntaxKind.PrivateKeyword */:
                case 122 /* SyntaxKind.ProtectedKeyword */:
                case 145 /* SyntaxKind.ReadonlyKeyword */:
                case 126 /* SyntaxKind.AbstractKeyword */:
                case 135 /* SyntaxKind.DeclareKeyword */:
                case 85 /* SyntaxKind.ConstKeyword */:
                case 130 /* SyntaxKind.AnyKeyword */:
                case 147 /* SyntaxKind.NumberKeyword */:
                case 158 /* SyntaxKind.BigIntKeyword */:
                case 143 /* SyntaxKind.NeverKeyword */:
                case 148 /* SyntaxKind.ObjectKeyword */:
                case 101 /* SyntaxKind.InKeyword */:
                case 144 /* SyntaxKind.OutKeyword */:
                case 159 /* SyntaxKind.OverrideKeyword */:
                case 150 /* SyntaxKind.StringKeyword */:
                case 133 /* SyntaxKind.BooleanKeyword */:
                case 151 /* SyntaxKind.SymbolKeyword */:
                case 114 /* SyntaxKind.VoidKeyword */:
                case 155 /* SyntaxKind.UnknownKeyword */:
                case 153 /* SyntaxKind.UndefinedKeyword */: // `undefined` is an Identifier in the expression case.
                    transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
                    break;
                case 106 /* SyntaxKind.SuperKeyword */:
                    transformFlags = 1024 /* TransformFlags.ContainsES2015 */ | 134217728 /* TransformFlags.ContainsLexicalSuper */;
                    break;
                case 124 /* SyntaxKind.StaticKeyword */:
                    transformFlags = 1024 /* TransformFlags.ContainsES2015 */;
                    break;
                case 108 /* SyntaxKind.ThisKeyword */:
                    // 'this' indicates a lexical 'this'
                    transformFlags = 16384 /* TransformFlags.ContainsLexicalThis */;
                    break;
            }
            if (transformFlags) {
                node.transformFlags |= transformFlags;
            }
            return node;
        }
        //
        // Reserved words
        //
        // @api
        function createSuper() {
            return createToken(106 /* SyntaxKind.SuperKeyword */);
        }
        // @api
        function createThis() {
            return createToken(108 /* SyntaxKind.ThisKeyword */);
        }
        // @api
        function createNull() {
            return createToken(104 /* SyntaxKind.NullKeyword */);
        }
        // @api
        function createTrue() {
            return createToken(110 /* SyntaxKind.TrueKeyword */);
        }
        // @api
        function createFalse() {
            return createToken(95 /* SyntaxKind.FalseKeyword */);
        }
        //
        // Modifiers
        //
        // @api
        function createModifier(kind) {
            return createToken(kind);
        }
        // @api
        function createModifiersFromModifierFlags(flags) {
            var result = [];
            if (flags & 1 /* ModifierFlags.Export */)
                result.push(createModifier(93 /* SyntaxKind.ExportKeyword */));
            if (flags & 2 /* ModifierFlags.Ambient */)
                result.push(createModifier(135 /* SyntaxKind.DeclareKeyword */));
            if (flags & 512 /* ModifierFlags.Default */)
                result.push(createModifier(88 /* SyntaxKind.DefaultKeyword */));
            if (flags & 2048 /* ModifierFlags.Const */)
                result.push(createModifier(85 /* SyntaxKind.ConstKeyword */));
            if (flags & 4 /* ModifierFlags.Public */)
                result.push(createModifier(123 /* SyntaxKind.PublicKeyword */));
            if (flags & 8 /* ModifierFlags.Private */)
                result.push(createModifier(121 /* SyntaxKind.PrivateKeyword */));
            if (flags & 16 /* ModifierFlags.Protected */)
                result.push(createModifier(122 /* SyntaxKind.ProtectedKeyword */));
            if (flags & 128 /* ModifierFlags.Abstract */)
                result.push(createModifier(126 /* SyntaxKind.AbstractKeyword */));
            if (flags & 32 /* ModifierFlags.Static */)
                result.push(createModifier(124 /* SyntaxKind.StaticKeyword */));
            if (flags & 16384 /* ModifierFlags.Override */)
                result.push(createModifier(159 /* SyntaxKind.OverrideKeyword */));
            if (flags & 64 /* ModifierFlags.Readonly */)
                result.push(createModifier(145 /* SyntaxKind.ReadonlyKeyword */));
            if (flags & 256 /* ModifierFlags.Async */)
                result.push(createModifier(131 /* SyntaxKind.AsyncKeyword */));
            if (flags & 32768 /* ModifierFlags.In */)
                result.push(createModifier(101 /* SyntaxKind.InKeyword */));
            if (flags & 65536 /* ModifierFlags.Out */)
                result.push(createModifier(144 /* SyntaxKind.OutKeyword */));
            return result.length ? result : undefined;
        }
        //
        // Names
        //
        // @api
        function createQualifiedName(left, right) {
            var node = createBaseNode(161 /* SyntaxKind.QualifiedName */);
            node.left = left;
            node.right = asName(right);
            node.transformFlags |=
                propagateChildFlags(node.left) |
                    propagateIdentifierNameFlags(node.right);
            return node;
        }
        // @api
        function updateQualifiedName(node, left, right) {
            return node.left !== left
                || node.right !== right
                ? update(createQualifiedName(left, right), node)
                : node;
        }
        // @api
        function createComputedPropertyName(expression) {
            var node = createBaseNode(162 /* SyntaxKind.ComputedPropertyName */);
            node.expression = parenthesizerRules().parenthesizeExpressionOfComputedPropertyName(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    1024 /* TransformFlags.ContainsES2015 */ |
                    131072 /* TransformFlags.ContainsComputedPropertyName */;
            return node;
        }
        // @api
        function updateComputedPropertyName(node, expression) {
            return node.expression !== expression
                ? update(createComputedPropertyName(expression), node)
                : node;
        }
        //
        // Signature elements
        //
        // @api
        function createTypeParameterDeclaration(modifiers, name, constraint, defaultType) {
            var node = createBaseNamedDeclaration(163 /* SyntaxKind.TypeParameter */, modifiers, name);
            node.constraint = constraint;
            node.default = defaultType;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateTypeParameterDeclaration(node, modifiers, name, constraint, defaultType) {
            return node.modifiers !== modifiers
                || node.name !== name
                || node.constraint !== constraint
                || node.default !== defaultType
                ? update(createTypeParameterDeclaration(modifiers, name, constraint, defaultType), node)
                : node;
        }
        // @api
        function createParameterDeclaration(modifiers, dotDotDotToken, name, questionToken, type, initializer) {
            var node = createBaseVariableLikeDeclaration(164 /* SyntaxKind.Parameter */, modifiers, name, type, initializer && parenthesizerRules().parenthesizeExpressionForDisallowedComma(initializer));
            node.dotDotDotToken = dotDotDotToken;
            node.questionToken = questionToken;
            if (ts.isThisIdentifier(node.name)) {
                node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            }
            else {
                node.transformFlags |=
                    propagateChildFlags(node.dotDotDotToken) |
                        propagateChildFlags(node.questionToken);
                if (questionToken)
                    node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
                if (ts.modifiersToFlags(node.modifiers) & 16476 /* ModifierFlags.ParameterPropertyModifier */)
                    node.transformFlags |= 8192 /* TransformFlags.ContainsTypeScriptClassSyntax */;
                if (initializer || dotDotDotToken)
                    node.transformFlags |= 1024 /* TransformFlags.ContainsES2015 */;
            }
            return node;
        }
        // @api
        function updateParameterDeclaration(node, modifiers, dotDotDotToken, name, questionToken, type, initializer) {
            return node.modifiers !== modifiers
                || node.dotDotDotToken !== dotDotDotToken
                || node.name !== name
                || node.questionToken !== questionToken
                || node.type !== type
                || node.initializer !== initializer
                ? update(createParameterDeclaration(modifiers, dotDotDotToken, name, questionToken, type, initializer), node)
                : node;
        }
        // @api
        function createDecorator(expression) {
            var node = createBaseNode(165 /* SyntaxKind.Decorator */);
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression, /*optionalChain*/ false);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    1 /* TransformFlags.ContainsTypeScript */ |
                    8192 /* TransformFlags.ContainsTypeScriptClassSyntax */ |
                    33554432 /* TransformFlags.ContainsDecorators */;
            return node;
        }
        // @api
        function updateDecorator(node, expression) {
            return node.expression !== expression
                ? update(createDecorator(expression), node)
                : node;
        }
        //
        // Type Elements
        //
        // @api
        function createPropertySignature(modifiers, name, questionToken, type) {
            var node = createBaseNamedDeclaration(166 /* SyntaxKind.PropertySignature */, modifiers, name);
            node.type = type;
            node.questionToken = questionToken;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            // The following properties are used only to report grammar errors
            node.initializer = undefined;
            return node;
        }
        // @api
        function updatePropertySignature(node, modifiers, name, questionToken, type) {
            return node.modifiers !== modifiers
                || node.name !== name
                || node.questionToken !== questionToken
                || node.type !== type
                ? finishUpdatePropertySignature(createPropertySignature(modifiers, name, questionToken, type), node)
                : node;
        }
        function finishUpdatePropertySignature(updated, original) {
            if (updated !== original) {
                // copy children used only for error reporting
                updated.initializer = original.initializer;
            }
            return update(updated, original);
        }
        // @api
        function createPropertyDeclaration(modifiers, name, questionOrExclamationToken, type, initializer) {
            var node = createBaseVariableLikeDeclaration(167 /* SyntaxKind.PropertyDeclaration */, modifiers, name, type, initializer);
            node.questionToken = questionOrExclamationToken && ts.isQuestionToken(questionOrExclamationToken) ? questionOrExclamationToken : undefined;
            node.exclamationToken = questionOrExclamationToken && ts.isExclamationToken(questionOrExclamationToken) ? questionOrExclamationToken : undefined;
            node.transformFlags |=
                propagateChildFlags(node.questionToken) |
                    propagateChildFlags(node.exclamationToken) |
                    16777216 /* TransformFlags.ContainsClassFields */;
            if (ts.isComputedPropertyName(node.name) || (ts.hasStaticModifier(node) && node.initializer)) {
                node.transformFlags |= 8192 /* TransformFlags.ContainsTypeScriptClassSyntax */;
            }
            if (questionOrExclamationToken || ts.modifiersToFlags(node.modifiers) & 2 /* ModifierFlags.Ambient */) {
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            }
            return node;
        }
        // @api
        function updatePropertyDeclaration(node, modifiers, name, questionOrExclamationToken, type, initializer) {
            return node.modifiers !== modifiers
                || node.name !== name
                || node.questionToken !== (questionOrExclamationToken !== undefined && ts.isQuestionToken(questionOrExclamationToken) ? questionOrExclamationToken : undefined)
                || node.exclamationToken !== (questionOrExclamationToken !== undefined && ts.isExclamationToken(questionOrExclamationToken) ? questionOrExclamationToken : undefined)
                || node.type !== type
                || node.initializer !== initializer
                ? update(createPropertyDeclaration(modifiers, name, questionOrExclamationToken, type, initializer), node)
                : node;
        }
        // @api
        function createMethodSignature(modifiers, name, questionToken, typeParameters, parameters, type) {
            var node = createBaseSignatureDeclaration(168 /* SyntaxKind.MethodSignature */, modifiers, name, typeParameters, parameters, type);
            node.questionToken = questionToken;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateMethodSignature(node, modifiers, name, questionToken, typeParameters, parameters, type) {
            return node.modifiers !== modifiers
                || node.name !== name
                || node.questionToken !== questionToken
                || node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                ? finishUpdateBaseSignatureDeclaration(createMethodSignature(modifiers, name, questionToken, typeParameters, parameters, type), node)
                : node;
        }
        // @api
        function createMethodDeclaration(modifiers, asteriskToken, name, questionToken, typeParameters, parameters, type, body) {
            var node = createBaseFunctionLikeDeclaration(169 /* SyntaxKind.MethodDeclaration */, modifiers, name, typeParameters, parameters, type, body);
            node.asteriskToken = asteriskToken;
            node.questionToken = questionToken;
            node.transformFlags |=
                propagateChildFlags(node.asteriskToken) |
                    propagateChildFlags(node.questionToken) |
                    1024 /* TransformFlags.ContainsES2015 */;
            if (questionToken) {
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            }
            if (ts.modifiersToFlags(node.modifiers) & 256 /* ModifierFlags.Async */) {
                if (asteriskToken) {
                    node.transformFlags |= 128 /* TransformFlags.ContainsES2018 */;
                }
                else {
                    node.transformFlags |= 256 /* TransformFlags.ContainsES2017 */;
                }
            }
            else if (asteriskToken) {
                node.transformFlags |= 2048 /* TransformFlags.ContainsGenerator */;
            }
            // The following properties are used only to report grammar errors
            node.exclamationToken = undefined;
            return node;
        }
        // @api
        function updateMethodDeclaration(node, modifiers, asteriskToken, name, questionToken, typeParameters, parameters, type, body) {
            return node.modifiers !== modifiers
                || node.asteriskToken !== asteriskToken
                || node.name !== name
                || node.questionToken !== questionToken
                || node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                || node.body !== body
                ? finishUpdateMethodDeclaration(createMethodDeclaration(modifiers, asteriskToken, name, questionToken, typeParameters, parameters, type, body), node)
                : node;
        }
        function finishUpdateMethodDeclaration(updated, original) {
            if (updated !== original) {
                updated.exclamationToken = original.exclamationToken;
            }
            return update(updated, original);
        }
        // @api
        function createClassStaticBlockDeclaration(body) {
            var node = createBaseGenericNamedDeclaration(170 /* SyntaxKind.ClassStaticBlockDeclaration */, 
            /*modifiers*/ undefined, 
            /*name*/ undefined, 
            /*typeParameters*/ undefined);
            node.body = body;
            node.transformFlags = propagateChildFlags(body) | 16777216 /* TransformFlags.ContainsClassFields */;
            // The following properties are used only to report grammar errors
            node.illegalDecorators = undefined;
            node.modifiers = undefined;
            return node;
        }
        // @api
        function updateClassStaticBlockDeclaration(node, body) {
            return node.body !== body
                ? finishUpdateClassStaticBlockDeclaration(createClassStaticBlockDeclaration(body), node)
                : node;
        }
        function finishUpdateClassStaticBlockDeclaration(updated, original) {
            if (updated !== original) {
                updated.illegalDecorators = original.illegalDecorators;
                updated.modifiers = original.modifiers;
            }
            return update(updated, original);
        }
        // @api
        function createConstructorDeclaration(modifiers, parameters, body) {
            var node = createBaseFunctionLikeDeclaration(171 /* SyntaxKind.Constructor */, modifiers, 
            /*name*/ undefined, 
            /*typeParameters*/ undefined, parameters, 
            /*type*/ undefined, body);
            node.transformFlags |= 1024 /* TransformFlags.ContainsES2015 */;
            // The following properties are used only to report grammar errors
            node.illegalDecorators = undefined;
            node.typeParameters = undefined;
            node.type = undefined;
            return node;
        }
        // @api
        function updateConstructorDeclaration(node, modifiers, parameters, body) {
            return node.modifiers !== modifiers
                || node.parameters !== parameters
                || node.body !== body
                ? finishUpdateConstructorDeclaration(createConstructorDeclaration(modifiers, parameters, body), node)
                : node;
        }
        function finishUpdateConstructorDeclaration(updated, original) {
            if (updated !== original) {
                updated.illegalDecorators = original.illegalDecorators;
                updated.typeParameters = original.typeParameters;
                updated.type = original.type;
            }
            return finishUpdateBaseSignatureDeclaration(updated, original);
        }
        // @api
        function createGetAccessorDeclaration(modifiers, name, parameters, type, body) {
            var node = createBaseFunctionLikeDeclaration(172 /* SyntaxKind.GetAccessor */, modifiers, name, 
            /*typeParameters*/ undefined, parameters, type, body);
            // The following properties are used only to report grammar errors
            node.typeParameters = undefined;
            return node;
        }
        // @api
        function updateGetAccessorDeclaration(node, modifiers, name, parameters, type, body) {
            return node.modifiers !== modifiers
                || node.name !== name
                || node.parameters !== parameters
                || node.type !== type
                || node.body !== body
                ? finishUpdateGetAccessorDeclaration(createGetAccessorDeclaration(modifiers, name, parameters, type, body), node)
                : node;
        }
        function finishUpdateGetAccessorDeclaration(updated, original) {
            if (updated !== original) {
                updated.typeParameters = original.typeParameters;
            }
            return finishUpdateBaseSignatureDeclaration(updated, original);
        }
        // @api
        function createSetAccessorDeclaration(modifiers, name, parameters, body) {
            var node = createBaseFunctionLikeDeclaration(173 /* SyntaxKind.SetAccessor */, modifiers, name, 
            /*typeParameters*/ undefined, parameters, 
            /*type*/ undefined, body);
            // The following properties are used only to report grammar errors
            node.typeParameters = undefined;
            node.type = undefined;
            return node;
        }
        // @api
        function updateSetAccessorDeclaration(node, modifiers, name, parameters, body) {
            return node.modifiers !== modifiers
                || node.name !== name
                || node.parameters !== parameters
                || node.body !== body
                ? finishUpdateSetAccessorDeclaration(createSetAccessorDeclaration(modifiers, name, parameters, body), node)
                : node;
        }
        function finishUpdateSetAccessorDeclaration(updated, original) {
            if (updated !== original) {
                updated.typeParameters = original.typeParameters;
                updated.type = original.type;
            }
            return finishUpdateBaseSignatureDeclaration(updated, original);
        }
        // @api
        function createCallSignature(typeParameters, parameters, type) {
            var node = createBaseSignatureDeclaration(174 /* SyntaxKind.CallSignature */, 
            /*modifiers*/ undefined, 
            /*name*/ undefined, typeParameters, parameters, type);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateCallSignature(node, typeParameters, parameters, type) {
            return node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                ? finishUpdateBaseSignatureDeclaration(createCallSignature(typeParameters, parameters, type), node)
                : node;
        }
        // @api
        function createConstructSignature(typeParameters, parameters, type) {
            var node = createBaseSignatureDeclaration(175 /* SyntaxKind.ConstructSignature */, 
            /*modifiers*/ undefined, 
            /*name*/ undefined, typeParameters, parameters, type);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateConstructSignature(node, typeParameters, parameters, type) {
            return node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                ? finishUpdateBaseSignatureDeclaration(createConstructSignature(typeParameters, parameters, type), node)
                : node;
        }
        // @api
        function createIndexSignature(modifiers, parameters, type) {
            var node = createBaseSignatureDeclaration(176 /* SyntaxKind.IndexSignature */, modifiers, 
            /*name*/ undefined, 
            /*typeParameters*/ undefined, parameters, type);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateIndexSignature(node, modifiers, parameters, type) {
            return node.parameters !== parameters
                || node.type !== type
                || node.modifiers !== modifiers
                ? finishUpdateBaseSignatureDeclaration(createIndexSignature(modifiers, parameters, type), node)
                : node;
        }
        // @api
        function createTemplateLiteralTypeSpan(type, literal) {
            var node = createBaseNode(199 /* SyntaxKind.TemplateLiteralTypeSpan */);
            node.type = type;
            node.literal = literal;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateTemplateLiteralTypeSpan(node, type, literal) {
            return node.type !== type
                || node.literal !== literal
                ? update(createTemplateLiteralTypeSpan(type, literal), node)
                : node;
        }
        //
        // Types
        //
        // @api
        function createKeywordTypeNode(kind) {
            return createToken(kind);
        }
        // @api
        function createTypePredicateNode(assertsModifier, parameterName, type) {
            var node = createBaseNode(177 /* SyntaxKind.TypePredicate */);
            node.assertsModifier = assertsModifier;
            node.parameterName = asName(parameterName);
            node.type = type;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateTypePredicateNode(node, assertsModifier, parameterName, type) {
            return node.assertsModifier !== assertsModifier
                || node.parameterName !== parameterName
                || node.type !== type
                ? update(createTypePredicateNode(assertsModifier, parameterName, type), node)
                : node;
        }
        // @api
        function createTypeReferenceNode(typeName, typeArguments) {
            var node = createBaseNode(178 /* SyntaxKind.TypeReference */);
            node.typeName = asName(typeName);
            node.typeArguments = typeArguments && parenthesizerRules().parenthesizeTypeArguments(createNodeArray(typeArguments));
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateTypeReferenceNode(node, typeName, typeArguments) {
            return node.typeName !== typeName
                || node.typeArguments !== typeArguments
                ? update(createTypeReferenceNode(typeName, typeArguments), node)
                : node;
        }
        // @api
        function createFunctionTypeNode(typeParameters, parameters, type) {
            var node = createBaseSignatureDeclaration(179 /* SyntaxKind.FunctionType */, 
            /*modifiers*/ undefined, 
            /*name*/ undefined, typeParameters, parameters, type);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            // The following properties are used only to report grammar errors
            node.modifiers = undefined;
            return node;
        }
        // @api
        function updateFunctionTypeNode(node, typeParameters, parameters, type) {
            return node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                ? finishUpdateFunctionTypeNode(createFunctionTypeNode(typeParameters, parameters, type), node)
                : node;
        }
        function finishUpdateFunctionTypeNode(updated, original) {
            if (updated !== original) {
                updated.modifiers = original.modifiers;
            }
            return finishUpdateBaseSignatureDeclaration(updated, original);
        }
        // @api
        function createConstructorTypeNode() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return args.length === 4 ? createConstructorTypeNode1.apply(void 0, args) :
                args.length === 3 ? createConstructorTypeNode2.apply(void 0, args) :
                    ts.Debug.fail("Incorrect number of arguments specified.");
        }
        function createConstructorTypeNode1(modifiers, typeParameters, parameters, type) {
            var node = createBaseSignatureDeclaration(180 /* SyntaxKind.ConstructorType */, modifiers, 
            /*name*/ undefined, typeParameters, parameters, type);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        /** @deprecated */
        function createConstructorTypeNode2(typeParameters, parameters, type) {
            return createConstructorTypeNode1(/*modifiers*/ undefined, typeParameters, parameters, type);
        }
        // @api
        function updateConstructorTypeNode() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return args.length === 5 ? updateConstructorTypeNode1.apply(void 0, args) :
                args.length === 4 ? updateConstructorTypeNode2.apply(void 0, args) :
                    ts.Debug.fail("Incorrect number of arguments specified.");
        }
        function updateConstructorTypeNode1(node, modifiers, typeParameters, parameters, type) {
            return node.modifiers !== modifiers
                || node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                ? finishUpdateBaseSignatureDeclaration(createConstructorTypeNode(modifiers, typeParameters, parameters, type), node)
                : node;
        }
        /** @deprecated */
        function updateConstructorTypeNode2(node, typeParameters, parameters, type) {
            return updateConstructorTypeNode1(node, node.modifiers, typeParameters, parameters, type);
        }
        // @api
        function createTypeQueryNode(exprName, typeArguments) {
            var node = createBaseNode(181 /* SyntaxKind.TypeQuery */);
            node.exprName = exprName;
            node.typeArguments = typeArguments && parenthesizerRules().parenthesizeTypeArguments(typeArguments);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateTypeQueryNode(node, exprName, typeArguments) {
            return node.exprName !== exprName
                || node.typeArguments !== typeArguments
                ? update(createTypeQueryNode(exprName, typeArguments), node)
                : node;
        }
        // @api
        function createTypeLiteralNode(members) {
            var node = createBaseNode(182 /* SyntaxKind.TypeLiteral */);
            node.members = createNodeArray(members);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateTypeLiteralNode(node, members) {
            return node.members !== members
                ? update(createTypeLiteralNode(members), node)
                : node;
        }
        // @api
        function createArrayTypeNode(elementType) {
            var node = createBaseNode(183 /* SyntaxKind.ArrayType */);
            node.elementType = parenthesizerRules().parenthesizeNonArrayTypeOfPostfixType(elementType);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateArrayTypeNode(node, elementType) {
            return node.elementType !== elementType
                ? update(createArrayTypeNode(elementType), node)
                : node;
        }
        // @api
        function createTupleTypeNode(elements) {
            var node = createBaseNode(184 /* SyntaxKind.TupleType */);
            node.elements = createNodeArray(parenthesizerRules().parenthesizeElementTypesOfTupleType(elements));
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateTupleTypeNode(node, elements) {
            return node.elements !== elements
                ? update(createTupleTypeNode(elements), node)
                : node;
        }
        // @api
        function createNamedTupleMember(dotDotDotToken, name, questionToken, type) {
            var node = createBaseNode(197 /* SyntaxKind.NamedTupleMember */);
            node.dotDotDotToken = dotDotDotToken;
            node.name = name;
            node.questionToken = questionToken;
            node.type = type;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateNamedTupleMember(node, dotDotDotToken, name, questionToken, type) {
            return node.dotDotDotToken !== dotDotDotToken
                || node.name !== name
                || node.questionToken !== questionToken
                || node.type !== type
                ? update(createNamedTupleMember(dotDotDotToken, name, questionToken, type), node)
                : node;
        }
        // @api
        function createOptionalTypeNode(type) {
            var node = createBaseNode(185 /* SyntaxKind.OptionalType */);
            node.type = parenthesizerRules().parenthesizeTypeOfOptionalType(type);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateOptionalTypeNode(node, type) {
            return node.type !== type
                ? update(createOptionalTypeNode(type), node)
                : node;
        }
        // @api
        function createRestTypeNode(type) {
            var node = createBaseNode(186 /* SyntaxKind.RestType */);
            node.type = type;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateRestTypeNode(node, type) {
            return node.type !== type
                ? update(createRestTypeNode(type), node)
                : node;
        }
        function createUnionOrIntersectionTypeNode(kind, types, parenthesize) {
            var node = createBaseNode(kind);
            node.types = factory.createNodeArray(parenthesize(types));
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        function updateUnionOrIntersectionTypeNode(node, types, parenthesize) {
            return node.types !== types
                ? update(createUnionOrIntersectionTypeNode(node.kind, types, parenthesize), node)
                : node;
        }
        // @api
        function createUnionTypeNode(types) {
            return createUnionOrIntersectionTypeNode(187 /* SyntaxKind.UnionType */, types, parenthesizerRules().parenthesizeConstituentTypesOfUnionType);
        }
        // @api
        function updateUnionTypeNode(node, types) {
            return updateUnionOrIntersectionTypeNode(node, types, parenthesizerRules().parenthesizeConstituentTypesOfUnionType);
        }
        // @api
        function createIntersectionTypeNode(types) {
            return createUnionOrIntersectionTypeNode(188 /* SyntaxKind.IntersectionType */, types, parenthesizerRules().parenthesizeConstituentTypesOfIntersectionType);
        }
        // @api
        function updateIntersectionTypeNode(node, types) {
            return updateUnionOrIntersectionTypeNode(node, types, parenthesizerRules().parenthesizeConstituentTypesOfIntersectionType);
        }
        // @api
        function createConditionalTypeNode(checkType, extendsType, trueType, falseType) {
            var node = createBaseNode(189 /* SyntaxKind.ConditionalType */);
            node.checkType = parenthesizerRules().parenthesizeCheckTypeOfConditionalType(checkType);
            node.extendsType = parenthesizerRules().parenthesizeExtendsTypeOfConditionalType(extendsType);
            node.trueType = trueType;
            node.falseType = falseType;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateConditionalTypeNode(node, checkType, extendsType, trueType, falseType) {
            return node.checkType !== checkType
                || node.extendsType !== extendsType
                || node.trueType !== trueType
                || node.falseType !== falseType
                ? update(createConditionalTypeNode(checkType, extendsType, trueType, falseType), node)
                : node;
        }
        // @api
        function createInferTypeNode(typeParameter) {
            var node = createBaseNode(190 /* SyntaxKind.InferType */);
            node.typeParameter = typeParameter;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateInferTypeNode(node, typeParameter) {
            return node.typeParameter !== typeParameter
                ? update(createInferTypeNode(typeParameter), node)
                : node;
        }
        // @api
        function createTemplateLiteralType(head, templateSpans) {
            var node = createBaseNode(198 /* SyntaxKind.TemplateLiteralType */);
            node.head = head;
            node.templateSpans = createNodeArray(templateSpans);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateTemplateLiteralType(node, head, templateSpans) {
            return node.head !== head
                || node.templateSpans !== templateSpans
                ? update(createTemplateLiteralType(head, templateSpans), node)
                : node;
        }
        // @api
        function createImportTypeNode(argument, assertions, qualifier, typeArguments, isTypeOf) {
            if (isTypeOf === void 0) { isTypeOf = false; }
            var node = createBaseNode(200 /* SyntaxKind.ImportType */);
            node.argument = argument;
            node.assertions = assertions;
            node.qualifier = qualifier;
            node.typeArguments = typeArguments && parenthesizerRules().parenthesizeTypeArguments(typeArguments);
            node.isTypeOf = isTypeOf;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateImportTypeNode(node, argument, assertions, qualifier, typeArguments, isTypeOf) {
            if (isTypeOf === void 0) { isTypeOf = node.isTypeOf; }
            return node.argument !== argument
                || node.assertions !== assertions
                || node.qualifier !== qualifier
                || node.typeArguments !== typeArguments
                || node.isTypeOf !== isTypeOf
                ? update(createImportTypeNode(argument, assertions, qualifier, typeArguments, isTypeOf), node)
                : node;
        }
        // @api
        function createParenthesizedType(type) {
            var node = createBaseNode(191 /* SyntaxKind.ParenthesizedType */);
            node.type = type;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateParenthesizedType(node, type) {
            return node.type !== type
                ? update(createParenthesizedType(type), node)
                : node;
        }
        // @api
        function createThisTypeNode() {
            var node = createBaseNode(192 /* SyntaxKind.ThisType */);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function createTypeOperatorNode(operator, type) {
            var node = createBaseNode(193 /* SyntaxKind.TypeOperator */);
            node.operator = operator;
            node.type = operator === 145 /* SyntaxKind.ReadonlyKeyword */ ?
                parenthesizerRules().parenthesizeOperandOfReadonlyTypeOperator(type) :
                parenthesizerRules().parenthesizeOperandOfTypeOperator(type);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateTypeOperatorNode(node, type) {
            return node.type !== type
                ? update(createTypeOperatorNode(node.operator, type), node)
                : node;
        }
        // @api
        function createIndexedAccessTypeNode(objectType, indexType) {
            var node = createBaseNode(194 /* SyntaxKind.IndexedAccessType */);
            node.objectType = parenthesizerRules().parenthesizeNonArrayTypeOfPostfixType(objectType);
            node.indexType = indexType;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateIndexedAccessTypeNode(node, objectType, indexType) {
            return node.objectType !== objectType
                || node.indexType !== indexType
                ? update(createIndexedAccessTypeNode(objectType, indexType), node)
                : node;
        }
        // @api
        function createMappedTypeNode(readonlyToken, typeParameter, nameType, questionToken, type, members) {
            var node = createBaseNode(195 /* SyntaxKind.MappedType */);
            node.readonlyToken = readonlyToken;
            node.typeParameter = typeParameter;
            node.nameType = nameType;
            node.questionToken = questionToken;
            node.type = type;
            node.members = members && createNodeArray(members);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateMappedTypeNode(node, readonlyToken, typeParameter, nameType, questionToken, type, members) {
            return node.readonlyToken !== readonlyToken
                || node.typeParameter !== typeParameter
                || node.nameType !== nameType
                || node.questionToken !== questionToken
                || node.type !== type
                || node.members !== members
                ? update(createMappedTypeNode(readonlyToken, typeParameter, nameType, questionToken, type, members), node)
                : node;
        }
        // @api
        function createLiteralTypeNode(literal) {
            var node = createBaseNode(196 /* SyntaxKind.LiteralType */);
            node.literal = literal;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateLiteralTypeNode(node, literal) {
            return node.literal !== literal
                ? update(createLiteralTypeNode(literal), node)
                : node;
        }
        //
        // Binding Patterns
        //
        // @api
        function createObjectBindingPattern(elements) {
            var node = createBaseNode(201 /* SyntaxKind.ObjectBindingPattern */);
            node.elements = createNodeArray(elements);
            node.transformFlags |=
                propagateChildrenFlags(node.elements) |
                    1024 /* TransformFlags.ContainsES2015 */ |
                    524288 /* TransformFlags.ContainsBindingPattern */;
            if (node.transformFlags & 32768 /* TransformFlags.ContainsRestOrSpread */) {
                node.transformFlags |=
                    128 /* TransformFlags.ContainsES2018 */ |
                        65536 /* TransformFlags.ContainsObjectRestOrSpread */;
            }
            return node;
        }
        // @api
        function updateObjectBindingPattern(node, elements) {
            return node.elements !== elements
                ? update(createObjectBindingPattern(elements), node)
                : node;
        }
        // @api
        function createArrayBindingPattern(elements) {
            var node = createBaseNode(202 /* SyntaxKind.ArrayBindingPattern */);
            node.elements = createNodeArray(elements);
            node.transformFlags |=
                propagateChildrenFlags(node.elements) |
                    1024 /* TransformFlags.ContainsES2015 */ |
                    524288 /* TransformFlags.ContainsBindingPattern */;
            return node;
        }
        // @api
        function updateArrayBindingPattern(node, elements) {
            return node.elements !== elements
                ? update(createArrayBindingPattern(elements), node)
                : node;
        }
        // @api
        function createBindingElement(dotDotDotToken, propertyName, name, initializer) {
            var node = createBaseBindingLikeDeclaration(203 /* SyntaxKind.BindingElement */, 
            /*modifiers*/ undefined, name, initializer && parenthesizerRules().parenthesizeExpressionForDisallowedComma(initializer));
            node.propertyName = asName(propertyName);
            node.dotDotDotToken = dotDotDotToken;
            node.transformFlags |=
                propagateChildFlags(node.dotDotDotToken) |
                    1024 /* TransformFlags.ContainsES2015 */;
            if (node.propertyName) {
                node.transformFlags |= ts.isIdentifier(node.propertyName) ?
                    propagateIdentifierNameFlags(node.propertyName) :
                    propagateChildFlags(node.propertyName);
            }
            if (dotDotDotToken)
                node.transformFlags |= 32768 /* TransformFlags.ContainsRestOrSpread */;
            return node;
        }
        // @api
        function updateBindingElement(node, dotDotDotToken, propertyName, name, initializer) {
            return node.propertyName !== propertyName
                || node.dotDotDotToken !== dotDotDotToken
                || node.name !== name
                || node.initializer !== initializer
                ? update(createBindingElement(dotDotDotToken, propertyName, name, initializer), node)
                : node;
        }
        //
        // Expression
        //
        function createBaseExpression(kind) {
            var node = createBaseNode(kind);
            // the following properties are commonly set by the checker/binder
            return node;
        }
        // @api
        function createArrayLiteralExpression(elements, multiLine) {
            var node = createBaseExpression(204 /* SyntaxKind.ArrayLiteralExpression */);
            // Ensure we add a trailing comma for something like `[NumericLiteral(1), NumericLiteral(2), OmittedExpresion]` so that
            // we end up with `[1, 2, ,]` instead of `[1, 2, ]` otherwise the `OmittedExpression` will just end up being treated like
            // a trailing comma.
            var lastElement = elements && ts.lastOrUndefined(elements);
            var elementsArray = createNodeArray(elements, lastElement && ts.isOmittedExpression(lastElement) ? true : undefined);
            node.elements = parenthesizerRules().parenthesizeExpressionsOfCommaDelimitedList(elementsArray);
            node.multiLine = multiLine;
            node.transformFlags |= propagateChildrenFlags(node.elements);
            return node;
        }
        // @api
        function updateArrayLiteralExpression(node, elements) {
            return node.elements !== elements
                ? update(createArrayLiteralExpression(elements, node.multiLine), node)
                : node;
        }
        // @api
        function createObjectLiteralExpression(properties, multiLine) {
            var node = createBaseExpression(205 /* SyntaxKind.ObjectLiteralExpression */);
            node.properties = createNodeArray(properties);
            node.multiLine = multiLine;
            node.transformFlags |= propagateChildrenFlags(node.properties);
            return node;
        }
        // @api
        function updateObjectLiteralExpression(node, properties) {
            return node.properties !== properties
                ? update(createObjectLiteralExpression(properties, node.multiLine), node)
                : node;
        }
        // @api
        function createPropertyAccessExpression(expression, name) {
            var node = createBaseExpression(206 /* SyntaxKind.PropertyAccessExpression */);
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression, /*optionalChain*/ false);
            node.name = asName(name);
            node.transformFlags =
                propagateChildFlags(node.expression) |
                    (ts.isIdentifier(node.name) ?
                        propagateIdentifierNameFlags(node.name) :
                        propagateChildFlags(node.name) | 536870912 /* TransformFlags.ContainsPrivateIdentifierInExpression */);
            if (ts.isSuperKeyword(expression)) {
                // super method calls require a lexical 'this'
                // super method calls require 'super' hoisting in ES2017 and ES2018 async functions and async generators
                node.transformFlags |=
                    256 /* TransformFlags.ContainsES2017 */ |
                        128 /* TransformFlags.ContainsES2018 */;
            }
            return node;
        }
        // @api
        function updatePropertyAccessExpression(node, expression, name) {
            if (ts.isPropertyAccessChain(node)) {
                return updatePropertyAccessChain(node, expression, node.questionDotToken, ts.cast(name, ts.isIdentifier));
            }
            return node.expression !== expression
                || node.name !== name
                ? update(createPropertyAccessExpression(expression, name), node)
                : node;
        }
        // @api
        function createPropertyAccessChain(expression, questionDotToken, name) {
            var node = createBaseExpression(206 /* SyntaxKind.PropertyAccessExpression */);
            node.flags |= 32 /* NodeFlags.OptionalChain */;
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression, /*optionalChain*/ true);
            node.questionDotToken = questionDotToken;
            node.name = asName(name);
            node.transformFlags |=
                32 /* TransformFlags.ContainsES2020 */ |
                    propagateChildFlags(node.expression) |
                    propagateChildFlags(node.questionDotToken) |
                    (ts.isIdentifier(node.name) ?
                        propagateIdentifierNameFlags(node.name) :
                        propagateChildFlags(node.name) | 536870912 /* TransformFlags.ContainsPrivateIdentifierInExpression */);
            return node;
        }
        // @api
        function updatePropertyAccessChain(node, expression, questionDotToken, name) {
            ts.Debug.assert(!!(node.flags & 32 /* NodeFlags.OptionalChain */), "Cannot update a PropertyAccessExpression using updatePropertyAccessChain. Use updatePropertyAccess instead.");
            // Because we are updating an existing PropertyAccessChain we want to inherit its emitFlags
            // instead of using the default from createPropertyAccess
            return node.expression !== expression
                || node.questionDotToken !== questionDotToken
                || node.name !== name
                ? update(createPropertyAccessChain(expression, questionDotToken, name), node)
                : node;
        }
        // @api
        function createElementAccessExpression(expression, index) {
            var node = createBaseExpression(207 /* SyntaxKind.ElementAccessExpression */);
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression, /*optionalChain*/ false);
            node.argumentExpression = asExpression(index);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.argumentExpression);
            if (ts.isSuperKeyword(expression)) {
                // super method calls require a lexical 'this'
                // super method calls require 'super' hoisting in ES2017 and ES2018 async functions and async generators
                node.transformFlags |=
                    256 /* TransformFlags.ContainsES2017 */ |
                        128 /* TransformFlags.ContainsES2018 */;
            }
            return node;
        }
        // @api
        function updateElementAccessExpression(node, expression, argumentExpression) {
            if (ts.isElementAccessChain(node)) {
                return updateElementAccessChain(node, expression, node.questionDotToken, argumentExpression);
            }
            return node.expression !== expression
                || node.argumentExpression !== argumentExpression
                ? update(createElementAccessExpression(expression, argumentExpression), node)
                : node;
        }
        // @api
        function createElementAccessChain(expression, questionDotToken, index) {
            var node = createBaseExpression(207 /* SyntaxKind.ElementAccessExpression */);
            node.flags |= 32 /* NodeFlags.OptionalChain */;
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression, /*optionalChain*/ true);
            node.questionDotToken = questionDotToken;
            node.argumentExpression = asExpression(index);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.questionDotToken) |
                    propagateChildFlags(node.argumentExpression) |
                    32 /* TransformFlags.ContainsES2020 */;
            return node;
        }
        // @api
        function updateElementAccessChain(node, expression, questionDotToken, argumentExpression) {
            ts.Debug.assert(!!(node.flags & 32 /* NodeFlags.OptionalChain */), "Cannot update a ElementAccessExpression using updateElementAccessChain. Use updateElementAccess instead.");
            // Because we are updating an existing ElementAccessChain we want to inherit its emitFlags
            // instead of using the default from createElementAccess
            return node.expression !== expression
                || node.questionDotToken !== questionDotToken
                || node.argumentExpression !== argumentExpression
                ? update(createElementAccessChain(expression, questionDotToken, argumentExpression), node)
                : node;
        }
        // @api
        function createCallExpression(expression, typeArguments, argumentsArray) {
            var node = createBaseExpression(208 /* SyntaxKind.CallExpression */);
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression, /*optionalChain*/ false);
            node.typeArguments = asNodeArray(typeArguments);
            node.arguments = parenthesizerRules().parenthesizeExpressionsOfCommaDelimitedList(createNodeArray(argumentsArray));
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildrenFlags(node.typeArguments) |
                    propagateChildrenFlags(node.arguments);
            if (node.typeArguments) {
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            }
            if (ts.isImportKeyword(node.expression)) {
                node.transformFlags |= 8388608 /* TransformFlags.ContainsDynamicImport */;
            }
            else if (ts.isSuperProperty(node.expression)) {
                node.transformFlags |= 16384 /* TransformFlags.ContainsLexicalThis */;
            }
            return node;
        }
        // @api
        function updateCallExpression(node, expression, typeArguments, argumentsArray) {
            if (ts.isCallChain(node)) {
                return updateCallChain(node, expression, node.questionDotToken, typeArguments, argumentsArray);
            }
            return node.expression !== expression
                || node.typeArguments !== typeArguments
                || node.arguments !== argumentsArray
                ? update(createCallExpression(expression, typeArguments, argumentsArray), node)
                : node;
        }
        // @api
        function createCallChain(expression, questionDotToken, typeArguments, argumentsArray) {
            var node = createBaseExpression(208 /* SyntaxKind.CallExpression */);
            node.flags |= 32 /* NodeFlags.OptionalChain */;
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression, /*optionalChain*/ true);
            node.questionDotToken = questionDotToken;
            node.typeArguments = asNodeArray(typeArguments);
            node.arguments = parenthesizerRules().parenthesizeExpressionsOfCommaDelimitedList(createNodeArray(argumentsArray));
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.questionDotToken) |
                    propagateChildrenFlags(node.typeArguments) |
                    propagateChildrenFlags(node.arguments) |
                    32 /* TransformFlags.ContainsES2020 */;
            if (node.typeArguments) {
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            }
            if (ts.isSuperProperty(node.expression)) {
                node.transformFlags |= 16384 /* TransformFlags.ContainsLexicalThis */;
            }
            return node;
        }
        // @api
        function updateCallChain(node, expression, questionDotToken, typeArguments, argumentsArray) {
            ts.Debug.assert(!!(node.flags & 32 /* NodeFlags.OptionalChain */), "Cannot update a CallExpression using updateCallChain. Use updateCall instead.");
            return node.expression !== expression
                || node.questionDotToken !== questionDotToken
                || node.typeArguments !== typeArguments
                || node.arguments !== argumentsArray
                ? update(createCallChain(expression, questionDotToken, typeArguments, argumentsArray), node)
                : node;
        }
        // @api
        function createNewExpression(expression, typeArguments, argumentsArray) {
            var node = createBaseExpression(209 /* SyntaxKind.NewExpression */);
            node.expression = parenthesizerRules().parenthesizeExpressionOfNew(expression);
            node.typeArguments = asNodeArray(typeArguments);
            node.arguments = argumentsArray ? parenthesizerRules().parenthesizeExpressionsOfCommaDelimitedList(argumentsArray) : undefined;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildrenFlags(node.typeArguments) |
                    propagateChildrenFlags(node.arguments) |
                    32 /* TransformFlags.ContainsES2020 */;
            if (node.typeArguments) {
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            }
            return node;
        }
        // @api
        function updateNewExpression(node, expression, typeArguments, argumentsArray) {
            return node.expression !== expression
                || node.typeArguments !== typeArguments
                || node.arguments !== argumentsArray
                ? update(createNewExpression(expression, typeArguments, argumentsArray), node)
                : node;
        }
        // @api
        function createTaggedTemplateExpression(tag, typeArguments, template) {
            var node = createBaseExpression(210 /* SyntaxKind.TaggedTemplateExpression */);
            node.tag = parenthesizerRules().parenthesizeLeftSideOfAccess(tag, /*optionalChain*/ false);
            node.typeArguments = asNodeArray(typeArguments);
            node.template = template;
            node.transformFlags |=
                propagateChildFlags(node.tag) |
                    propagateChildrenFlags(node.typeArguments) |
                    propagateChildFlags(node.template) |
                    1024 /* TransformFlags.ContainsES2015 */;
            if (node.typeArguments) {
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            }
            if (ts.hasInvalidEscape(node.template)) {
                node.transformFlags |= 128 /* TransformFlags.ContainsES2018 */;
            }
            return node;
        }
        // @api
        function updateTaggedTemplateExpression(node, tag, typeArguments, template) {
            return node.tag !== tag
                || node.typeArguments !== typeArguments
                || node.template !== template
                ? update(createTaggedTemplateExpression(tag, typeArguments, template), node)
                : node;
        }
        // @api
        function createTypeAssertion(type, expression) {
            var node = createBaseExpression(211 /* SyntaxKind.TypeAssertionExpression */);
            node.expression = parenthesizerRules().parenthesizeOperandOfPrefixUnary(expression);
            node.type = type;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.type) |
                    1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateTypeAssertion(node, type, expression) {
            return node.type !== type
                || node.expression !== expression
                ? update(createTypeAssertion(type, expression), node)
                : node;
        }
        // @api
        function createParenthesizedExpression(expression) {
            var node = createBaseExpression(212 /* SyntaxKind.ParenthesizedExpression */);
            node.expression = expression;
            node.transformFlags = propagateChildFlags(node.expression);
            return node;
        }
        // @api
        function updateParenthesizedExpression(node, expression) {
            return node.expression !== expression
                ? update(createParenthesizedExpression(expression), node)
                : node;
        }
        // @api
        function createFunctionExpression(modifiers, asteriskToken, name, typeParameters, parameters, type, body) {
            var node = createBaseFunctionLikeDeclaration(213 /* SyntaxKind.FunctionExpression */, modifiers, name, typeParameters, parameters, type, body);
            node.asteriskToken = asteriskToken;
            node.transformFlags |= propagateChildFlags(node.asteriskToken);
            if (node.typeParameters) {
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            }
            if (ts.modifiersToFlags(node.modifiers) & 256 /* ModifierFlags.Async */) {
                if (node.asteriskToken) {
                    node.transformFlags |= 128 /* TransformFlags.ContainsES2018 */;
                }
                else {
                    node.transformFlags |= 256 /* TransformFlags.ContainsES2017 */;
                }
            }
            else if (node.asteriskToken) {
                node.transformFlags |= 2048 /* TransformFlags.ContainsGenerator */;
            }
            return node;
        }
        // @api
        function updateFunctionExpression(node, modifiers, asteriskToken, name, typeParameters, parameters, type, body) {
            return node.name !== name
                || node.modifiers !== modifiers
                || node.asteriskToken !== asteriskToken
                || node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                || node.body !== body
                ? finishUpdateBaseSignatureDeclaration(createFunctionExpression(modifiers, asteriskToken, name, typeParameters, parameters, type, body), node)
                : node;
        }
        // @api
        function createArrowFunction(modifiers, typeParameters, parameters, type, equalsGreaterThanToken, body) {
            var node = createBaseFunctionLikeDeclaration(214 /* SyntaxKind.ArrowFunction */, modifiers, 
            /*name*/ undefined, typeParameters, parameters, type, parenthesizerRules().parenthesizeConciseBodyOfArrowFunction(body));
            node.equalsGreaterThanToken = equalsGreaterThanToken !== null && equalsGreaterThanToken !== void 0 ? equalsGreaterThanToken : createToken(38 /* SyntaxKind.EqualsGreaterThanToken */);
            node.transformFlags |=
                propagateChildFlags(node.equalsGreaterThanToken) |
                    1024 /* TransformFlags.ContainsES2015 */;
            if (ts.modifiersToFlags(node.modifiers) & 256 /* ModifierFlags.Async */) {
                node.transformFlags |= 256 /* TransformFlags.ContainsES2017 */ | 16384 /* TransformFlags.ContainsLexicalThis */;
            }
            return node;
        }
        // @api
        function updateArrowFunction(node, modifiers, typeParameters, parameters, type, equalsGreaterThanToken, body) {
            return node.modifiers !== modifiers
                || node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                || node.equalsGreaterThanToken !== equalsGreaterThanToken
                || node.body !== body
                ? finishUpdateBaseSignatureDeclaration(createArrowFunction(modifiers, typeParameters, parameters, type, equalsGreaterThanToken, body), node)
                : node;
        }
        // @api
        function createDeleteExpression(expression) {
            var node = createBaseExpression(215 /* SyntaxKind.DeleteExpression */);
            node.expression = parenthesizerRules().parenthesizeOperandOfPrefixUnary(expression);
            node.transformFlags |= propagateChildFlags(node.expression);
            return node;
        }
        // @api
        function updateDeleteExpression(node, expression) {
            return node.expression !== expression
                ? update(createDeleteExpression(expression), node)
                : node;
        }
        // @api
        function createTypeOfExpression(expression) {
            var node = createBaseExpression(216 /* SyntaxKind.TypeOfExpression */);
            node.expression = parenthesizerRules().parenthesizeOperandOfPrefixUnary(expression);
            node.transformFlags |= propagateChildFlags(node.expression);
            return node;
        }
        // @api
        function updateTypeOfExpression(node, expression) {
            return node.expression !== expression
                ? update(createTypeOfExpression(expression), node)
                : node;
        }
        // @api
        function createVoidExpression(expression) {
            var node = createBaseExpression(217 /* SyntaxKind.VoidExpression */);
            node.expression = parenthesizerRules().parenthesizeOperandOfPrefixUnary(expression);
            node.transformFlags |= propagateChildFlags(node.expression);
            return node;
        }
        // @api
        function updateVoidExpression(node, expression) {
            return node.expression !== expression
                ? update(createVoidExpression(expression), node)
                : node;
        }
        // @api
        function createAwaitExpression(expression) {
            var node = createBaseExpression(218 /* SyntaxKind.AwaitExpression */);
            node.expression = parenthesizerRules().parenthesizeOperandOfPrefixUnary(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    256 /* TransformFlags.ContainsES2017 */ |
                    128 /* TransformFlags.ContainsES2018 */ |
                    2097152 /* TransformFlags.ContainsAwait */;
            return node;
        }
        // @api
        function updateAwaitExpression(node, expression) {
            return node.expression !== expression
                ? update(createAwaitExpression(expression), node)
                : node;
        }
        // @api
        function createPrefixUnaryExpression(operator, operand) {
            var node = createBaseExpression(219 /* SyntaxKind.PrefixUnaryExpression */);
            node.operator = operator;
            node.operand = parenthesizerRules().parenthesizeOperandOfPrefixUnary(operand);
            node.transformFlags |= propagateChildFlags(node.operand);
            // Only set this flag for non-generated identifiers and non-"local" names. See the
            // comment in `visitPreOrPostfixUnaryExpression` in module.ts
            if ((operator === 45 /* SyntaxKind.PlusPlusToken */ || operator === 46 /* SyntaxKind.MinusMinusToken */) &&
                ts.isIdentifier(node.operand) &&
                !ts.isGeneratedIdentifier(node.operand) &&
                !ts.isLocalName(node.operand)) {
                node.transformFlags |= 268435456 /* TransformFlags.ContainsUpdateExpressionForIdentifier */;
            }
            return node;
        }
        // @api
        function updatePrefixUnaryExpression(node, operand) {
            return node.operand !== operand
                ? update(createPrefixUnaryExpression(node.operator, operand), node)
                : node;
        }
        // @api
        function createPostfixUnaryExpression(operand, operator) {
            var node = createBaseExpression(220 /* SyntaxKind.PostfixUnaryExpression */);
            node.operator = operator;
            node.operand = parenthesizerRules().parenthesizeOperandOfPostfixUnary(operand);
            node.transformFlags |= propagateChildFlags(node.operand);
            // Only set this flag for non-generated identifiers and non-"local" names. See the
            // comment in `visitPreOrPostfixUnaryExpression` in module.ts
            if (ts.isIdentifier(node.operand) &&
                !ts.isGeneratedIdentifier(node.operand) &&
                !ts.isLocalName(node.operand)) {
                node.transformFlags |= 268435456 /* TransformFlags.ContainsUpdateExpressionForIdentifier */;
            }
            return node;
        }
        // @api
        function updatePostfixUnaryExpression(node, operand) {
            return node.operand !== operand
                ? update(createPostfixUnaryExpression(operand, node.operator), node)
                : node;
        }
        // @api
        function createBinaryExpression(left, operator, right) {
            var node = createBaseExpression(221 /* SyntaxKind.BinaryExpression */);
            var operatorToken = asToken(operator);
            var operatorKind = operatorToken.kind;
            node.left = parenthesizerRules().parenthesizeLeftSideOfBinary(operatorKind, left);
            node.operatorToken = operatorToken;
            node.right = parenthesizerRules().parenthesizeRightSideOfBinary(operatorKind, node.left, right);
            node.transformFlags |=
                propagateChildFlags(node.left) |
                    propagateChildFlags(node.operatorToken) |
                    propagateChildFlags(node.right);
            if (operatorKind === 60 /* SyntaxKind.QuestionQuestionToken */) {
                node.transformFlags |= 32 /* TransformFlags.ContainsES2020 */;
            }
            else if (operatorKind === 63 /* SyntaxKind.EqualsToken */) {
                if (ts.isObjectLiteralExpression(node.left)) {
                    node.transformFlags |=
                        1024 /* TransformFlags.ContainsES2015 */ |
                            128 /* TransformFlags.ContainsES2018 */ |
                            4096 /* TransformFlags.ContainsDestructuringAssignment */ |
                            propagateAssignmentPatternFlags(node.left);
                }
                else if (ts.isArrayLiteralExpression(node.left)) {
                    node.transformFlags |=
                        1024 /* TransformFlags.ContainsES2015 */ |
                            4096 /* TransformFlags.ContainsDestructuringAssignment */ |
                            propagateAssignmentPatternFlags(node.left);
                }
            }
            else if (operatorKind === 42 /* SyntaxKind.AsteriskAsteriskToken */ || operatorKind === 67 /* SyntaxKind.AsteriskAsteriskEqualsToken */) {
                node.transformFlags |= 512 /* TransformFlags.ContainsES2016 */;
            }
            else if (ts.isLogicalOrCoalescingAssignmentOperator(operatorKind)) {
                node.transformFlags |= 16 /* TransformFlags.ContainsES2021 */;
            }
            if (operatorKind === 101 /* SyntaxKind.InKeyword */ && ts.isPrivateIdentifier(node.left)) {
                node.transformFlags |= 536870912 /* TransformFlags.ContainsPrivateIdentifierInExpression */;
            }
            return node;
        }
        function propagateAssignmentPatternFlags(node) {
            if (node.transformFlags & 65536 /* TransformFlags.ContainsObjectRestOrSpread */)
                return 65536 /* TransformFlags.ContainsObjectRestOrSpread */;
            if (node.transformFlags & 128 /* TransformFlags.ContainsES2018 */) {
                // check for nested spread assignments, otherwise '{ x: { a, ...b } = foo } = c'
                // will not be correctly interpreted by the ES2018 transformer
                for (var _i = 0, _a = ts.getElementsOfBindingOrAssignmentPattern(node); _i < _a.length; _i++) {
                    var element = _a[_i];
                    var target = ts.getTargetOfBindingOrAssignmentElement(element);
                    if (target && ts.isAssignmentPattern(target)) {
                        if (target.transformFlags & 65536 /* TransformFlags.ContainsObjectRestOrSpread */) {
                            return 65536 /* TransformFlags.ContainsObjectRestOrSpread */;
                        }
                        if (target.transformFlags & 128 /* TransformFlags.ContainsES2018 */) {
                            var flags_1 = propagateAssignmentPatternFlags(target);
                            if (flags_1)
                                return flags_1;
                        }
                    }
                }
            }
            return 0 /* TransformFlags.None */;
        }
        // @api
        function updateBinaryExpression(node, left, operator, right) {
            return node.left !== left
                || node.operatorToken !== operator
                || node.right !== right
                ? update(createBinaryExpression(left, operator, right), node)
                : node;
        }
        // @api
        function createConditionalExpression(condition, questionToken, whenTrue, colonToken, whenFalse) {
            var node = createBaseExpression(222 /* SyntaxKind.ConditionalExpression */);
            node.condition = parenthesizerRules().parenthesizeConditionOfConditionalExpression(condition);
            node.questionToken = questionToken !== null && questionToken !== void 0 ? questionToken : createToken(57 /* SyntaxKind.QuestionToken */);
            node.whenTrue = parenthesizerRules().parenthesizeBranchOfConditionalExpression(whenTrue);
            node.colonToken = colonToken !== null && colonToken !== void 0 ? colonToken : createToken(58 /* SyntaxKind.ColonToken */);
            node.whenFalse = parenthesizerRules().parenthesizeBranchOfConditionalExpression(whenFalse);
            node.transformFlags |=
                propagateChildFlags(node.condition) |
                    propagateChildFlags(node.questionToken) |
                    propagateChildFlags(node.whenTrue) |
                    propagateChildFlags(node.colonToken) |
                    propagateChildFlags(node.whenFalse);
            return node;
        }
        // @api
        function updateConditionalExpression(node, condition, questionToken, whenTrue, colonToken, whenFalse) {
            return node.condition !== condition
                || node.questionToken !== questionToken
                || node.whenTrue !== whenTrue
                || node.colonToken !== colonToken
                || node.whenFalse !== whenFalse
                ? update(createConditionalExpression(condition, questionToken, whenTrue, colonToken, whenFalse), node)
                : node;
        }
        // @api
        function createTemplateExpression(head, templateSpans) {
            var node = createBaseExpression(223 /* SyntaxKind.TemplateExpression */);
            node.head = head;
            node.templateSpans = createNodeArray(templateSpans);
            node.transformFlags |=
                propagateChildFlags(node.head) |
                    propagateChildrenFlags(node.templateSpans) |
                    1024 /* TransformFlags.ContainsES2015 */;
            return node;
        }
        // @api
        function updateTemplateExpression(node, head, templateSpans) {
            return node.head !== head
                || node.templateSpans !== templateSpans
                ? update(createTemplateExpression(head, templateSpans), node)
                : node;
        }
        function createTemplateLiteralLikeNodeChecked(kind, text, rawText, templateFlags) {
            if (templateFlags === void 0) { templateFlags = 0 /* TokenFlags.None */; }
            ts.Debug.assert(!(templateFlags & ~2048 /* TokenFlags.TemplateLiteralLikeFlags */), "Unsupported template flags.");
            // NOTE: without the assignment to `undefined`, we don't narrow the initial type of `cooked`.
            // eslint-disable-next-line no-undef-init
            var cooked = undefined;
            if (rawText !== undefined && rawText !== text) {
                cooked = getCookedText(kind, rawText);
                if (typeof cooked === "object") {
                    return ts.Debug.fail("Invalid raw text");
                }
            }
            if (text === undefined) {
                if (cooked === undefined) {
                    return ts.Debug.fail("Arguments 'text' and 'rawText' may not both be undefined.");
                }
                text = cooked;
            }
            else if (cooked !== undefined) {
                ts.Debug.assert(text === cooked, "Expected argument 'text' to be the normalized (i.e. 'cooked') version of argument 'rawText'.");
            }
            return createTemplateLiteralLikeNode(kind, text, rawText, templateFlags);
        }
        // @api
        function createTemplateLiteralLikeNode(kind, text, rawText, templateFlags) {
            var node = createBaseToken(kind);
            node.text = text;
            node.rawText = rawText;
            node.templateFlags = templateFlags & 2048 /* TokenFlags.TemplateLiteralLikeFlags */;
            node.transformFlags |= 1024 /* TransformFlags.ContainsES2015 */;
            if (node.templateFlags) {
                node.transformFlags |= 128 /* TransformFlags.ContainsES2018 */;
            }
            return node;
        }
        // @api
        function createTemplateHead(text, rawText, templateFlags) {
            return createTemplateLiteralLikeNodeChecked(15 /* SyntaxKind.TemplateHead */, text, rawText, templateFlags);
        }
        // @api
        function createTemplateMiddle(text, rawText, templateFlags) {
            return createTemplateLiteralLikeNodeChecked(16 /* SyntaxKind.TemplateMiddle */, text, rawText, templateFlags);
        }
        // @api
        function createTemplateTail(text, rawText, templateFlags) {
            return createTemplateLiteralLikeNodeChecked(17 /* SyntaxKind.TemplateTail */, text, rawText, templateFlags);
        }
        // @api
        function createNoSubstitutionTemplateLiteral(text, rawText, templateFlags) {
            return createTemplateLiteralLikeNodeChecked(14 /* SyntaxKind.NoSubstitutionTemplateLiteral */, text, rawText, templateFlags);
        }
        // @api
        function createYieldExpression(asteriskToken, expression) {
            ts.Debug.assert(!asteriskToken || !!expression, "A `YieldExpression` with an asteriskToken must have an expression.");
            var node = createBaseExpression(224 /* SyntaxKind.YieldExpression */);
            node.expression = expression && parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.asteriskToken = asteriskToken;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.asteriskToken) |
                    1024 /* TransformFlags.ContainsES2015 */ |
                    128 /* TransformFlags.ContainsES2018 */ |
                    1048576 /* TransformFlags.ContainsYield */;
            return node;
        }
        // @api
        function updateYieldExpression(node, asteriskToken, expression) {
            return node.expression !== expression
                || node.asteriskToken !== asteriskToken
                ? update(createYieldExpression(asteriskToken, expression), node)
                : node;
        }
        // @api
        function createSpreadElement(expression) {
            var node = createBaseExpression(225 /* SyntaxKind.SpreadElement */);
            node.expression = parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    1024 /* TransformFlags.ContainsES2015 */ |
                    32768 /* TransformFlags.ContainsRestOrSpread */;
            return node;
        }
        // @api
        function updateSpreadElement(node, expression) {
            return node.expression !== expression
                ? update(createSpreadElement(expression), node)
                : node;
        }
        // @api
        function createClassExpression(modifiers, name, typeParameters, heritageClauses, members) {
            var node = createBaseClassLikeDeclaration(226 /* SyntaxKind.ClassExpression */, modifiers, name, typeParameters, heritageClauses, members);
            node.transformFlags |= 1024 /* TransformFlags.ContainsES2015 */;
            return node;
        }
        // @api
        function updateClassExpression(node, modifiers, name, typeParameters, heritageClauses, members) {
            return node.modifiers !== modifiers
                || node.name !== name
                || node.typeParameters !== typeParameters
                || node.heritageClauses !== heritageClauses
                || node.members !== members
                ? update(createClassExpression(modifiers, name, typeParameters, heritageClauses, members), node)
                : node;
        }
        // @api
        function createOmittedExpression() {
            return createBaseExpression(227 /* SyntaxKind.OmittedExpression */);
        }
        // @api
        function createExpressionWithTypeArguments(expression, typeArguments) {
            var node = createBaseNode(228 /* SyntaxKind.ExpressionWithTypeArguments */);
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression, /*optionalChain*/ false);
            node.typeArguments = typeArguments && parenthesizerRules().parenthesizeTypeArguments(typeArguments);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildrenFlags(node.typeArguments) |
                    1024 /* TransformFlags.ContainsES2015 */;
            return node;
        }
        // @api
        function updateExpressionWithTypeArguments(node, expression, typeArguments) {
            return node.expression !== expression
                || node.typeArguments !== typeArguments
                ? update(createExpressionWithTypeArguments(expression, typeArguments), node)
                : node;
        }
        // @api
        function createAsExpression(expression, type) {
            var node = createBaseExpression(229 /* SyntaxKind.AsExpression */);
            node.expression = expression;
            node.type = type;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.type) |
                    1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateAsExpression(node, expression, type) {
            return node.expression !== expression
                || node.type !== type
                ? update(createAsExpression(expression, type), node)
                : node;
        }
        // @api
        function createNonNullExpression(expression) {
            var node = createBaseExpression(230 /* SyntaxKind.NonNullExpression */);
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression, /*optionalChain*/ false);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateNonNullExpression(node, expression) {
            if (ts.isNonNullChain(node)) {
                return updateNonNullChain(node, expression);
            }
            return node.expression !== expression
                ? update(createNonNullExpression(expression), node)
                : node;
        }
        // @api
        function createNonNullChain(expression) {
            var node = createBaseExpression(230 /* SyntaxKind.NonNullExpression */);
            node.flags |= 32 /* NodeFlags.OptionalChain */;
            node.expression = parenthesizerRules().parenthesizeLeftSideOfAccess(expression, /*optionalChain*/ true);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateNonNullChain(node, expression) {
            ts.Debug.assert(!!(node.flags & 32 /* NodeFlags.OptionalChain */), "Cannot update a NonNullExpression using updateNonNullChain. Use updateNonNullExpression instead.");
            return node.expression !== expression
                ? update(createNonNullChain(expression), node)
                : node;
        }
        // @api
        function createMetaProperty(keywordToken, name) {
            var node = createBaseExpression(231 /* SyntaxKind.MetaProperty */);
            node.keywordToken = keywordToken;
            node.name = name;
            node.transformFlags |= propagateChildFlags(node.name);
            switch (keywordToken) {
                case 103 /* SyntaxKind.NewKeyword */:
                    node.transformFlags |= 1024 /* TransformFlags.ContainsES2015 */;
                    break;
                case 100 /* SyntaxKind.ImportKeyword */:
                    node.transformFlags |= 4 /* TransformFlags.ContainsESNext */;
                    break;
                default:
                    return ts.Debug.assertNever(keywordToken);
            }
            return node;
        }
        // @api
        function updateMetaProperty(node, name) {
            return node.name !== name
                ? update(createMetaProperty(node.keywordToken, name), node)
                : node;
        }
        //
        // Misc
        //
        // @api
        function createTemplateSpan(expression, literal) {
            var node = createBaseNode(233 /* SyntaxKind.TemplateSpan */);
            node.expression = expression;
            node.literal = literal;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.literal) |
                    1024 /* TransformFlags.ContainsES2015 */;
            return node;
        }
        // @api
        function updateTemplateSpan(node, expression, literal) {
            return node.expression !== expression
                || node.literal !== literal
                ? update(createTemplateSpan(expression, literal), node)
                : node;
        }
        // @api
        function createSemicolonClassElement() {
            var node = createBaseNode(234 /* SyntaxKind.SemicolonClassElement */);
            node.transformFlags |= 1024 /* TransformFlags.ContainsES2015 */;
            return node;
        }
        //
        // Element
        //
        // @api
        function createBlock(statements, multiLine) {
            var node = createBaseNode(235 /* SyntaxKind.Block */);
            node.statements = createNodeArray(statements);
            node.multiLine = multiLine;
            node.transformFlags |= propagateChildrenFlags(node.statements);
            return node;
        }
        // @api
        function updateBlock(node, statements) {
            return node.statements !== statements
                ? update(createBlock(statements, node.multiLine), node)
                : node;
        }
        // @api
        function createVariableStatement(modifiers, declarationList) {
            var node = createBaseDeclaration(237 /* SyntaxKind.VariableStatement */);
            node.modifiers = asNodeArray(modifiers);
            node.declarationList = ts.isArray(declarationList) ? createVariableDeclarationList(declarationList) : declarationList;
            node.transformFlags |=
                propagateChildrenFlags(node.modifiers) |
                    propagateChildFlags(node.declarationList);
            if (ts.modifiersToFlags(node.modifiers) & 2 /* ModifierFlags.Ambient */) {
                node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            }
            return node;
        }
        // @api
        function updateVariableStatement(node, modifiers, declarationList) {
            return node.modifiers !== modifiers
                || node.declarationList !== declarationList
                ? update(createVariableStatement(modifiers, declarationList), node)
                : node;
        }
        // @api
        function createEmptyStatement() {
            return createBaseNode(236 /* SyntaxKind.EmptyStatement */);
        }
        // @api
        function createExpressionStatement(expression) {
            var node = createBaseNode(238 /* SyntaxKind.ExpressionStatement */);
            node.expression = parenthesizerRules().parenthesizeExpressionOfExpressionStatement(expression);
            node.transformFlags |= propagateChildFlags(node.expression);
            return node;
        }
        // @api
        function updateExpressionStatement(node, expression) {
            return node.expression !== expression
                ? update(createExpressionStatement(expression), node)
                : node;
        }
        // @api
        function createIfStatement(expression, thenStatement, elseStatement) {
            var node = createBaseNode(239 /* SyntaxKind.IfStatement */);
            node.expression = expression;
            node.thenStatement = asEmbeddedStatement(thenStatement);
            node.elseStatement = asEmbeddedStatement(elseStatement);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.thenStatement) |
                    propagateChildFlags(node.elseStatement);
            return node;
        }
        // @api
        function updateIfStatement(node, expression, thenStatement, elseStatement) {
            return node.expression !== expression
                || node.thenStatement !== thenStatement
                || node.elseStatement !== elseStatement
                ? update(createIfStatement(expression, thenStatement, elseStatement), node)
                : node;
        }
        // @api
        function createDoStatement(statement, expression) {
            var node = createBaseNode(240 /* SyntaxKind.DoStatement */);
            node.statement = asEmbeddedStatement(statement);
            node.expression = expression;
            node.transformFlags |=
                propagateChildFlags(node.statement) |
                    propagateChildFlags(node.expression);
            return node;
        }
        // @api
        function updateDoStatement(node, statement, expression) {
            return node.statement !== statement
                || node.expression !== expression
                ? update(createDoStatement(statement, expression), node)
                : node;
        }
        // @api
        function createWhileStatement(expression, statement) {
            var node = createBaseNode(241 /* SyntaxKind.WhileStatement */);
            node.expression = expression;
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.statement);
            return node;
        }
        // @api
        function updateWhileStatement(node, expression, statement) {
            return node.expression !== expression
                || node.statement !== statement
                ? update(createWhileStatement(expression, statement), node)
                : node;
        }
        // @api
        function createForStatement(initializer, condition, incrementor, statement) {
            var node = createBaseNode(242 /* SyntaxKind.ForStatement */);
            node.initializer = initializer;
            node.condition = condition;
            node.incrementor = incrementor;
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.initializer) |
                    propagateChildFlags(node.condition) |
                    propagateChildFlags(node.incrementor) |
                    propagateChildFlags(node.statement);
            return node;
        }
        // @api
        function updateForStatement(node, initializer, condition, incrementor, statement) {
            return node.initializer !== initializer
                || node.condition !== condition
                || node.incrementor !== incrementor
                || node.statement !== statement
                ? update(createForStatement(initializer, condition, incrementor, statement), node)
                : node;
        }
        // @api
        function createForInStatement(initializer, expression, statement) {
            var node = createBaseNode(243 /* SyntaxKind.ForInStatement */);
            node.initializer = initializer;
            node.expression = expression;
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.initializer) |
                    propagateChildFlags(node.expression) |
                    propagateChildFlags(node.statement);
            return node;
        }
        // @api
        function updateForInStatement(node, initializer, expression, statement) {
            return node.initializer !== initializer
                || node.expression !== expression
                || node.statement !== statement
                ? update(createForInStatement(initializer, expression, statement), node)
                : node;
        }
        // @api
        function createForOfStatement(awaitModifier, initializer, expression, statement) {
            var node = createBaseNode(244 /* SyntaxKind.ForOfStatement */);
            node.awaitModifier = awaitModifier;
            node.initializer = initializer;
            node.expression = parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.awaitModifier) |
                    propagateChildFlags(node.initializer) |
                    propagateChildFlags(node.expression) |
                    propagateChildFlags(node.statement) |
                    1024 /* TransformFlags.ContainsES2015 */;
            if (awaitModifier)
                node.transformFlags |= 128 /* TransformFlags.ContainsES2018 */;
            return node;
        }
        // @api
        function updateForOfStatement(node, awaitModifier, initializer, expression, statement) {
            return node.awaitModifier !== awaitModifier
                || node.initializer !== initializer
                || node.expression !== expression
                || node.statement !== statement
                ? update(createForOfStatement(awaitModifier, initializer, expression, statement), node)
                : node;
        }
        // @api
        function createContinueStatement(label) {
            var node = createBaseNode(245 /* SyntaxKind.ContinueStatement */);
            node.label = asName(label);
            node.transformFlags |=
                propagateChildFlags(node.label) |
                    4194304 /* TransformFlags.ContainsHoistedDeclarationOrCompletion */;
            return node;
        }
        // @api
        function updateContinueStatement(node, label) {
            return node.label !== label
                ? update(createContinueStatement(label), node)
                : node;
        }
        // @api
        function createBreakStatement(label) {
            var node = createBaseNode(246 /* SyntaxKind.BreakStatement */);
            node.label = asName(label);
            node.transformFlags |=
                propagateChildFlags(node.label) |
                    4194304 /* TransformFlags.ContainsHoistedDeclarationOrCompletion */;
            return node;
        }
        // @api
        function updateBreakStatement(node, label) {
            return node.label !== label
                ? update(createBreakStatement(label), node)
                : node;
        }
        // @api
        function createReturnStatement(expression) {
            var node = createBaseNode(247 /* SyntaxKind.ReturnStatement */);
            node.expression = expression;
            // return in an ES2018 async generator must be awaited
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    128 /* TransformFlags.ContainsES2018 */ |
                    4194304 /* TransformFlags.ContainsHoistedDeclarationOrCompletion */;
            return node;
        }
        // @api
        function updateReturnStatement(node, expression) {
            return node.expression !== expression
                ? update(createReturnStatement(expression), node)
                : node;
        }
        // @api
        function createWithStatement(expression, statement) {
            var node = createBaseNode(248 /* SyntaxKind.WithStatement */);
            node.expression = expression;
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.statement);
            return node;
        }
        // @api
        function updateWithStatement(node, expression, statement) {
            return node.expression !== expression
                || node.statement !== statement
                ? update(createWithStatement(expression, statement), node)
                : node;
        }
        // @api
        function createSwitchStatement(expression, caseBlock) {
            var node = createBaseNode(249 /* SyntaxKind.SwitchStatement */);
            node.expression = parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.caseBlock = caseBlock;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.caseBlock);
            return node;
        }
        // @api
        function updateSwitchStatement(node, expression, caseBlock) {
            return node.expression !== expression
                || node.caseBlock !== caseBlock
                ? update(createSwitchStatement(expression, caseBlock), node)
                : node;
        }
        // @api
        function createLabeledStatement(label, statement) {
            var node = createBaseNode(250 /* SyntaxKind.LabeledStatement */);
            node.label = asName(label);
            node.statement = asEmbeddedStatement(statement);
            node.transformFlags |=
                propagateChildFlags(node.label) |
                    propagateChildFlags(node.statement);
            return node;
        }
        // @api
        function updateLabeledStatement(node, label, statement) {
            return node.label !== label
                || node.statement !== statement
                ? update(createLabeledStatement(label, statement), node)
                : node;
        }
        // @api
        function createThrowStatement(expression) {
            var node = createBaseNode(251 /* SyntaxKind.ThrowStatement */);
            node.expression = expression;
            node.transformFlags |= propagateChildFlags(node.expression);
            return node;
        }
        // @api
        function updateThrowStatement(node, expression) {
            return node.expression !== expression
                ? update(createThrowStatement(expression), node)
                : node;
        }
        // @api
        function createTryStatement(tryBlock, catchClause, finallyBlock) {
            var node = createBaseNode(252 /* SyntaxKind.TryStatement */);
            node.tryBlock = tryBlock;
            node.catchClause = catchClause;
            node.finallyBlock = finallyBlock;
            node.transformFlags |=
                propagateChildFlags(node.tryBlock) |
                    propagateChildFlags(node.catchClause) |
                    propagateChildFlags(node.finallyBlock);
            return node;
        }
        // @api
        function updateTryStatement(node, tryBlock, catchClause, finallyBlock) {
            return node.tryBlock !== tryBlock
                || node.catchClause !== catchClause
                || node.finallyBlock !== finallyBlock
                ? update(createTryStatement(tryBlock, catchClause, finallyBlock), node)
                : node;
        }
        // @api
        function createDebuggerStatement() {
            return createBaseNode(253 /* SyntaxKind.DebuggerStatement */);
        }
        // @api
        function createVariableDeclaration(name, exclamationToken, type, initializer) {
            var node = createBaseVariableLikeDeclaration(254 /* SyntaxKind.VariableDeclaration */, 
            /*modifiers*/ undefined, name, type, initializer && parenthesizerRules().parenthesizeExpressionForDisallowedComma(initializer));
            node.exclamationToken = exclamationToken;
            node.transformFlags |= propagateChildFlags(node.exclamationToken);
            if (exclamationToken) {
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            }
            return node;
        }
        // @api
        function updateVariableDeclaration(node, name, exclamationToken, type, initializer) {
            return node.name !== name
                || node.type !== type
                || node.exclamationToken !== exclamationToken
                || node.initializer !== initializer
                ? update(createVariableDeclaration(name, exclamationToken, type, initializer), node)
                : node;
        }
        // @api
        function createVariableDeclarationList(declarations, flags) {
            if (flags === void 0) { flags = 0 /* NodeFlags.None */; }
            var node = createBaseNode(255 /* SyntaxKind.VariableDeclarationList */);
            node.flags |= flags & 3 /* NodeFlags.BlockScoped */;
            node.declarations = createNodeArray(declarations);
            node.transformFlags |=
                propagateChildrenFlags(node.declarations) |
                    4194304 /* TransformFlags.ContainsHoistedDeclarationOrCompletion */;
            if (flags & 3 /* NodeFlags.BlockScoped */) {
                node.transformFlags |=
                    1024 /* TransformFlags.ContainsES2015 */ |
                        262144 /* TransformFlags.ContainsBlockScopedBinding */;
            }
            return node;
        }
        // @api
        function updateVariableDeclarationList(node, declarations) {
            return node.declarations !== declarations
                ? update(createVariableDeclarationList(declarations, node.flags), node)
                : node;
        }
        // @api
        function createFunctionDeclaration(modifiers, asteriskToken, name, typeParameters, parameters, type, body) {
            var node = createBaseFunctionLikeDeclaration(256 /* SyntaxKind.FunctionDeclaration */, modifiers, name, typeParameters, parameters, type, body);
            node.asteriskToken = asteriskToken;
            if (!node.body || ts.modifiersToFlags(node.modifiers) & 2 /* ModifierFlags.Ambient */) {
                node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            }
            else {
                node.transformFlags |=
                    propagateChildFlags(node.asteriskToken) |
                        4194304 /* TransformFlags.ContainsHoistedDeclarationOrCompletion */;
                if (ts.modifiersToFlags(node.modifiers) & 256 /* ModifierFlags.Async */) {
                    if (node.asteriskToken) {
                        node.transformFlags |= 128 /* TransformFlags.ContainsES2018 */;
                    }
                    else {
                        node.transformFlags |= 256 /* TransformFlags.ContainsES2017 */;
                    }
                }
                else if (node.asteriskToken) {
                    node.transformFlags |= 2048 /* TransformFlags.ContainsGenerator */;
                }
            }
            // The following properties are used only to report grammar errors
            node.illegalDecorators = undefined;
            return node;
        }
        // @api
        function updateFunctionDeclaration(node, modifiers, asteriskToken, name, typeParameters, parameters, type, body) {
            return node.modifiers !== modifiers
                || node.asteriskToken !== asteriskToken
                || node.name !== name
                || node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                || node.body !== body
                ? finishUpdateFunctionDeclaration(createFunctionDeclaration(modifiers, asteriskToken, name, typeParameters, parameters, type, body), node)
                : node;
        }
        function finishUpdateFunctionDeclaration(updated, original) {
            if (updated !== original) {
                // copy children used only for error reporting
                updated.illegalDecorators = original.illegalDecorators;
            }
            return finishUpdateBaseSignatureDeclaration(updated, original);
        }
        // @api
        function createClassDeclaration(modifiers, name, typeParameters, heritageClauses, members) {
            var node = createBaseClassLikeDeclaration(257 /* SyntaxKind.ClassDeclaration */, modifiers, name, typeParameters, heritageClauses, members);
            if (ts.modifiersToFlags(node.modifiers) & 2 /* ModifierFlags.Ambient */) {
                node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            }
            else {
                node.transformFlags |= 1024 /* TransformFlags.ContainsES2015 */;
                if (node.transformFlags & 8192 /* TransformFlags.ContainsTypeScriptClassSyntax */) {
                    node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
                }
            }
            return node;
        }
        // @api
        function updateClassDeclaration(node, modifiers, name, typeParameters, heritageClauses, members) {
            return node.modifiers !== modifiers
                || node.name !== name
                || node.typeParameters !== typeParameters
                || node.heritageClauses !== heritageClauses
                || node.members !== members
                ? update(createClassDeclaration(modifiers, name, typeParameters, heritageClauses, members), node)
                : node;
        }
        // @api
        function createInterfaceDeclaration(modifiers, name, typeParameters, heritageClauses, members) {
            var node = createBaseInterfaceOrClassLikeDeclaration(258 /* SyntaxKind.InterfaceDeclaration */, modifiers, name, typeParameters, heritageClauses);
            node.members = createNodeArray(members);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            // The following properties are used only to report grammar errors
            node.illegalDecorators = undefined;
            return node;
        }
        // @api
        function updateInterfaceDeclaration(node, modifiers, name, typeParameters, heritageClauses, members) {
            return node.modifiers !== modifiers
                || node.name !== name
                || node.typeParameters !== typeParameters
                || node.heritageClauses !== heritageClauses
                || node.members !== members
                ? finishUpdateInterfaceDeclaration(createInterfaceDeclaration(modifiers, name, typeParameters, heritageClauses, members), node)
                : node;
        }
        function finishUpdateInterfaceDeclaration(updated, original) {
            if (updated !== original) {
                updated.illegalDecorators = original.illegalDecorators;
            }
            return update(updated, original);
        }
        // @api
        function createTypeAliasDeclaration(modifiers, name, typeParameters, type) {
            var node = createBaseGenericNamedDeclaration(259 /* SyntaxKind.TypeAliasDeclaration */, modifiers, name, typeParameters);
            node.type = type;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            // The following properties are used only to report grammar errors
            node.illegalDecorators = undefined;
            return node;
        }
        // @api
        function updateTypeAliasDeclaration(node, modifiers, name, typeParameters, type) {
            return node.modifiers !== modifiers
                || node.name !== name
                || node.typeParameters !== typeParameters
                || node.type !== type
                ? finishUpdateTypeAliasDeclaration(createTypeAliasDeclaration(modifiers, name, typeParameters, type), node)
                : node;
        }
        function finishUpdateTypeAliasDeclaration(updated, original) {
            if (updated !== original) {
                updated.illegalDecorators = original.illegalDecorators;
            }
            return update(updated, original);
        }
        // @api
        function createEnumDeclaration(modifiers, name, members) {
            var node = createBaseNamedDeclaration(260 /* SyntaxKind.EnumDeclaration */, modifiers, name);
            node.members = createNodeArray(members);
            node.transformFlags |=
                propagateChildrenFlags(node.members) |
                    1 /* TransformFlags.ContainsTypeScript */;
            node.transformFlags &= ~67108864 /* TransformFlags.ContainsPossibleTopLevelAwait */; // Enum declarations cannot contain `await`
            // The following properties are used only to report grammar errors
            node.illegalDecorators = undefined;
            return node;
        }
        // @api
        function updateEnumDeclaration(node, modifiers, name, members) {
            return node.modifiers !== modifiers
                || node.name !== name
                || node.members !== members
                ? finishUpdateEnumDeclaration(createEnumDeclaration(modifiers, name, members), node)
                : node;
        }
        function finishUpdateEnumDeclaration(updated, original) {
            if (updated !== original) {
                updated.illegalDecorators = original.illegalDecorators;
            }
            return update(updated, original);
        }
        // @api
        function createModuleDeclaration(modifiers, name, body, flags) {
            if (flags === void 0) { flags = 0 /* NodeFlags.None */; }
            var node = createBaseDeclaration(261 /* SyntaxKind.ModuleDeclaration */);
            node.modifiers = asNodeArray(modifiers);
            node.flags |= flags & (16 /* NodeFlags.Namespace */ | 4 /* NodeFlags.NestedNamespace */ | 1024 /* NodeFlags.GlobalAugmentation */);
            node.name = name;
            node.body = body;
            if (ts.modifiersToFlags(node.modifiers) & 2 /* ModifierFlags.Ambient */) {
                node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            }
            else {
                node.transformFlags |=
                    propagateChildrenFlags(node.modifiers) |
                        propagateChildFlags(node.name) |
                        propagateChildFlags(node.body) |
                        1 /* TransformFlags.ContainsTypeScript */;
            }
            node.transformFlags &= ~67108864 /* TransformFlags.ContainsPossibleTopLevelAwait */; // Module declarations cannot contain `await`.
            // The following properties are used only to report grammar errors
            node.illegalDecorators = undefined;
            return node;
        }
        // @api
        function updateModuleDeclaration(node, modifiers, name, body) {
            return node.modifiers !== modifiers
                || node.name !== name
                || node.body !== body
                ? finishUpdateModuleDeclaration(createModuleDeclaration(modifiers, name, body, node.flags), node)
                : node;
        }
        function finishUpdateModuleDeclaration(updated, original) {
            if (updated !== original) {
                updated.illegalDecorators = original.illegalDecorators;
            }
            return update(updated, original);
        }
        // @api
        function createModuleBlock(statements) {
            var node = createBaseNode(262 /* SyntaxKind.ModuleBlock */);
            node.statements = createNodeArray(statements);
            node.transformFlags |= propagateChildrenFlags(node.statements);
            return node;
        }
        // @api
        function updateModuleBlock(node, statements) {
            return node.statements !== statements
                ? update(createModuleBlock(statements), node)
                : node;
        }
        // @api
        function createCaseBlock(clauses) {
            var node = createBaseNode(263 /* SyntaxKind.CaseBlock */);
            node.clauses = createNodeArray(clauses);
            node.transformFlags |= propagateChildrenFlags(node.clauses);
            return node;
        }
        // @api
        function updateCaseBlock(node, clauses) {
            return node.clauses !== clauses
                ? update(createCaseBlock(clauses), node)
                : node;
        }
        // @api
        function createNamespaceExportDeclaration(name) {
            var node = createBaseNamedDeclaration(264 /* SyntaxKind.NamespaceExportDeclaration */, 
            /*modifiers*/ undefined, name);
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            // The following properties are used only to report grammar errors
            node.illegalDecorators = undefined;
            node.modifiers = undefined;
            return node;
        }
        // @api
        function updateNamespaceExportDeclaration(node, name) {
            return node.name !== name
                ? finishUpdateNamespaceExportDeclaration(createNamespaceExportDeclaration(name), node)
                : node;
        }
        function finishUpdateNamespaceExportDeclaration(updated, original) {
            if (updated !== original) {
                updated.illegalDecorators = original.illegalDecorators;
                updated.modifiers = original.modifiers;
            }
            return update(updated, original);
        }
        // @api
        function createImportEqualsDeclaration(modifiers, isTypeOnly, name, moduleReference) {
            var node = createBaseNamedDeclaration(265 /* SyntaxKind.ImportEqualsDeclaration */, modifiers, name);
            node.isTypeOnly = isTypeOnly;
            node.moduleReference = moduleReference;
            node.transformFlags |= propagateChildFlags(node.moduleReference);
            if (!ts.isExternalModuleReference(node.moduleReference))
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            node.transformFlags &= ~67108864 /* TransformFlags.ContainsPossibleTopLevelAwait */; // Import= declaration is always parsed in an Await context
            // The following properties are used only to report grammar errors
            node.illegalDecorators = undefined;
            return node;
        }
        // @api
        function updateImportEqualsDeclaration(node, modifiers, isTypeOnly, name, moduleReference) {
            return node.modifiers !== modifiers
                || node.isTypeOnly !== isTypeOnly
                || node.name !== name
                || node.moduleReference !== moduleReference
                ? finishUpdateImportEqualsDeclaration(createImportEqualsDeclaration(modifiers, isTypeOnly, name, moduleReference), node)
                : node;
        }
        function finishUpdateImportEqualsDeclaration(updated, original) {
            if (updated !== original) {
                updated.illegalDecorators = original.illegalDecorators;
            }
            return update(updated, original);
        }
        // @api
        function createImportDeclaration(modifiers, importClause, moduleSpecifier, assertClause) {
            var node = createBaseDeclaration(266 /* SyntaxKind.ImportDeclaration */);
            node.modifiers = asNodeArray(modifiers);
            node.importClause = importClause;
            node.moduleSpecifier = moduleSpecifier;
            node.assertClause = assertClause;
            node.transformFlags |=
                propagateChildFlags(node.importClause) |
                    propagateChildFlags(node.moduleSpecifier);
            node.transformFlags &= ~67108864 /* TransformFlags.ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            // The following properties are used only to report grammar errors
            node.illegalDecorators = undefined;
            return node;
        }
        // @api
        function updateImportDeclaration(node, modifiers, importClause, moduleSpecifier, assertClause) {
            return node.modifiers !== modifiers
                || node.importClause !== importClause
                || node.moduleSpecifier !== moduleSpecifier
                || node.assertClause !== assertClause
                ? finishUpdateImportDeclaration(createImportDeclaration(modifiers, importClause, moduleSpecifier, assertClause), node)
                : node;
        }
        function finishUpdateImportDeclaration(updated, original) {
            if (updated !== original) {
                updated.illegalDecorators = original.illegalDecorators;
            }
            return update(updated, original);
        }
        // @api
        function createImportClause(isTypeOnly, name, namedBindings) {
            var node = createBaseNode(267 /* SyntaxKind.ImportClause */);
            node.isTypeOnly = isTypeOnly;
            node.name = name;
            node.namedBindings = namedBindings;
            node.transformFlags |=
                propagateChildFlags(node.name) |
                    propagateChildFlags(node.namedBindings);
            if (isTypeOnly) {
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            }
            node.transformFlags &= ~67108864 /* TransformFlags.ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateImportClause(node, isTypeOnly, name, namedBindings) {
            return node.isTypeOnly !== isTypeOnly
                || node.name !== name
                || node.namedBindings !== namedBindings
                ? update(createImportClause(isTypeOnly, name, namedBindings), node)
                : node;
        }
        // @api
        function createAssertClause(elements, multiLine) {
            var node = createBaseNode(293 /* SyntaxKind.AssertClause */);
            node.elements = createNodeArray(elements);
            node.multiLine = multiLine;
            node.transformFlags |= 4 /* TransformFlags.ContainsESNext */;
            return node;
        }
        // @api
        function updateAssertClause(node, elements, multiLine) {
            return node.elements !== elements
                || node.multiLine !== multiLine
                ? update(createAssertClause(elements, multiLine), node)
                : node;
        }
        // @api
        function createAssertEntry(name, value) {
            var node = createBaseNode(294 /* SyntaxKind.AssertEntry */);
            node.name = name;
            node.value = value;
            node.transformFlags |= 4 /* TransformFlags.ContainsESNext */;
            return node;
        }
        // @api
        function updateAssertEntry(node, name, value) {
            return node.name !== name
                || node.value !== value
                ? update(createAssertEntry(name, value), node)
                : node;
        }
        // @api
        function createImportTypeAssertionContainer(clause, multiLine) {
            var node = createBaseNode(295 /* SyntaxKind.ImportTypeAssertionContainer */);
            node.assertClause = clause;
            node.multiLine = multiLine;
            return node;
        }
        // @api
        function updateImportTypeAssertionContainer(node, clause, multiLine) {
            return node.assertClause !== clause
                || node.multiLine !== multiLine
                ? update(createImportTypeAssertionContainer(clause, multiLine), node)
                : node;
        }
        // @api
        function createNamespaceImport(name) {
            var node = createBaseNode(268 /* SyntaxKind.NamespaceImport */);
            node.name = name;
            node.transformFlags |= propagateChildFlags(node.name);
            node.transformFlags &= ~67108864 /* TransformFlags.ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateNamespaceImport(node, name) {
            return node.name !== name
                ? update(createNamespaceImport(name), node)
                : node;
        }
        // @api
        function createNamespaceExport(name) {
            var node = createBaseNode(274 /* SyntaxKind.NamespaceExport */);
            node.name = name;
            node.transformFlags |=
                propagateChildFlags(node.name) |
                    4 /* TransformFlags.ContainsESNext */;
            node.transformFlags &= ~67108864 /* TransformFlags.ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateNamespaceExport(node, name) {
            return node.name !== name
                ? update(createNamespaceExport(name), node)
                : node;
        }
        // @api
        function createNamedImports(elements) {
            var node = createBaseNode(269 /* SyntaxKind.NamedImports */);
            node.elements = createNodeArray(elements);
            node.transformFlags |= propagateChildrenFlags(node.elements);
            node.transformFlags &= ~67108864 /* TransformFlags.ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateNamedImports(node, elements) {
            return node.elements !== elements
                ? update(createNamedImports(elements), node)
                : node;
        }
        // @api
        function createImportSpecifier(isTypeOnly, propertyName, name) {
            var node = createBaseNode(270 /* SyntaxKind.ImportSpecifier */);
            node.isTypeOnly = isTypeOnly;
            node.propertyName = propertyName;
            node.name = name;
            node.transformFlags |=
                propagateChildFlags(node.propertyName) |
                    propagateChildFlags(node.name);
            node.transformFlags &= ~67108864 /* TransformFlags.ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateImportSpecifier(node, isTypeOnly, propertyName, name) {
            return node.isTypeOnly !== isTypeOnly
                || node.propertyName !== propertyName
                || node.name !== name
                ? update(createImportSpecifier(isTypeOnly, propertyName, name), node)
                : node;
        }
        // @api
        function createExportAssignment(modifiers, isExportEquals, expression) {
            var node = createBaseDeclaration(271 /* SyntaxKind.ExportAssignment */);
            node.modifiers = asNodeArray(modifiers);
            node.isExportEquals = isExportEquals;
            node.expression = isExportEquals
                ? parenthesizerRules().parenthesizeRightSideOfBinary(63 /* SyntaxKind.EqualsToken */, /*leftSide*/ undefined, expression)
                : parenthesizerRules().parenthesizeExpressionOfExportDefault(expression);
            node.transformFlags |= propagateChildrenFlags(node.modifiers) | propagateChildFlags(node.expression);
            node.transformFlags &= ~67108864 /* TransformFlags.ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            // The following properties are used only to report grammar errors
            node.illegalDecorators = undefined;
            return node;
        }
        // @api
        function updateExportAssignment(node, modifiers, expression) {
            return node.modifiers !== modifiers
                || node.expression !== expression
                ? finishUpdateExportAssignment(createExportAssignment(modifiers, node.isExportEquals, expression), node)
                : node;
        }
        function finishUpdateExportAssignment(updated, original) {
            if (updated !== original) {
                updated.illegalDecorators = original.illegalDecorators;
            }
            return update(updated, original);
        }
        // @api
        function createExportDeclaration(modifiers, isTypeOnly, exportClause, moduleSpecifier, assertClause) {
            var node = createBaseDeclaration(272 /* SyntaxKind.ExportDeclaration */);
            node.modifiers = asNodeArray(modifiers);
            node.isTypeOnly = isTypeOnly;
            node.exportClause = exportClause;
            node.moduleSpecifier = moduleSpecifier;
            node.assertClause = assertClause;
            node.transformFlags |=
                propagateChildrenFlags(node.modifiers) |
                    propagateChildFlags(node.exportClause) |
                    propagateChildFlags(node.moduleSpecifier);
            node.transformFlags &= ~67108864 /* TransformFlags.ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            // The following properties are used only to report grammar errors
            node.illegalDecorators = undefined;
            return node;
        }
        // @api
        function updateExportDeclaration(node, modifiers, isTypeOnly, exportClause, moduleSpecifier, assertClause) {
            return node.modifiers !== modifiers
                || node.isTypeOnly !== isTypeOnly
                || node.exportClause !== exportClause
                || node.moduleSpecifier !== moduleSpecifier
                || node.assertClause !== assertClause
                ? finishUpdateExportDeclaration(createExportDeclaration(modifiers, isTypeOnly, exportClause, moduleSpecifier, assertClause), node)
                : node;
        }
        function finishUpdateExportDeclaration(updated, original) {
            if (updated !== original) {
                updated.illegalDecorators = original.illegalDecorators;
            }
            return update(updated, original);
        }
        // @api
        function createNamedExports(elements) {
            var node = createBaseNode(273 /* SyntaxKind.NamedExports */);
            node.elements = createNodeArray(elements);
            node.transformFlags |= propagateChildrenFlags(node.elements);
            node.transformFlags &= ~67108864 /* TransformFlags.ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateNamedExports(node, elements) {
            return node.elements !== elements
                ? update(createNamedExports(elements), node)
                : node;
        }
        // @api
        function createExportSpecifier(isTypeOnly, propertyName, name) {
            var node = createBaseNode(275 /* SyntaxKind.ExportSpecifier */);
            node.isTypeOnly = isTypeOnly;
            node.propertyName = asName(propertyName);
            node.name = asName(name);
            node.transformFlags |=
                propagateChildFlags(node.propertyName) |
                    propagateChildFlags(node.name);
            node.transformFlags &= ~67108864 /* TransformFlags.ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateExportSpecifier(node, isTypeOnly, propertyName, name) {
            return node.isTypeOnly !== isTypeOnly
                || node.propertyName !== propertyName
                || node.name !== name
                ? update(createExportSpecifier(isTypeOnly, propertyName, name), node)
                : node;
        }
        // @api
        function createMissingDeclaration() {
            var node = createBaseDeclaration(276 /* SyntaxKind.MissingDeclaration */);
            return node;
        }
        //
        // Module references
        //
        // @api
        function createExternalModuleReference(expression) {
            var node = createBaseNode(277 /* SyntaxKind.ExternalModuleReference */);
            node.expression = expression;
            node.transformFlags |= propagateChildFlags(node.expression);
            node.transformFlags &= ~67108864 /* TransformFlags.ContainsPossibleTopLevelAwait */; // always parsed in an Await context
            return node;
        }
        // @api
        function updateExternalModuleReference(node, expression) {
            return node.expression !== expression
                ? update(createExternalModuleReference(expression), node)
                : node;
        }
        //
        // JSDoc
        //
        // @api
        // createJSDocAllType
        // createJSDocUnknownType
        function createJSDocPrimaryTypeWorker(kind) {
            return createBaseNode(kind);
        }
        // @api
        // createJSDocNullableType
        // createJSDocNonNullableType
        function createJSDocPrePostfixUnaryTypeWorker(kind, type, postfix) {
            if (postfix === void 0) { postfix = false; }
            var node = createJSDocUnaryTypeWorker(kind, postfix ? type && parenthesizerRules().parenthesizeNonArrayTypeOfPostfixType(type) : type);
            node.postfix = postfix;
            return node;
        }
        // @api
        // createJSDocOptionalType
        // createJSDocVariadicType
        // createJSDocNamepathType
        function createJSDocUnaryTypeWorker(kind, type) {
            var node = createBaseNode(kind);
            node.type = type;
            return node;
        }
        // @api
        // updateJSDocNonNullableType
        // updateJSDocNullableType
        function updateJSDocPrePostfixUnaryTypeWorker(kind, node, type) {
            return node.type !== type
                ? update(createJSDocPrePostfixUnaryTypeWorker(kind, type, node.postfix), node)
                : node;
        }
        // @api
        // updateJSDocOptionalType
        // updateJSDocVariadicType
        // updateJSDocNamepathType
        function updateJSDocUnaryTypeWorker(kind, node, type) {
            return node.type !== type
                ? update(createJSDocUnaryTypeWorker(kind, type), node)
                : node;
        }
        // @api
        function createJSDocFunctionType(parameters, type) {
            var node = createBaseSignatureDeclaration(317 /* SyntaxKind.JSDocFunctionType */, 
            /*modifiers*/ undefined, 
            /*name*/ undefined, 
            /*typeParameters*/ undefined, parameters, type);
            return node;
        }
        // @api
        function updateJSDocFunctionType(node, parameters, type) {
            return node.parameters !== parameters
                || node.type !== type
                ? update(createJSDocFunctionType(parameters, type), node)
                : node;
        }
        // @api
        function createJSDocTypeLiteral(propertyTags, isArrayType) {
            if (isArrayType === void 0) { isArrayType = false; }
            var node = createBaseNode(322 /* SyntaxKind.JSDocTypeLiteral */);
            node.jsDocPropertyTags = asNodeArray(propertyTags);
            node.isArrayType = isArrayType;
            return node;
        }
        // @api
        function updateJSDocTypeLiteral(node, propertyTags, isArrayType) {
            return node.jsDocPropertyTags !== propertyTags
                || node.isArrayType !== isArrayType
                ? update(createJSDocTypeLiteral(propertyTags, isArrayType), node)
                : node;
        }
        // @api
        function createJSDocTypeExpression(type) {
            var node = createBaseNode(309 /* SyntaxKind.JSDocTypeExpression */);
            node.type = type;
            return node;
        }
        // @api
        function updateJSDocTypeExpression(node, type) {
            return node.type !== type
                ? update(createJSDocTypeExpression(type), node)
                : node;
        }
        // @api
        function createJSDocSignature(typeParameters, parameters, type) {
            var node = createBaseNode(323 /* SyntaxKind.JSDocSignature */);
            node.typeParameters = asNodeArray(typeParameters);
            node.parameters = createNodeArray(parameters);
            node.type = type;
            return node;
        }
        // @api
        function updateJSDocSignature(node, typeParameters, parameters, type) {
            return node.typeParameters !== typeParameters
                || node.parameters !== parameters
                || node.type !== type
                ? update(createJSDocSignature(typeParameters, parameters, type), node)
                : node;
        }
        function getDefaultTagName(node) {
            var defaultTagName = getDefaultTagNameForKind(node.kind);
            return node.tagName.escapedText === ts.escapeLeadingUnderscores(defaultTagName)
                ? node.tagName
                : createIdentifier(defaultTagName);
        }
        // @api
        function createBaseJSDocTag(kind, tagName, comment) {
            var node = createBaseNode(kind);
            node.tagName = tagName;
            node.comment = comment;
            return node;
        }
        // @api
        function createJSDocTemplateTag(tagName, constraint, typeParameters, comment) {
            var node = createBaseJSDocTag(344 /* SyntaxKind.JSDocTemplateTag */, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("template"), comment);
            node.constraint = constraint;
            node.typeParameters = createNodeArray(typeParameters);
            return node;
        }
        // @api
        function updateJSDocTemplateTag(node, tagName, constraint, typeParameters, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.constraint !== constraint
                || node.typeParameters !== typeParameters
                || node.comment !== comment
                ? update(createJSDocTemplateTag(tagName, constraint, typeParameters, comment), node)
                : node;
        }
        // @api
        function createJSDocTypedefTag(tagName, typeExpression, fullName, comment) {
            var node = createBaseJSDocTag(345 /* SyntaxKind.JSDocTypedefTag */, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("typedef"), comment);
            node.typeExpression = typeExpression;
            node.fullName = fullName;
            node.name = ts.getJSDocTypeAliasName(fullName);
            return node;
        }
        // @api
        function updateJSDocTypedefTag(node, tagName, typeExpression, fullName, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.typeExpression !== typeExpression
                || node.fullName !== fullName
                || node.comment !== comment
                ? update(createJSDocTypedefTag(tagName, typeExpression, fullName, comment), node)
                : node;
        }
        // @api
        function createJSDocParameterTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
            var node = createBaseJSDocTag(340 /* SyntaxKind.JSDocParameterTag */, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("param"), comment);
            node.typeExpression = typeExpression;
            node.name = name;
            node.isNameFirst = !!isNameFirst;
            node.isBracketed = isBracketed;
            return node;
        }
        // @api
        function updateJSDocParameterTag(node, tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.name !== name
                || node.isBracketed !== isBracketed
                || node.typeExpression !== typeExpression
                || node.isNameFirst !== isNameFirst
                || node.comment !== comment
                ? update(createJSDocParameterTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment), node)
                : node;
        }
        // @api
        function createJSDocPropertyTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
            var node = createBaseJSDocTag(347 /* SyntaxKind.JSDocPropertyTag */, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("prop"), comment);
            node.typeExpression = typeExpression;
            node.name = name;
            node.isNameFirst = !!isNameFirst;
            node.isBracketed = isBracketed;
            return node;
        }
        // @api
        function updateJSDocPropertyTag(node, tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.name !== name
                || node.isBracketed !== isBracketed
                || node.typeExpression !== typeExpression
                || node.isNameFirst !== isNameFirst
                || node.comment !== comment
                ? update(createJSDocPropertyTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment), node)
                : node;
        }
        // @api
        function createJSDocCallbackTag(tagName, typeExpression, fullName, comment) {
            var node = createBaseJSDocTag(338 /* SyntaxKind.JSDocCallbackTag */, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("callback"), comment);
            node.typeExpression = typeExpression;
            node.fullName = fullName;
            node.name = ts.getJSDocTypeAliasName(fullName);
            return node;
        }
        // @api
        function updateJSDocCallbackTag(node, tagName, typeExpression, fullName, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.typeExpression !== typeExpression
                || node.fullName !== fullName
                || node.comment !== comment
                ? update(createJSDocCallbackTag(tagName, typeExpression, fullName, comment), node)
                : node;
        }
        // @api
        function createJSDocAugmentsTag(tagName, className, comment) {
            var node = createBaseJSDocTag(328 /* SyntaxKind.JSDocAugmentsTag */, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("augments"), comment);
            node.class = className;
            return node;
        }
        // @api
        function updateJSDocAugmentsTag(node, tagName, className, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.class !== className
                || node.comment !== comment
                ? update(createJSDocAugmentsTag(tagName, className, comment), node)
                : node;
        }
        // @api
        function createJSDocImplementsTag(tagName, className, comment) {
            var node = createBaseJSDocTag(329 /* SyntaxKind.JSDocImplementsTag */, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("implements"), comment);
            node.class = className;
            return node;
        }
        // @api
        function createJSDocSeeTag(tagName, name, comment) {
            var node = createBaseJSDocTag(346 /* SyntaxKind.JSDocSeeTag */, tagName !== null && tagName !== void 0 ? tagName : createIdentifier("see"), comment);
            node.name = name;
            return node;
        }
        // @api
        function updateJSDocSeeTag(node, tagName, name, comment) {
            return node.tagName !== tagName
                || node.name !== name
                || node.comment !== comment
                ? update(createJSDocSeeTag(tagName, name, comment), node)
                : node;
        }
        // @api
        function createJSDocNameReference(name) {
            var node = createBaseNode(310 /* SyntaxKind.JSDocNameReference */);
            node.name = name;
            return node;
        }
        // @api
        function updateJSDocNameReference(node, name) {
            return node.name !== name
                ? update(createJSDocNameReference(name), node)
                : node;
        }
        // @api
        function createJSDocMemberName(left, right) {
            var node = createBaseNode(311 /* SyntaxKind.JSDocMemberName */);
            node.left = left;
            node.right = right;
            node.transformFlags |=
                propagateChildFlags(node.left) |
                    propagateChildFlags(node.right);
            return node;
        }
        // @api
        function updateJSDocMemberName(node, left, right) {
            return node.left !== left
                || node.right !== right
                ? update(createJSDocMemberName(left, right), node)
                : node;
        }
        // @api
        function createJSDocLink(name, text) {
            var node = createBaseNode(324 /* SyntaxKind.JSDocLink */);
            node.name = name;
            node.text = text;
            return node;
        }
        // @api
        function updateJSDocLink(node, name, text) {
            return node.name !== name
                ? update(createJSDocLink(name, text), node)
                : node;
        }
        // @api
        function createJSDocLinkCode(name, text) {
            var node = createBaseNode(325 /* SyntaxKind.JSDocLinkCode */);
            node.name = name;
            node.text = text;
            return node;
        }
        // @api
        function updateJSDocLinkCode(node, name, text) {
            return node.name !== name
                ? update(createJSDocLinkCode(name, text), node)
                : node;
        }
        // @api
        function createJSDocLinkPlain(name, text) {
            var node = createBaseNode(326 /* SyntaxKind.JSDocLinkPlain */);
            node.name = name;
            node.text = text;
            return node;
        }
        // @api
        function updateJSDocLinkPlain(node, name, text) {
            return node.name !== name
                ? update(createJSDocLinkPlain(name, text), node)
                : node;
        }
        // @api
        function updateJSDocImplementsTag(node, tagName, className, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.class !== className
                || node.comment !== comment
                ? update(createJSDocImplementsTag(tagName, className, comment), node)
                : node;
        }
        // @api
        // createJSDocAuthorTag
        // createJSDocClassTag
        // createJSDocPublicTag
        // createJSDocPrivateTag
        // createJSDocProtectedTag
        // createJSDocReadonlyTag
        // createJSDocDeprecatedTag
        function createJSDocSimpleTagWorker(kind, tagName, comment) {
            var node = createBaseJSDocTag(kind, tagName !== null && tagName !== void 0 ? tagName : createIdentifier(getDefaultTagNameForKind(kind)), comment);
            return node;
        }
        // @api
        // updateJSDocAuthorTag
        // updateJSDocClassTag
        // updateJSDocPublicTag
        // updateJSDocPrivateTag
        // updateJSDocProtectedTag
        // updateJSDocReadonlyTag
        // updateJSDocDeprecatedTag
        function updateJSDocSimpleTagWorker(kind, node, tagName, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.comment !== comment
                ? update(createJSDocSimpleTagWorker(kind, tagName, comment), node) :
                node;
        }
        // @api
        // createJSDocTypeTag
        // createJSDocReturnTag
        // createJSDocThisTag
        // createJSDocEnumTag
        function createJSDocTypeLikeTagWorker(kind, tagName, typeExpression, comment) {
            var node = createBaseJSDocTag(kind, tagName !== null && tagName !== void 0 ? tagName : createIdentifier(getDefaultTagNameForKind(kind)), comment);
            node.typeExpression = typeExpression;
            return node;
        }
        // @api
        // updateJSDocTypeTag
        // updateJSDocReturnTag
        // updateJSDocThisTag
        // updateJSDocEnumTag
        function updateJSDocTypeLikeTagWorker(kind, node, tagName, typeExpression, comment) {
            if (tagName === void 0) { tagName = getDefaultTagName(node); }
            return node.tagName !== tagName
                || node.typeExpression !== typeExpression
                || node.comment !== comment
                ? update(createJSDocTypeLikeTagWorker(kind, tagName, typeExpression, comment), node)
                : node;
        }
        // @api
        function createJSDocUnknownTag(tagName, comment) {
            var node = createBaseJSDocTag(327 /* SyntaxKind.JSDocTag */, tagName, comment);
            return node;
        }
        // @api
        function updateJSDocUnknownTag(node, tagName, comment) {
            return node.tagName !== tagName
                || node.comment !== comment
                ? update(createJSDocUnknownTag(tagName, comment), node)
                : node;
        }
        // @api
        function createJSDocText(text) {
            var node = createBaseNode(321 /* SyntaxKind.JSDocText */);
            node.text = text;
            return node;
        }
        // @api
        function updateJSDocText(node, text) {
            return node.text !== text
                ? update(createJSDocText(text), node)
                : node;
        }
        // @api
        function createJSDocComment(comment, tags) {
            var node = createBaseNode(320 /* SyntaxKind.JSDoc */);
            node.comment = comment;
            node.tags = asNodeArray(tags);
            return node;
        }
        // @api
        function updateJSDocComment(node, comment, tags) {
            return node.comment !== comment
                || node.tags !== tags
                ? update(createJSDocComment(comment, tags), node)
                : node;
        }
        //
        // JSX
        //
        // @api
        function createJsxElement(openingElement, children, closingElement) {
            var node = createBaseNode(278 /* SyntaxKind.JsxElement */);
            node.openingElement = openingElement;
            node.children = createNodeArray(children);
            node.closingElement = closingElement;
            node.transformFlags |=
                propagateChildFlags(node.openingElement) |
                    propagateChildrenFlags(node.children) |
                    propagateChildFlags(node.closingElement) |
                    2 /* TransformFlags.ContainsJsx */;
            return node;
        }
        // @api
        function updateJsxElement(node, openingElement, children, closingElement) {
            return node.openingElement !== openingElement
                || node.children !== children
                || node.closingElement !== closingElement
                ? update(createJsxElement(openingElement, children, closingElement), node)
                : node;
        }
        // @api
        function createJsxSelfClosingElement(tagName, typeArguments, attributes) {
            var node = createBaseNode(279 /* SyntaxKind.JsxSelfClosingElement */);
            node.tagName = tagName;
            node.typeArguments = asNodeArray(typeArguments);
            node.attributes = attributes;
            node.transformFlags |=
                propagateChildFlags(node.tagName) |
                    propagateChildrenFlags(node.typeArguments) |
                    propagateChildFlags(node.attributes) |
                    2 /* TransformFlags.ContainsJsx */;
            if (node.typeArguments) {
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            }
            return node;
        }
        // @api
        function updateJsxSelfClosingElement(node, tagName, typeArguments, attributes) {
            return node.tagName !== tagName
                || node.typeArguments !== typeArguments
                || node.attributes !== attributes
                ? update(createJsxSelfClosingElement(tagName, typeArguments, attributes), node)
                : node;
        }
        // @api
        function createJsxOpeningElement(tagName, typeArguments, attributes) {
            var node = createBaseNode(280 /* SyntaxKind.JsxOpeningElement */);
            node.tagName = tagName;
            node.typeArguments = asNodeArray(typeArguments);
            node.attributes = attributes;
            node.transformFlags |=
                propagateChildFlags(node.tagName) |
                    propagateChildrenFlags(node.typeArguments) |
                    propagateChildFlags(node.attributes) |
                    2 /* TransformFlags.ContainsJsx */;
            if (typeArguments) {
                node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
            }
            return node;
        }
        // @api
        function updateJsxOpeningElement(node, tagName, typeArguments, attributes) {
            return node.tagName !== tagName
                || node.typeArguments !== typeArguments
                || node.attributes !== attributes
                ? update(createJsxOpeningElement(tagName, typeArguments, attributes), node)
                : node;
        }
        // @api
        function createJsxClosingElement(tagName) {
            var node = createBaseNode(281 /* SyntaxKind.JsxClosingElement */);
            node.tagName = tagName;
            node.transformFlags |=
                propagateChildFlags(node.tagName) |
                    2 /* TransformFlags.ContainsJsx */;
            return node;
        }
        // @api
        function updateJsxClosingElement(node, tagName) {
            return node.tagName !== tagName
                ? update(createJsxClosingElement(tagName), node)
                : node;
        }
        // @api
        function createJsxFragment(openingFragment, children, closingFragment) {
            var node = createBaseNode(282 /* SyntaxKind.JsxFragment */);
            node.openingFragment = openingFragment;
            node.children = createNodeArray(children);
            node.closingFragment = closingFragment;
            node.transformFlags |=
                propagateChildFlags(node.openingFragment) |
                    propagateChildrenFlags(node.children) |
                    propagateChildFlags(node.closingFragment) |
                    2 /* TransformFlags.ContainsJsx */;
            return node;
        }
        // @api
        function updateJsxFragment(node, openingFragment, children, closingFragment) {
            return node.openingFragment !== openingFragment
                || node.children !== children
                || node.closingFragment !== closingFragment
                ? update(createJsxFragment(openingFragment, children, closingFragment), node)
                : node;
        }
        // @api
        function createJsxText(text, containsOnlyTriviaWhiteSpaces) {
            var node = createBaseNode(11 /* SyntaxKind.JsxText */);
            node.text = text;
            node.containsOnlyTriviaWhiteSpaces = !!containsOnlyTriviaWhiteSpaces;
            node.transformFlags |= 2 /* TransformFlags.ContainsJsx */;
            return node;
        }
        // @api
        function updateJsxText(node, text, containsOnlyTriviaWhiteSpaces) {
            return node.text !== text
                || node.containsOnlyTriviaWhiteSpaces !== containsOnlyTriviaWhiteSpaces
                ? update(createJsxText(text, containsOnlyTriviaWhiteSpaces), node)
                : node;
        }
        // @api
        function createJsxOpeningFragment() {
            var node = createBaseNode(283 /* SyntaxKind.JsxOpeningFragment */);
            node.transformFlags |= 2 /* TransformFlags.ContainsJsx */;
            return node;
        }
        // @api
        function createJsxJsxClosingFragment() {
            var node = createBaseNode(284 /* SyntaxKind.JsxClosingFragment */);
            node.transformFlags |= 2 /* TransformFlags.ContainsJsx */;
            return node;
        }
        // @api
        function createJsxAttribute(name, initializer) {
            var node = createBaseNode(285 /* SyntaxKind.JsxAttribute */);
            node.name = name;
            node.initializer = initializer;
            node.transformFlags |=
                propagateChildFlags(node.name) |
                    propagateChildFlags(node.initializer) |
                    2 /* TransformFlags.ContainsJsx */;
            return node;
        }
        // @api
        function updateJsxAttribute(node, name, initializer) {
            return node.name !== name
                || node.initializer !== initializer
                ? update(createJsxAttribute(name, initializer), node)
                : node;
        }
        // @api
        function createJsxAttributes(properties) {
            var node = createBaseNode(286 /* SyntaxKind.JsxAttributes */);
            node.properties = createNodeArray(properties);
            node.transformFlags |=
                propagateChildrenFlags(node.properties) |
                    2 /* TransformFlags.ContainsJsx */;
            return node;
        }
        // @api
        function updateJsxAttributes(node, properties) {
            return node.properties !== properties
                ? update(createJsxAttributes(properties), node)
                : node;
        }
        // @api
        function createJsxSpreadAttribute(expression) {
            var node = createBaseNode(287 /* SyntaxKind.JsxSpreadAttribute */);
            node.expression = expression;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    2 /* TransformFlags.ContainsJsx */;
            return node;
        }
        // @api
        function updateJsxSpreadAttribute(node, expression) {
            return node.expression !== expression
                ? update(createJsxSpreadAttribute(expression), node)
                : node;
        }
        // @api
        function createJsxExpression(dotDotDotToken, expression) {
            var node = createBaseNode(288 /* SyntaxKind.JsxExpression */);
            node.dotDotDotToken = dotDotDotToken;
            node.expression = expression;
            node.transformFlags |=
                propagateChildFlags(node.dotDotDotToken) |
                    propagateChildFlags(node.expression) |
                    2 /* TransformFlags.ContainsJsx */;
            return node;
        }
        // @api
        function updateJsxExpression(node, expression) {
            return node.expression !== expression
                ? update(createJsxExpression(node.dotDotDotToken, expression), node)
                : node;
        }
        //
        // Clauses
        //
        // @api
        function createCaseClause(expression, statements) {
            var node = createBaseNode(289 /* SyntaxKind.CaseClause */);
            node.expression = parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.statements = createNodeArray(statements);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildrenFlags(node.statements);
            return node;
        }
        // @api
        function updateCaseClause(node, expression, statements) {
            return node.expression !== expression
                || node.statements !== statements
                ? update(createCaseClause(expression, statements), node)
                : node;
        }
        // @api
        function createDefaultClause(statements) {
            var node = createBaseNode(290 /* SyntaxKind.DefaultClause */);
            node.statements = createNodeArray(statements);
            node.transformFlags = propagateChildrenFlags(node.statements);
            return node;
        }
        // @api
        function updateDefaultClause(node, statements) {
            return node.statements !== statements
                ? update(createDefaultClause(statements), node)
                : node;
        }
        // @api
        function createHeritageClause(token, types) {
            var node = createBaseNode(291 /* SyntaxKind.HeritageClause */);
            node.token = token;
            node.types = createNodeArray(types);
            node.transformFlags |= propagateChildrenFlags(node.types);
            switch (token) {
                case 94 /* SyntaxKind.ExtendsKeyword */:
                    node.transformFlags |= 1024 /* TransformFlags.ContainsES2015 */;
                    break;
                case 117 /* SyntaxKind.ImplementsKeyword */:
                    node.transformFlags |= 1 /* TransformFlags.ContainsTypeScript */;
                    break;
                default:
                    return ts.Debug.assertNever(token);
            }
            return node;
        }
        // @api
        function updateHeritageClause(node, types) {
            return node.types !== types
                ? update(createHeritageClause(node.token, types), node)
                : node;
        }
        // @api
        function createCatchClause(variableDeclaration, block) {
            var node = createBaseNode(292 /* SyntaxKind.CatchClause */);
            if (typeof variableDeclaration === "string" || variableDeclaration && !ts.isVariableDeclaration(variableDeclaration)) {
                variableDeclaration = createVariableDeclaration(variableDeclaration, 
                /*exclamationToken*/ undefined, 
                /*type*/ undefined, 
                /*initializer*/ undefined);
            }
            node.variableDeclaration = variableDeclaration;
            node.block = block;
            node.transformFlags |=
                propagateChildFlags(node.variableDeclaration) |
                    propagateChildFlags(node.block);
            if (!variableDeclaration)
                node.transformFlags |= 64 /* TransformFlags.ContainsES2019 */;
            return node;
        }
        // @api
        function updateCatchClause(node, variableDeclaration, block) {
            return node.variableDeclaration !== variableDeclaration
                || node.block !== block
                ? update(createCatchClause(variableDeclaration, block), node)
                : node;
        }
        //
        // Property assignments
        //
        // @api
        function createPropertyAssignment(name, initializer) {
            var node = createBaseNamedDeclaration(296 /* SyntaxKind.PropertyAssignment */, 
            /*modifiers*/ undefined, name);
            node.initializer = parenthesizerRules().parenthesizeExpressionForDisallowedComma(initializer);
            node.transformFlags |=
                propagateChildFlags(node.name) |
                    propagateChildFlags(node.initializer);
            // The following properties are used only to report grammar errors
            node.illegalDecorators = undefined;
            node.modifiers = undefined;
            node.questionToken = undefined;
            node.exclamationToken = undefined;
            return node;
        }
        // @api
        function updatePropertyAssignment(node, name, initializer) {
            return node.name !== name
                || node.initializer !== initializer
                ? finishUpdatePropertyAssignment(createPropertyAssignment(name, initializer), node)
                : node;
        }
        function finishUpdatePropertyAssignment(updated, original) {
            // copy children used only for error reporting
            if (updated !== original) {
                updated.illegalDecorators = original.illegalDecorators;
                updated.modifiers = original.modifiers;
                updated.questionToken = original.questionToken;
                updated.exclamationToken = original.exclamationToken;
            }
            return update(updated, original);
        }
        // @api
        function createShorthandPropertyAssignment(name, objectAssignmentInitializer) {
            var node = createBaseNamedDeclaration(297 /* SyntaxKind.ShorthandPropertyAssignment */, 
            /*modifiers*/ undefined, name);
            node.objectAssignmentInitializer = objectAssignmentInitializer && parenthesizerRules().parenthesizeExpressionForDisallowedComma(objectAssignmentInitializer);
            node.transformFlags |=
                propagateChildFlags(node.objectAssignmentInitializer) |
                    1024 /* TransformFlags.ContainsES2015 */;
            // The following properties are used only to report grammar errors
            node.equalsToken = undefined;
            node.illegalDecorators = undefined;
            node.modifiers = undefined;
            node.questionToken = undefined;
            node.exclamationToken = undefined;
            return node;
        }
        // @api
        function updateShorthandPropertyAssignment(node, name, objectAssignmentInitializer) {
            return node.name !== name
                || node.objectAssignmentInitializer !== objectAssignmentInitializer
                ? finishUpdateShorthandPropertyAssignment(createShorthandPropertyAssignment(name, objectAssignmentInitializer), node)
                : node;
        }
        function finishUpdateShorthandPropertyAssignment(updated, original) {
            if (updated !== original) {
                // copy children used only for error reporting
                updated.equalsToken = original.equalsToken;
                updated.illegalDecorators = original.illegalDecorators;
                updated.modifiers = original.modifiers;
                updated.questionToken = original.questionToken;
                updated.exclamationToken = original.exclamationToken;
            }
            return update(updated, original);
        }
        // @api
        function createSpreadAssignment(expression) {
            var node = createBaseNode(298 /* SyntaxKind.SpreadAssignment */);
            node.expression = parenthesizerRules().parenthesizeExpressionForDisallowedComma(expression);
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    128 /* TransformFlags.ContainsES2018 */ |
                    65536 /* TransformFlags.ContainsObjectRestOrSpread */;
            return node;
        }
        // @api
        function updateSpreadAssignment(node, expression) {
            return node.expression !== expression
                ? update(createSpreadAssignment(expression), node)
                : node;
        }
        //
        // Enum
        //
        // @api
        function createEnumMember(name, initializer) {
            var node = createBaseNode(299 /* SyntaxKind.EnumMember */);
            node.name = asName(name);
            node.initializer = initializer && parenthesizerRules().parenthesizeExpressionForDisallowedComma(initializer);
            node.transformFlags |=
                propagateChildFlags(node.name) |
                    propagateChildFlags(node.initializer) |
                    1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
        // @api
        function updateEnumMember(node, name, initializer) {
            return node.name !== name
                || node.initializer !== initializer
                ? update(createEnumMember(name, initializer), node)
                : node;
        }
        //
        // Top-level nodes
        //
        // @api
        function createSourceFile(statements, endOfFileToken, flags) {
            var node = baseFactory.createBaseSourceFileNode(305 /* SyntaxKind.SourceFile */);
            node.statements = createNodeArray(statements);
            node.endOfFileToken = endOfFileToken;
            node.flags |= flags;
            node.fileName = "";
            node.text = "";
            node.languageVersion = 0;
            node.languageVariant = 0;
            node.scriptKind = 0;
            node.isDeclarationFile = false;
            node.hasNoDefaultLib = false;
            node.transformFlags |=
                propagateChildrenFlags(node.statements) |
                    propagateChildFlags(node.endOfFileToken);
            return node;
        }
        function cloneSourceFileWithChanges(source, statements, isDeclarationFile, referencedFiles, typeReferences, hasNoDefaultLib, libReferences) {
            var node = (source.redirectInfo ? Object.create(source.redirectInfo.redirectTarget) : baseFactory.createBaseSourceFileNode(305 /* SyntaxKind.SourceFile */));
            for (var p in source) {
                if (p === "emitNode" || ts.hasProperty(node, p) || !ts.hasProperty(source, p))
                    continue;
                node[p] = source[p];
            }
            node.flags |= source.flags;
            node.statements = createNodeArray(statements);
            node.endOfFileToken = source.endOfFileToken;
            node.isDeclarationFile = isDeclarationFile;
            node.referencedFiles = referencedFiles;
            node.typeReferenceDirectives = typeReferences;
            node.hasNoDefaultLib = hasNoDefaultLib;
            node.libReferenceDirectives = libReferences;
            node.transformFlags =
                propagateChildrenFlags(node.statements) |
                    propagateChildFlags(node.endOfFileToken);
            node.impliedNodeFormat = source.impliedNodeFormat;
            return node;
        }
        // @api
        function updateSourceFile(node, statements, isDeclarationFile, referencedFiles, typeReferenceDirectives, hasNoDefaultLib, libReferenceDirectives) {
            if (isDeclarationFile === void 0) { isDeclarationFile = node.isDeclarationFile; }
            if (referencedFiles === void 0) { referencedFiles = node.referencedFiles; }
            if (typeReferenceDirectives === void 0) { typeReferenceDirectives = node.typeReferenceDirectives; }
            if (hasNoDefaultLib === void 0) { hasNoDefaultLib = node.hasNoDefaultLib; }
            if (libReferenceDirectives === void 0) { libReferenceDirectives = node.libReferenceDirectives; }
            return node.statements !== statements
                || node.isDeclarationFile !== isDeclarationFile
                || node.referencedFiles !== referencedFiles
                || node.typeReferenceDirectives !== typeReferenceDirectives
                || node.hasNoDefaultLib !== hasNoDefaultLib
                || node.libReferenceDirectives !== libReferenceDirectives
                ? update(cloneSourceFileWithChanges(node, statements, isDeclarationFile, referencedFiles, typeReferenceDirectives, hasNoDefaultLib, libReferenceDirectives), node)
                : node;
        }
        // @api
        function createBundle(sourceFiles, prepends) {
            if (prepends === void 0) { prepends = ts.emptyArray; }
            var node = createBaseNode(306 /* SyntaxKind.Bundle */);
            node.prepends = prepends;
            node.sourceFiles = sourceFiles;
            return node;
        }
        // @api
        function updateBundle(node, sourceFiles, prepends) {
            if (prepends === void 0) { prepends = ts.emptyArray; }
            return node.sourceFiles !== sourceFiles
                || node.prepends !== prepends
                ? update(createBundle(sourceFiles, prepends), node)
                : node;
        }
        // @api
        function createUnparsedSource(prologues, syntheticReferences, texts) {
            var node = createBaseNode(307 /* SyntaxKind.UnparsedSource */);
            node.prologues = prologues;
            node.syntheticReferences = syntheticReferences;
            node.texts = texts;
            node.fileName = "";
            node.text = "";
            node.referencedFiles = ts.emptyArray;
            node.libReferenceDirectives = ts.emptyArray;
            node.getLineAndCharacterOfPosition = function (pos) { return ts.getLineAndCharacterOfPosition(node, pos); };
            return node;
        }
        function createBaseUnparsedNode(kind, data) {
            var node = createBaseNode(kind);
            node.data = data;
            return node;
        }
        // @api
        function createUnparsedPrologue(data) {
            return createBaseUnparsedNode(300 /* SyntaxKind.UnparsedPrologue */, data);
        }
        // @api
        function createUnparsedPrepend(data, texts) {
            var node = createBaseUnparsedNode(301 /* SyntaxKind.UnparsedPrepend */, data);
            node.texts = texts;
            return node;
        }
        // @api
        function createUnparsedTextLike(data, internal) {
            return createBaseUnparsedNode(internal ? 303 /* SyntaxKind.UnparsedInternalText */ : 302 /* SyntaxKind.UnparsedText */, data);
        }
        // @api
        function createUnparsedSyntheticReference(section) {
            var node = createBaseNode(304 /* SyntaxKind.UnparsedSyntheticReference */);
            node.data = section.data;
            node.section = section;
            return node;
        }
        // @api
        function createInputFiles() {
            var node = createBaseNode(308 /* SyntaxKind.InputFiles */);
            node.javascriptText = "";
            node.declarationText = "";
            return node;
        }
        //
        // Synthetic Nodes (used by checker)
        //
        // @api
        function createSyntheticExpression(type, isSpread, tupleNameSource) {
            if (isSpread === void 0) { isSpread = false; }
            var node = createBaseNode(232 /* SyntaxKind.SyntheticExpression */);
            node.type = type;
            node.isSpread = isSpread;
            node.tupleNameSource = tupleNameSource;
            return node;
        }
        // @api
        function createSyntaxList(children) {
            var node = createBaseNode(348 /* SyntaxKind.SyntaxList */);
            node._children = children;
            return node;
        }
        //
        // Transformation nodes
        //
        /**
         * Creates a synthetic statement to act as a placeholder for a not-emitted statement in
         * order to preserve comments.
         *
         * @param original The original statement.
         */
        // @api
        function createNotEmittedStatement(original) {
            var node = createBaseNode(349 /* SyntaxKind.NotEmittedStatement */);
            node.original = original;
            ts.setTextRange(node, original);
            return node;
        }
        /**
         * Creates a synthetic expression to act as a placeholder for a not-emitted expression in
         * order to preserve comments or sourcemap positions.
         *
         * @param expression The inner expression to emit.
         * @param original The original outer expression.
         */
        // @api
        function createPartiallyEmittedExpression(expression, original) {
            var node = createBaseNode(350 /* SyntaxKind.PartiallyEmittedExpression */);
            node.expression = expression;
            node.original = original;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    1 /* TransformFlags.ContainsTypeScript */;
            ts.setTextRange(node, original);
            return node;
        }
        // @api
        function updatePartiallyEmittedExpression(node, expression) {
            return node.expression !== expression
                ? update(createPartiallyEmittedExpression(expression, node.original), node)
                : node;
        }
        function flattenCommaElements(node) {
            if (ts.nodeIsSynthesized(node) && !ts.isParseTreeNode(node) && !node.original && !node.emitNode && !node.id) {
                if (ts.isCommaListExpression(node)) {
                    return node.elements;
                }
                if (ts.isBinaryExpression(node) && ts.isCommaToken(node.operatorToken)) {
                    return [node.left, node.right];
                }
            }
            return node;
        }
        // @api
        function createCommaListExpression(elements) {
            var node = createBaseNode(351 /* SyntaxKind.CommaListExpression */);
            node.elements = createNodeArray(ts.sameFlatMap(elements, flattenCommaElements));
            node.transformFlags |= propagateChildrenFlags(node.elements);
            return node;
        }
        // @api
        function updateCommaListExpression(node, elements) {
            return node.elements !== elements
                ? update(createCommaListExpression(elements), node)
                : node;
        }
        /**
         * Creates a synthetic element to act as a placeholder for the end of an emitted declaration in
         * order to properly emit exports.
         */
        // @api
        function createEndOfDeclarationMarker(original) {
            var node = createBaseNode(353 /* SyntaxKind.EndOfDeclarationMarker */);
            node.emitNode = {};
            node.original = original;
            return node;
        }
        /**
         * Creates a synthetic element to act as a placeholder for the beginning of a merged declaration in
         * order to properly emit exports.
         */
        // @api
        function createMergeDeclarationMarker(original) {
            var node = createBaseNode(352 /* SyntaxKind.MergeDeclarationMarker */);
            node.emitNode = {};
            node.original = original;
            return node;
        }
        // @api
        function createSyntheticReferenceExpression(expression, thisArg) {
            var node = createBaseNode(354 /* SyntaxKind.SyntheticReferenceExpression */);
            node.expression = expression;
            node.thisArg = thisArg;
            node.transformFlags |=
                propagateChildFlags(node.expression) |
                    propagateChildFlags(node.thisArg);
            return node;
        }
        // @api
        function updateSyntheticReferenceExpression(node, expression, thisArg) {
            return node.expression !== expression
                || node.thisArg !== thisArg
                ? update(createSyntheticReferenceExpression(expression, thisArg), node)
                : node;
        }
        function cloneNode(node) {
            // We don't use "clone" from core.ts here, as we need to preserve the prototype chain of
            // the original node. We also need to exclude specific properties and only include own-
            // properties (to skip members already defined on the shared prototype).
            if (node === undefined) {
                return node;
            }
            var clone = ts.isSourceFile(node) ? baseFactory.createBaseSourceFileNode(305 /* SyntaxKind.SourceFile */) :
                ts.isIdentifier(node) ? baseFactory.createBaseIdentifierNode(79 /* SyntaxKind.Identifier */) :
                    ts.isPrivateIdentifier(node) ? baseFactory.createBasePrivateIdentifierNode(80 /* SyntaxKind.PrivateIdentifier */) :
                        !ts.isNodeKind(node.kind) ? baseFactory.createBaseTokenNode(node.kind) :
                            baseFactory.createBaseNode(node.kind);
            clone.flags |= (node.flags & ~8 /* NodeFlags.Synthesized */);
            clone.transformFlags = node.transformFlags;
            setOriginalNode(clone, node);
            for (var key in node) {
                if (clone.hasOwnProperty(key) || !node.hasOwnProperty(key)) {
                    continue;
                }
                clone[key] = node[key];
            }
            return clone;
        }
        function createImmediatelyInvokedFunctionExpression(statements, param, paramValue) {
            return createCallExpression(createFunctionExpression(
            /*modifiers*/ undefined, 
            /*asteriskToken*/ undefined, 
            /*name*/ undefined, 
            /*typeParameters*/ undefined, 
            /*parameters*/ param ? [param] : [], 
            /*type*/ undefined, createBlock(statements, /*multiLine*/ true)), 
            /*typeArguments*/ undefined, 
            /*argumentsArray*/ paramValue ? [paramValue] : []);
        }
        function createImmediatelyInvokedArrowFunction(statements, param, paramValue) {
            return createCallExpression(createArrowFunction(
            /*modifiers*/ undefined, 
            /*typeParameters*/ undefined, 
            /*parameters*/ param ? [param] : [], 
            /*type*/ undefined, 
            /*equalsGreaterThanToken*/ undefined, createBlock(statements, /*multiLine*/ true)), 
            /*typeArguments*/ undefined, 
            /*argumentsArray*/ paramValue ? [paramValue] : []);
        }
        function createVoidZero() {
            return createVoidExpression(createNumericLiteral("0"));
        }
        function createExportDefault(expression) {
            return createExportAssignment(
            /*modifiers*/ undefined, 
            /*isExportEquals*/ false, expression);
        }
        function createExternalModuleExport(exportName) {
            return createExportDeclaration(
            /*modifiers*/ undefined, 
            /*isTypeOnly*/ false, createNamedExports([
                createExportSpecifier(/*isTypeOnly*/ false, /*propertyName*/ undefined, exportName)
            ]));
        }
        //
        // Utilities
        //
        function createTypeCheck(value, tag) {
            return tag === "undefined"
                ? factory.createStrictEquality(value, createVoidZero())
                : factory.createStrictEquality(createTypeOfExpression(value), createStringLiteral(tag));
        }
        function createMethodCall(object, methodName, argumentsList) {
            // Preserve the optionality of `object`.
            if (ts.isCallChain(object)) {
                return createCallChain(createPropertyAccessChain(object, /*questionDotToken*/ undefined, methodName), 
                /*questionDotToken*/ undefined, 
                /*typeArguments*/ undefined, argumentsList);
            }
            return createCallExpression(createPropertyAccessExpression(object, methodName), 
            /*typeArguments*/ undefined, argumentsList);
        }
        function createFunctionBindCall(target, thisArg, argumentsList) {
            return createMethodCall(target, "bind", __spreadArray([thisArg], argumentsList, true));
        }
        function createFunctionCallCall(target, thisArg, argumentsList) {
            return createMethodCall(target, "call", __spreadArray([thisArg], argumentsList, true));
        }
        function createFunctionApplyCall(target, thisArg, argumentsExpression) {
            return createMethodCall(target, "apply", [thisArg, argumentsExpression]);
        }
        function createGlobalMethodCall(globalObjectName, methodName, argumentsList) {
            return createMethodCall(createIdentifier(globalObjectName), methodName, argumentsList);
        }
        function createArraySliceCall(array, start) {
            return createMethodCall(array, "slice", start === undefined ? [] : [asExpression(start)]);
        }
        function createArrayConcatCall(array, argumentsList) {
            return createMethodCall(array, "concat", argumentsList);
        }
        function createObjectDefinePropertyCall(target, propertyName, attributes) {
            return createGlobalMethodCall("Object", "defineProperty", [target, asExpression(propertyName), attributes]);
        }
        function createReflectGetCall(target, propertyKey, receiver) {
            return createGlobalMethodCall("Reflect", "get", receiver ? [target, propertyKey, receiver] : [target, propertyKey]);
        }
        function createReflectSetCall(target, propertyKey, value, receiver) {
            return createGlobalMethodCall("Reflect", "set", receiver ? [target, propertyKey, value, receiver] : [target, propertyKey, value]);
        }
        function tryAddPropertyAssignment(properties, propertyName, expression) {
            if (expression) {
                properties.push(createPropertyAssignment(propertyName, expression));
                return true;
            }
            return false;
        }
        function createPropertyDescriptor(attributes, singleLine) {
            var properties = [];
            tryAddPropertyAssignment(properties, "enumerable", asExpression(attributes.enumerable));
            tryAddPropertyAssignment(properties, "configurable", asExpression(attributes.configurable));
            var isData = tryAddPropertyAssignment(properties, "writable", asExpression(attributes.writable));
            isData = tryAddPropertyAssignment(properties, "value", attributes.value) || isData;
            var isAccessor = tryAddPropertyAssignment(properties, "get", attributes.get);
            isAccessor = tryAddPropertyAssignment(properties, "set", attributes.set) || isAccessor;
            ts.Debug.assert(!(isData && isAccessor), "A PropertyDescriptor may not be both an accessor descriptor and a data descriptor.");
            return createObjectLiteralExpression(properties, !singleLine);
        }
        function updateOuterExpression(outerExpression, expression) {
            switch (outerExpression.kind) {
                case 212 /* SyntaxKind.ParenthesizedExpression */: return updateParenthesizedExpression(outerExpression, expression);
                case 211 /* SyntaxKind.TypeAssertionExpression */: return updateTypeAssertion(outerExpression, outerExpression.type, expression);
                case 229 /* SyntaxKind.AsExpression */: return updateAsExpression(outerExpression, expression, outerExpression.type);
                case 230 /* SyntaxKind.NonNullExpression */: return updateNonNullExpression(outerExpression, expression);
                case 350 /* SyntaxKind.PartiallyEmittedExpression */: return updatePartiallyEmittedExpression(outerExpression, expression);
            }
        }
        /**
         * Determines whether a node is a parenthesized expression that can be ignored when recreating outer expressions.
         *
         * A parenthesized expression can be ignored when all of the following are true:
         *
         * - It's `pos` and `end` are not -1
         * - It does not have a custom source map range
         * - It does not have a custom comment range
         * - It does not have synthetic leading or trailing comments
         *
         * If an outermost parenthesized expression is ignored, but the containing expression requires a parentheses around
         * the expression to maintain precedence, a new parenthesized expression should be created automatically when
         * the containing expression is created/updated.
         */
        function isIgnorableParen(node) {
            return ts.isParenthesizedExpression(node)
                && ts.nodeIsSynthesized(node)
                && ts.nodeIsSynthesized(ts.getSourceMapRange(node))
                && ts.nodeIsSynthesized(ts.getCommentRange(node))
                && !ts.some(ts.getSyntheticLeadingComments(node))
                && !ts.some(ts.getSyntheticTrailingComments(node));
        }
        function restoreOuterExpressions(outerExpression, innerExpression, kinds) {
            if (kinds === void 0) { kinds = 15 /* OuterExpressionKinds.All */; }
            if (outerExpression && ts.isOuterExpression(outerExpression, kinds) && !isIgnorableParen(outerExpression)) {
                return updateOuterExpression(outerExpression, restoreOuterExpressions(outerExpression.expression, innerExpression));
            }
            return innerExpression;
        }
        function restoreEnclosingLabel(node, outermostLabeledStatement, afterRestoreLabelCallback) {
            if (!outermostLabeledStatement) {
                return node;
            }
            var updated = updateLabeledStatement(outermostLabeledStatement, outermostLabeledStatement.label, ts.isLabeledStatement(outermostLabeledStatement.statement)
                ? restoreEnclosingLabel(node, outermostLabeledStatement.statement)
                : node);
            if (afterRestoreLabelCallback) {
                afterRestoreLabelCallback(outermostLabeledStatement);
            }
            return updated;
        }
        function shouldBeCapturedInTempVariable(node, cacheIdentifiers) {
            var target = ts.skipParentheses(node);
            switch (target.kind) {
                case 79 /* SyntaxKind.Identifier */:
                    return cacheIdentifiers;
                case 108 /* SyntaxKind.ThisKeyword */:
                case 8 /* SyntaxKind.NumericLiteral */:
                case 9 /* SyntaxKind.BigIntLiteral */:
                case 10 /* SyntaxKind.StringLiteral */:
                    return false;
                case 204 /* SyntaxKind.ArrayLiteralExpression */:
                    var elements = target.elements;
                    if (elements.length === 0) {
                        return false;
                    }
                    return true;
                case 205 /* SyntaxKind.ObjectLiteralExpression */:
                    return target.properties.length > 0;
                default:
                    return true;
            }
        }
        function createCallBinding(expression, recordTempVariable, languageVersion, cacheIdentifiers) {
            if (cacheIdentifiers === void 0) { cacheIdentifiers = false; }
            var callee = ts.skipOuterExpressions(expression, 15 /* OuterExpressionKinds.All */);
            var thisArg;
            var target;
            if (ts.isSuperProperty(callee)) {
                thisArg = createThis();
                target = callee;
            }
            else if (ts.isSuperKeyword(callee)) {
                thisArg = createThis();
                target = languageVersion !== undefined && languageVersion < 2 /* ScriptTarget.ES2015 */
                    ? ts.setTextRange(createIdentifier("_super"), callee)
                    : callee;
            }
            else if (ts.getEmitFlags(callee) & 4096 /* EmitFlags.HelperName */) {
                thisArg = createVoidZero();
                target = parenthesizerRules().parenthesizeLeftSideOfAccess(callee, /*optionalChain*/ false);
            }
            else if (ts.isPropertyAccessExpression(callee)) {
                if (shouldBeCapturedInTempVariable(callee.expression, cacheIdentifiers)) {
                    // for `a.b()` target is `(_a = a).b` and thisArg is `_a`
                    thisArg = createTempVariable(recordTempVariable);
                    target = createPropertyAccessExpression(ts.setTextRange(factory.createAssignment(thisArg, callee.expression), callee.expression), callee.name);
                    ts.setTextRange(target, callee);
                }
                else {
                    thisArg = callee.expression;
                    target = callee;
                }
            }
            else if (ts.isElementAccessExpression(callee)) {
                if (shouldBeCapturedInTempVariable(callee.expression, cacheIdentifiers)) {
                    // for `a[b]()` target is `(_a = a)[b]` and thisArg is `_a`
                    thisArg = createTempVariable(recordTempVariable);
                    target = createElementAccessExpression(ts.setTextRange(factory.createAssignment(thisArg, callee.expression), callee.expression), callee.argumentExpression);
                    ts.setTextRange(target, callee);
                }
                else {
                    thisArg = callee.expression;
                    target = callee;
                }
            }
            else {
                // for `a()` target is `a` and thisArg is `void 0`
                thisArg = createVoidZero();
                target = parenthesizerRules().parenthesizeLeftSideOfAccess(expression, /*optionalChain*/ false);
            }
            return { target: target, thisArg: thisArg };
        }
        function createAssignmentTargetWrapper(paramName, expression) {
            return createPropertyAccessExpression(
            // Explicit parens required because of v8 regression (https://bugs.chromium.org/p/v8/issues/detail?id=9560)
            createParenthesizedExpression(createObjectLiteralExpression([
                createSetAccessorDeclaration(
                /*modifiers*/ undefined, "value", [createParameterDeclaration(
                    /*modifiers*/ undefined, 
                    /*dotDotDotToken*/ undefined, paramName, 
                    /*questionToken*/ undefined, 
                    /*type*/ undefined, 
                    /*initializer*/ undefined)], createBlock([
                    createExpressionStatement(expression)
                ]))
            ])), "value");
        }
        function inlineExpressions(expressions) {
            // Avoid deeply nested comma expressions as traversing them during emit can result in "Maximum call
            // stack size exceeded" errors.
            return expressions.length > 10
                ? createCommaListExpression(expressions)
                : ts.reduceLeft(expressions, factory.createComma);
        }
        function getName(node, allowComments, allowSourceMaps, emitFlags) {
            if (emitFlags === void 0) { emitFlags = 0; }
            var nodeName = ts.getNameOfDeclaration(node);
            if (nodeName && ts.isIdentifier(nodeName) && !ts.isGeneratedIdentifier(nodeName)) {
                // TODO(rbuckton): Does this need to be parented?
                var name = ts.setParent(ts.setTextRange(cloneNode(nodeName), nodeName), nodeName.parent);
                emitFlags |= ts.getEmitFlags(nodeName);
                if (!allowSourceMaps)
                    emitFlags |= 48 /* EmitFlags.NoSourceMap */;
                if (!allowComments)
                    emitFlags |= 1536 /* EmitFlags.NoComments */;
                if (emitFlags)
                    ts.setEmitFlags(name, emitFlags);
                return name;
            }
            return getGeneratedNameForNode(node);
        }
        /**
         * Gets the internal name of a declaration. This is primarily used for declarations that can be
         * referred to by name in the body of an ES5 class function body. An internal name will *never*
         * be prefixed with an module or namespace export modifier like "exports." when emitted as an
         * expression. An internal name will also *never* be renamed due to a collision with a block
         * scoped variable.
         *
         * @param node The declaration.
         * @param allowComments A value indicating whether comments may be emitted for the name.
         * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
         */
        function getInternalName(node, allowComments, allowSourceMaps) {
            return getName(node, allowComments, allowSourceMaps, 16384 /* EmitFlags.LocalName */ | 32768 /* EmitFlags.InternalName */);
        }
        /**
         * Gets the local name of a declaration. This is primarily used for declarations that can be
         * referred to by name in the declaration's immediate scope (classes, enums, namespaces). A
         * local name will *never* be prefixed with an module or namespace export modifier like
         * "exports." when emitted as an expression.
         *
         * @param node The declaration.
         * @param allowComments A value indicating whether comments may be emitted for the name.
         * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
         */
        function getLocalName(node, allowComments, allowSourceMaps) {
            return getName(node, allowComments, allowSourceMaps, 16384 /* EmitFlags.LocalName */);
        }
        /**
         * Gets the export name of a declaration. This is primarily used for declarations that can be
         * referred to by name in the declaration's immediate scope (classes, enums, namespaces). An
         * export name will *always* be prefixed with an module or namespace export modifier like
         * `"exports."` when emitted as an expression if the name points to an exported symbol.
         *
         * @param node The declaration.
         * @param allowComments A value indicating whether comments may be emitted for the name.
         * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
         */
        function getExportName(node, allowComments, allowSourceMaps) {
            return getName(node, allowComments, allowSourceMaps, 8192 /* EmitFlags.ExportName */);
        }
        /**
         * Gets the name of a declaration for use in declarations.
         *
         * @param node The declaration.
         * @param allowComments A value indicating whether comments may be emitted for the name.
         * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
         */
        function getDeclarationName(node, allowComments, allowSourceMaps) {
            return getName(node, allowComments, allowSourceMaps);
        }
        /**
         * Gets a namespace-qualified name for use in expressions.
         *
         * @param ns The namespace identifier.
         * @param name The name.
         * @param allowComments A value indicating whether comments may be emitted for the name.
         * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
         */
        function getNamespaceMemberName(ns, name, allowComments, allowSourceMaps) {
            var qualifiedName = createPropertyAccessExpression(ns, ts.nodeIsSynthesized(name) ? name : cloneNode(name));
            ts.setTextRange(qualifiedName, name);
            var emitFlags = 0;
            if (!allowSourceMaps)
                emitFlags |= 48 /* EmitFlags.NoSourceMap */;
            if (!allowComments)
                emitFlags |= 1536 /* EmitFlags.NoComments */;
            if (emitFlags)
                ts.setEmitFlags(qualifiedName, emitFlags);
            return qualifiedName;
        }
        /**
         * Gets the exported name of a declaration for use in expressions.
         *
         * An exported name will *always* be prefixed with an module or namespace export modifier like
         * "exports." if the name points to an exported symbol.
         *
         * @param ns The namespace identifier.
         * @param node The declaration.
         * @param allowComments A value indicating whether comments may be emitted for the name.
         * @param allowSourceMaps A value indicating whether source maps may be emitted for the name.
         */
        function getExternalModuleOrNamespaceExportName(ns, node, allowComments, allowSourceMaps) {
            if (ns && ts.hasSyntacticModifier(node, 1 /* ModifierFlags.Export */)) {
                return getNamespaceMemberName(ns, getName(node), allowComments, allowSourceMaps);
            }
            return getExportName(node, allowComments, allowSourceMaps);
        }
        /**
         * Copies any necessary standard and custom prologue-directives into target array.
         * @param source origin statements array
         * @param target result statements array
         * @param ensureUseStrict boolean determining whether the function need to add prologue-directives
         * @param visitor Optional callback used to visit any custom prologue directives.
         */
        function copyPrologue(source, target, ensureUseStrict, visitor) {
            var offset = copyStandardPrologue(source, target, 0, ensureUseStrict);
            return copyCustomPrologue(source, target, offset, visitor);
        }
        function isUseStrictPrologue(node) {
            return ts.isStringLiteral(node.expression) && node.expression.text === "use strict";
        }
        function createUseStrictPrologue() {
            return ts.startOnNewLine(createExpressionStatement(createStringLiteral("use strict")));
        }
        /**
         * Copies only the standard (string-expression) prologue-directives into the target statement-array.
         * @param source origin statements array
         * @param target result statements array
         * @param statementOffset The offset at which to begin the copy.
         * @param ensureUseStrict boolean determining whether the function need to add prologue-directives
         * @returns Count of how many directive statements were copied.
         */
        function copyStandardPrologue(source, target, statementOffset, ensureUseStrict) {
            if (statementOffset === void 0) { statementOffset = 0; }
            ts.Debug.assert(target.length === 0, "Prologue directives should be at the first statement in the target statements array");
            var foundUseStrict = false;
            var numStatements = source.length;
            while (statementOffset < numStatements) {
                var statement = source[statementOffset];
                if (ts.isPrologueDirective(statement)) {
                    if (isUseStrictPrologue(statement)) {
                        foundUseStrict = true;
                    }
                    target.push(statement);
                }
                else {
                    break;
                }
                statementOffset++;
            }
            if (ensureUseStrict && !foundUseStrict) {
                target.push(createUseStrictPrologue());
            }
            return statementOffset;
        }
        function copyCustomPrologue(source, target, statementOffset, visitor, filter) {
            if (filter === void 0) { filter = ts.returnTrue; }
            var numStatements = source.length;
            while (statementOffset !== undefined && statementOffset < numStatements) {
                var statement = source[statementOffset];
                if (ts.getEmitFlags(statement) & 1048576 /* EmitFlags.CustomPrologue */ && filter(statement)) {
                    ts.append(target, visitor ? ts.visitNode(statement, visitor, ts.isStatement) : statement);
                }
                else {
                    break;
                }
                statementOffset++;
            }
            return statementOffset;
        }
        /**
         * Ensures "use strict" directive is added
         *
         * @param statements An array of statements
         */
        function ensureUseStrict(statements) {
            var foundUseStrict = ts.findUseStrictPrologue(statements);
            if (!foundUseStrict) {
                return ts.setTextRange(createNodeArray(__spreadArray([createUseStrictPrologue()], statements, true)), statements);
            }
            return statements;
        }
        /**
         * Lifts a NodeArray containing only Statement nodes to a block.
         *
         * @param nodes The NodeArray.
         */
        function liftToBlock(nodes) {
            ts.Debug.assert(ts.every(nodes, ts.isStatementOrBlock), "Cannot lift nodes to a Block.");
            return ts.singleOrUndefined(nodes) || createBlock(nodes);
        }
        function findSpanEnd(array, test, start) {
            var i = start;
            while (i < array.length && test(array[i])) {
                i++;
            }
            return i;
        }
        function mergeLexicalEnvironment(statements, declarations) {
            if (!ts.some(declarations)) {
                return statements;
            }
            // When we merge new lexical statements into an existing statement list, we merge them in the following manner:
            //
            // Given:
            //
            // | Left                               | Right                               |
            // |------------------------------------|-------------------------------------|
            // | [standard prologues (left)]        | [standard prologues (right)]        |
            // | [hoisted functions (left)]         | [hoisted functions (right)]         |
            // | [hoisted variables (left)]         | [hoisted variables (right)]         |
            // | [lexical init statements (left)]   | [lexical init statements (right)]   |
            // | [other statements (left)]          |                                     |
            //
            // The resulting statement list will be:
            //
            // | Result                              |
            // |-------------------------------------|
            // | [standard prologues (right)]        |
            // | [standard prologues (left)]         |
            // | [hoisted functions (right)]         |
            // | [hoisted functions (left)]          |
            // | [hoisted variables (right)]         |
            // | [hoisted variables (left)]          |
            // | [lexical init statements (right)]   |
            // | [lexical init statements (left)]    |
            // | [other statements (left)]           |
            //
            // NOTE: It is expected that new lexical init statements must be evaluated before existing lexical init statements,
            // as the prior transformation may depend on the evaluation of the lexical init statements to be in the correct state.
            // find standard prologues on left in the following order: standard directives, hoisted functions, hoisted variables, other custom
            var leftStandardPrologueEnd = findSpanEnd(statements, ts.isPrologueDirective, 0);
            var leftHoistedFunctionsEnd = findSpanEnd(statements, ts.isHoistedFunction, leftStandardPrologueEnd);
            var leftHoistedVariablesEnd = findSpanEnd(statements, ts.isHoistedVariableStatement, leftHoistedFunctionsEnd);
            // find standard prologues on right in the following order: standard directives, hoisted functions, hoisted variables, other custom
            var rightStandardPrologueEnd = findSpanEnd(declarations, ts.isPrologueDirective, 0);
            var rightHoistedFunctionsEnd = findSpanEnd(declarations, ts.isHoistedFunction, rightStandardPrologueEnd);
            var rightHoistedVariablesEnd = findSpanEnd(declarations, ts.isHoistedVariableStatement, rightHoistedFunctionsEnd);
            var rightCustomPrologueEnd = findSpanEnd(declarations, ts.isCustomPrologue, rightHoistedVariablesEnd);
            ts.Debug.assert(rightCustomPrologueEnd === declarations.length, "Expected declarations to be valid standard or custom prologues");
            // splice prologues from the right into the left. We do this in reverse order
            // so that we don't need to recompute the index on the left when we insert items.
            var left = ts.isNodeArray(statements) ? statements.slice() : statements;
            // splice other custom prologues from right into left
            if (rightCustomPrologueEnd > rightHoistedVariablesEnd) {
                left.splice.apply(left, __spreadArray([leftHoistedVariablesEnd, 0], declarations.slice(rightHoistedVariablesEnd, rightCustomPrologueEnd), false));
            }
            // splice hoisted variables from right into left
            if (rightHoistedVariablesEnd > rightHoistedFunctionsEnd) {
                left.splice.apply(left, __spreadArray([leftHoistedFunctionsEnd, 0], declarations.slice(rightHoistedFunctionsEnd, rightHoistedVariablesEnd), false));
            }
            // splice hoisted functions from right into left
            if (rightHoistedFunctionsEnd > rightStandardPrologueEnd) {
                left.splice.apply(left, __spreadArray([leftStandardPrologueEnd, 0], declarations.slice(rightStandardPrologueEnd, rightHoistedFunctionsEnd), false));
            }
            // splice standard prologues from right into left (that are not already in left)
            if (rightStandardPrologueEnd > 0) {
                if (leftStandardPrologueEnd === 0) {
                    left.splice.apply(left, __spreadArray([0, 0], declarations.slice(0, rightStandardPrologueEnd), false));
                }
                else {
                    var leftPrologues = new ts.Map();
                    for (var i = 0; i < leftStandardPrologueEnd; i++) {
                        var leftPrologue = statements[i];
                        leftPrologues.set(leftPrologue.expression.text, true);
                    }
                    for (var i = rightStandardPrologueEnd - 1; i >= 0; i--) {
                        var rightPrologue = declarations[i];
                        if (!leftPrologues.has(rightPrologue.expression.text)) {
                            left.unshift(rightPrologue);
                        }
                    }
                }
            }
            if (ts.isNodeArray(statements)) {
                return ts.setTextRange(createNodeArray(left, statements.hasTrailingComma), statements);
            }
            return statements;
        }
        function updateModifiers(node, modifiers) {
            var _a;
            var modifierArray;
            if (typeof modifiers === "number") {
                modifierArray = createModifiersFromModifierFlags(modifiers);
            }
            else {
                modifierArray = modifiers;
            }
            return ts.isTypeParameterDeclaration(node) ? updateTypeParameterDeclaration(node, modifierArray, node.name, node.constraint, node.default) :
                ts.isParameter(node) ? updateParameterDeclaration(node, modifierArray, node.dotDotDotToken, node.name, node.questionToken, node.type, node.initializer) :
                    ts.isConstructorTypeNode(node) ? updateConstructorTypeNode1(node, modifierArray, node.typeParameters, node.parameters, node.type) :
                        ts.isPropertySignature(node) ? updatePropertySignature(node, modifierArray, node.name, node.questionToken, node.type) :
                            ts.isPropertyDeclaration(node) ? updatePropertyDeclaration(node, modifierArray, node.name, (_a = node.questionToken) !== null && _a !== void 0 ? _a : node.exclamationToken, node.type, node.initializer) :
                                ts.isMethodSignature(node) ? updateMethodSignature(node, modifierArray, node.name, node.questionToken, node.typeParameters, node.parameters, node.type) :
                                    ts.isMethodDeclaration(node) ? updateMethodDeclaration(node, modifierArray, node.asteriskToken, node.name, node.questionToken, node.typeParameters, node.parameters, node.type, node.body) :
                                        ts.isConstructorDeclaration(node) ? updateConstructorDeclaration(node, modifierArray, node.parameters, node.body) :
                                            ts.isGetAccessorDeclaration(node) ? updateGetAccessorDeclaration(node, modifierArray, node.name, node.parameters, node.type, node.body) :
                                                ts.isSetAccessorDeclaration(node) ? updateSetAccessorDeclaration(node, modifierArray, node.name, node.parameters, node.body) :
                                                    ts.isIndexSignatureDeclaration(node) ? updateIndexSignature(node, modifierArray, node.parameters, node.type) :
                                                        ts.isFunctionExpression(node) ? updateFunctionExpression(node, modifierArray, node.asteriskToken, node.name, node.typeParameters, node.parameters, node.type, node.body) :
                                                            ts.isArrowFunction(node) ? updateArrowFunction(node, modifierArray, node.typeParameters, node.parameters, node.type, node.equalsGreaterThanToken, node.body) :
                                                                ts.isClassExpression(node) ? updateClassExpression(node, modifierArray, node.name, node.typeParameters, node.heritageClauses, node.members) :
                                                                    ts.isVariableStatement(node) ? updateVariableStatement(node, modifierArray, node.declarationList) :
                                                                        ts.isFunctionDeclaration(node) ? updateFunctionDeclaration(node, modifierArray, node.asteriskToken, node.name, node.typeParameters, node.parameters, node.type, node.body) :
                                                                            ts.isClassDeclaration(node) ? updateClassDeclaration(node, modifierArray, node.name, node.typeParameters, node.heritageClauses, node.members) :
                                                                                ts.isInterfaceDeclaration(node) ? updateInterfaceDeclaration(node, modifierArray, node.name, node.typeParameters, node.heritageClauses, node.members) :
                                                                                    ts.isTypeAliasDeclaration(node) ? updateTypeAliasDeclaration(node, modifierArray, node.name, node.typeParameters, node.type) :
                                                                                        ts.isEnumDeclaration(node) ? updateEnumDeclaration(node, modifierArray, node.name, node.members) :
                                                                                            ts.isModuleDeclaration(node) ? updateModuleDeclaration(node, modifierArray, node.name, node.body) :
                                                                                                ts.isImportEqualsDeclaration(node) ? updateImportEqualsDeclaration(node, modifierArray, node.isTypeOnly, node.name, node.moduleReference) :
                                                                                                    ts.isImportDeclaration(node) ? updateImportDeclaration(node, modifierArray, node.importClause, node.moduleSpecifier, node.assertClause) :
                                                                                                        ts.isExportAssignment(node) ? updateExportAssignment(node, modifierArray, node.expression) :
                                                                                                            ts.isExportDeclaration(node) ? updateExportDeclaration(node, modifierArray, node.isTypeOnly, node.exportClause, node.moduleSpecifier, node.assertClause) :
                                                                                                                ts.Debug.assertNever(node);
        }
        function asNodeArray(array) {
            return array ? createNodeArray(array) : undefined;
        }
        function asName(name) {
            return typeof name === "string" ? createIdentifier(name) :
                name;
        }
        function asExpression(value) {
            return typeof value === "string" ? createStringLiteral(value) :
                typeof value === "number" ? createNumericLiteral(value) :
                    typeof value === "boolean" ? value ? createTrue() : createFalse() :
                        value;
        }
        function asToken(value) {
            return typeof value === "number" ? createToken(value) : value;
        }
        function asEmbeddedStatement(statement) {
            return statement && ts.isNotEmittedStatement(statement) ? ts.setTextRange(setOriginalNode(createEmptyStatement(), statement), statement) : statement;
        }
    }
    ts.createNodeFactory = createNodeFactory;
    function updateWithoutOriginal(updated, original) {
        if (updated !== original) {
            ts.setTextRange(updated, original);
        }
        return updated;
    }
    function updateWithOriginal(updated, original) {
        if (updated !== original) {
            setOriginalNode(updated, original);
            ts.setTextRange(updated, original);
        }
        return updated;
    }
    function getDefaultTagNameForKind(kind) {
        switch (kind) {
            case 343 /* SyntaxKind.JSDocTypeTag */: return "type";
            case 341 /* SyntaxKind.JSDocReturnTag */: return "returns";
            case 342 /* SyntaxKind.JSDocThisTag */: return "this";
            case 339 /* SyntaxKind.JSDocEnumTag */: return "enum";
            case 330 /* SyntaxKind.JSDocAuthorTag */: return "author";
            case 332 /* SyntaxKind.JSDocClassTag */: return "class";
            case 333 /* SyntaxKind.JSDocPublicTag */: return "public";
            case 334 /* SyntaxKind.JSDocPrivateTag */: return "private";
            case 335 /* SyntaxKind.JSDocProtectedTag */: return "protected";
            case 336 /* SyntaxKind.JSDocReadonlyTag */: return "readonly";
            case 337 /* SyntaxKind.JSDocOverrideTag */: return "override";
            case 344 /* SyntaxKind.JSDocTemplateTag */: return "template";
            case 345 /* SyntaxKind.JSDocTypedefTag */: return "typedef";
            case 340 /* SyntaxKind.JSDocParameterTag */: return "param";
            case 347 /* SyntaxKind.JSDocPropertyTag */: return "prop";
            case 338 /* SyntaxKind.JSDocCallbackTag */: return "callback";
            case 328 /* SyntaxKind.JSDocAugmentsTag */: return "augments";
            case 329 /* SyntaxKind.JSDocImplementsTag */: return "implements";
            default:
                return ts.Debug.fail("Unsupported kind: ".concat(ts.Debug.formatSyntaxKind(kind)));
        }
    }
    var rawTextScanner;
    var invalidValueSentinel = {};
    function getCookedText(kind, rawText) {
        if (!rawTextScanner) {
            rawTextScanner = ts.createScanner(99 /* ScriptTarget.Latest */, /*skipTrivia*/ false, 0 /* LanguageVariant.Standard */);
        }
        switch (kind) {
            case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                rawTextScanner.setText("`" + rawText + "`");
                break;
            case 15 /* SyntaxKind.TemplateHead */:
                // tslint:disable-next-line no-invalid-template-strings
                rawTextScanner.setText("`" + rawText + "${");
                break;
            case 16 /* SyntaxKind.TemplateMiddle */:
                // tslint:disable-next-line no-invalid-template-strings
                rawTextScanner.setText("}" + rawText + "${");
                break;
            case 17 /* SyntaxKind.TemplateTail */:
                rawTextScanner.setText("}" + rawText + "`");
                break;
        }
        var token = rawTextScanner.scan();
        if (token === 19 /* SyntaxKind.CloseBraceToken */) {
            token = rawTextScanner.reScanTemplateToken(/*isTaggedTemplate*/ false);
        }
        if (rawTextScanner.isUnterminated()) {
            rawTextScanner.setText(undefined);
            return invalidValueSentinel;
        }
        var tokenValue;
        switch (token) {
            case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
            case 15 /* SyntaxKind.TemplateHead */:
            case 16 /* SyntaxKind.TemplateMiddle */:
            case 17 /* SyntaxKind.TemplateTail */:
                tokenValue = rawTextScanner.getTokenValue();
                break;
        }
        if (tokenValue === undefined || rawTextScanner.scan() !== 1 /* SyntaxKind.EndOfFileToken */) {
            rawTextScanner.setText(undefined);
            return invalidValueSentinel;
        }
        rawTextScanner.setText(undefined);
        return tokenValue;
    }
    function propagateIdentifierNameFlags(node) {
        // An IdentifierName is allowed to be `await`
        return propagateChildFlags(node) & ~67108864 /* TransformFlags.ContainsPossibleTopLevelAwait */;
    }
    function propagatePropertyNameFlagsOfChild(node, transformFlags) {
        return transformFlags | (node.transformFlags & 134234112 /* TransformFlags.PropertyNamePropagatingFlags */);
    }
    function propagateChildFlags(child) {
        if (!child)
            return 0 /* TransformFlags.None */;
        var childFlags = child.transformFlags & ~getTransformFlagsSubtreeExclusions(child.kind);
        return ts.isNamedDeclaration(child) && ts.isPropertyName(child.name) ? propagatePropertyNameFlagsOfChild(child.name, childFlags) : childFlags;
    }
    function propagateChildrenFlags(children) {
        return children ? children.transformFlags : 0 /* TransformFlags.None */;
    }
    function aggregateChildrenFlags(children) {
        var subtreeFlags = 0 /* TransformFlags.None */;
        for (var _i = 0, children_2 = children; _i < children_2.length; _i++) {
            var child = children_2[_i];
            subtreeFlags |= propagateChildFlags(child);
        }
        children.transformFlags = subtreeFlags;
    }
    /**
     * Gets the transform flags to exclude when unioning the transform flags of a subtree.
     */
    /* @internal */
    function getTransformFlagsSubtreeExclusions(kind) {
        if (kind >= 177 /* SyntaxKind.FirstTypeNode */ && kind <= 200 /* SyntaxKind.LastTypeNode */) {
            return -2 /* TransformFlags.TypeExcludes */;
        }
        switch (kind) {
            case 208 /* SyntaxKind.CallExpression */:
            case 209 /* SyntaxKind.NewExpression */:
            case 204 /* SyntaxKind.ArrayLiteralExpression */:
                return -2147450880 /* TransformFlags.ArrayLiteralOrCallOrNewExcludes */;
            case 261 /* SyntaxKind.ModuleDeclaration */:
                return -1941676032 /* TransformFlags.ModuleExcludes */;
            case 164 /* SyntaxKind.Parameter */:
                return -2147483648 /* TransformFlags.ParameterExcludes */;
            case 214 /* SyntaxKind.ArrowFunction */:
                return -2072174592 /* TransformFlags.ArrowFunctionExcludes */;
            case 213 /* SyntaxKind.FunctionExpression */:
            case 256 /* SyntaxKind.FunctionDeclaration */:
                return -1937940480 /* TransformFlags.FunctionExcludes */;
            case 255 /* SyntaxKind.VariableDeclarationList */:
                return -2146893824 /* TransformFlags.VariableDeclarationListExcludes */;
            case 257 /* SyntaxKind.ClassDeclaration */:
            case 226 /* SyntaxKind.ClassExpression */:
                return -2147344384 /* TransformFlags.ClassExcludes */;
            case 171 /* SyntaxKind.Constructor */:
                return -1937948672 /* TransformFlags.ConstructorExcludes */;
            case 167 /* SyntaxKind.PropertyDeclaration */:
                return -2013249536 /* TransformFlags.PropertyExcludes */;
            case 169 /* SyntaxKind.MethodDeclaration */:
            case 172 /* SyntaxKind.GetAccessor */:
            case 173 /* SyntaxKind.SetAccessor */:
                return -2005057536 /* TransformFlags.MethodOrAccessorExcludes */;
            case 130 /* SyntaxKind.AnyKeyword */:
            case 147 /* SyntaxKind.NumberKeyword */:
            case 158 /* SyntaxKind.BigIntKeyword */:
            case 143 /* SyntaxKind.NeverKeyword */:
            case 150 /* SyntaxKind.StringKeyword */:
            case 148 /* SyntaxKind.ObjectKeyword */:
            case 133 /* SyntaxKind.BooleanKeyword */:
            case 151 /* SyntaxKind.SymbolKeyword */:
            case 114 /* SyntaxKind.VoidKeyword */:
            case 163 /* SyntaxKind.TypeParameter */:
            case 166 /* SyntaxKind.PropertySignature */:
            case 168 /* SyntaxKind.MethodSignature */:
            case 174 /* SyntaxKind.CallSignature */:
            case 175 /* SyntaxKind.ConstructSignature */:
            case 176 /* SyntaxKind.IndexSignature */:
            case 258 /* SyntaxKind.InterfaceDeclaration */:
            case 259 /* SyntaxKind.TypeAliasDeclaration */:
                return -2 /* TransformFlags.TypeExcludes */;
            case 205 /* SyntaxKind.ObjectLiteralExpression */:
                return -2147278848 /* TransformFlags.ObjectLiteralExcludes */;
            case 292 /* SyntaxKind.CatchClause */:
                return -2147418112 /* TransformFlags.CatchClauseExcludes */;
            case 201 /* SyntaxKind.ObjectBindingPattern */:
            case 202 /* SyntaxKind.ArrayBindingPattern */:
                return -2147450880 /* TransformFlags.BindingPatternExcludes */;
            case 211 /* SyntaxKind.TypeAssertionExpression */:
            case 229 /* SyntaxKind.AsExpression */:
            case 350 /* SyntaxKind.PartiallyEmittedExpression */:
            case 212 /* SyntaxKind.ParenthesizedExpression */:
            case 106 /* SyntaxKind.SuperKeyword */:
                return -2147483648 /* TransformFlags.OuterExpressionExcludes */;
            case 206 /* SyntaxKind.PropertyAccessExpression */:
            case 207 /* SyntaxKind.ElementAccessExpression */:
                return -2147483648 /* TransformFlags.PropertyAccessExcludes */;
            default:
                return -2147483648 /* TransformFlags.NodeExcludes */;
        }
    }
    ts.getTransformFlagsSubtreeExclusions = getTransformFlagsSubtreeExclusions;
    var baseFactory = ts.createBaseNodeFactory();
    function makeSynthetic(node) {
        node.flags |= 8 /* NodeFlags.Synthesized */;
        return node;
    }
    var syntheticFactory = {
        createBaseSourceFileNode: function (kind) { return makeSynthetic(baseFactory.createBaseSourceFileNode(kind)); },
        createBaseIdentifierNode: function (kind) { return makeSynthetic(baseFactory.createBaseIdentifierNode(kind)); },
        createBasePrivateIdentifierNode: function (kind) { return makeSynthetic(baseFactory.createBasePrivateIdentifierNode(kind)); },
        createBaseTokenNode: function (kind) { return makeSynthetic(baseFactory.createBaseTokenNode(kind)); },
        createBaseNode: function (kind) { return makeSynthetic(baseFactory.createBaseNode(kind)); },
    };
    ts.factory = createNodeFactory(4 /* NodeFactoryFlags.NoIndentationOnFreshPropertyAccess */, syntheticFactory);
    function createUnparsedSourceFile(textOrInputFiles, mapPathOrType, mapTextOrStripInternal) {
        var stripInternal;
        var bundleFileInfo;
        var fileName;
        var text;
        var length;
        var sourceMapPath;
        var sourceMapText;
        var getText;
        var getSourceMapText;
        var oldFileOfCurrentEmit;
        if (!ts.isString(textOrInputFiles)) {
            ts.Debug.assert(mapPathOrType === "js" || mapPathOrType === "dts");
            fileName = (mapPathOrType === "js" ? textOrInputFiles.javascriptPath : textOrInputFiles.declarationPath) || "";
            sourceMapPath = mapPathOrType === "js" ? textOrInputFiles.javascriptMapPath : textOrInputFiles.declarationMapPath;
            getText = function () { return mapPathOrType === "js" ? textOrInputFiles.javascriptText : textOrInputFiles.declarationText; };
            getSourceMapText = function () { return mapPathOrType === "js" ? textOrInputFiles.javascriptMapText : textOrInputFiles.declarationMapText; };
            length = function () { return getText().length; };
            if (textOrInputFiles.buildInfo && textOrInputFiles.buildInfo.bundle) {
                ts.Debug.assert(mapTextOrStripInternal === undefined || typeof mapTextOrStripInternal === "boolean");
                stripInternal = mapTextOrStripInternal;
                bundleFileInfo = mapPathOrType === "js" ? textOrInputFiles.buildInfo.bundle.js : textOrInputFiles.buildInfo.bundle.dts;
                oldFileOfCurrentEmit = textOrInputFiles.oldFileOfCurrentEmit;
            }
        }
        else {
            fileName = "";
            text = textOrInputFiles;
            length = textOrInputFiles.length;
            sourceMapPath = mapPathOrType;
            sourceMapText = mapTextOrStripInternal;
        }
        var node = oldFileOfCurrentEmit ?
            parseOldFileOfCurrentEmit(ts.Debug.checkDefined(bundleFileInfo)) :
            parseUnparsedSourceFile(bundleFileInfo, stripInternal, length);
        node.fileName = fileName;
        node.sourceMapPath = sourceMapPath;
        node.oldFileOfCurrentEmit = oldFileOfCurrentEmit;
        if (getText && getSourceMapText) {
            Object.defineProperty(node, "text", { get: getText });
            Object.defineProperty(node, "sourceMapText", { get: getSourceMapText });
        }
        else {
            ts.Debug.assert(!oldFileOfCurrentEmit);
            node.text = text !== null && text !== void 0 ? text : "";
            node.sourceMapText = sourceMapText;
        }
        return node;
    }
    ts.createUnparsedSourceFile = createUnparsedSourceFile;
    function parseUnparsedSourceFile(bundleFileInfo, stripInternal, length) {
        var prologues;
        var helpers;
        var referencedFiles;
        var typeReferenceDirectives;
        var libReferenceDirectives;
        var prependChildren;
        var texts;
        var hasNoDefaultLib;
        for (var _i = 0, _a = bundleFileInfo ? bundleFileInfo.sections : ts.emptyArray; _i < _a.length; _i++) {
            var section = _a[_i];
            switch (section.kind) {
                case "prologue" /* BundleFileSectionKind.Prologue */:
                    prologues = ts.append(prologues, ts.setTextRange(ts.factory.createUnparsedPrologue(section.data), section));
                    break;
                case "emitHelpers" /* BundleFileSectionKind.EmitHelpers */:
                    helpers = ts.append(helpers, ts.getAllUnscopedEmitHelpers().get(section.data));
                    break;
                case "no-default-lib" /* BundleFileSectionKind.NoDefaultLib */:
                    hasNoDefaultLib = true;
                    break;
                case "reference" /* BundleFileSectionKind.Reference */:
                    referencedFiles = ts.append(referencedFiles, { pos: -1, end: -1, fileName: section.data });
                    break;
                case "type" /* BundleFileSectionKind.Type */:
                    typeReferenceDirectives = ts.append(typeReferenceDirectives, { pos: -1, end: -1, fileName: section.data });
                    break;
                case "type-import" /* BundleFileSectionKind.TypeResolutionModeImport */:
                    typeReferenceDirectives = ts.append(typeReferenceDirectives, { pos: -1, end: -1, fileName: section.data, resolutionMode: ts.ModuleKind.ESNext });
                    break;
                case "type-require" /* BundleFileSectionKind.TypeResolutionModeRequire */:
                    typeReferenceDirectives = ts.append(typeReferenceDirectives, { pos: -1, end: -1, fileName: section.data, resolutionMode: ts.ModuleKind.CommonJS });
                    break;
                case "lib" /* BundleFileSectionKind.Lib */:
                    libReferenceDirectives = ts.append(libReferenceDirectives, { pos: -1, end: -1, fileName: section.data });
                    break;
                case "prepend" /* BundleFileSectionKind.Prepend */:
                    var prependTexts = void 0;
                    for (var _b = 0, _c = section.texts; _b < _c.length; _b++) {
                        var text = _c[_b];
                        if (!stripInternal || text.kind !== "internal" /* BundleFileSectionKind.Internal */) {
                            prependTexts = ts.append(prependTexts, ts.setTextRange(ts.factory.createUnparsedTextLike(text.data, text.kind === "internal" /* BundleFileSectionKind.Internal */), text));
                        }
                    }
                    prependChildren = ts.addRange(prependChildren, prependTexts);
                    texts = ts.append(texts, ts.factory.createUnparsedPrepend(section.data, prependTexts !== null && prependTexts !== void 0 ? prependTexts : ts.emptyArray));
                    break;
                case "internal" /* BundleFileSectionKind.Internal */:
                    if (stripInternal) {
                        if (!texts)
                            texts = [];
                        break;
                    }
                // falls through
                case "text" /* BundleFileSectionKind.Text */:
                    texts = ts.append(texts, ts.setTextRange(ts.factory.createUnparsedTextLike(section.data, section.kind === "internal" /* BundleFileSectionKind.Internal */), section));
                    break;
                default:
                    ts.Debug.assertNever(section);
            }
        }
        if (!texts) {
            var textNode = ts.factory.createUnparsedTextLike(/*data*/ undefined, /*internal*/ false);
            ts.setTextRangePosWidth(textNode, 0, typeof length === "function" ? length() : length);
            texts = [textNode];
        }
        var node = ts.parseNodeFactory.createUnparsedSource(prologues !== null && prologues !== void 0 ? prologues : ts.emptyArray, /*syntheticReferences*/ undefined, texts);
        ts.setEachParent(prologues, node);
        ts.setEachParent(texts, node);
        ts.setEachParent(prependChildren, node);
        node.hasNoDefaultLib = hasNoDefaultLib;
        node.helpers = helpers;
        node.referencedFiles = referencedFiles || ts.emptyArray;
        node.typeReferenceDirectives = typeReferenceDirectives;
        node.libReferenceDirectives = libReferenceDirectives || ts.emptyArray;
        return node;
    }
    function parseOldFileOfCurrentEmit(bundleFileInfo) {
        var texts;
        var syntheticReferences;
        for (var _i = 0, _a = bundleFileInfo.sections; _i < _a.length; _i++) {
            var section = _a[_i];
            switch (section.kind) {
                case "internal" /* BundleFileSectionKind.Internal */:
                case "text" /* BundleFileSectionKind.Text */:
                    texts = ts.append(texts, ts.setTextRange(ts.factory.createUnparsedTextLike(section.data, section.kind === "internal" /* BundleFileSectionKind.Internal */), section));
                    break;
                case "no-default-lib" /* BundleFileSectionKind.NoDefaultLib */:
                case "reference" /* BundleFileSectionKind.Reference */:
                case "type" /* BundleFileSectionKind.Type */:
                case "type-import" /* BundleFileSectionKind.TypeResolutionModeImport */:
                case "type-require" /* BundleFileSectionKind.TypeResolutionModeRequire */:
                case "lib" /* BundleFileSectionKind.Lib */:
                    syntheticReferences = ts.append(syntheticReferences, ts.setTextRange(ts.factory.createUnparsedSyntheticReference(section), section));
                    break;
                // Ignore
                case "prologue" /* BundleFileSectionKind.Prologue */:
                case "emitHelpers" /* BundleFileSectionKind.EmitHelpers */:
                case "prepend" /* BundleFileSectionKind.Prepend */:
                    break;
                default:
                    ts.Debug.assertNever(section);
            }
        }
        var node = ts.factory.createUnparsedSource(ts.emptyArray, syntheticReferences, texts !== null && texts !== void 0 ? texts : ts.emptyArray);
        ts.setEachParent(syntheticReferences, node);
        ts.setEachParent(texts, node);
        node.helpers = ts.map(bundleFileInfo.sources && bundleFileInfo.sources.helpers, function (name) { return ts.getAllUnscopedEmitHelpers().get(name); });
        return node;
    }
    function createInputFiles(javascriptTextOrReadFileText, declarationTextOrJavascriptPath, javascriptMapPath, javascriptMapTextOrDeclarationPath, declarationMapPath, declarationMapTextOrBuildInfoPath, javascriptPath, declarationPath, buildInfoPath, buildInfo, oldFileOfCurrentEmit) {
        var node = ts.parseNodeFactory.createInputFiles();
        if (!ts.isString(javascriptTextOrReadFileText)) {
            var cache_1 = new ts.Map();
            var textGetter_1 = function (path) {
                if (path === undefined)
                    return undefined;
                var value = cache_1.get(path);
                if (value === undefined) {
                    value = javascriptTextOrReadFileText(path);
                    cache_1.set(path, value !== undefined ? value : false);
                }
                return value !== false ? value : undefined;
            };
            var definedTextGetter_1 = function (path) {
                var result = textGetter_1(path);
                return result !== undefined ? result : "/* Input file ".concat(path, " was missing */\r\n");
            };
            var buildInfo_1;
            var getAndCacheBuildInfo_1 = function (getText) {
                if (buildInfo_1 === undefined) {
                    var result = getText();
                    buildInfo_1 = result !== undefined ? ts.getBuildInfo(result) : false;
                }
                return buildInfo_1 || undefined;
            };
            node.javascriptPath = declarationTextOrJavascriptPath;
            node.javascriptMapPath = javascriptMapPath;
            node.declarationPath = ts.Debug.checkDefined(javascriptMapTextOrDeclarationPath);
            node.declarationMapPath = declarationMapPath;
            node.buildInfoPath = declarationMapTextOrBuildInfoPath;
            Object.defineProperties(node, {
                javascriptText: { get: function () { return definedTextGetter_1(declarationTextOrJavascriptPath); } },
                javascriptMapText: { get: function () { return textGetter_1(javascriptMapPath); } },
                declarationText: { get: function () { return definedTextGetter_1(ts.Debug.checkDefined(javascriptMapTextOrDeclarationPath)); } },
                declarationMapText: { get: function () { return textGetter_1(declarationMapPath); } },
                buildInfo: { get: function () { return getAndCacheBuildInfo_1(function () { return textGetter_1(declarationMapTextOrBuildInfoPath); }); } }
            });
        }
        else {
            node.javascriptText = javascriptTextOrReadFileText;
            node.javascriptMapPath = javascriptMapPath;
            node.javascriptMapText = javascriptMapTextOrDeclarationPath;
            node.declarationText = declarationTextOrJavascriptPath;
            node.declarationMapPath = declarationMapPath;
            node.declarationMapText = declarationMapTextOrBuildInfoPath;
            node.javascriptPath = javascriptPath;
            node.declarationPath = declarationPath;
            node.buildInfoPath = buildInfoPath;
            node.buildInfo = buildInfo;
            node.oldFileOfCurrentEmit = oldFileOfCurrentEmit;
        }
        return node;
    }
    ts.createInputFiles = createInputFiles;
    // tslint:disable-next-line variable-name
    var SourceMapSource;
    /**
     * Create an external source map source file reference
     */
    function createSourceMapSource(fileName, text, skipTrivia) {
        return new (SourceMapSource || (SourceMapSource = ts.objectAllocator.getSourceMapSourceConstructor()))(fileName, text, skipTrivia);
    }
    ts.createSourceMapSource = createSourceMapSource;
    // Utilities
    function setOriginalNode(node, original) {
        node.original = original;
        if (original) {
            var emitNode = original.emitNode;
            if (emitNode)
                node.emitNode = mergeEmitNode(emitNode, node.emitNode);
        }
        return node;
    }
    ts.setOriginalNode = setOriginalNode;
    function mergeEmitNode(sourceEmitNode, destEmitNode) {
        var flags = sourceEmitNode.flags, leadingComments = sourceEmitNode.leadingComments, trailingComments = sourceEmitNode.trailingComments, commentRange = sourceEmitNode.commentRange, sourceMapRange = sourceEmitNode.sourceMapRange, tokenSourceMapRanges = sourceEmitNode.tokenSourceMapRanges, constantValue = sourceEmitNode.constantValue, helpers = sourceEmitNode.helpers, startsOnNewLine = sourceEmitNode.startsOnNewLine;
        if (!destEmitNode)
            destEmitNode = {};
        // We are using `.slice()` here in case `destEmitNode.leadingComments` is pushed to later.
        if (leadingComments)
            destEmitNode.leadingComments = ts.addRange(leadingComments.slice(), destEmitNode.leadingComments);
        if (trailingComments)
            destEmitNode.trailingComments = ts.addRange(trailingComments.slice(), destEmitNode.trailingComments);
        if (flags)
            destEmitNode.flags = flags & ~268435456 /* EmitFlags.Immutable */;
        if (commentRange)
            destEmitNode.commentRange = commentRange;
        if (sourceMapRange)
            destEmitNode.sourceMapRange = sourceMapRange;
        if (tokenSourceMapRanges)
            destEmitNode.tokenSourceMapRanges = mergeTokenSourceMapRanges(tokenSourceMapRanges, destEmitNode.tokenSourceMapRanges);
        if (constantValue !== undefined)
            destEmitNode.constantValue = constantValue;
        if (helpers) {
            for (var _i = 0, helpers_1 = helpers; _i < helpers_1.length; _i++) {
                var helper = helpers_1[_i];
                destEmitNode.helpers = ts.appendIfUnique(destEmitNode.helpers, helper);
            }
        }
        if (startsOnNewLine !== undefined)
            destEmitNode.startsOnNewLine = startsOnNewLine;
        return destEmitNode;
    }
    function mergeTokenSourceMapRanges(sourceRanges, destRanges) {
        if (!destRanges)
            destRanges = [];
        for (var key in sourceRanges) {
            destRanges[key] = sourceRanges[key];
        }
        return destRanges;
    }
})(ts || (ts = {}));
var ts;
(function (ts) {
    /**
     * Associates a node with the current transformation, initializing
     * various transient transformation properties.
     * @internal
     */
    function getOrCreateEmitNode(node) {
        var _a;
        if (!node.emitNode) {
            if (ts.isParseTreeNode(node)) {
                // To avoid holding onto transformation artifacts, we keep track of any
                // parse tree node we are annotating. This allows us to clean them up after
                // all transformations have completed.
                if (node.kind === 305 /* SyntaxKind.SourceFile */) {
                    return node.emitNode = { annotatedNodes: [node] };
                }
                var sourceFile = (_a = ts.getSourceFileOfNode(ts.getParseTreeNode(ts.getSourceFileOfNode(node)))) !== null && _a !== void 0 ? _a : ts.Debug.fail("Could not determine parsed source file.");
                getOrCreateEmitNode(sourceFile).annotatedNodes.push(node);
            }
            node.emitNode = {};
        }
        else {
            ts.Debug.assert(!(node.emitNode.flags & 268435456 /* EmitFlags.Immutable */), "Invalid attempt to mutate an immutable node.");
        }
        return node.emitNode;
    }
    ts.getOrCreateEmitNode = getOrCreateEmitNode;
    /**
     * Clears any `EmitNode` entries from parse-tree nodes.
     * @param sourceFile A source file.
     */
    function disposeEmitNodes(sourceFile) {
        var _a, _b;
        // During transformation we may need to annotate a parse tree node with transient
        // transformation properties. As parse tree nodes live longer than transformation
        // nodes, we need to make sure we reclaim any memory allocated for custom ranges
        // from these nodes to ensure we do not hold onto entire subtrees just for position
        // information. We also need to reset these nodes to a pre-transformation state
        // for incremental parsing scenarios so that we do not impact later emit.
        var annotatedNodes = (_b = (_a = ts.getSourceFileOfNode(ts.getParseTreeNode(sourceFile))) === null || _a === void 0 ? void 0 : _a.emitNode) === null || _b === void 0 ? void 0 : _b.annotatedNodes;
        if (annotatedNodes) {
            for (var _i = 0, annotatedNodes_1 = annotatedNodes; _i < annotatedNodes_1.length; _i++) {
                var node = annotatedNodes_1[_i];
                node.emitNode = undefined;
            }
        }
    }
    ts.disposeEmitNodes = disposeEmitNodes;
    /**
     * Sets `EmitFlags.NoComments` on a node and removes any leading and trailing synthetic comments.
     * @internal
     */
    function removeAllComments(node) {
        var emitNode = getOrCreateEmitNode(node);
        emitNode.flags |= 1536 /* EmitFlags.NoComments */;
        emitNode.leadingComments = undefined;
        emitNode.trailingComments = undefined;
        return node;
    }
    ts.removeAllComments = removeAllComments;
    /**
     * Sets flags that control emit behavior of a node.
     */
    function setEmitFlags(node, emitFlags) {
        getOrCreateEmitNode(node).flags = emitFlags;
        return node;
    }
    ts.setEmitFlags = setEmitFlags;
    /**
     * Sets flags that control emit behavior of a node.
     */
    /* @internal */
    function addEmitFlags(node, emitFlags) {
        var emitNode = getOrCreateEmitNode(node);
        emitNode.flags = emitNode.flags | emitFlags;
        return node;
    }
    ts.addEmitFlags = addEmitFlags;
    /**
     * Gets a custom text range to use when emitting source maps.
     */
    function getSourceMapRange(node) {
        var _a, _b;
        return (_b = (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.sourceMapRange) !== null && _b !== void 0 ? _b : node;
    }
    ts.getSourceMapRange = getSourceMapRange;
    /**
     * Sets a custom text range to use when emitting source maps.
     */
    function setSourceMapRange(node, range) {
        getOrCreateEmitNode(node).sourceMapRange = range;
        return node;
    }
    ts.setSourceMapRange = setSourceMapRange;
    /**
     * Gets the TextRange to use for source maps for a token of a node.
     */
    function getTokenSourceMapRange(node, token) {
        var _a, _b;
        return (_b = (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.tokenSourceMapRanges) === null || _b === void 0 ? void 0 : _b[token];
    }
    ts.getTokenSourceMapRange = getTokenSourceMapRange;
    /**
     * Sets the TextRange to use for source maps for a token of a node.
     */
    function setTokenSourceMapRange(node, token, range) {
        var _a;
        var emitNode = getOrCreateEmitNode(node);
        var tokenSourceMapRanges = (_a = emitNode.tokenSourceMapRanges) !== null && _a !== void 0 ? _a : (emitNode.tokenSourceMapRanges = []);
        tokenSourceMapRanges[token] = range;
        return node;
    }
    ts.setTokenSourceMapRange = setTokenSourceMapRange;
    /**
     * Gets a custom text range to use when emitting comments.
     */
    /*@internal*/
    function getStartsOnNewLine(node) {
        var _a;
        return (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.startsOnNewLine;
    }
    ts.getStartsOnNewLine = getStartsOnNewLine;
    /**
     * Sets a custom text range to use when emitting comments.
     */
    /*@internal*/
    function setStartsOnNewLine(node, newLine) {
        getOrCreateEmitNode(node).startsOnNewLine = newLine;
        return node;
    }
    ts.setStartsOnNewLine = setStartsOnNewLine;
    /**
     * Gets a custom text range to use when emitting comments.
     */
    function getCommentRange(node) {
        var _a, _b;
        return (_b = (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.commentRange) !== null && _b !== void 0 ? _b : node;
    }
    ts.getCommentRange = getCommentRange;
    /**
     * Sets a custom text range to use when emitting comments.
     */
    function setCommentRange(node, range) {
        getOrCreateEmitNode(node).commentRange = range;
        return node;
    }
    ts.setCommentRange = setCommentRange;
    function getSyntheticLeadingComments(node) {
        var _a;
        return (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.leadingComments;
    }
    ts.getSyntheticLeadingComments = getSyntheticLeadingComments;
    function setSyntheticLeadingComments(node, comments) {
        getOrCreateEmitNode(node).leadingComments = comments;
        return node;
    }
    ts.setSyntheticLeadingComments = setSyntheticLeadingComments;
    function addSyntheticLeadingComment(node, kind, text, hasTrailingNewLine) {
        return setSyntheticLeadingComments(node, ts.append(getSyntheticLeadingComments(node), { kind: kind, pos: -1, end: -1, hasTrailingNewLine: hasTrailingNewLine, text: text }));
    }
    ts.addSyntheticLeadingComment = addSyntheticLeadingComment;
    function getSyntheticTrailingComments(node) {
        var _a;
        return (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.trailingComments;
    }
    ts.getSyntheticTrailingComments = getSyntheticTrailingComments;
    function setSyntheticTrailingComments(node, comments) {
        getOrCreateEmitNode(node).trailingComments = comments;
        return node;
    }
    ts.setSyntheticTrailingComments = setSyntheticTrailingComments;
    function addSyntheticTrailingComment(node, kind, text, hasTrailingNewLine) {
        return setSyntheticTrailingComments(node, ts.append(getSyntheticTrailingComments(node), { kind: kind, pos: -1, end: -1, hasTrailingNewLine: hasTrailingNewLine, text: text }));
    }
    ts.addSyntheticTrailingComment = addSyntheticTrailingComment;
    function moveSyntheticComments(node, original) {
        setSyntheticLeadingComments(node, getSyntheticLeadingComments(original));
        setSyntheticTrailingComments(node, getSyntheticTrailingComments(original));
        var emit = getOrCreateEmitNode(original);
        emit.leadingComments = undefined;
        emit.trailingComments = undefined;
        return node;
    }
    ts.moveSyntheticComments = moveSyntheticComments;
    /**
     * Gets the constant value to emit for an expression representing an enum.
     */
    function getConstantValue(node) {
        var _a;
        return (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.constantValue;
    }
    ts.getConstantValue = getConstantValue;
    /**
     * Sets the constant value to emit for an expression.
     */
    function setConstantValue(node, value) {
        var emitNode = getOrCreateEmitNode(node);
        emitNode.constantValue = value;
        return node;
    }
    ts.setConstantValue = setConstantValue;
    /**
     * Adds an EmitHelper to a node.
     */
    function addEmitHelper(node, helper) {
        var emitNode = getOrCreateEmitNode(node);
        emitNode.helpers = ts.append(emitNode.helpers, helper);
        return node;
    }
    ts.addEmitHelper = addEmitHelper;
    /**
     * Add EmitHelpers to a node.
     */
    function addEmitHelpers(node, helpers) {
        if (ts.some(helpers)) {
            var emitNode = getOrCreateEmitNode(node);
            for (var _i = 0, helpers_2 = helpers; _i < helpers_2.length; _i++) {
                var helper = helpers_2[_i];
                emitNode.helpers = ts.appendIfUnique(emitNode.helpers, helper);
            }
        }
        return node;
    }
    ts.addEmitHelpers = addEmitHelpers;
    /**
     * Removes an EmitHelper from a node.
     */
    function removeEmitHelper(node, helper) {
        var _a;
        var helpers = (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.helpers;
        if (helpers) {
            return ts.orderedRemoveItem(helpers, helper);
        }
        return false;
    }
    ts.removeEmitHelper = removeEmitHelper;
    /**
     * Gets the EmitHelpers of a node.
     */
    function getEmitHelpers(node) {
        var _a;
        return (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.helpers;
    }
    ts.getEmitHelpers = getEmitHelpers;
    /**
     * Moves matching emit helpers from a source node to a target node.
     */
    function moveEmitHelpers(source, target, predicate) {
        var sourceEmitNode = source.emitNode;
        var sourceEmitHelpers = sourceEmitNode && sourceEmitNode.helpers;
        if (!ts.some(sourceEmitHelpers))
            return;
        var targetEmitNode = getOrCreateEmitNode(target);
        var helpersRemoved = 0;
        for (var i = 0; i < sourceEmitHelpers.length; i++) {
            var helper = sourceEmitHelpers[i];
            if (predicate(helper)) {
                helpersRemoved++;
                targetEmitNode.helpers = ts.appendIfUnique(targetEmitNode.helpers, helper);
            }
            else if (helpersRemoved > 0) {
                sourceEmitHelpers[i - helpersRemoved] = helper;
            }
        }
        if (helpersRemoved > 0) {
            sourceEmitHelpers.length -= helpersRemoved;
        }
    }
    ts.moveEmitHelpers = moveEmitHelpers;
    /**
     * Gets the SnippetElement of a node.
     */
    /* @internal */
    function getSnippetElement(node) {
        var _a;
        return (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.snippetElement;
    }
    ts.getSnippetElement = getSnippetElement;
    /**
     * Sets the SnippetElement of a node.
     */
    /* @internal */
    function setSnippetElement(node, snippet) {
        var emitNode = getOrCreateEmitNode(node);
        emitNode.snippetElement = snippet;
        return node;
    }
    ts.setSnippetElement = setSnippetElement;
    /* @internal */
    function ignoreSourceNewlines(node) {
        getOrCreateEmitNode(node).flags |= 134217728 /* EmitFlags.IgnoreSourceNewlines */;
        return node;
    }
    ts.ignoreSourceNewlines = ignoreSourceNewlines;
    /* @internal */
    function setTypeNode(node, type) {
        var emitNode = getOrCreateEmitNode(node);
        emitNode.typeNode = type;
        return node;
    }
    ts.setTypeNode = setTypeNode;
    /* @internal */
    function getTypeNode(node) {
        var _a;
        return (_a = node.emitNode) === null || _a === void 0 ? void 0 : _a.typeNode;
    }
    ts.getTypeNode = getTypeNode;
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    function createEmitHelperFactory(context) {
        var factory = context.factory;
        var immutableTrue = ts.memoize(function () { return ts.setEmitFlags(factory.createTrue(), 268435456 /* EmitFlags.Immutable */); });
        var immutableFalse = ts.memoize(function () { return ts.setEmitFlags(factory.createFalse(), 268435456 /* EmitFlags.Immutable */); });
        return {
            getUnscopedHelperName: getUnscopedHelperName,
            // TypeScript Helpers
            createDecorateHelper: createDecorateHelper,
            createMetadataHelper: createMetadataHelper,
            createParamHelper: createParamHelper,
            // ES2018 Helpers
            createAssignHelper: createAssignHelper,
            createAwaitHelper: createAwaitHelper,
            createAsyncGeneratorHelper: createAsyncGeneratorHelper,
            createAsyncDelegatorHelper: createAsyncDelegatorHelper,
            createAsyncValuesHelper: createAsyncValuesHelper,
            // ES2018 Destructuring Helpers
            createRestHelper: createRestHelper,
            // ES2017 Helpers
            createAwaiterHelper: createAwaiterHelper,
            // ES2015 Helpers
            createExtendsHelper: createExtendsHelper,
            createTemplateObjectHelper: createTemplateObjectHelper,
            createSpreadArrayHelper: createSpreadArrayHelper,
            // ES2015 Destructuring Helpers
            createValuesHelper: createValuesHelper,
            createReadHelper: createReadHelper,
            // ES2015 Generator Helpers
            createGeneratorHelper: createGeneratorHelper,
            // ES Module Helpers
            createCreateBindingHelper: createCreateBindingHelper,
            createImportStarHelper: createImportStarHelper,
            createImportStarCallbackHelper: createImportStarCallbackHelper,
            createImportDefaultHelper: createImportDefaultHelper,
            createExportStarHelper: createExportStarHelper,
            // Class Fields Helpers
            createClassPrivateFieldGetHelper: createClassPrivateFieldGetHelper,
            createClassPrivateFieldSetHelper: createClassPrivateFieldSetHelper,
            createClassPrivateFieldInHelper: createClassPrivateFieldInHelper
        };
        /**
         * Gets an identifier for the name of an *unscoped* emit helper.
         */
        function getUnscopedHelperName(name) {
            return ts.setEmitFlags(factory.createIdentifier(name), 4096 /* EmitFlags.HelperName */ | 2 /* EmitFlags.AdviseOnEmitNode */);
        }
        // TypeScript Helpers
        function createDecorateHelper(decoratorExpressions, target, memberName, descriptor) {
            context.requestEmitHelper(ts.decorateHelper);
            var argumentsArray = [];
            argumentsArray.push(factory.createArrayLiteralExpression(decoratorExpressions, /*multiLine*/ true));
            argumentsArray.push(target);
            if (memberName) {
                argumentsArray.push(memberName);
                if (descriptor) {
                    argumentsArray.push(descriptor);
                }
            }
            return factory.createCallExpression(getUnscopedHelperName("__decorate"), 
            /*typeArguments*/ undefined, argumentsArray);
        }
        function createMetadataHelper(metadataKey, metadataValue) {
            context.requestEmitHelper(ts.metadataHelper);
            return factory.createCallExpression(getUnscopedHelperName("__metadata"), 
            /*typeArguments*/ undefined, [
                factory.createStringLiteral(metadataKey),
                metadataValue
            ]);
        }
        function createParamHelper(expression, parameterOffset, location) {
            context.requestEmitHelper(ts.paramHelper);
            return ts.setTextRange(factory.createCallExpression(getUnscopedHelperName("__param"), 
            /*typeArguments*/ undefined, [
                factory.createNumericLiteral(parameterOffset + ""),
                expression
            ]), location);
        }
        // ES2018 Helpers
        function createAssignHelper(attributesSegments) {
            if (ts.getEmitScriptTarget(context.getCompilerOptions()) >= 2 /* ScriptTarget.ES2015 */) {
                return factory.createCallExpression(factory.createPropertyAccessExpression(factory.createIdentifier("Object"), "assign"), 
                /*typeArguments*/ undefined, attributesSegments);
            }
            context.requestEmitHelper(ts.assignHelper);
            return factory.createCallExpression(getUnscopedHelperName("__assign"), 
            /*typeArguments*/ undefined, attributesSegments);
        }
        function createAwaitHelper(expression) {
            context.requestEmitHelper(ts.awaitHelper);
            return factory.createCallExpression(getUnscopedHelperName("__await"), /*typeArguments*/ undefined, [expression]);
        }
        function createAsyncGeneratorHelper(generatorFunc, hasLexicalThis) {
            context.requestEmitHelper(ts.awaitHelper);
            context.requestEmitHelper(ts.asyncGeneratorHelper);
            // Mark this node as originally an async function
            (generatorFunc.emitNode || (generatorFunc.emitNode = {})).flags |= 262144 /* EmitFlags.AsyncFunctionBody */ | 524288 /* EmitFlags.ReuseTempVariableScope */;
            return factory.createCallExpression(getUnscopedHelperName("__asyncGenerator"), 
            /*typeArguments*/ undefined, [
                hasLexicalThis ? factory.createThis() : factory.createVoidZero(),
                factory.createIdentifier("arguments"),
                generatorFunc
            ]);
        }
        function createAsyncDelegatorHelper(expression) {
            context.requestEmitHelper(ts.awaitHelper);
            context.requestEmitHelper(ts.asyncDelegator);
            return factory.createCallExpression(getUnscopedHelperName("__asyncDelegator"), 
            /*typeArguments*/ undefined, [expression]);
        }
        function createAsyncValuesHelper(expression) {
            context.requestEmitHelper(ts.asyncValues);
            return factory.createCallExpression(getUnscopedHelperName("__asyncValues"), 
            /*typeArguments*/ undefined, [expression]);
        }
        // ES2018 Destructuring Helpers
        /** Given value: o, propName: p, pattern: { a, b, ...p } from the original statement
         * `{ a, b, ...p } = o`, create `p = __rest(o, ["a", "b"]);`
         */
        function createRestHelper(value, elements, computedTempVariables, location) {
            context.requestEmitHelper(ts.restHelper);
            var propertyNames = [];
            var computedTempVariableOffset = 0;
            for (var i = 0; i < elements.length - 1; i++) {
                var propertyName = ts.getPropertyNameOfBindingOrAssignmentElement(elements[i]);
                if (propertyName) {
                    if (ts.isComputedPropertyName(propertyName)) {
                        ts.Debug.assertIsDefined(computedTempVariables, "Encountered computed property name but 'computedTempVariables' argument was not provided.");
                        var temp = computedTempVariables[computedTempVariableOffset];
                        computedTempVariableOffset++;
                        // typeof _tmp === "symbol" ? _tmp : _tmp + ""
                        propertyNames.push(factory.createConditionalExpression(factory.createTypeCheck(temp, "symbol"), 
                        /*questionToken*/ undefined, temp, 
                        /*colonToken*/ undefined, factory.createAdd(temp, factory.createStringLiteral(""))));
                    }
                    else {
                        propertyNames.push(factory.createStringLiteralFromNode(propertyName));
                    }
                }
            }
            return factory.createCallExpression(getUnscopedHelperName("__rest"), 
            /*typeArguments*/ undefined, [
                value,
                ts.setTextRange(factory.createArrayLiteralExpression(propertyNames), location)
            ]);
        }
        // ES2017 Helpers
        function createAwaiterHelper(hasLexicalThis, hasLexicalArguments, promiseConstructor, body) {
            context.requestEmitHelper(ts.awaiterHelper);
            var generatorFunc = factory.createFunctionExpression(
            /*modifiers*/ undefined, factory.createToken(41 /* SyntaxKind.AsteriskToken */), 
            /*name*/ undefined, 
            /*typeParameters*/ undefined, 
            /*parameters*/ [], 
            /*type*/ undefined, body);
            // Mark this node as originally an async function
            (generatorFunc.emitNode || (generatorFunc.emitNode = {})).flags |= 262144 /* EmitFlags.AsyncFunctionBody */ | 524288 /* EmitFlags.ReuseTempVariableScope */;
            return factory.createCallExpression(getUnscopedHelperName("__awaiter"), 
            /*typeArguments*/ undefined, [
                hasLexicalThis ? factory.createThis() : factory.createVoidZero(),
                hasLexicalArguments ? factory.createIdentifier("arguments") : factory.createVoidZero(),
                promiseConstructor ? ts.createExpressionFromEntityName(factory, promiseConstructor) : factory.createVoidZero(),
                generatorFunc
            ]);
        }
        // ES2015 Helpers
        function createExtendsHelper(name) {
            context.requestEmitHelper(ts.extendsHelper);
            return factory.createCallExpression(getUnscopedHelperName("__extends"), 
            /*typeArguments*/ undefined, [name, factory.createUniqueName("_super", 16 /* GeneratedIdentifierFlags.Optimistic */ | 32 /* GeneratedIdentifierFlags.FileLevel */)]);
        }
        function createTemplateObjectHelper(cooked, raw) {
            context.requestEmitHelper(ts.templateObjectHelper);
            return factory.createCallExpression(getUnscopedHelperName("__makeTemplateObject"), 
            /*typeArguments*/ undefined, [cooked, raw]);
        }
        function createSpreadArrayHelper(to, from, packFrom) {
            context.requestEmitHelper(ts.spreadArrayHelper);
            return factory.createCallExpression(getUnscopedHelperName("__spreadArray"), 
            /*typeArguments*/ undefined, [to, from, packFrom ? immutableTrue() : immutableFalse()]);
        }
        // ES2015 Destructuring Helpers
        function createValuesHelper(expression) {
            context.requestEmitHelper(ts.valuesHelper);
            return factory.createCallExpression(getUnscopedHelperName("__values"), 
            /*typeArguments*/ undefined, [expression]);
        }
        function createReadHelper(iteratorRecord, count) {
            context.requestEmitHelper(ts.readHelper);
            return factory.createCallExpression(getUnscopedHelperName("__read"), 
            /*typeArguments*/ undefined, count !== undefined
                ? [iteratorRecord, factory.createNumericLiteral(count + "")]
                : [iteratorRecord]);
        }
        // ES2015 Generator Helpers
        function createGeneratorHelper(body) {
            context.requestEmitHelper(ts.generatorHelper);
            return factory.createCallExpression(getUnscopedHelperName("__generator"), 
            /*typeArguments*/ undefined, [factory.createThis(), body]);
        }
        // ES Module Helpers
        function createCreateBindingHelper(module, inputName, outputName) {
            context.requestEmitHelper(ts.createBindingHelper);
            return factory.createCallExpression(getUnscopedHelperName("__createBinding"), 
            /*typeArguments*/ undefined, __spreadArray([factory.createIdentifier("exports"), module, inputName], (outputName ? [outputName] : []), true));
        }
        function createImportStarHelper(expression) {
            context.requestEmitHelper(ts.importStarHelper);
            return factory.createCallExpression(getUnscopedHelperName("__importStar"), 
            /*typeArguments*/ undefined, [expression]);
        }
        function createImportStarCallbackHelper() {
            context.requestEmitHelper(ts.importStarHelper);
            return getUnscopedHelperName("__importStar");
        }
        function createImportDefaultHelper(expression) {
            context.requestEmitHelper(ts.importDefaultHelper);
            return factory.createCallExpression(getUnscopedHelperName("__importDefault"), 
            /*typeArguments*/ undefined, [expression]);
        }
        function createExportStarHelper(moduleExpression, exportsExpression) {
            if (exportsExpression === void 0) { exportsExpression = factory.createIdentifier("exports"); }
            context.requestEmitHelper(ts.exportStarHelper);
            context.requestEmitHelper(ts.createBindingHelper);
            return factory.createCallExpression(getUnscopedHelperName("__exportStar"), 
            /*typeArguments*/ undefined, [moduleExpression, exportsExpression]);
        }
        // Class Fields Helpers
        function createClassPrivateFieldGetHelper(receiver, state, kind, f) {
            context.requestEmitHelper(ts.classPrivateFieldGetHelper);
            var args;
            if (!f) {
                args = [receiver, state, factory.createStringLiteral(kind)];
            }
            else {
                args = [receiver, state, factory.createStringLiteral(kind), f];
            }
            return factory.createCallExpression(getUnscopedHelperName("__classPrivateFieldGet"), /*typeArguments*/ undefined, args);
        }
        function createClassPrivateFieldSetHelper(receiver, state, value, kind, f) {
            context.requestEmitHelper(ts.classPrivateFieldSetHelper);
            var args;
            if (!f) {
                args = [receiver, state, value, factory.createStringLiteral(kind)];
            }
            else {
                args = [receiver, state, value, factory.createStringLiteral(kind), f];
            }
            return factory.createCallExpression(getUnscopedHelperName("__classPrivateFieldSet"), /*typeArguments*/ undefined, args);
        }
        function createClassPrivateFieldInHelper(state, receiver) {
            context.requestEmitHelper(ts.classPrivateFieldInHelper);
            return factory.createCallExpression(getUnscopedHelperName("__classPrivateFieldIn"), /* typeArguments*/ undefined, [state, receiver]);
        }
    }
    ts.createEmitHelperFactory = createEmitHelperFactory;
    /* @internal */
    function compareEmitHelpers(x, y) {
        if (x === y)
            return 0 /* Comparison.EqualTo */;
        if (x.priority === y.priority)
            return 0 /* Comparison.EqualTo */;
        if (x.priority === undefined)
            return 1 /* Comparison.GreaterThan */;
        if (y.priority === undefined)
            return -1 /* Comparison.LessThan */;
        return ts.compareValues(x.priority, y.priority);
    }
    ts.compareEmitHelpers = compareEmitHelpers;
    /**
     * @param input Template string input strings
     * @param args Names which need to be made file-level unique
     */
    function helperString(input) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return function (uniqueName) {
            var result = "";
            for (var i = 0; i < args.length; i++) {
                result += input[i];
                result += uniqueName(args[i]);
            }
            result += input[input.length - 1];
            return result;
        };
    }
    ts.helperString = helperString;
    // TypeScript Helpers
    ts.decorateHelper = {
        name: "typescript:decorate",
        importName: "__decorate",
        scoped: false,
        priority: 2,
        text: "\n            var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n                var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n                if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n                else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n                return c > 3 && r && Object.defineProperty(target, key, r), r;\n            };"
    };
    ts.metadataHelper = {
        name: "typescript:metadata",
        importName: "__metadata",
        scoped: false,
        priority: 3,
        text: "\n            var __metadata = (this && this.__metadata) || function (k, v) {\n                if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n            };"
    };
    ts.paramHelper = {
        name: "typescript:param",
        importName: "__param",
        scoped: false,
        priority: 4,
        text: "\n            var __param = (this && this.__param) || function (paramIndex, decorator) {\n                return function (target, key) { decorator(target, key, paramIndex); }\n            };"
    };
    // ES2018 Helpers
    ts.assignHelper = {
        name: "typescript:assign",
        importName: "__assign",
        scoped: false,
        priority: 1,
        text: "\n            var __assign = (this && this.__assign) || function () {\n                __assign = Object.assign || function(t) {\n                    for (var s, i = 1, n = arguments.length; i < n; i++) {\n                        s = arguments[i];\n                        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                            t[p] = s[p];\n                    }\n                    return t;\n                };\n                return __assign.apply(this, arguments);\n            };"
    };
    ts.awaitHelper = {
        name: "typescript:await",
        importName: "__await",
        scoped: false,
        text: "\n            var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }"
    };
    ts.asyncGeneratorHelper = {
        name: "typescript:asyncGenerator",
        importName: "__asyncGenerator",
        scoped: false,
        dependencies: [ts.awaitHelper],
        text: "\n            var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n                if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n                var g = generator.apply(thisArg, _arguments || []), i, q = [];\n                return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\n                function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n                function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n                function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n                function fulfill(value) { resume(\"next\", value); }\n                function reject(value) { resume(\"throw\", value); }\n                function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n            };"
    };
    ts.asyncDelegator = {
        name: "typescript:asyncDelegator",
        importName: "__asyncDelegator",
        scoped: false,
        dependencies: [ts.awaitHelper],
        text: "\n            var __asyncDelegator = (this && this.__asyncDelegator) || function (o) {\n                var i, p;\n                return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n                function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\n            };"
    };
    ts.asyncValues = {
        name: "typescript:asyncValues",
        importName: "__asyncValues",
        scoped: false,
        text: "\n            var __asyncValues = (this && this.__asyncValues) || function (o) {\n                if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n                var m = o[Symbol.asyncIterator], i;\n                return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n                function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n                function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n            };"
    };
    // ES2018 Destructuring Helpers
    ts.restHelper = {
        name: "typescript:rest",
        importName: "__rest",
        scoped: false,
        text: "\n            var __rest = (this && this.__rest) || function (s, e) {\n                var t = {};\n                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n                    t[p] = s[p];\n                if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n                    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n                        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                            t[p[i]] = s[p[i]];\n                    }\n                return t;\n            };"
    };
    // ES2017 Helpers
    ts.awaiterHelper = {
        name: "typescript:awaiter",
        importName: "__awaiter",
        scoped: false,
        priority: 5,
        text: "\n            var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n                function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n                return new (P || (P = Promise))(function (resolve, reject) {\n                    function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n                    function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n                    function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n                    step((generator = generator.apply(thisArg, _arguments || [])).next());\n                });\n            };"
    };
    // ES2015 Helpers
    ts.extendsHelper = {
        name: "typescript:extends",
        importName: "__extends",
        scoped: false,
        priority: 0,
        text: "\n            var __extends = (this && this.__extends) || (function () {\n                var extendStatics = function (d, b) {\n                    extendStatics = Object.setPrototypeOf ||\n                        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n                        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n                    return extendStatics(d, b);\n                };\n\n                return function (d, b) {\n                    if (typeof b !== \"function\" && b !== null)\n                        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n                    extendStatics(d, b);\n                    function __() { this.constructor = d; }\n                    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n                };\n            })();"
    };
    ts.templateObjectHelper = {
        name: "typescript:makeTemplateObject",
        importName: "__makeTemplateObject",
        scoped: false,
        priority: 0,
        text: "\n            var __makeTemplateObject = (this && this.__makeTemplateObject) || function (cooked, raw) {\n                if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n                return cooked;\n            };"
    };
    ts.readHelper = {
        name: "typescript:read",
        importName: "__read",
        scoped: false,
        text: "\n            var __read = (this && this.__read) || function (o, n) {\n                var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n                if (!m) return o;\n                var i = m.call(o), r, ar = [], e;\n                try {\n                    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n                }\n                catch (error) { e = { error: error }; }\n                finally {\n                    try {\n                        if (r && !r.done && (m = i[\"return\"])) m.call(i);\n                    }\n                    finally { if (e) throw e.error; }\n                }\n                return ar;\n            };"
    };
    ts.spreadArrayHelper = {
        name: "typescript:spreadArray",
        importName: "__spreadArray",
        scoped: false,
        text: "\n            var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n                if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n                    if (ar || !(i in from)) {\n                        if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n                        ar[i] = from[i];\n                    }\n                }\n                return to.concat(ar || Array.prototype.slice.call(from));\n            };"
    };
    // ES2015 Destructuring Helpers
    ts.valuesHelper = {
        name: "typescript:values",
        importName: "__values",
        scoped: false,
        text: "\n            var __values = (this && this.__values) || function(o) {\n                var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n                if (m) return m.call(o);\n                if (o && typeof o.length === \"number\") return {\n                    next: function () {\n                        if (o && i >= o.length) o = void 0;\n                        return { value: o && o[i++], done: !o };\n                    }\n                };\n                throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n            };"
    };
    // ES2015 Generator Helpers
    // The __generator helper is used by down-level transformations to emulate the runtime
    // semantics of an ES2015 generator function. When called, this helper returns an
    // object that implements the Iterator protocol, in that it has `next`, `return`, and
    // `throw` methods that step through the generator when invoked.
    //
    // parameters:
    //  @param thisArg  The value to use as the `this` binding for the transformed generator body.
    //  @param body     A function that acts as the transformed generator body.
    //
    // variables:
    //  _       Persistent state for the generator that is shared between the helper and the
    //          generator body. The state object has the following members:
    //            sent() - A method that returns or throws the current completion value.
    //            label  - The next point at which to resume evaluation of the generator body.
    //            trys   - A stack of protected regions (try/catch/finally blocks).
    //            ops    - A stack of pending instructions when inside of a finally block.
    //  f       A value indicating whether the generator is executing.
    //  y       An iterator to delegate for a yield*.
    //  t       A temporary variable that holds one of the following values (note that these
    //          cases do not overlap):
    //          - The completion value when resuming from a `yield` or `yield*`.
    //          - The error value for a catch block.
    //          - The current protected region (array of try/catch/finally/end labels).
    //          - The verb (`next`, `throw`, or `return` method) to delegate to the expression
    //            of a `yield*`.
    //          - The result of evaluating the verb delegated to the expression of a `yield*`.
    //
    // functions:
    //  verb(n)     Creates a bound callback to the `step` function for opcode `n`.
    //  step(op)    Evaluates opcodes in a generator body until execution is suspended or
    //              completed.
    //
    // The __generator helper understands a limited set of instructions:
    //  0: next(value?)     - Start or resume the generator with the specified value.
    //  1: throw(error)     - Resume the generator with an exception. If the generator is
    //                        suspended inside of one or more protected regions, evaluates
    //                        any intervening finally blocks between the current label and
    //                        the nearest catch block or function boundary. If uncaught, the
    //                        exception is thrown to the caller.
    //  2: return(value?)   - Resume the generator as if with a return. If the generator is
    //                        suspended inside of one or more protected regions, evaluates any
    //                        intervening finally blocks.
    //  3: break(label)     - Jump to the specified label. If the label is outside of the
    //                        current protected region, evaluates any intervening finally
    //                        blocks.
    //  4: yield(value?)    - Yield execution to the caller with an optional value. When
    //                        resumed, the generator will continue at the next label.
    //  5: yield*(value)    - Delegates evaluation to the supplied iterator. When
    //                        delegation completes, the generator will continue at the next
    //                        label.
    //  6: catch(error)     - Handles an exception thrown from within the generator body. If
    //                        the current label is inside of one or more protected regions,
    //                        evaluates any intervening finally blocks between the current
    //                        label and the nearest catch block or function boundary. If
    //                        uncaught, the exception is thrown to the caller.
    //  7: endfinally       - Ends a finally block, resuming the last instruction prior to
    //                        entering a finally block.
    //
    // For examples of how these are used, see the comments in ./transformers/generators.ts
    ts.generatorHelper = {
        name: "typescript:generator",
        importName: "__generator",
        scoped: false,
        priority: 6,
        text: "\n            var __generator = (this && this.__generator) || function (thisArg, body) {\n                var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n                return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n                function verb(n) { return function (v) { return step([n, v]); }; }\n                function step(op) {\n                    if (f) throw new TypeError(\"Generator is already executing.\");\n                    while (_) try {\n                        if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n                        if (y = 0, t) op = [op[0] & 2, t.value];\n                        switch (op[0]) {\n                            case 0: case 1: t = op; break;\n                            case 4: _.label++; return { value: op[1], done: false };\n                            case 5: _.label++; y = op[1]; op = [0]; continue;\n                            case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                            default:\n                                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                                if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                                if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                                if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                                if (t[2]) _.ops.pop();\n                                _.trys.pop(); continue;\n                        }\n                        op = body.call(thisArg, _);\n                    } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n                    if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n                }\n            };"
    };
    // ES Module Helpers
    ts.createBindingHelper = {
        name: "typescript:commonjscreatebinding",
        importName: "__createBinding",
        scoped: false,
        priority: 1,
        text: "\n            var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n                if (k2 === undefined) k2 = k;\n                var desc = Object.getOwnPropertyDescriptor(m, k);\n                if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n                  desc = { enumerable: true, get: function() { return m[k]; } };\n                }\n                Object.defineProperty(o, k2, desc);\n            }) : (function(o, m, k, k2) {\n                if (k2 === undefined) k2 = k;\n                o[k2] = m[k];\n            }));"
    };
    ts.setModuleDefaultHelper = {
        name: "typescript:commonjscreatevalue",
        importName: "__setModuleDefault",
        scoped: false,
        priority: 1,
        text: "\n            var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n                Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n            }) : function(o, v) {\n                o[\"default\"] = v;\n            });"
    };
    // emit helper for `import * as Name from "foo"`
    ts.importStarHelper = {
        name: "typescript:commonjsimportstar",
        importName: "__importStar",
        scoped: false,
        dependencies: [ts.createBindingHelper, ts.setModuleDefaultHelper],
        priority: 2,
        text: "\n            var __importStar = (this && this.__importStar) || function (mod) {\n                if (mod && mod.__esModule) return mod;\n                var result = {};\n                if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n                __setModuleDefault(result, mod);\n                return result;\n            };"
    };
    // emit helper for `import Name from "foo"`
    ts.importDefaultHelper = {
        name: "typescript:commonjsimportdefault",
        importName: "__importDefault",
        scoped: false,
        text: "\n            var __importDefault = (this && this.__importDefault) || function (mod) {\n                return (mod && mod.__esModule) ? mod : { \"default\": mod };\n            };"
    };
    ts.exportStarHelper = {
        name: "typescript:export-star",
        importName: "__exportStar",
        scoped: false,
        dependencies: [ts.createBindingHelper],
        priority: 2,
        text: "\n            var __exportStar = (this && this.__exportStar) || function(m, exports) {\n                for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n            };"
    };
    /**
     * Parameters:
     *  @param receiver  The object from which the private member will be read.
     *  @param state  One of the following:
     *      - A WeakMap used to read a private instance field.
     *      - A WeakSet used as an instance brand for private instance methods and accessors.
     *      - A function value that should be the undecorated class constructor used to brand check private static fields, methods, and accessors.
     *  @param kind  (optional pre TS 4.3, required for TS 4.3+) One of the following values:
     *      - undefined  Indicates a private instance field (pre TS 4.3).
     *      - "f"  Indicates a private field (instance or static).
     *      - "m"  Indicates a private method (instance or static).
     *      - "a"  Indicates a private accessor (instance or static).
     *  @param f  (optional pre TS 4.3) Depends on the arguments for state and kind:
     *      - If kind is "m", this should be the function corresponding to the static or instance method.
     *      - If kind is "a", this should be the function corresponding to the getter method, or undefined if the getter was not defined.
     *      - If kind is "f" and state is a function, this should be an object holding the value of a static field, or undefined if the static field declaration has not yet been evaluated.
     * Usage:
     * This helper will only ever be used by the compiler in the following ways:
     *
     * Reading from a private instance field (pre TS 4.3):
     *      __classPrivateFieldGet(<any>, <WeakMap>)
     *
     * Reading from a private instance field (TS 4.3+):
     *      __classPrivateFieldGet(<any>, <WeakMap>, "f")
     *
     * Reading from a private instance get accessor (when defined, TS 4.3+):
     *      __classPrivateFieldGet(<any>, <WeakSet>, "a", <function>)
     *
     * Reading from a private instance get accessor (when not defined, TS 4.3+):
     *      __classPrivateFieldGet(<any>, <WeakSet>, "a", void 0)
     *      NOTE: This always results in a runtime error.
     *
     * Reading from a private instance method (TS 4.3+):
     *      __classPrivateFieldGet(<any>, <WeakSet>, "m", <function>)
     *
     * Reading from a private static field (TS 4.3+):
     *      __classPrivateFieldGet(<any>, <constructor>, "f", <{ value: any }>)
     *
     * Reading from a private static get accessor (when defined, TS 4.3+):
     *      __classPrivateFieldGet(<any>, <constructor>, "a", <function>)
     *
     * Reading from a private static get accessor (when not defined, TS 4.3+):
     *      __classPrivateFieldGet(<any>, <constructor>, "a", void 0)
     *      NOTE: This always results in a runtime error.
     *
     * Reading from a private static method (TS 4.3+):
     *      __classPrivateFieldGet(<any>, <constructor>, "m", <function>)
     */
    ts.classPrivateFieldGetHelper = {
        name: "typescript:classPrivateFieldGet",
        importName: "__classPrivateFieldGet",
        scoped: false,
        text: "\n            var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n                if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n                if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n                return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n            };"
    };
    /**
     * Parameters:
     *  @param receiver  The object on which the private member will be set.
     *  @param state  One of the following:
     *      - A WeakMap used to store a private instance field.
     *      - A WeakSet used as an instance brand for private instance methods and accessors.
     *      - A function value that should be the undecorated class constructor used to brand check private static fields, methods, and accessors.
     *  @param value  The value to set.
     *  @param kind  (optional pre TS 4.3, required for TS 4.3+) One of the following values:
     *       - undefined  Indicates a private instance field (pre TS 4.3).
     *       - "f"  Indicates a private field (instance or static).
     *       - "m"  Indicates a private method (instance or static).
     *       - "a"  Indicates a private accessor (instance or static).
     *   @param f  (optional pre TS 4.3) Depends on the arguments for state and kind:
     *       - If kind is "m", this should be the function corresponding to the static or instance method.
     *       - If kind is "a", this should be the function corresponding to the setter method, or undefined if the setter was not defined.
     *       - If kind is "f" and state is a function, this should be an object holding the value of a static field, or undefined if the static field declaration has not yet been evaluated.
     * Usage:
     * This helper will only ever be used by the compiler in the following ways:
     *
     * Writing to a private instance field (pre TS 4.3):
     *      __classPrivateFieldSet(<any>, <WeakMap>, <any>)
     *
     * Writing to a private instance field (TS 4.3+):
     *      __classPrivateFieldSet(<any>, <WeakMap>, <any>, "f")
     *
     * Writing to a private instance set accessor (when defined, TS 4.3+):
     *      __classPrivateFieldSet(<any>, <WeakSet>, <any>, "a", <function>)
     *
     * Writing to a private instance set accessor (when not defined, TS 4.3+):
     *      __classPrivateFieldSet(<any>, <WeakSet>, <any>, "a", void 0)
     *      NOTE: This always results in a runtime error.
     *
     * Writing to a private instance method (TS 4.3+):
     *      __classPrivateFieldSet(<any>, <WeakSet>, <any>, "m", <function>)
     *      NOTE: This always results in a runtime error.
     *
     * Writing to a private static field (TS 4.3+):
     *      __classPrivateFieldSet(<any>, <constructor>, <any>, "f", <{ value: any }>)
     *
     * Writing to a private static set accessor (when defined, TS 4.3+):
     *      __classPrivateFieldSet(<any>, <constructor>, <any>, "a", <function>)
     *
     * Writing to a private static set accessor (when not defined, TS 4.3+):
     *      __classPrivateFieldSet(<any>, <constructor>, <any>, "a", void 0)
     *      NOTE: This always results in a runtime error.
     *
     * Writing to a private static method (TS 4.3+):
     *      __classPrivateFieldSet(<any>, <constructor>, <any>, "m", <function>)
     *      NOTE: This always results in a runtime error.
     */
    ts.classPrivateFieldSetHelper = {
        name: "typescript:classPrivateFieldSet",
        importName: "__classPrivateFieldSet",
        scoped: false,
        text: "\n            var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n                if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n                if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n                if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n                return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n            };"
    };
    /**
     * Parameters:
     *  @param state  One of the following:
     *      - A WeakMap when the member is a private instance field.
     *      - A WeakSet when the member is a private instance method or accessor.
     *      - A function value that should be the undecorated class constructor when the member is a private static field, method, or accessor.
     *  @param receiver  The object being checked if it has the private member.
     *
     * Usage:
     * This helper is used to transform `#field in expression` to
     *      `__classPrivateFieldIn(<weakMap/weakSet/constructor>, expression)`
     */
    ts.classPrivateFieldInHelper = {
        name: "typescript:classPrivateFieldIn",
        importName: "__classPrivateFieldIn",
        scoped: false,
        text: "\n            var __classPrivateFieldIn = (this && this.__classPrivateFieldIn) || function(state, receiver) {\n                if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n                return typeof state === \"function\" ? receiver === state : state.has(receiver);\n            };"
    };
    var allUnscopedEmitHelpers;
    function getAllUnscopedEmitHelpers() {
        return allUnscopedEmitHelpers || (allUnscopedEmitHelpers = ts.arrayToMap([
            ts.decorateHelper,
            ts.metadataHelper,
            ts.paramHelper,
            ts.assignHelper,
            ts.awaitHelper,
            ts.asyncGeneratorHelper,
            ts.asyncDelegator,
            ts.asyncValues,
            ts.restHelper,
            ts.awaiterHelper,
            ts.extendsHelper,
            ts.templateObjectHelper,
            ts.spreadArrayHelper,
            ts.valuesHelper,
            ts.readHelper,
            ts.generatorHelper,
            ts.importStarHelper,
            ts.importDefaultHelper,
            ts.exportStarHelper,
            ts.classPrivateFieldGetHelper,
            ts.classPrivateFieldSetHelper,
            ts.classPrivateFieldInHelper,
            ts.createBindingHelper,
            ts.setModuleDefaultHelper
        ], function (helper) { return helper.name; }));
    }
    ts.getAllUnscopedEmitHelpers = getAllUnscopedEmitHelpers;
    ts.asyncSuperHelper = {
        name: "typescript:async-super",
        scoped: true,
        text: helperString(__makeTemplateObject(["\n            const ", " = name => super[name];"], ["\n            const ", " = name => super[name];"]), "_superIndex")
    };
    ts.advancedAsyncSuperHelper = {
        name: "typescript:advanced-async-super",
        scoped: true,
        text: helperString(__makeTemplateObject(["\n            const ", " = (function (geti, seti) {\n                const cache = Object.create(null);\n                return name => cache[name] || (cache[name] = { get value() { return geti(name); }, set value(v) { seti(name, v); } });\n            })(name => super[name], (name, value) => super[name] = value);"], ["\n            const ", " = (function (geti, seti) {\n                const cache = Object.create(null);\n                return name => cache[name] || (cache[name] = { get value() { return geti(name); }, set value(v) { seti(name, v); } });\n            })(name => super[name], (name, value) => super[name] = value);"]), "_superIndex")
    };
    function isCallToHelper(firstSegment, helperName) {
        return ts.isCallExpression(firstSegment)
            && ts.isIdentifier(firstSegment.expression)
            && (ts.getEmitFlags(firstSegment.expression) & 4096 /* EmitFlags.HelperName */) !== 0
            && firstSegment.expression.escapedText === helperName;
    }
    ts.isCallToHelper = isCallToHelper;
})(ts || (ts = {}));
var ts;
(function (ts) {
    // Literals
    function isNumericLiteral(node) {
        return node.kind === 8 /* SyntaxKind.NumericLiteral */;
    }
    ts.isNumericLiteral = isNumericLiteral;
    function isBigIntLiteral(node) {
        return node.kind === 9 /* SyntaxKind.BigIntLiteral */;
    }
    ts.isBigIntLiteral = isBigIntLiteral;
    function isStringLiteral(node) {
        return node.kind === 10 /* SyntaxKind.StringLiteral */;
    }
    ts.isStringLiteral = isStringLiteral;
    function isJsxText(node) {
        return node.kind === 11 /* SyntaxKind.JsxText */;
    }
    ts.isJsxText = isJsxText;
    function isRegularExpressionLiteral(node) {
        return node.kind === 13 /* SyntaxKind.RegularExpressionLiteral */;
    }
    ts.isRegularExpressionLiteral = isRegularExpressionLiteral;
    function isNoSubstitutionTemplateLiteral(node) {
        return node.kind === 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */;
    }
    ts.isNoSubstitutionTemplateLiteral = isNoSubstitutionTemplateLiteral;
    // Pseudo-literals
    function isTemplateHead(node) {
        return node.kind === 15 /* SyntaxKind.TemplateHead */;
    }
    ts.isTemplateHead = isTemplateHead;
    function isTemplateMiddle(node) {
        return node.kind === 16 /* SyntaxKind.TemplateMiddle */;
    }
    ts.isTemplateMiddle = isTemplateMiddle;
    function isTemplateTail(node) {
        return node.kind === 17 /* SyntaxKind.TemplateTail */;
    }
    ts.isTemplateTail = isTemplateTail;
    // Punctuation
    function isDotDotDotToken(node) {
        return node.kind === 25 /* SyntaxKind.DotDotDotToken */;
    }
    ts.isDotDotDotToken = isDotDotDotToken;
    /*@internal*/
    function isCommaToken(node) {
        return node.kind === 27 /* SyntaxKind.CommaToken */;
    }
    ts.isCommaToken = isCommaToken;
    function isPlusToken(node) {
        return node.kind === 39 /* SyntaxKind.PlusToken */;
    }
    ts.isPlusToken = isPlusToken;
    function isMinusToken(node) {
        return node.kind === 40 /* SyntaxKind.MinusToken */;
    }
    ts.isMinusToken = isMinusToken;
    function isAsteriskToken(node) {
        return node.kind === 41 /* SyntaxKind.AsteriskToken */;
    }
    ts.isAsteriskToken = isAsteriskToken;
    /*@internal*/
    function isExclamationToken(node) {
        return node.kind === 53 /* SyntaxKind.ExclamationToken */;
    }
    ts.isExclamationToken = isExclamationToken;
    /*@internal*/
    function isQuestionToken(node) {
        return node.kind === 57 /* SyntaxKind.QuestionToken */;
    }
    ts.isQuestionToken = isQuestionToken;
    /*@internal*/
    function isColonToken(node) {
        return node.kind === 58 /* SyntaxKind.ColonToken */;
    }
    ts.isColonToken = isColonToken;
    /*@internal*/
    function isQuestionDotToken(node) {
        return node.kind === 28 /* SyntaxKind.QuestionDotToken */;
    }
    ts.isQuestionDotToken = isQuestionDotToken;
    /*@internal*/
    function isEqualsGreaterThanToken(node) {
        return node.kind === 38 /* SyntaxKind.EqualsGreaterThanToken */;
    }
    ts.isEqualsGreaterThanToken = isEqualsGreaterThanToken;
    // Identifiers
    function isIdentifier(node) {
        return node.kind === 79 /* SyntaxKind.Identifier */;
    }
    ts.isIdentifier = isIdentifier;
    function isPrivateIdentifier(node) {
        return node.kind === 80 /* SyntaxKind.PrivateIdentifier */;
    }
    ts.isPrivateIdentifier = isPrivateIdentifier;
    // Reserved Words
    /* @internal */
    function isExportModifier(node) {
        return node.kind === 93 /* SyntaxKind.ExportKeyword */;
    }
    ts.isExportModifier = isExportModifier;
    /* @internal */
    function isAsyncModifier(node) {
        return node.kind === 131 /* SyntaxKind.AsyncKeyword */;
    }
    ts.isAsyncModifier = isAsyncModifier;
    /* @internal */
    function isAssertsKeyword(node) {
        return node.kind === 128 /* SyntaxKind.AssertsKeyword */;
    }
    ts.isAssertsKeyword = isAssertsKeyword;
    /* @internal */
    function isAwaitKeyword(node) {
        return node.kind === 132 /* SyntaxKind.AwaitKeyword */;
    }
    ts.isAwaitKeyword = isAwaitKeyword;
    /* @internal */
    function isReadonlyKeyword(node) {
        return node.kind === 145 /* SyntaxKind.ReadonlyKeyword */;
    }
    ts.isReadonlyKeyword = isReadonlyKeyword;
    /* @internal */
    function isStaticModifier(node) {
        return node.kind === 124 /* SyntaxKind.StaticKeyword */;
    }
    ts.isStaticModifier = isStaticModifier;
    /* @internal */
    function isAbstractModifier(node) {
        return node.kind === 126 /* SyntaxKind.AbstractKeyword */;
    }
    ts.isAbstractModifier = isAbstractModifier;
    /* @internal */
    function isOverrideModifier(node) {
        return node.kind === 159 /* SyntaxKind.OverrideKeyword */;
    }
    ts.isOverrideModifier = isOverrideModifier;
    /*@internal*/
    function isSuperKeyword(node) {
        return node.kind === 106 /* SyntaxKind.SuperKeyword */;
    }
    ts.isSuperKeyword = isSuperKeyword;
    /*@internal*/
    function isImportKeyword(node) {
        return node.kind === 100 /* SyntaxKind.ImportKeyword */;
    }
    ts.isImportKeyword = isImportKeyword;
    // Names
    function isQualifiedName(node) {
        return node.kind === 161 /* SyntaxKind.QualifiedName */;
    }
    ts.isQualifiedName = isQualifiedName;
    function isComputedPropertyName(node) {
        return node.kind === 162 /* SyntaxKind.ComputedPropertyName */;
    }
    ts.isComputedPropertyName = isComputedPropertyName;
    // Signature elements
    function isTypeParameterDeclaration(node) {
        return node.kind === 163 /* SyntaxKind.TypeParameter */;
    }
    ts.isTypeParameterDeclaration = isTypeParameterDeclaration;
    // TODO(rbuckton): Rename to 'isParameterDeclaration'
    function isParameter(node) {
        return node.kind === 164 /* SyntaxKind.Parameter */;
    }
    ts.isParameter = isParameter;
    function isDecorator(node) {
        return node.kind === 165 /* SyntaxKind.Decorator */;
    }
    ts.isDecorator = isDecorator;
    // TypeMember
    function isPropertySignature(node) {
        return node.kind === 166 /* SyntaxKind.PropertySignature */;
    }
    ts.isPropertySignature = isPropertySignature;
    function isPropertyDeclaration(node) {
        return node.kind === 167 /* SyntaxKind.PropertyDeclaration */;
    }
    ts.isPropertyDeclaration = isPropertyDeclaration;
    function isMethodSignature(node) {
        return node.kind === 168 /* SyntaxKind.MethodSignature */;
    }
    ts.isMethodSignature = isMethodSignature;
    function isMethodDeclaration(node) {
        return node.kind === 169 /* SyntaxKind.MethodDeclaration */;
    }
    ts.isMethodDeclaration = isMethodDeclaration;
    function isClassStaticBlockDeclaration(node) {
        return node.kind === 170 /* SyntaxKind.ClassStaticBlockDeclaration */;
    }
    ts.isClassStaticBlockDeclaration = isClassStaticBlockDeclaration;
    function isConstructorDeclaration(node) {
        return node.kind === 171 /* SyntaxKind.Constructor */;
    }
    ts.isConstructorDeclaration = isConstructorDeclaration;
    function isGetAccessorDeclaration(node) {
        return node.kind === 172 /* SyntaxKind.GetAccessor */;
    }
    ts.isGetAccessorDeclaration = isGetAccessorDeclaration;
    function isSetAccessorDeclaration(node) {
        return node.kind === 173 /* SyntaxKind.SetAccessor */;
    }
    ts.isSetAccessorDeclaration = isSetAccessorDeclaration;
    function isCallSignatureDeclaration(node) {
        return node.kind === 174 /* SyntaxKind.CallSignature */;
    }
    ts.isCallSignatureDeclaration = isCallSignatureDeclaration;
    function isConstructSignatureDeclaration(node) {
        return node.kind === 175 /* SyntaxKind.ConstructSignature */;
    }
    ts.isConstructSignatureDeclaration = isConstructSignatureDeclaration;
    function isIndexSignatureDeclaration(node) {
        return node.kind === 176 /* SyntaxKind.IndexSignature */;
    }
    ts.isIndexSignatureDeclaration = isIndexSignatureDeclaration;
    // Type
    function isTypePredicateNode(node) {
        return node.kind === 177 /* SyntaxKind.TypePredicate */;
    }
    ts.isTypePredicateNode = isTypePredicateNode;
    function isTypeReferenceNode(node) {
        return node.kind === 178 /* SyntaxKind.TypeReference */;
    }
    ts.isTypeReferenceNode = isTypeReferenceNode;
    function isFunctionTypeNode(node) {
        return node.kind === 179 /* SyntaxKind.FunctionType */;
    }
    ts.isFunctionTypeNode = isFunctionTypeNode;
    function isConstructorTypeNode(node) {
        return node.kind === 180 /* SyntaxKind.ConstructorType */;
    }
    ts.isConstructorTypeNode = isConstructorTypeNode;
    function isTypeQueryNode(node) {
        return node.kind === 181 /* SyntaxKind.TypeQuery */;
    }
    ts.isTypeQueryNode = isTypeQueryNode;
    function isTypeLiteralNode(node) {
        return node.kind === 182 /* SyntaxKind.TypeLiteral */;
    }
    ts.isTypeLiteralNode = isTypeLiteralNode;
    function isArrayTypeNode(node) {
        return node.kind === 183 /* SyntaxKind.ArrayType */;
    }
    ts.isArrayTypeNode = isArrayTypeNode;
    function isTupleTypeNode(node) {
        return node.kind === 184 /* SyntaxKind.TupleType */;
    }
    ts.isTupleTypeNode = isTupleTypeNode;
    function isNamedTupleMember(node) {
        return node.kind === 197 /* SyntaxKind.NamedTupleMember */;
    }
    ts.isNamedTupleMember = isNamedTupleMember;
    function isOptionalTypeNode(node) {
        return node.kind === 185 /* SyntaxKind.OptionalType */;
    }
    ts.isOptionalTypeNode = isOptionalTypeNode;
    function isRestTypeNode(node) {
        return node.kind === 186 /* SyntaxKind.RestType */;
    }
    ts.isRestTypeNode = isRestTypeNode;
    function isUnionTypeNode(node) {
        return node.kind === 187 /* SyntaxKind.UnionType */;
    }
    ts.isUnionTypeNode = isUnionTypeNode;
    function isIntersectionTypeNode(node) {
        return node.kind === 188 /* SyntaxKind.IntersectionType */;
    }
    ts.isIntersectionTypeNode = isIntersectionTypeNode;
    function isConditionalTypeNode(node) {
        return node.kind === 189 /* SyntaxKind.ConditionalType */;
    }
    ts.isConditionalTypeNode = isConditionalTypeNode;
    function isInferTypeNode(node) {
        return node.kind === 190 /* SyntaxKind.InferType */;
    }
    ts.isInferTypeNode = isInferTypeNode;
    function isParenthesizedTypeNode(node) {
        return node.kind === 191 /* SyntaxKind.ParenthesizedType */;
    }
    ts.isParenthesizedTypeNode = isParenthesizedTypeNode;
    function isThisTypeNode(node) {
        return node.kind === 192 /* SyntaxKind.ThisType */;
    }
    ts.isThisTypeNode = isThisTypeNode;
    function isTypeOperatorNode(node) {
        return node.kind === 193 /* SyntaxKind.TypeOperator */;
    }
    ts.isTypeOperatorNode = isTypeOperatorNode;
    function isIndexedAccessTypeNode(node) {
        return node.kind === 194 /* SyntaxKind.IndexedAccessType */;
    }
    ts.isIndexedAccessTypeNode = isIndexedAccessTypeNode;
    function isMappedTypeNode(node) {
        return node.kind === 195 /* SyntaxKind.MappedType */;
    }
    ts.isMappedTypeNode = isMappedTypeNode;
    function isLiteralTypeNode(node) {
        return node.kind === 196 /* SyntaxKind.LiteralType */;
    }
    ts.isLiteralTypeNode = isLiteralTypeNode;
    function isImportTypeNode(node) {
        return node.kind === 200 /* SyntaxKind.ImportType */;
    }
    ts.isImportTypeNode = isImportTypeNode;
    function isTemplateLiteralTypeSpan(node) {
        return node.kind === 199 /* SyntaxKind.TemplateLiteralTypeSpan */;
    }
    ts.isTemplateLiteralTypeSpan = isTemplateLiteralTypeSpan;
    function isTemplateLiteralTypeNode(node) {
        return node.kind === 198 /* SyntaxKind.TemplateLiteralType */;
    }
    ts.isTemplateLiteralTypeNode = isTemplateLiteralTypeNode;
    // Binding patterns
    function isObjectBindingPattern(node) {
        return node.kind === 201 /* SyntaxKind.ObjectBindingPattern */;
    }
    ts.isObjectBindingPattern = isObjectBindingPattern;
    function isArrayBindingPattern(node) {
        return node.kind === 202 /* SyntaxKind.ArrayBindingPattern */;
    }
    ts.isArrayBindingPattern = isArrayBindingPattern;
    function isBindingElement(node) {
        return node.kind === 203 /* SyntaxKind.BindingElement */;
    }
    ts.isBindingElement = isBindingElement;
    // Expression
    function isArrayLiteralExpression(node) {
        return node.kind === 204 /* SyntaxKind.ArrayLiteralExpression */;
    }
    ts.isArrayLiteralExpression = isArrayLiteralExpression;
    function isObjectLiteralExpression(node) {
        return node.kind === 205 /* SyntaxKind.ObjectLiteralExpression */;
    }
    ts.isObjectLiteralExpression = isObjectLiteralExpression;
    function isPropertyAccessExpression(node) {
        return node.kind === 206 /* SyntaxKind.PropertyAccessExpression */;
    }
    ts.isPropertyAccessExpression = isPropertyAccessExpression;
    function isElementAccessExpression(node) {
        return node.kind === 207 /* SyntaxKind.ElementAccessExpression */;
    }
    ts.isElementAccessExpression = isElementAccessExpression;
    function isCallExpression(node) {
        return node.kind === 208 /* SyntaxKind.CallExpression */;
    }
    ts.isCallExpression = isCallExpression;
    function isNewExpression(node) {
        return node.kind === 209 /* SyntaxKind.NewExpression */;
    }
    ts.isNewExpression = isNewExpression;
    function isTaggedTemplateExpression(node) {
        return node.kind === 210 /* SyntaxKind.TaggedTemplateExpression */;
    }
    ts.isTaggedTemplateExpression = isTaggedTemplateExpression;
    function isTypeAssertionExpression(node) {
        return node.kind === 211 /* SyntaxKind.TypeAssertionExpression */;
    }
    ts.isTypeAssertionExpression = isTypeAssertionExpression;
    function isParenthesizedExpression(node) {
        return node.kind === 212 /* SyntaxKind.ParenthesizedExpression */;
    }
    ts.isParenthesizedExpression = isParenthesizedExpression;
    function isFunctionExpression(node) {
        return node.kind === 213 /* SyntaxKind.FunctionExpression */;
    }
    ts.isFunctionExpression = isFunctionExpression;
    function isArrowFunction(node) {
        return node.kind === 214 /* SyntaxKind.ArrowFunction */;
    }
    ts.isArrowFunction = isArrowFunction;
    function isDeleteExpression(node) {
        return node.kind === 215 /* SyntaxKind.DeleteExpression */;
    }
    ts.isDeleteExpression = isDeleteExpression;
    function isTypeOfExpression(node) {
        return node.kind === 216 /* SyntaxKind.TypeOfExpression */;
    }
    ts.isTypeOfExpression = isTypeOfExpression;
    function isVoidExpression(node) {
        return node.kind === 217 /* SyntaxKind.VoidExpression */;
    }
    ts.isVoidExpression = isVoidExpression;
    function isAwaitExpression(node) {
        return node.kind === 218 /* SyntaxKind.AwaitExpression */;
    }
    ts.isAwaitExpression = isAwaitExpression;
    function isPrefixUnaryExpression(node) {
        return node.kind === 219 /* SyntaxKind.PrefixUnaryExpression */;
    }
    ts.isPrefixUnaryExpression = isPrefixUnaryExpression;
    function isPostfixUnaryExpression(node) {
        return node.kind === 220 /* SyntaxKind.PostfixUnaryExpression */;
    }
    ts.isPostfixUnaryExpression = isPostfixUnaryExpression;
    function isBinaryExpression(node) {
        return node.kind === 221 /* SyntaxKind.BinaryExpression */;
    }
    ts.isBinaryExpression = isBinaryExpression;
    function isConditionalExpression(node) {
        return node.kind === 222 /* SyntaxKind.ConditionalExpression */;
    }
    ts.isConditionalExpression = isConditionalExpression;
    function isTemplateExpression(node) {
        return node.kind === 223 /* SyntaxKind.TemplateExpression */;
    }
    ts.isTemplateExpression = isTemplateExpression;
    function isYieldExpression(node) {
        return node.kind === 224 /* SyntaxKind.YieldExpression */;
    }
    ts.isYieldExpression = isYieldExpression;
    function isSpreadElement(node) {
        return node.kind === 225 /* SyntaxKind.SpreadElement */;
    }
    ts.isSpreadElement = isSpreadElement;
    function isClassExpression(node) {
        return node.kind === 226 /* SyntaxKind.ClassExpression */;
    }
    ts.isClassExpression = isClassExpression;
    function isOmittedExpression(node) {
        return node.kind === 227 /* SyntaxKind.OmittedExpression */;
    }
    ts.isOmittedExpression = isOmittedExpression;
    function isExpressionWithTypeArguments(node) {
        return node.kind === 228 /* SyntaxKind.ExpressionWithTypeArguments */;
    }
    ts.isExpressionWithTypeArguments = isExpressionWithTypeArguments;
    function isAsExpression(node) {
        return node.kind === 229 /* SyntaxKind.AsExpression */;
    }
    ts.isAsExpression = isAsExpression;
    function isNonNullExpression(node) {
        return node.kind === 230 /* SyntaxKind.NonNullExpression */;
    }
    ts.isNonNullExpression = isNonNullExpression;
    function isMetaProperty(node) {
        return node.kind === 231 /* SyntaxKind.MetaProperty */;
    }
    ts.isMetaProperty = isMetaProperty;
    function isSyntheticExpression(node) {
        return node.kind === 232 /* SyntaxKind.SyntheticExpression */;
    }
    ts.isSyntheticExpression = isSyntheticExpression;
    function isPartiallyEmittedExpression(node) {
        return node.kind === 350 /* SyntaxKind.PartiallyEmittedExpression */;
    }
    ts.isPartiallyEmittedExpression = isPartiallyEmittedExpression;
    function isCommaListExpression(node) {
        return node.kind === 351 /* SyntaxKind.CommaListExpression */;
    }
    ts.isCommaListExpression = isCommaListExpression;
    // Misc
    function isTemplateSpan(node) {
        return node.kind === 233 /* SyntaxKind.TemplateSpan */;
    }
    ts.isTemplateSpan = isTemplateSpan;
    function isSemicolonClassElement(node) {
        return node.kind === 234 /* SyntaxKind.SemicolonClassElement */;
    }
    ts.isSemicolonClassElement = isSemicolonClassElement;
    // Elements
    function isBlock(node) {
        return node.kind === 235 /* SyntaxKind.Block */;
    }
    ts.isBlock = isBlock;
    function isVariableStatement(node) {
        return node.kind === 237 /* SyntaxKind.VariableStatement */;
    }
    ts.isVariableStatement = isVariableStatement;
    function isEmptyStatement(node) {
        return node.kind === 236 /* SyntaxKind.EmptyStatement */;
    }
    ts.isEmptyStatement = isEmptyStatement;
    function isExpressionStatement(node) {
        return node.kind === 238 /* SyntaxKind.ExpressionStatement */;
    }
    ts.isExpressionStatement = isExpressionStatement;
    function isIfStatement(node) {
        return node.kind === 239 /* SyntaxKind.IfStatement */;
    }
    ts.isIfStatement = isIfStatement;
    function isDoStatement(node) {
        return node.kind === 240 /* SyntaxKind.DoStatement */;
    }
    ts.isDoStatement = isDoStatement;
    function isWhileStatement(node) {
        return node.kind === 241 /* SyntaxKind.WhileStatement */;
    }
    ts.isWhileStatement = isWhileStatement;
    function isForStatement(node) {
        return node.kind === 242 /* SyntaxKind.ForStatement */;
    }
    ts.isForStatement = isForStatement;
    function isForInStatement(node) {
        return node.kind === 243 /* SyntaxKind.ForInStatement */;
    }
    ts.isForInStatement = isForInStatement;
    function isForOfStatement(node) {
        return node.kind === 244 /* SyntaxKind.ForOfStatement */;
    }
    ts.isForOfStatement = isForOfStatement;
    function isContinueStatement(node) {
        return node.kind === 245 /* SyntaxKind.ContinueStatement */;
    }
    ts.isContinueStatement = isContinueStatement;
    function isBreakStatement(node) {
        return node.kind === 246 /* SyntaxKind.BreakStatement */;
    }
    ts.isBreakStatement = isBreakStatement;
    function isReturnStatement(node) {
        return node.kind === 247 /* SyntaxKind.ReturnStatement */;
    }
    ts.isReturnStatement = isReturnStatement;
    function isWithStatement(node) {
        return node.kind === 248 /* SyntaxKind.WithStatement */;
    }
    ts.isWithStatement = isWithStatement;
    function isSwitchStatement(node) {
        return node.kind === 249 /* SyntaxKind.SwitchStatement */;
    }
    ts.isSwitchStatement = isSwitchStatement;
    function isLabeledStatement(node) {
        return node.kind === 250 /* SyntaxKind.LabeledStatement */;
    }
    ts.isLabeledStatement = isLabeledStatement;
    function isThrowStatement(node) {
        return node.kind === 251 /* SyntaxKind.ThrowStatement */;
    }
    ts.isThrowStatement = isThrowStatement;
    function isTryStatement(node) {
        return node.kind === 252 /* SyntaxKind.TryStatement */;
    }
    ts.isTryStatement = isTryStatement;
    function isDebuggerStatement(node) {
        return node.kind === 253 /* SyntaxKind.DebuggerStatement */;
    }
    ts.isDebuggerStatement = isDebuggerStatement;
    function isVariableDeclaration(node) {
        return node.kind === 254 /* SyntaxKind.VariableDeclaration */;
    }
    ts.isVariableDeclaration = isVariableDeclaration;
    function isVariableDeclarationList(node) {
        return node.kind === 255 /* SyntaxKind.VariableDeclarationList */;
    }
    ts.isVariableDeclarationList = isVariableDeclarationList;
    function isFunctionDeclaration(node) {
        return node.kind === 256 /* SyntaxKind.FunctionDeclaration */;
    }
    ts.isFunctionDeclaration = isFunctionDeclaration;
    function isClassDeclaration(node) {
        return node.kind === 257 /* SyntaxKind.ClassDeclaration */;
    }
    ts.isClassDeclaration = isClassDeclaration;
    function isInterfaceDeclaration(node) {
        return node.kind === 258 /* SyntaxKind.InterfaceDeclaration */;
    }
    ts.isInterfaceDeclaration = isInterfaceDeclaration;
    function isTypeAliasDeclaration(node) {
        return node.kind === 259 /* SyntaxKind.TypeAliasDeclaration */;
    }
    ts.isTypeAliasDeclaration = isTypeAliasDeclaration;
    function isEnumDeclaration(node) {
        return node.kind === 260 /* SyntaxKind.EnumDeclaration */;
    }
    ts.isEnumDeclaration = isEnumDeclaration;
    function isModuleDeclaration(node) {
        return node.kind === 261 /* SyntaxKind.ModuleDeclaration */;
    }
    ts.isModuleDeclaration = isModuleDeclaration;
    function isModuleBlock(node) {
        return node.kind === 262 /* SyntaxKind.ModuleBlock */;
    }
    ts.isModuleBlock = isModuleBlock;
    function isCaseBlock(node) {
        return node.kind === 263 /* SyntaxKind.CaseBlock */;
    }
    ts.isCaseBlock = isCaseBlock;
    function isNamespaceExportDeclaration(node) {
        return node.kind === 264 /* SyntaxKind.NamespaceExportDeclaration */;
    }
    ts.isNamespaceExportDeclaration = isNamespaceExportDeclaration;
    function isImportEqualsDeclaration(node) {
        return node.kind === 265 /* SyntaxKind.ImportEqualsDeclaration */;
    }
    ts.isImportEqualsDeclaration = isImportEqualsDeclaration;
    function isImportDeclaration(node) {
        return node.kind === 266 /* SyntaxKind.ImportDeclaration */;
    }
    ts.isImportDeclaration = isImportDeclaration;
    function isImportClause(node) {
        return node.kind === 267 /* SyntaxKind.ImportClause */;
    }
    ts.isImportClause = isImportClause;
    function isImportTypeAssertionContainer(node) {
        return node.kind === 295 /* SyntaxKind.ImportTypeAssertionContainer */;
    }
    ts.isImportTypeAssertionContainer = isImportTypeAssertionContainer;
    function isAssertClause(node) {
        return node.kind === 293 /* SyntaxKind.AssertClause */;
    }
    ts.isAssertClause = isAssertClause;
    function isAssertEntry(node) {
        return node.kind === 294 /* SyntaxKind.AssertEntry */;
    }
    ts.isAssertEntry = isAssertEntry;
    function isNamespaceImport(node) {
        return node.kind === 268 /* SyntaxKind.NamespaceImport */;
    }
    ts.isNamespaceImport = isNamespaceImport;
    function isNamespaceExport(node) {
        return node.kind === 274 /* SyntaxKind.NamespaceExport */;
    }
    ts.isNamespaceExport = isNamespaceExport;
    function isNamedImports(node) {
        return node.kind === 269 /* SyntaxKind.NamedImports */;
    }
    ts.isNamedImports = isNamedImports;
    function isImportSpecifier(node) {
        return node.kind === 270 /* SyntaxKind.ImportSpecifier */;
    }
    ts.isImportSpecifier = isImportSpecifier;
    function isExportAssignment(node) {
        return node.kind === 271 /* SyntaxKind.ExportAssignment */;
    }
    ts.isExportAssignment = isExportAssignment;
    function isExportDeclaration(node) {
        return node.kind === 272 /* SyntaxKind.ExportDeclaration */;
    }
    ts.isExportDeclaration = isExportDeclaration;
    function isNamedExports(node) {
        return node.kind === 273 /* SyntaxKind.NamedExports */;
    }
    ts.isNamedExports = isNamedExports;
    function isExportSpecifier(node) {
        return node.kind === 275 /* SyntaxKind.ExportSpecifier */;
    }
    ts.isExportSpecifier = isExportSpecifier;
    function isMissingDeclaration(node) {
        return node.kind === 276 /* SyntaxKind.MissingDeclaration */;
    }
    ts.isMissingDeclaration = isMissingDeclaration;
    function isNotEmittedStatement(node) {
        return node.kind === 349 /* SyntaxKind.NotEmittedStatement */;
    }
    ts.isNotEmittedStatement = isNotEmittedStatement;
    /* @internal */
    function isSyntheticReference(node) {
        return node.kind === 354 /* SyntaxKind.SyntheticReferenceExpression */;
    }
    ts.isSyntheticReference = isSyntheticReference;
    /* @internal */
    function isMergeDeclarationMarker(node) {
        return node.kind === 352 /* SyntaxKind.MergeDeclarationMarker */;
    }
    ts.isMergeDeclarationMarker = isMergeDeclarationMarker;
    /* @internal */
    function isEndOfDeclarationMarker(node) {
        return node.kind === 353 /* SyntaxKind.EndOfDeclarationMarker */;
    }
    ts.isEndOfDeclarationMarker = isEndOfDeclarationMarker;
    // Module References
    function isExternalModuleReference(node) {
        return node.kind === 277 /* SyntaxKind.ExternalModuleReference */;
    }
    ts.isExternalModuleReference = isExternalModuleReference;
    // JSX
    function isJsxElement(node) {
        return node.kind === 278 /* SyntaxKind.JsxElement */;
    }
    ts.isJsxElement = isJsxElement;
    function isJsxSelfClosingElement(node) {
        return node.kind === 279 /* SyntaxKind.JsxSelfClosingElement */;
    }
    ts.isJsxSelfClosingElement = isJsxSelfClosingElement;
    function isJsxOpeningElement(node) {
        return node.kind === 280 /* SyntaxKind.JsxOpeningElement */;
    }
    ts.isJsxOpeningElement = isJsxOpeningElement;
    function isJsxClosingElement(node) {
        return node.kind === 281 /* SyntaxKind.JsxClosingElement */;
    }
    ts.isJsxClosingElement = isJsxClosingElement;
    function isJsxFragment(node) {
        return node.kind === 282 /* SyntaxKind.JsxFragment */;
    }
    ts.isJsxFragment = isJsxFragment;
    function isJsxOpeningFragment(node) {
        return node.kind === 283 /* SyntaxKind.JsxOpeningFragment */;
    }
    ts.isJsxOpeningFragment = isJsxOpeningFragment;
    function isJsxClosingFragment(node) {
        return node.kind === 284 /* SyntaxKind.JsxClosingFragment */;
    }
    ts.isJsxClosingFragment = isJsxClosingFragment;
    function isJsxAttribute(node) {
        return node.kind === 285 /* SyntaxKind.JsxAttribute */;
    }
    ts.isJsxAttribute = isJsxAttribute;
    function isJsxAttributes(node) {
        return node.kind === 286 /* SyntaxKind.JsxAttributes */;
    }
    ts.isJsxAttributes = isJsxAttributes;
    function isJsxSpreadAttribute(node) {
        return node.kind === 287 /* SyntaxKind.JsxSpreadAttribute */;
    }
    ts.isJsxSpreadAttribute = isJsxSpreadAttribute;
    function isJsxExpression(node) {
        return node.kind === 288 /* SyntaxKind.JsxExpression */;
    }
    ts.isJsxExpression = isJsxExpression;
    // Clauses
    function isCaseClause(node) {
        return node.kind === 289 /* SyntaxKind.CaseClause */;
    }
    ts.isCaseClause = isCaseClause;
    function isDefaultClause(node) {
        return node.kind === 290 /* SyntaxKind.DefaultClause */;
    }
    ts.isDefaultClause = isDefaultClause;
    function isHeritageClause(node) {
        return node.kind === 291 /* SyntaxKind.HeritageClause */;
    }
    ts.isHeritageClause = isHeritageClause;
    function isCatchClause(node) {
        return node.kind === 292 /* SyntaxKind.CatchClause */;
    }
    ts.isCatchClause = isCatchClause;
    // Property assignments
    function isPropertyAssignment(node) {
        return node.kind === 296 /* SyntaxKind.PropertyAssignment */;
    }
    ts.isPropertyAssignment = isPropertyAssignment;
    function isShorthandPropertyAssignment(node) {
        return node.kind === 297 /* SyntaxKind.ShorthandPropertyAssignment */;
    }
    ts.isShorthandPropertyAssignment = isShorthandPropertyAssignment;
    function isSpreadAssignment(node) {
        return node.kind === 298 /* SyntaxKind.SpreadAssignment */;
    }
    ts.isSpreadAssignment = isSpreadAssignment;
    // Enum
    function isEnumMember(node) {
        return node.kind === 299 /* SyntaxKind.EnumMember */;
    }
    ts.isEnumMember = isEnumMember;
    // Unparsed
    // TODO(rbuckton): isUnparsedPrologue
    function isUnparsedPrepend(node) {
        return node.kind === 301 /* SyntaxKind.UnparsedPrepend */;
    }
    ts.isUnparsedPrepend = isUnparsedPrepend;
    // TODO(rbuckton): isUnparsedText
    // TODO(rbuckton): isUnparsedInternalText
    // TODO(rbuckton): isUnparsedSyntheticReference
    // Top-level nodes
    function isSourceFile(node) {
        return node.kind === 305 /* SyntaxKind.SourceFile */;
    }
    ts.isSourceFile = isSourceFile;
    function isBundle(node) {
        return node.kind === 306 /* SyntaxKind.Bundle */;
    }
    ts.isBundle = isBundle;
    function isUnparsedSource(node) {
        return node.kind === 307 /* SyntaxKind.UnparsedSource */;
    }
    ts.isUnparsedSource = isUnparsedSource;
    // TODO(rbuckton): isInputFiles
    // JSDoc Elements
    function isJSDocTypeExpression(node) {
        return node.kind === 309 /* SyntaxKind.JSDocTypeExpression */;
    }
    ts.isJSDocTypeExpression = isJSDocTypeExpression;
    function isJSDocNameReference(node) {
        return node.kind === 310 /* SyntaxKind.JSDocNameReference */;
    }
    ts.isJSDocNameReference = isJSDocNameReference;
    function isJSDocMemberName(node) {
        return node.kind === 311 /* SyntaxKind.JSDocMemberName */;
    }
    ts.isJSDocMemberName = isJSDocMemberName;
    function isJSDocLink(node) {
        return node.kind === 324 /* SyntaxKind.JSDocLink */;
    }
    ts.isJSDocLink = isJSDocLink;
    function isJSDocLinkCode(node) {
        return node.kind === 325 /* SyntaxKind.JSDocLinkCode */;
    }
    ts.isJSDocLinkCode = isJSDocLinkCode;
    function isJSDocLinkPlain(node) {
        return node.kind === 326 /* SyntaxKind.JSDocLinkPlain */;
    }
    ts.isJSDocLinkPlain = isJSDocLinkPlain;
    function isJSDocAllType(node) {
        return node.kind === 312 /* SyntaxKind.JSDocAllType */;
    }
    ts.isJSDocAllType = isJSDocAllType;
    function isJSDocUnknownType(node) {
        return node.kind === 313 /* SyntaxKind.JSDocUnknownType */;
    }
    ts.isJSDocUnknownType = isJSDocUnknownType;
    function isJSDocNullableType(node) {
        return node.kind === 314 /* SyntaxKind.JSDocNullableType */;
    }
    ts.isJSDocNullableType = isJSDocNullableType;
    function isJSDocNonNullableType(node) {
        return node.kind === 315 /* SyntaxKind.JSDocNonNullableType */;
    }
    ts.isJSDocNonNullableType = isJSDocNonNullableType;
    function isJSDocOptionalType(node) {
        return node.kind === 316 /* SyntaxKind.JSDocOptionalType */;
    }
    ts.isJSDocOptionalType = isJSDocOptionalType;
    function isJSDocFunctionType(node) {
        return node.kind === 317 /* SyntaxKind.JSDocFunctionType */;
    }
    ts.isJSDocFunctionType = isJSDocFunctionType;
    function isJSDocVariadicType(node) {
        return node.kind === 318 /* SyntaxKind.JSDocVariadicType */;
    }
    ts.isJSDocVariadicType = isJSDocVariadicType;
    function isJSDocNamepathType(node) {
        return node.kind === 319 /* SyntaxKind.JSDocNamepathType */;
    }
    ts.isJSDocNamepathType = isJSDocNamepathType;
    function isJSDoc(node) {
        return node.kind === 320 /* SyntaxKind.JSDoc */;
    }
    ts.isJSDoc = isJSDoc;
    function isJSDocTypeLiteral(node) {
        return node.kind === 322 /* SyntaxKind.JSDocTypeLiteral */;
    }
    ts.isJSDocTypeLiteral = isJSDocTypeLiteral;
    function isJSDocSignature(node) {
        return node.kind === 323 /* SyntaxKind.JSDocSignature */;
    }
    ts.isJSDocSignature = isJSDocSignature;
    // JSDoc Tags
    function isJSDocAugmentsTag(node) {
        return node.kind === 328 /* SyntaxKind.JSDocAugmentsTag */;
    }
    ts.isJSDocAugmentsTag = isJSDocAugmentsTag;
    function isJSDocAuthorTag(node) {
        return node.kind === 330 /* SyntaxKind.JSDocAuthorTag */;
    }
    ts.isJSDocAuthorTag = isJSDocAuthorTag;
    function isJSDocClassTag(node) {
        return node.kind === 332 /* SyntaxKind.JSDocClassTag */;
    }
    ts.isJSDocClassTag = isJSDocClassTag;
    function isJSDocCallbackTag(node) {
        return node.kind === 338 /* SyntaxKind.JSDocCallbackTag */;
    }
    ts.isJSDocCallbackTag = isJSDocCallbackTag;
    function isJSDocPublicTag(node) {
        return node.kind === 333 /* SyntaxKind.JSDocPublicTag */;
    }
    ts.isJSDocPublicTag = isJSDocPublicTag;
    function isJSDocPrivateTag(node) {
        return node.kind === 334 /* SyntaxKind.JSDocPrivateTag */;
    }
    ts.isJSDocPrivateTag = isJSDocPrivateTag;
    function isJSDocProtectedTag(node) {
        return node.kind === 335 /* SyntaxKind.JSDocProtectedTag */;
    }
    ts.isJSDocProtectedTag = isJSDocProtectedTag;
    function isJSDocReadonlyTag(node) {
        return node.kind === 336 /* SyntaxKind.JSDocReadonlyTag */;
    }
    ts.isJSDocReadonlyTag = isJSDocReadonlyTag;
    function isJSDocOverrideTag(node) {
        return node.kind === 337 /* SyntaxKind.JSDocOverrideTag */;
    }
    ts.isJSDocOverrideTag = isJSDocOverrideTag;
    function isJSDocDeprecatedTag(node) {
        return node.kind === 331 /* SyntaxKind.JSDocDeprecatedTag */;
    }
    ts.isJSDocDeprecatedTag = isJSDocDeprecatedTag;
    function isJSDocSeeTag(node) {
        return node.kind === 346 /* SyntaxKind.JSDocSeeTag */;
    }
    ts.isJSDocSeeTag = isJSDocSeeTag;
    function isJSDocEnumTag(node) {
        return node.kind === 339 /* SyntaxKind.JSDocEnumTag */;
    }
    ts.isJSDocEnumTag = isJSDocEnumTag;
    function isJSDocParameterTag(node) {
        return node.kind === 340 /* SyntaxKind.JSDocParameterTag */;
    }
    ts.isJSDocParameterTag = isJSDocParameterTag;
    function isJSDocReturnTag(node) {
        return node.kind === 341 /* SyntaxKind.JSDocReturnTag */;
    }
    ts.isJSDocReturnTag = isJSDocReturnTag;
    function isJSDocThisTag(node) {
        return node.kind === 342 /* SyntaxKind.JSDocThisTag */;
    }
    ts.isJSDocThisTag = isJSDocThisTag;
    function isJSDocTypeTag(node) {
        return node.kind === 343 /* SyntaxKind.JSDocTypeTag */;
    }
    ts.isJSDocTypeTag = isJSDocTypeTag;
    function isJSDocTemplateTag(node) {
        return node.kind === 344 /* SyntaxKind.JSDocTemplateTag */;
    }
    ts.isJSDocTemplateTag = isJSDocTemplateTag;
    function isJSDocTypedefTag(node) {
        return node.kind === 345 /* SyntaxKind.JSDocTypedefTag */;
    }
    ts.isJSDocTypedefTag = isJSDocTypedefTag;
    function isJSDocUnknownTag(node) {
        return node.kind === 327 /* SyntaxKind.JSDocTag */;
    }
    ts.isJSDocUnknownTag = isJSDocUnknownTag;
    function isJSDocPropertyTag(node) {
        return node.kind === 347 /* SyntaxKind.JSDocPropertyTag */;
    }
    ts.isJSDocPropertyTag = isJSDocPropertyTag;
    function isJSDocImplementsTag(node) {
        return node.kind === 329 /* SyntaxKind.JSDocImplementsTag */;
    }
    ts.isJSDocImplementsTag = isJSDocImplementsTag;
    // Synthesized list
    /* @internal */
    function isSyntaxList(n) {
        return n.kind === 348 /* SyntaxKind.SyntaxList */;
    }
    ts.isSyntaxList = isSyntaxList;
})(ts || (ts = {}));
/* @internal */
var ts;
(function (ts) {
    // Compound nodes
    function createEmptyExports(factory) {
        return factory.createExportDeclaration(/*modifiers*/ undefined, /*isTypeOnly*/ false, factory.createNamedExports([]), /*moduleSpecifier*/ undefined);
    }
    ts.createEmptyExports = createEmptyExports;
    function createMemberAccessForPropertyName(factory, target, memberName, location) {
        if (ts.isComputedPropertyName(memberName)) {
            return ts.setTextRange(factory.createElementAccessExpression(target, memberName.expression), location);
        }
        else {
            var expression = ts.setTextRange(ts.isMemberName(memberName)
                ? factory.createPropertyAccessExpression(target, memberName)
                : factory.createElementAccessExpression(target, memberName), memberName);
            ts.getOrCreateEmitNode(expression).flags |= 64 /* EmitFlags.NoNestedSourceMaps */;
            return expression;
        }
    }
    ts.createMemberAccessForPropertyName = createMemberAccessForPropertyName;
    function createReactNamespace(reactNamespace, parent) {
        // To ensure the emit resolver can properly resolve the namespace, we need to
        // treat this identifier as if it were a source tree node by clearing the `Synthesized`
        // flag and setting a parent node.
        var react = ts.parseNodeFactory.createIdentifier(reactNamespace || "React");
        // Set the parent that is in parse tree
        // this makes sure that parent chain is intact for checker to traverse complete scope tree
        ts.setParent(react, ts.getParseTreeNode(parent));
        return react;
    }
    function createJsxFactoryExpressionFromEntityName(factory, jsxFactory, parent) {
        if (ts.isQualifiedName(jsxFactory)) {
            var left = createJsxFactoryExpressionFromEntityName(factory, jsxFactory.left, parent);
            var right = factory.createIdentifier(ts.idText(jsxFactory.right));
            right.escapedText = jsxFactory.right.escapedText;
            return factory.createPropertyAccessExpression(left, right);
        }
        else {
            return createReactNamespace(ts.idText(jsxFactory), parent);
        }
    }
    function createJsxFactoryExpression(factory, jsxFactoryEntity, reactNamespace, parent) {
        return jsxFactoryEntity ?
            createJsxFactoryExpressionFromEntityName(factory, jsxFactoryEntity, parent) :
            factory.createPropertyAccessExpression(createReactNamespace(reactNamespace, parent), "createElement");
    }
    ts.createJsxFactoryExpression = createJsxFactoryExpression;
    function createJsxFragmentFactoryExpression(factory, jsxFragmentFactoryEntity, reactNamespace, parent) {
        return jsxFragmentFactoryEntity ?
            createJsxFactoryExpressionFromEntityName(factory, jsxFragmentFactoryEntity, parent) :
            factory.createPropertyAccessExpression(createReactNamespace(reactNamespace, parent), "Fragment");
    }
    function createExpressionForJsxElement(factory, callee, tagName, props, children, location) {
        var argumentsList = [tagName];
        if (props) {
            argumentsList.push(props);
        }
        if (children && children.length > 0) {
            if (!props) {
                argumentsList.push(factory.createNull());
            }
            if (children.length > 1) {
                for (var _i = 0, children_3 = children; _i < children_3.length; _i++) {
                    var child = children_3[_i];
                    startOnNewLine(child);
                    argumentsList.push(child);
                }
            }
            else {
                argumentsList.push(children[0]);
            }
        }
        return ts.setTextRange(factory.createCallExpression(callee, 
        /*typeArguments*/ undefined, argumentsList), location);
    }
    ts.createExpressionForJsxElement = createExpressionForJsxElement;
    function createExpressionForJsxFragment(factory, jsxFactoryEntity, jsxFragmentFactoryEntity, reactNamespace, children, parentElement, location) {
        var tagName = createJsxFragmentFactoryExpression(factory, jsxFragmentFactoryEntity, reactNamespace, parentElement);
        var argumentsList = [tagName, factory.createNull()];
        if (children && children.length > 0) {
            if (children.length > 1) {
                for (var _i = 0, children_4 = children; _i < children_4.length; _i++) {
                    var child = children_4[_i];
                    startOnNewLine(child);
                    argumentsList.push(child);
                }
            }
            else {
                argumentsList.push(children[0]);
            }
        }
        return ts.setTextRange(factory.createCallExpression(createJsxFactoryExpression(factory, jsxFactoryEntity, reactNamespace, parentElement), 
        /*typeArguments*/ undefined, argumentsList), location);
    }
    ts.createExpressionForJsxFragment = createExpressionForJsxFragment;
    // Utilities
    function createForOfBindingStatement(factory, node, boundValue) {
        if (ts.isVariableDeclarationList(node)) {
            var firstDeclaration = ts.first(node.declarations);
            var updatedDeclaration = factory.updateVariableDeclaration(firstDeclaration, firstDeclaration.name, 
            /*exclamationToken*/ undefined, 
            /*type*/ undefined, boundValue);
            return ts.setTextRange(factory.createVariableStatement(
            /*modifiers*/ undefined, factory.updateVariableDeclarationList(node, [updatedDeclaration])), 
            /*location*/ node);
        }
        else {
            var updatedExpression = ts.setTextRange(factory.createAssignment(node, boundValue), /*location*/ node);
            return ts.setTextRange(factory.createExpressionStatement(updatedExpression), /*location*/ node);
        }
    }
    ts.createForOfBindingStatement = createForOfBindingStatement;
    function insertLeadingStatement(factory, dest, source) {
        if (ts.isBlock(dest)) {
            return factory.updateBlock(dest, ts.setTextRange(factory.createNodeArray(__spreadArray([source], dest.statements, true)), dest.statements));
        }
        else {
            return factory.createBlock(factory.createNodeArray([dest, source]), /*multiLine*/ true);
        }
    }
    ts.insertLeadingStatement = insertLeadingStatement;
    function createExpressionFromEntityName(factory, node) {
        if (ts.isQualifiedName(node)) {
            var left = createExpressionFromEntityName(factory, node.left);
            // TODO(rbuckton): Does this need to be parented?
            var right = ts.setParent(ts.setTextRange(factory.cloneNode(node.right), node.right), node.right.parent);
            return ts.setTextRange(factory.createPropertyAccessExpression(left, right), node);
        }
        else {
            // TODO(rbuckton): Does this need to be parented?
            return ts.setParent(ts.setTextRange(factory.cloneNode(node), node), node.parent);
        }
    }
    ts.createExpressionFromEntityName = createExpressionFromEntityName;
    function createExpressionForPropertyName(factory, memberName) {
        if (ts.isIdentifier(memberName)) {
            return factory.createStringLiteralFromNode(memberName);
        }
        else if (ts.isComputedPropertyName(memberName)) {
            // TODO(rbuckton): Does this need to be parented?
            return ts.setParent(ts.setTextRange(factory.cloneNode(memberName.expression), memberName.expression), memberName.expression.parent);
        }
        else {
            // TODO(rbuckton): Does this need to be parented?
            return ts.setParent(ts.setTextRange(factory.cloneNode(memberName), memberName), memberName.parent);
        }
    }
    ts.createExpressionForPropertyName = createExpressionForPropertyName;
    function createExpressionForAccessorDeclaration(factory, properties, property, receiver, multiLine) {
        var _a = ts.getAllAccessorDeclarations(properties, property), firstAccessor = _a.firstAccessor, getAccessor = _a.getAccessor, setAccessor = _a.setAccessor;
        if (property === firstAccessor) {
            return ts.setTextRange(factory.createObjectDefinePropertyCall(receiver, createExpressionForPropertyName(factory, property.name), factory.createPropertyDescriptor({
                enumerable: factory.createFalse(),
                configurable: true,
                get: getAccessor && ts.setTextRange(ts.setOriginalNode(factory.createFunctionExpression(ts.getModifiers(getAccessor), 
                /*asteriskToken*/ undefined, 
                /*name*/ undefined, 
                /*typeParameters*/ undefined, getAccessor.parameters, 
                /*type*/ undefined, getAccessor.body // TODO: GH#18217
                ), getAccessor), getAccessor),
                set: setAccessor && ts.setTextRange(ts.setOriginalNode(factory.createFunctionExpression(ts.getModifiers(setAccessor), 
                /*asteriskToken*/ undefined, 
                /*name*/ undefined, 
                /*typeParameters*/ undefined, setAccessor.parameters, 
                /*type*/ undefined, setAccessor.body // TODO: GH#18217
                ), setAccessor), setAccessor)
            }, !multiLine)), firstAccessor);
        }
        return undefined;
    }
    function createExpressionForPropertyAssignment(factory, property, receiver) {
        return ts.setOriginalNode(ts.setTextRange(factory.createAssignment(createMemberAccessForPropertyName(factory, receiver, property.name, /*location*/ property.name), property.initializer), property), property);
    }
    function createExpressionForShorthandPropertyAssignment(factory, property, receiver) {
        return ts.setOriginalNode(ts.setTextRange(factory.createAssignment(createMemberAccessForPropertyName(factory, receiver, property.name, /*location*/ property.name), factory.cloneNode(property.name)), 
        /*location*/ property), 
        /*original*/ property);
    }
    function createExpressionForMethodDeclaration(factory, method, receiver) {
        return ts.setOriginalNode(ts.setTextRange(factory.createAssignment(createMemberAccessForPropertyName(factory, receiver, method.name, /*location*/ method.name), ts.setOriginalNode(ts.setTextRange(factory.createFunctionExpression(ts.getModifiers(method), method.asteriskToken, 
        /*name*/ undefined, 
        /*typeParameters*/ undefined, method.parameters, 
        /*type*/ undefined, method.body // TODO: GH#18217
        ), 
        /*location*/ method), 
        /*original*/ method)), 
        /*location*/ method), 
        /*original*/ method);
    }
    function createExpressionForObjectLiteralElementLike(factory, node, property, receiver) {
        if (property.name && ts.isPrivateIdentifier(property.name)) {
            ts.Debug.failBadSyntaxKind(property.name, "Private identifiers are not allowed in object literals.");
        }
        switch (property.kind) {
            case 172 /* SyntaxKind.GetAccessor */:
            case 173 /* SyntaxKind.SetAccessor */:
                return createExpressionForAccessorDeclaration(factory, node.properties, property, receiver, !!node.multiLine);
            case 296 /* SyntaxKind.PropertyAssignment */:
                return createExpressionForPropertyAssignment(factory, property, receiver);
            case 297 /* SyntaxKind.ShorthandPropertyAssignment */:
                return createExpressionForShorthandPropertyAssignment(factory, property, receiver);
            case 169 /* SyntaxKind.MethodDeclaration */:
                return createExpressionForMethodDeclaration(factory, property, receiver);
        }
    }
    ts.createExpressionForObjectLiteralElementLike = createExpressionForObjectLiteralElementLike;
    /**
     * Expand the read and increment/decrement operations a pre- or post-increment or pre- or post-decrement expression.
     *
     * ```ts
     * // input
     * <expression>++
     * // output (if result is not discarded)
     * var <temp>;
     * (<temp> = <expression>, <resultVariable> = <temp>++, <temp>)
     * // output (if result is discarded)
     * var <temp>;
     * (<temp> = <expression>, <temp>++, <temp>)
     *
     * // input
     * ++<expression>
     * // output (if result is not discarded)
     * var <temp>;
     * (<temp> = <expression>, <resultVariable> = ++<temp>)
     * // output (if result is discarded)
     * var <temp>;
     * (<temp> = <expression>, ++<temp>)
     * ```
     *
     * It is up to the caller to supply a temporary variable for `<resultVariable>` if one is needed.
     * The temporary variable `<temp>` is injected so that `++` and `--` work uniformly with `number` and `bigint`.
     * The result of the expression is always the final result of incrementing or decrementing the expression, so that it can be used for storage.
     *
     * @param factory {@link NodeFactory} used to create the expanded representation.
     * @param node The original prefix or postfix unary node.
     * @param expression The expression to use as the value to increment or decrement
     * @param resultVariable A temporary variable in which to store the result. Pass `undefined` if the result is discarded, or if the value of `<temp>` is the expected result.
     */
    function expandPreOrPostfixIncrementOrDecrementExpression(factory, node, expression, recordTempVariable, resultVariable) {
        var operator = node.operator;
        ts.Debug.assert(operator === 45 /* SyntaxKind.PlusPlusToken */ || operator === 46 /* SyntaxKind.MinusMinusToken */, "Expected 'node' to be a pre- or post-increment or pre- or post-decrement expression");
        var temp = factory.createTempVariable(recordTempVariable);
        expression = factory.createAssignment(temp, expression);
        ts.setTextRange(expression, node.operand);
        var operation = ts.isPrefixUnaryExpression(node) ?
            factory.createPrefixUnaryExpression(operator, temp) :
            factory.createPostfixUnaryExpression(temp, operator);
        ts.setTextRange(operation, node);
        if (resultVariable) {
            operation = factory.createAssignment(resultVariable, operation);
            ts.setTextRange(operation, node);
        }
        expression = factory.createComma(expression, operation);
        ts.setTextRange(expression, node);
        if (ts.isPostfixUnaryExpression(node)) {
            expression = factory.createComma(expression, temp);
            ts.setTextRange(expression, node);
        }
        return expression;
    }
    ts.expandPreOrPostfixIncrementOrDecrementExpression = expandPreOrPostfixIncrementOrDecrementExpression;
    /**
     * Gets whether an identifier should only be referred to by its internal name.
     */
    function isInternalName(node) {
        return (ts.getEmitFlags(node) & 32768 /* EmitFlags.InternalName */) !== 0;
    }
    ts.isInternalName = isInternalName;
    /**
     * Gets whether an identifier should only be referred to by its local name.
     */
    function isLocalName(node) {
        return (ts.getEmitFlags(node) & 16384 /* EmitFlags.LocalName */) !== 0;
    }
    ts.isLocalName = isLocalName;
    /**
     * Gets whether an identifier should only be referred to by its export representation if the
     * name points to an exported symbol.
     */
    function isExportName(node) {
        return (ts.getEmitFlags(node) & 8192 /* EmitFlags.ExportName */) !== 0;
    }
    ts.isExportName = isExportName;
    function isUseStrictPrologue(node) {
        return ts.isStringLiteral(node.expression) && node.expression.text === "use strict";
    }
    function findUseStrictPrologue(statements) {
        for (var _i = 0, statements_1 = statements; _i < statements_1.length; _i++) {
            var statement = statements_1[_i];
            if (ts.isPrologueDirective(statement)) {
                if (isUseStrictPrologue(statement)) {
                    return statement;
                }
            }
            else {
                break;
            }
        }
        return undefined;
    }
    ts.findUseStrictPrologue = findUseStrictPrologue;
    function startsWithUseStrict(statements) {
        var firstStatement = ts.firstOrUndefined(statements);
        return firstStatement !== undefined
            && ts.isPrologueDirective(firstStatement)
            && isUseStrictPrologue(firstStatement);
    }
    ts.startsWithUseStrict = startsWithUseStrict;
    function isCommaSequence(node) {
        return node.kind === 221 /* SyntaxKind.BinaryExpression */ && node.operatorToken.kind === 27 /* SyntaxKind.CommaToken */ ||
            node.kind === 351 /* SyntaxKind.CommaListExpression */;
    }
    ts.isCommaSequence = isCommaSequence;
    function isJSDocTypeAssertion(node) {
        return ts.isParenthesizedExpression(node)
            && ts.isInJSFile(node)
            && !!ts.getJSDocTypeTag(node);
    }
    ts.isJSDocTypeAssertion = isJSDocTypeAssertion;
    function getJSDocTypeAssertionType(node) {
        var type = ts.getJSDocType(node);
        ts.Debug.assertIsDefined(type);
        return type;
    }
    ts.getJSDocTypeAssertionType = getJSDocTypeAssertionType;
    function isOuterExpression(node, kinds) {
        if (kinds === void 0) { kinds = 15 /* OuterExpressionKinds.All */; }
        switch (node.kind) {
            case 212 /* SyntaxKind.ParenthesizedExpression */:
                if (kinds & 16 /* OuterExpressionKinds.ExcludeJSDocTypeAssertion */ && isJSDocTypeAssertion(node)) {
                    return false;
                }
                return (kinds & 1 /* OuterExpressionKinds.Parentheses */) !== 0;
            case 211 /* SyntaxKind.TypeAssertionExpression */:
            case 229 /* SyntaxKind.AsExpression */:
                return (kinds & 2 /* OuterExpressionKinds.TypeAssertions */) !== 0;
            case 230 /* SyntaxKind.NonNullExpression */:
                return (kinds & 4 /* OuterExpressionKinds.NonNullAssertions */) !== 0;
            case 350 /* SyntaxKind.PartiallyEmittedExpression */:
                return (kinds & 8 /* OuterExpressionKinds.PartiallyEmittedExpressions */) !== 0;
        }
        return false;
    }
    ts.isOuterExpression = isOuterExpression;
    function skipOuterExpressions(node, kinds) {
        if (kinds === void 0) { kinds = 15 /* OuterExpressionKinds.All */; }
        while (isOuterExpression(node, kinds)) {
            node = node.expression;
        }
        return node;
    }
    ts.skipOuterExpressions = skipOuterExpressions;
    function skipAssertions(node) {
        return skipOuterExpressions(node, 6 /* OuterExpressionKinds.Assertions */);
    }
    ts.skipAssertions = skipAssertions;
    function startOnNewLine(node) {
        return ts.setStartsOnNewLine(node, /*newLine*/ true);
    }
    ts.startOnNewLine = startOnNewLine;
    function getExternalHelpersModuleName(node) {
        var parseNode = ts.getOriginalNode(node, ts.isSourceFile);
        var emitNode = parseNode && parseNode.emitNode;
        return emitNode && emitNode.externalHelpersModuleName;
    }
    ts.getExternalHelpersModuleName = getExternalHelpersModuleName;
    function hasRecordedExternalHelpers(sourceFile) {
        var parseNode = ts.getOriginalNode(sourceFile, ts.isSourceFile);
        var emitNode = parseNode && parseNode.emitNode;
        return !!emitNode && (!!emitNode.externalHelpersModuleName || !!emitNode.externalHelpers);
    }
    ts.hasRecordedExternalHelpers = hasRecordedExternalHelpers;
    function createExternalHelpersImportDeclarationIfNeeded(nodeFactory, helperFactory, sourceFile, compilerOptions, hasExportStarsToExportValues, hasImportStar, hasImportDefault) {
        if (compilerOptions.importHelpers && ts.isEffectiveExternalModule(sourceFile, compilerOptions)) {
            var namedBindings = void 0;
            var moduleKind = ts.getEmitModuleKind(compilerOptions);
            if ((moduleKind >= ts.ModuleKind.ES2015 && moduleKind <= ts.ModuleKind.ESNext) || sourceFile.impliedNodeFormat === ts.ModuleKind.ESNext) {
                // use named imports
                var helpers = ts.getEmitHelpers(sourceFile);
                if (helpers) {
                    var helperNames = [];
                    for (var _i = 0, helpers_3 = helpers; _i < helpers_3.length; _i++) {
                        var helper = helpers_3[_i];
                        if (!helper.scoped) {
                            var importName = helper.importName;
                            if (importName) {
                                ts.pushIfUnique(helperNames, importName);
                            }
                        }
                    }
                    if (ts.some(helperNames)) {
                        helperNames.sort(ts.compareStringsCaseSensitive);
                        // Alias the imports if the names are used somewhere in the file.
                        // NOTE: We don't need to care about global import collisions as this is a module.
                        namedBindings = nodeFactory.createNamedImports(ts.map(helperNames, function (name) { return ts.isFileLevelUniqueName(sourceFile, name)
                            ? nodeFactory.createImportSpecifier(/*isTypeOnly*/ false, /*propertyName*/ undefined, nodeFactory.createIdentifier(name))
                            : nodeFactory.createImportSpecifier(/*isTypeOnly*/ false, nodeFactory.createIdentifier(name), helperFactory.getUnscopedHelperName(name)); }));
                        var parseNode = ts.getOriginalNode(sourceFile, ts.isSourceFile);
                        var emitNode = ts.getOrCreateEmitNode(parseNode);
                        emitNode.externalHelpers = true;
                    }
                }
            }
            else {
                // use a namespace import
                var externalHelpersModuleName = getOrCreateExternalHelpersModuleNameIfNeeded(nodeFactory, sourceFile, compilerOptions, hasExportStarsToExportValues, hasImportStar || hasImportDefault);
                if (externalHelpersModuleName) {
                    namedBindings = nodeFactory.createNamespaceImport(externalHelpersModuleName);
                }
            }
            if (namedBindings) {
                var externalHelpersImportDeclaration = nodeFactory.createImportDeclaration(
                /*modifiers*/ undefined, nodeFactory.createImportClause(/*isTypeOnly*/ false, /*name*/ undefined, namedBindings), nodeFactory.createStringLiteral(ts.externalHelpersModuleNameText), 
                /*assertClause*/ undefined);
                ts.addEmitFlags(externalHelpersImportDeclaration, 67108864 /* EmitFlags.NeverApplyImportHelper */);
                return externalHelpersImportDeclaration;
            }
        }
    }
    ts.createExternalHelpersImportDeclarationIfNeeded = createExternalHelpersImportDeclarationIfNeeded;
    function getOrCreateExternalHelpersModuleNameIfNeeded(factory, node, compilerOptions, hasExportStarsToExportValues, hasImportStarOrImportDefault) {
        if (compilerOptions.importHelpers && ts.isEffectiveExternalModule(node, compilerOptions)) {
            var externalHelpersModuleName = getExternalHelpersModuleName(node);
            if (externalHelpersModuleName) {
                return externalHelpersModuleName;
            }
            var moduleKind = ts.getEmitModuleKind(compilerOptions);
            var create = (hasExportStarsToExportValues || (ts.getESModuleInterop(compilerOptions) && hasImportStarOrImportDefault))
                && moduleKind !== ts.ModuleKind.System
                && (moduleKind < ts.ModuleKind.ES2015 || node.impliedNodeFormat === ts.ModuleKind.CommonJS);
            if (!create) {
                var helpers = ts.getEmitHelpers(node);
                if (helpers) {
                    for (var _i = 0, helpers_4 = helpers; _i < helpers_4.length; _i++) {
                        var helper = helpers_4[_i];
                        if (!helper.scoped) {
                            create = true;
                            break;
                        }
                    }
                }
            }
            if (create) {
                var parseNode = ts.getOriginalNode(node, ts.isSourceFile);
                var emitNode = ts.getOrCreateEmitNode(parseNode);
                return emitNode.externalHelpersModuleName || (emitNode.externalHelpersModuleName = factory.createUniqueName(ts.externalHelpersModuleNameText));
            }
        }
    }
    ts.getOrCreateExternalHelpersModuleNameIfNeeded = getOrCreateExternalHelpersModuleNameIfNeeded;
    /**
     * Get the name of that target module from an import or export declaration
     */
    function getLocalNameForExternalImport(factory, node, sourceFile) {
        var namespaceDeclaration = ts.getNamespaceDeclarationNode(node);
        if (namespaceDeclaration && !ts.isDefaultImport(node) && !ts.isExportNamespaceAsDefaultDeclaration(node)) {
            var name = namespaceDeclaration.name;
            return ts.isGeneratedIdentifier(name) ? name : factory.createIdentifier(ts.getSourceTextOfNodeFromSourceFile(sourceFile, name) || ts.idText(name));
        }
        if (node.kind === 266 /* SyntaxKind.ImportDeclaration */ && node.importClause) {
            return factory.getGeneratedNameForNode(node);
        }
        if (node.kind === 272 /* SyntaxKind.ExportDeclaration */ && node.moduleSpecifier) {
            return factory.getGeneratedNameForNode(node);
        }
        return undefined;
    }
    ts.getLocalNameForExternalImport = getLocalNameForExternalImport;
    /**
     * Get the name of a target module from an import/export declaration as should be written in the emitted output.
     * The emitted output name can be different from the input if:
     *  1. The module has a /// <amd-module name="<new name>" />
     *  2. --out or --outFile is used, making the name relative to the rootDir
     *  3- The containing SourceFile has an entry in renamedDependencies for the import as requested by some module loaders (e.g. System).
     * Otherwise, a new StringLiteral node representing the module name will be returned.
     */
    function getExternalModuleNameLiteral(factory, importNode, sourceFile, host, resolver, compilerOptions) {
        var moduleName = ts.getExternalModuleName(importNode);
        if (moduleName && ts.isStringLiteral(moduleName)) {
            return tryGetModuleNameFromDeclaration(importNode, host, factory, resolver, compilerOptions)
                || tryRenameExternalModule(factory, moduleName, sourceFile)
                || factory.cloneNode(moduleName);
        }
        return undefined;
    }
    ts.getExternalModuleNameLiteral = getExternalModuleNameLiteral;
    /**
     * Some bundlers (SystemJS builder) sometimes want to rename dependencies.
     * Here we check if alternative name was provided for a given moduleName and return it if possible.
     */
    function tryRenameExternalModule(factory, moduleName, sourceFile) {
        var rename = sourceFile.renamedDependencies && sourceFile.renamedDependencies.get(moduleName.text);
        return rename ? factory.createStringLiteral(rename) : undefined;
    }
    /**
     * Get the name of a module as should be written in the emitted output.
     * The emitted output name can be different from the input if:
     *  1. The module has a /// <amd-module name="<new name>" />
     *  2. --out or --outFile is used, making the name relative to the rootDir
     * Otherwise, a new StringLiteral node representing the module name will be returned.
     */
    function tryGetModuleNameFromFile(factory, file, host, options) {
        if (!file) {
            return undefined;
        }
        if (file.moduleName) {
            return factory.createStringLiteral(file.moduleName);
        }
        if (!file.isDeclarationFile && ts.outFile(options)) {
            return factory.createStringLiteral(ts.getExternalModuleNameFromPath(host, file.fileName));
        }
        return undefined;
    }
    ts.tryGetModuleNameFromFile = tryGetModuleNameFromFile;
    function tryGetModuleNameFromDeclaration(declaration, host, factory, resolver, compilerOptions) {
        return tryGetModuleNameFromFile(factory, resolver.getExternalModuleFileFromDeclaration(declaration), host, compilerOptions);
    }
    /**
     * Gets the initializer of an BindingOrAssignmentElement.
     */
    function getInitializerOfBindingOrAssignmentElement(bindingElement) {
        if (ts.isDeclarationBindingElement(bindingElement)) {
            // `1` in `let { a = 1 } = ...`
            // `1` in `let { a: b = 1 } = ...`
            // `1` in `let { a: {b} = 1 } = ...`
            // `1` in `let { a: [b] = 1 } = ...`
            // `1` in `let [a = 1] = ...`
            // `1` in `let [{a} = 1] = ...`
            // `1` in `let [[a] = 1] = ...`
            return bindingElement.initializer;
        }
        if (ts.isPropertyAssignment(bindingElement)) {
            // `1` in `({ a: b = 1 } = ...)`
            // `1` in `({ a: {b} = 1 } = ...)`
            // `1` in `({ a: [b] = 1 } = ...)`
            var initializer = bindingElement.initializer;
            return ts.isAssignmentExpression(initializer, /*excludeCompoundAssignment*/ true)
                ? initializer.right
                : undefined;
        }
        if (ts.isShorthandPropertyAssignment(bindingElement)) {
            // `1` in `({ a = 1 } = ...)`
            return bindingElement.objectAssignmentInitializer;
        }
        if (ts.isAssignmentExpression(bindingElement, /*excludeCompoundAssignment*/ true)) {
            // `1` in `[a = 1] = ...`
            // `1` in `[{a} = 1] = ...`
            // `1` in `[[a] = 1] = ...`
            return bindingElement.right;
        }
        if (ts.isSpreadElement(bindingElement)) {
            // Recovery consistent with existing emit.
            return getInitializerOfBindingOrAssignmentElement(bindingElement.expression);
        }
    }
    ts.getInitializerOfBindingOrAssignmentElement = getInitializerOfBindingOrAssignmentElement;
    /**
     * Gets the name of an BindingOrAssignmentElement.
     */
    function getTargetOfBindingOrAssignmentElement(bindingElement) {
        if (ts.isDeclarationBindingElement(bindingElement)) {
            // `a` in `let { a } = ...`
            // `a` in `let { a = 1 } = ...`
            // `b` in `let { a: b } = ...`
            // `b` in `let { a: b = 1 } = ...`
            // `a` in `let { ...a } = ...`
            // `{b}` in `let { a: {b} } = ...`
            // `{b}` in `let { a: {b} = 1 } = ...`
            // `[b]` in `let { a: [b] } = ...`
            // `[b]` in `let { a: [b] = 1 } = ...`
            // `a` in `let [a] = ...`
            // `a` in `let [a = 1] = ...`
            // `a` in `let [...a] = ...`
            // `{a}` in `let [{a}] = ...`
            // `{a}` in `let [{a} = 1] = ...`
            // `[a]` in `let [[a]] = ...`
            // `[a]` in `let [[a] = 1] = ...`
            return bindingElement.name;
        }
        if (ts.isObjectLiteralElementLike(bindingElement)) {
            switch (bindingElement.kind) {
                case 296 /* SyntaxKind.PropertyAssignment */:
                    // `b` in `({ a: b } = ...)`
                    // `b` in `({ a: b = 1 } = ...)`
                    // `{b}` in `({ a: {b} } = ...)`
                    // `{b}` in `({ a: {b} = 1 } = ...)`
                    // `[b]` in `({ a: [b] } = ...)`
                    // `[b]` in `({ a: [b] = 1 } = ...)`
                    // `b.c` in `({ a: b.c } = ...)`
                    // `b.c` in `({ a: b.c = 1 } = ...)`
                    // `b[0]` in `({ a: b[0] } = ...)`
                    // `b[0]` in `({ a: b[0] = 1 } = ...)`
                    return getTargetOfBindingOrAssignmentElement(bindingElement.initializer);
                case 297 /* SyntaxKind.ShorthandPropertyAssignment */:
                    // `a` in `({ a } = ...)`
                    // `a` in `({ a = 1 } = ...)`
                    return bindingElement.name;
                case 298 /* SyntaxKind.SpreadAssignment */:
                    // `a` in `({ ...a } = ...)`
                    return getTargetOfBindingOrAssignmentElement(bindingElement.expression);
            }
            // no target
            return undefined;
        }
        if (ts.isAssignmentExpression(bindingElement, /*excludeCompoundAssignment*/ true)) {
            // `a` in `[a = 1] = ...`
            // `{a}` in `[{a} = 1] = ...`
            // `[a]` in `[[a] = 1] = ...`
            // `a.b` in `[a.b = 1] = ...`
            // `a[0]` in `[a[0] = 1] = ...`
            return getTargetOfBindingOrAssignmentElement(bindingElement.left);
        }
        if (ts.isSpreadElement(bindingElement)) {
            // `a` in `[...a] = ...`
            return getTargetOfBindingOrAssignmentElement(bindingElement.expression);
        }
        // `a` in `[a] = ...`
        // `{a}` in `[{a}] = ...`
        // `[a]` in `[[a]] = ...`
        // `a.b` in `[a.b] = ...`
        // `a[0]` in `[a[0]] = ...`
        return bindingElement;
    }
    ts.getTargetOfBindingOrAssignmentElement = getTargetOfBindingOrAssignmentElement;
    /**
     * Determines whether an BindingOrAssignmentElement is a rest element.
     */
    function getRestIndicatorOfBindingOrAssignmentElement(bindingElement) {
        switch (bindingElement.kind) {
            case 164 /* SyntaxKind.Parameter */:
            case 203 /* SyntaxKind.BindingElement */:
                // `...` in `let [...a] = ...`
                return bindingElement.dotDotDotToken;
            case 225 /* SyntaxKind.SpreadElement */:
            case 298 /* SyntaxKind.SpreadAssignment */:
                // `...` in `[...a] = ...`
                return bindingElement;
        }
        return undefined;
    }
    ts.getRestIndicatorOfBindingOrAssignmentElement = getRestIndicatorOfBindingOrAssignmentElement;
    /**
     * Gets the property name of a BindingOrAssignmentElement
     */
    function getPropertyNameOfBindingOrAssignmentElement(bindingElement) {
        var propertyName = tryGetPropertyNameOfBindingOrAssignmentElement(bindingElement);
        ts.Debug.assert(!!propertyName || ts.isSpreadAssignment(bindingElement), "Invalid property name for binding element.");
        return propertyName;
    }
    ts.getPropertyNameOfBindingOrAssignmentElement = getPropertyNameOfBindingOrAssignmentElement;
    function tryGetPropertyNameOfBindingOrAssignmentElement(bindingElement) {
        switch (bindingElement.kind) {
            case 203 /* SyntaxKind.BindingElement */:
                // `a` in `let { a: b } = ...`
                // `[a]` in `let { [a]: b } = ...`
                // `"a"` in `let { "a": b } = ...`
                // `1` in `let { 1: b } = ...`
                if (bindingElement.propertyName) {
                    var propertyName = bindingElement.propertyName;
                    if (ts.isPrivateIdentifier(propertyName)) {
                        return ts.Debug.failBadSyntaxKind(propertyName);
                    }
                    return ts.isComputedPropertyName(propertyName) && isStringOrNumericLiteral(propertyName.expression)
                        ? propertyName.expression
                        : propertyName;
                }
                break;
            case 296 /* SyntaxKind.PropertyAssignment */:
                // `a` in `({ a: b } = ...)`
                // `[a]` in `({ [a]: b } = ...)`
                // `"a"` in `({ "a": b } = ...)`
                // `1` in `({ 1: b } = ...)`
                if (bindingElement.name) {
                    var propertyName = bindingElement.name;
                    if (ts.isPrivateIdentifier(propertyName)) {
                        return ts.Debug.failBadSyntaxKind(propertyName);
                    }
                    return ts.isComputedPropertyName(propertyName) && isStringOrNumericLiteral(propertyName.expression)
                        ? propertyName.expression
                        : propertyName;
                }
                break;
            case 298 /* SyntaxKind.SpreadAssignment */:
                // `a` in `({ ...a } = ...)`
                if (bindingElement.name && ts.isPrivateIdentifier(bindingElement.name)) {
                    return ts.Debug.failBadSyntaxKind(bindingElement.name);
                }
                return bindingElement.name;
        }
        var target = getTargetOfBindingOrAssignmentElement(bindingElement);
        if (target && ts.isPropertyName(target)) {
            return target;
        }
    }
    ts.tryGetPropertyNameOfBindingOrAssignmentElement = tryGetPropertyNameOfBindingOrAssignmentElement;
    function isStringOrNumericLiteral(node) {
        var kind = node.kind;
        return kind === 10 /* SyntaxKind.StringLiteral */
            || kind === 8 /* SyntaxKind.NumericLiteral */;
    }
    /**
     * Gets the elements of a BindingOrAssignmentPattern
     */
    function getElementsOfBindingOrAssignmentPattern(name) {
        switch (name.kind) {
            case 201 /* SyntaxKind.ObjectBindingPattern */:
            case 202 /* SyntaxKind.ArrayBindingPattern */:
            case 204 /* SyntaxKind.ArrayLiteralExpression */:
                // `a` in `{a}`
                // `a` in `[a]`
                return name.elements;
            case 205 /* SyntaxKind.ObjectLiteralExpression */:
                // `a` in `{a}`
                return name.properties;
        }
    }
    ts.getElementsOfBindingOrAssignmentPattern = getElementsOfBindingOrAssignmentPattern;
    /* @internal */
    function getJSDocTypeAliasName(fullName) {
        if (fullName) {
            var rightNode = fullName;
            while (true) {
                if (ts.isIdentifier(rightNode) || !rightNode.body) {
                    return ts.isIdentifier(rightNode) ? rightNode : rightNode.name;
                }
                rightNode = rightNode.body;
            }
        }
    }
    ts.getJSDocTypeAliasName = getJSDocTypeAliasName;
    function canHaveIllegalType(node) {
        var kind = node.kind;
        return kind === 171 /* SyntaxKind.Constructor */
            || kind === 173 /* SyntaxKind.SetAccessor */;
    }
    ts.canHaveIllegalType = canHaveIllegalType;
    function canHaveIllegalTypeParameters(node) {
        var kind = node.kind;
        return kind === 171 /* SyntaxKind.Constructor */
            || kind === 172 /* SyntaxKind.GetAccessor */
            || kind === 173 /* SyntaxKind.SetAccessor */;
    }
    ts.canHaveIllegalTypeParameters = canHaveIllegalTypeParameters;
    function canHaveIllegalDecorators(node) {
        var kind = node.kind;
        return kind === 296 /* SyntaxKind.PropertyAssignment */
            || kind === 297 /* SyntaxKind.ShorthandPropertyAssignment */
            || kind === 256 /* SyntaxKind.FunctionDeclaration */
            || kind === 171 /* SyntaxKind.Constructor */
            || kind === 176 /* SyntaxKind.IndexSignature */
            || kind === 170 /* SyntaxKind.ClassStaticBlockDeclaration */
            || kind === 276 /* SyntaxKind.MissingDeclaration */
            || kind === 237 /* SyntaxKind.VariableStatement */
            || kind === 258 /* SyntaxKind.InterfaceDeclaration */
            || kind === 259 /* SyntaxKind.TypeAliasDeclaration */
            || kind === 260 /* SyntaxKind.EnumDeclaration */
            || kind === 261 /* SyntaxKind.ModuleDeclaration */
            || kind === 265 /* SyntaxKind.ImportEqualsDeclaration */
            || kind === 266 /* SyntaxKind.ImportDeclaration */
            || kind === 264 /* SyntaxKind.NamespaceExportDeclaration */
            || kind === 272 /* SyntaxKind.ExportDeclaration */
            || kind === 271 /* SyntaxKind.ExportAssignment */;
    }
    ts.canHaveIllegalDecorators = canHaveIllegalDecorators;
    function canHaveIllegalModifiers(node) {
        var kind = node.kind;
        return kind === 170 /* SyntaxKind.ClassStaticBlockDeclaration */
            || kind === 296 /* SyntaxKind.PropertyAssignment */
            || kind === 297 /* SyntaxKind.ShorthandPropertyAssignment */
            || kind === 179 /* SyntaxKind.FunctionType */
            || kind === 276 /* SyntaxKind.MissingDeclaration */
            || kind === 264 /* SyntaxKind.NamespaceExportDeclaration */;
    }
    ts.canHaveIllegalModifiers = canHaveIllegalModifiers;
    ts.isTypeNodeOrTypeParameterDeclaration = ts.or(ts.isTypeNode, ts.isTypeParameterDeclaration);
    ts.isQuestionOrExclamationToken = ts.or(ts.isQuestionToken, ts.isExclamationToken);
    ts.isIdentifierOrThisTypeNode = ts.or(ts.isIdentifier, ts.isThisTypeNode);
    ts.isReadonlyKeywordOrPlusOrMinusToken = ts.or(ts.isReadonlyKeyword, ts.isPlusToken, ts.isMinusToken);
    ts.isQuestionOrPlusOrMinusToken = ts.or(ts.isQuestionToken, ts.isPlusToken, ts.isMinusToken);
    ts.isModuleName = ts.or(ts.isIdentifier, ts.isStringLiteral);
    function isLiteralTypeLikeExpression(node) {
        var kind = node.kind;
        return kind === 104 /* SyntaxKind.NullKeyword */
            || kind === 110 /* SyntaxKind.TrueKeyword */
            || kind === 95 /* SyntaxKind.FalseKeyword */
            || ts.isLiteralExpression(node)
            || ts.isPrefixUnaryExpression(node);
    }
    ts.isLiteralTypeLikeExpression = isLiteralTypeLikeExpression;
    function isExponentiationOperator(kind) {
        return kind === 42 /* SyntaxKind.AsteriskAsteriskToken */;
    }
    function isMultiplicativeOperator(kind) {
        return kind === 41 /* SyntaxKind.AsteriskToken */
            || kind === 43 /* SyntaxKind.SlashToken */
            || kind === 44 /* SyntaxKind.PercentToken */;
    }
    function isMultiplicativeOperatorOrHigher(kind) {
        return isExponentiationOperator(kind)
            || isMultiplicativeOperator(kind);
    }
    function isAdditiveOperator(kind) {
        return kind === 39 /* SyntaxKind.PlusToken */
            || kind === 40 /* SyntaxKind.MinusToken */;
    }
    function isAdditiveOperatorOrHigher(kind) {
        return isAdditiveOperator(kind)
            || isMultiplicativeOperatorOrHigher(kind);
    }
    function isShiftOperator(kind) {
        return kind === 47 /* SyntaxKind.LessThanLessThanToken */
            || kind === 48 /* SyntaxKind.GreaterThanGreaterThanToken */
            || kind === 49 /* SyntaxKind.GreaterThanGreaterThanGreaterThanToken */;
    }
    function isShiftOperatorOrHigher(kind) {
        return isShiftOperator(kind)
            || isAdditiveOperatorOrHigher(kind);
    }
    function isRelationalOperator(kind) {
        return kind === 29 /* SyntaxKind.LessThanToken */
            || kind === 32 /* SyntaxKind.LessThanEqualsToken */
            || kind === 31 /* SyntaxKind.GreaterThanToken */
            || kind === 33 /* SyntaxKind.GreaterThanEqualsToken */
            || kind === 102 /* SyntaxKind.InstanceOfKeyword */
            || kind === 101 /* SyntaxKind.InKeyword */;
    }
    function isRelationalOperatorOrHigher(kind) {
        return isRelationalOperator(kind)
            || isShiftOperatorOrHigher(kind);
    }
    function isEqualityOperator(kind) {
        return kind === 34 /* SyntaxKind.EqualsEqualsToken */
            || kind === 36 /* SyntaxKind.EqualsEqualsEqualsToken */
            || kind === 35 /* SyntaxKind.ExclamationEqualsToken */
            || kind === 37 /* SyntaxKind.ExclamationEqualsEqualsToken */;
    }
    function isEqualityOperatorOrHigher(kind) {
        return isEqualityOperator(kind)
            || isRelationalOperatorOrHigher(kind);
    }
    function isBitwiseOperator(kind) {
        return kind === 50 /* SyntaxKind.AmpersandToken */
            || kind === 51 /* SyntaxKind.BarToken */
            || kind === 52 /* SyntaxKind.CaretToken */;
    }
    function isBitwiseOperatorOrHigher(kind) {
        return isBitwiseOperator(kind)
            || isEqualityOperatorOrHigher(kind);
    }
    // NOTE: The version in utilities includes ExclamationToken, which is not a binary operator.
    function isLogicalOperator(kind) {
        return kind === 55 /* SyntaxKind.AmpersandAmpersandToken */
            || kind === 56 /* SyntaxKind.BarBarToken */;
    }
    function isLogicalOperatorOrHigher(kind) {
        return isLogicalOperator(kind)
            || isBitwiseOperatorOrHigher(kind);
    }
    function isAssignmentOperatorOrHigher(kind) {
        return kind === 60 /* SyntaxKind.QuestionQuestionToken */
            || isLogicalOperatorOrHigher(kind)
            || ts.isAssignmentOperator(kind);
    }
    function isBinaryOperator(kind) {
        return isAssignmentOperatorOrHigher(kind)
            || kind === 27 /* SyntaxKind.CommaToken */;
    }
    function isBinaryOperatorToken(node) {
        return isBinaryOperator(node.kind);
    }
    ts.isBinaryOperatorToken = isBinaryOperatorToken;
    var BinaryExpressionState;
    (function (BinaryExpressionState) {
        /**
         * Handles walking into a `BinaryExpression`.
         * @param machine State machine handler functions
         * @param frame The current frame
         * @returns The new frame
         */
        function enter(machine, stackIndex, stateStack, nodeStack, userStateStack, _resultHolder, outerState) {
            var prevUserState = stackIndex > 0 ? userStateStack[stackIndex - 1] : undefined;
            ts.Debug.assertEqual(stateStack[stackIndex], enter);
            userStateStack[stackIndex] = machine.onEnter(nodeStack[stackIndex], prevUserState, outerState);
            stateStack[stackIndex] = nextState(machine, enter);
            return stackIndex;
        }
        BinaryExpressionState.enter = enter;
        /**
         * Handles walking the `left` side of a `BinaryExpression`.
         * @param machine State machine handler functions
         * @param frame The current frame
         * @returns The new frame
         */
        function left(machine, stackIndex, stateStack, nodeStack, userStateStack, _resultHolder, _outerState) {
            ts.Debug.assertEqual(stateStack[stackIndex], left);
            ts.Debug.assertIsDefined(machine.onLeft);
            stateStack[stackIndex] = nextState(machine, left);
            var nextNode = machine.onLeft(nodeStack[stackIndex].left, userStateStack[stackIndex], nodeStack[stackIndex]);
            if (nextNode) {
                checkCircularity(stackIndex, nodeStack, nextNode);
                return pushStack(stackIndex, stateStack, nodeStack, userStateStack, nextNode);
            }
            return stackIndex;
        }
        BinaryExpressionState.left = left;
        /**
         * Handles walking the `operatorToken` of a `BinaryExpression`.
         * @param machine State machine handler functions
         * @param frame The current frame
         * @returns The new frame
         */
        function operator(machine, stackIndex, stateStack, nodeStack, userStateStack, _resultHolder, _outerState) {
            ts.Debug.assertEqual(stateStack[stackIndex], operator);
            ts.Debug.assertIsDefined(machine.onOperator);
            stateStack[stackIndex] = nextState(machine, operator);
            machine.onOperator(nodeStack[stackIndex].operatorToken, userStateStack[stackIndex], nodeStack[stackIndex]);
            return stackIndex;
        }
        BinaryExpressionState.operator = operator;
        /**
         * Handles walking the `right` side of a `BinaryExpression`.
         * @param machine State machine handler functions
         * @param frame The current frame
         * @returns The new frame
         */
        function right(machine, stackIndex, stateStack, nodeStack, userStateStack, _resultHolder, _outerState) {
            ts.Debug.assertEqual(stateStack[stackIndex], right);
            ts.Debug.assertIsDefined(machine.onRight);
            stateStack[stackIndex] = nextState(machine, right);
            var nextNode = machine.onRight(nodeStack[stackIndex].right, userStateStack[stackIndex], nodeStack[stackIndex]);
            if (nextNode) {
                checkCircularity(stackIndex, nodeStack, nextNode);
                return pushStack(stackIndex, stateStack, nodeStack, userStateStack, nextNode);
            }
            return stackIndex;
        }
        BinaryExpressionState.right = right;
        /**
         * Handles walking out of a `BinaryExpression`.
         * @param machine State machine handler functions
         * @param frame The current frame
         * @returns The new frame
         */
        function exit(machine, stackIndex, stateStack, nodeStack, userStateStack, resultHolder, _outerState) {
            ts.Debug.assertEqual(stateStack[stackIndex], exit);
            stateStack[stackIndex] = nextState(machine, exit);
            var result = machine.onExit(nodeStack[stackIndex], userStateStack[stackIndex]);
            if (stackIndex > 0) {
                stackIndex--;
                if (machine.foldState) {
                    var side = stateStack[stackIndex] === exit ? "right" : "left";
                    userStateStack[stackIndex] = machine.foldState(userStateStack[stackIndex], result, side);
                }
            }
            else {
                resultHolder.value = result;
            }
            return stackIndex;
        }
        BinaryExpressionState.exit = exit;
        /**
         * Handles a frame that is already done.
         * @returns The `done` state.
         */
        function done(_machine, stackIndex, stateStack, _nodeStack, _userStateStack, _resultHolder, _outerState) {
            ts.Debug.assertEqual(stateStack[stackIndex], done);
            return stackIndex;
        }
        BinaryExpressionState.done = done;
        function nextState(machine, currentState) {
            switch (currentState) {
                case enter:
                    if (machine.onLeft)
                        return left;
                // falls through
                case left:
                    if (machine.onOperator)
                        return operator;
                // falls through
                case operator:
                    if (machine.onRight)
                        return right;
                // falls through
                case right: return exit;
                case exit: return done;
                case done: return done;
                default: ts.Debug.fail("Invalid state");
            }
        }
        BinaryExpressionState.nextState = nextState;
        function pushStack(stackIndex, stateStack, nodeStack, userStateStack, node) {
            stackIndex++;
            stateStack[stackIndex] = enter;
            nodeStack[stackIndex] = node;
            userStateStack[stackIndex] = undefined;
            return stackIndex;
        }
        function checkCircularity(stackIndex, nodeStack, node) {
            if (ts.Debug.shouldAssert(2 /* AssertionLevel.Aggressive */)) {
                while (stackIndex >= 0) {
                    ts.Debug.assert(nodeStack[stackIndex] !== node, "Circular traversal detected.");
                    stackIndex--;
                }
            }
        }
    })(BinaryExpressionState || (BinaryExpressionState = {}));
    /**
     * Holds state machine handler functions
     */
    var BinaryExpressionStateMachine = /** @class */ (function () {
        function BinaryExpressionStateMachine(onEnter, onLeft, onOperator, onRight, onExit, foldState) {
            this.onEnter = onEnter;
            this.onLeft = onLeft;
            this.onOperator = onOperator;
            this.onRight = onRight;
            this.onExit = onExit;
            this.foldState = foldState;
        }
        return BinaryExpressionStateMachine;
    }());
    function createBinaryExpressionTrampoline(onEnter, onLeft, onOperator, onRight, onExit, foldState) {
        var machine = new BinaryExpressionStateMachine(onEnter, onLeft, onOperator, onRight, onExit, foldState);
        return trampoline;
        function trampoline(node, outerState) {
            var resultHolder = { value: undefined };
            var stateStack = [BinaryExpressionState.enter];
            var nodeStack = [node];
            var userStateStack = [undefined];
            var stackIndex = 0;
            while (stateStack[stackIndex] !== BinaryExpressionState.done) {
                stackIndex = stateStack[stackIndex](machine, stackIndex, stateStack, nodeStack, userStateStack, resultHolder, outerState);
            }
            ts.Debug.assertEqual(stackIndex, 0);
            return resultHolder.value;
        }
    }
    ts.createBinaryExpressionTrampoline = createBinaryExpressionTrampoline;
    function elideNodes(factory, nodes) {
        if (nodes === undefined)
            return undefined;
        if (nodes.length === 0)
            return nodes;
        return ts.setTextRange(factory.createNodeArray([], nodes.hasTrailingComma), nodes);
    }
    ts.elideNodes = elideNodes;
})(ts || (ts = {}));
var ts;
(function (ts) {
    function setTextRange(range, location) {
        return location ? ts.setTextRangePosEnd(range, location.pos, location.end) : range;
    }
    ts.setTextRange = setTextRange;
    function canHaveModifiers(node) {
        var kind = node.kind;
        return kind === 163 /* SyntaxKind.TypeParameter */
            || kind === 164 /* SyntaxKind.Parameter */
            || kind === 166 /* SyntaxKind.PropertySignature */
            || kind === 167 /* SyntaxKind.PropertyDeclaration */
            || kind === 168 /* SyntaxKind.MethodSignature */
            || kind === 169 /* SyntaxKind.MethodDeclaration */
            || kind === 171 /* SyntaxKind.Constructor */
            || kind === 172 /* SyntaxKind.GetAccessor */
            || kind === 173 /* SyntaxKind.SetAccessor */
            || kind === 176 /* SyntaxKind.IndexSignature */
            || kind === 180 /* SyntaxKind.ConstructorType */
            || kind === 213 /* SyntaxKind.FunctionExpression */
            || kind === 214 /* SyntaxKind.ArrowFunction */
            || kind === 226 /* SyntaxKind.ClassExpression */
            || kind === 237 /* SyntaxKind.VariableStatement */
            || kind === 256 /* SyntaxKind.FunctionDeclaration */
            || kind === 257 /* SyntaxKind.ClassDeclaration */
            || kind === 258 /* SyntaxKind.InterfaceDeclaration */
            || kind === 259 /* SyntaxKind.TypeAliasDeclaration */
            || kind === 260 /* SyntaxKind.EnumDeclaration */
            || kind === 261 /* SyntaxKind.ModuleDeclaration */
            || kind === 265 /* SyntaxKind.ImportEqualsDeclaration */
            || kind === 266 /* SyntaxKind.ImportDeclaration */
            || kind === 271 /* SyntaxKind.ExportAssignment */
            || kind === 272 /* SyntaxKind.ExportDeclaration */;
    }
    ts.canHaveModifiers = canHaveModifiers;
    function canHaveDecorators(node) {
        var kind = node.kind;
        return kind === 164 /* SyntaxKind.Parameter */
            || kind === 167 /* SyntaxKind.PropertyDeclaration */
            || kind === 169 /* SyntaxKind.MethodDeclaration */
            || kind === 172 /* SyntaxKind.GetAccessor */
            || kind === 173 /* SyntaxKind.SetAccessor */
            || kind === 226 /* SyntaxKind.ClassExpression */
            || kind === 257 /* SyntaxKind.ClassDeclaration */;
    }
    ts.canHaveDecorators = canHaveDecorators;
})(ts || (ts = {}));
var ts;
(function (ts) {
    var SignatureFlags;
    (function (SignatureFlags) {
        SignatureFlags[SignatureFlags["None"] = 0] = "None";
        SignatureFlags[SignatureFlags["Yield"] = 1] = "Yield";
        SignatureFlags[SignatureFlags["Await"] = 2] = "Await";
        SignatureFlags[SignatureFlags["Type"] = 4] = "Type";
        SignatureFlags[SignatureFlags["IgnoreMissingOpenBrace"] = 16] = "IgnoreMissingOpenBrace";
        SignatureFlags[SignatureFlags["JSDoc"] = 32] = "JSDoc";
    })(SignatureFlags || (SignatureFlags = {}));
    var SpeculationKind;
    (function (SpeculationKind) {
        SpeculationKind[SpeculationKind["TryParse"] = 0] = "TryParse";
        SpeculationKind[SpeculationKind["Lookahead"] = 1] = "Lookahead";
        SpeculationKind[SpeculationKind["Reparse"] = 2] = "Reparse";
    })(SpeculationKind || (SpeculationKind = {}));
    var NodeConstructor;
    var TokenConstructor;
    var IdentifierConstructor;
    var PrivateIdentifierConstructor;
    var SourceFileConstructor;
    /**
     * NOTE: You should not use this, it is only exported to support `createNode` in `~/src/deprecatedCompat/deprecations.ts`.
     */
    /* @internal */
    ts.parseBaseNodeFactory = {
        createBaseSourceFileNode: function (kind) { return new (SourceFileConstructor || (SourceFileConstructor = ts.objectAllocator.getSourceFileConstructor()))(kind, -1, -1); },
        createBaseIdentifierNode: function (kind) { return new (IdentifierConstructor || (IdentifierConstructor = ts.objectAllocator.getIdentifierConstructor()))(kind, -1, -1); },
        createBasePrivateIdentifierNode: function (kind) { return new (PrivateIdentifierConstructor || (PrivateIdentifierConstructor = ts.objectAllocator.getPrivateIdentifierConstructor()))(kind, -1, -1); },
        createBaseTokenNode: function (kind) { return new (TokenConstructor || (TokenConstructor = ts.objectAllocator.getTokenConstructor()))(kind, -1, -1); },
        createBaseNode: function (kind) { return new (NodeConstructor || (NodeConstructor = ts.objectAllocator.getNodeConstructor()))(kind, -1, -1); },
    };
    /* @internal */
    ts.parseNodeFactory = ts.createNodeFactory(1 /* NodeFactoryFlags.NoParenthesizerRules */, ts.parseBaseNodeFactory);
    function visitNode(cbNode, node) {
        return node && cbNode(node);
    }
    function visitNodes(cbNode, cbNodes, nodes) {
        if (nodes) {
            if (cbNodes) {
                return cbNodes(nodes);
            }
            for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
                var node = nodes_1[_i];
                var result = cbNode(node);
                if (result) {
                    return result;
                }
            }
        }
    }
    /*@internal*/
    function isJSDocLikeText(text, start) {
        return text.charCodeAt(start + 1) === 42 /* CharacterCodes.asterisk */ &&
            text.charCodeAt(start + 2) === 42 /* CharacterCodes.asterisk */ &&
            text.charCodeAt(start + 3) !== 47 /* CharacterCodes.slash */;
    }
    ts.isJSDocLikeText = isJSDocLikeText;
    /*@internal*/
    function isFileProbablyExternalModule(sourceFile) {
        // Try to use the first top-level import/export when available, then
        // fall back to looking for an 'import.meta' somewhere in the tree if necessary.
        return ts.forEach(sourceFile.statements, isAnExternalModuleIndicatorNode) ||
            getImportMetaIfNecessary(sourceFile);
    }
    ts.isFileProbablyExternalModule = isFileProbablyExternalModule;
    function isAnExternalModuleIndicatorNode(node) {
        return ts.canHaveModifiers(node) && hasModifierOfKind(node, 93 /* SyntaxKind.ExportKeyword */)
            || ts.isImportEqualsDeclaration(node) && ts.isExternalModuleReference(node.moduleReference)
            || ts.isImportDeclaration(node)
            || ts.isExportAssignment(node)
            || ts.isExportDeclaration(node) ? node : undefined;
    }
    function getImportMetaIfNecessary(sourceFile) {
        return sourceFile.flags & 4194304 /* NodeFlags.PossiblyContainsImportMeta */ ?
            walkTreeForImportMeta(sourceFile) :
            undefined;
    }
    function walkTreeForImportMeta(node) {
        return isImportMeta(node) ? node : forEachChild(node, walkTreeForImportMeta);
    }
    /** Do not use hasModifier inside the parser; it relies on parent pointers. Use this instead. */
    function hasModifierOfKind(node, kind) {
        return ts.some(node.modifiers, function (m) { return m.kind === kind; });
    }
    function isImportMeta(node) {
        return ts.isMetaProperty(node) && node.keywordToken === 100 /* SyntaxKind.ImportKeyword */ && node.name.escapedText === "meta";
    }
    /**
     * Invokes a callback for each child of the given node. The 'cbNode' callback is invoked for all child nodes
     * stored in properties. If a 'cbNodes' callback is specified, it is invoked for embedded arrays; otherwise,
     * embedded arrays are flattened and the 'cbNode' callback is invoked for each element. If a callback returns
     * a truthy value, iteration stops and that value is returned. Otherwise, undefined is returned.
     *
     * @param node a given node to visit its children
     * @param cbNode a callback to be invoked for all child nodes
     * @param cbNodes a callback to be invoked for embedded array
     *
     * @remarks `forEachChild` must visit the children of a node in the order
     * that they appear in the source code. The language service depends on this property to locate nodes by position.
     */
    function forEachChild(node, cbNode, cbNodes) {
        if (!node || node.kind <= 160 /* SyntaxKind.LastToken */) {
            return;
        }
        switch (node.kind) {
            case 161 /* SyntaxKind.QualifiedName */:
                return visitNode(cbNode, node.left) ||
                    visitNode(cbNode, node.right);
            case 163 /* SyntaxKind.TypeParameter */:
                return visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.constraint) ||
                    visitNode(cbNode, node.default) ||
                    visitNode(cbNode, node.expression);
            case 297 /* SyntaxKind.ShorthandPropertyAssignment */:
                return visitNodes(cbNode, cbNodes, node.illegalDecorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNode(cbNode, node.exclamationToken) ||
                    visitNode(cbNode, node.equalsToken) ||
                    visitNode(cbNode, node.objectAssignmentInitializer);
            case 298 /* SyntaxKind.SpreadAssignment */:
                return visitNode(cbNode, node.expression);
            case 164 /* SyntaxKind.Parameter */:
                return visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.dotDotDotToken) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNode(cbNode, node.type) ||
                    visitNode(cbNode, node.initializer);
            case 167 /* SyntaxKind.PropertyDeclaration */:
                return visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNode(cbNode, node.exclamationToken) ||
                    visitNode(cbNode, node.type) ||
                    visitNode(cbNode, node.initializer);
            case 166 /* SyntaxKind.PropertySignature */:
                return visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNode(cbNode, node.type) ||
                    visitNode(cbNode, node.initializer);
            case 296 /* SyntaxKind.PropertyAssignment */:
                return visitNodes(cbNode, cbNodes, node.illegalDecorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNode(cbNode, node.exclamationToken) ||
                    visitNode(cbNode, node.initializer);
            case 254 /* SyntaxKind.VariableDeclaration */:
                return visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.exclamationToken) ||
                    visitNode(cbNode, node.type) ||
                    visitNode(cbNode, node.initializer);
            case 203 /* SyntaxKind.BindingElement */:
                return visitNode(cbNode, node.dotDotDotToken) ||
                    visitNode(cbNode, node.propertyName) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.initializer);
            case 176 /* SyntaxKind.IndexSignature */:
                return visitNodes(cbNode, cbNodes, node.illegalDecorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    visitNodes(cbNode, cbNodes, node.parameters) ||
                    visitNode(cbNode, node.type);
            case 180 /* SyntaxKind.ConstructorType */:
                return visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    visitNodes(cbNode, cbNodes, node.parameters) ||
                    visitNode(cbNode, node.type);
            case 179 /* SyntaxKind.FunctionType */:
                return visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    visitNodes(cbNode, cbNodes, node.parameters) ||
                    visitNode(cbNode, node.type);
            case 174 /* SyntaxKind.CallSignature */:
            case 175 /* SyntaxKind.ConstructSignature */:
                return visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    visitNodes(cbNode, cbNodes, node.parameters) ||
                    visitNode(cbNode, node.type);
            case 169 /* SyntaxKind.MethodDeclaration */:
                return visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.asteriskToken) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNode(cbNode, node.exclamationToken) ||
                    visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    visitNodes(cbNode, cbNodes, node.parameters) ||
                    visitNode(cbNode, node.type) ||
                    visitNode(cbNode, node.body);
            case 168 /* SyntaxKind.MethodSignature */:
                return visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    visitNodes(cbNode, cbNodes, node.parameters) ||
                    visitNode(cbNode, node.type);
            case 171 /* SyntaxKind.Constructor */:
                return visitNodes(cbNode, cbNodes, node.illegalDecorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    visitNodes(cbNode, cbNodes, node.parameters) ||
                    visitNode(cbNode, node.type) ||
                    visitNode(cbNode, node.body);
            case 172 /* SyntaxKind.GetAccessor */:
                return visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    visitNodes(cbNode, cbNodes, node.parameters) ||
                    visitNode(cbNode, node.type) ||
                    visitNode(cbNode, node.body);
            case 173 /* SyntaxKind.SetAccessor */:
                return visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    visitNodes(cbNode, cbNodes, node.parameters) ||
                    visitNode(cbNode, node.type) ||
                    visitNode(cbNode, node.body);
            case 256 /* SyntaxKind.FunctionDeclaration */:
                return visitNodes(cbNode, cbNodes, node.illegalDecorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.asteriskToken) ||
                    visitNode(cbNode, node.name) ||
                    visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    visitNodes(cbNode, cbNodes, node.parameters) ||
                    visitNode(cbNode, node.type) ||
                    visitNode(cbNode, node.body);
            case 213 /* SyntaxKind.FunctionExpression */:
                return visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.asteriskToken) ||
                    visitNode(cbNode, node.name) ||
                    visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    visitNodes(cbNode, cbNodes, node.parameters) ||
                    visitNode(cbNode, node.type) ||
                    visitNode(cbNode, node.body);
            case 214 /* SyntaxKind.ArrowFunction */:
                return visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    visitNodes(cbNode, cbNodes, node.parameters) ||
                    visitNode(cbNode, node.type) ||
                    visitNode(cbNode, node.equalsGreaterThanToken) ||
                    visitNode(cbNode, node.body);
            case 170 /* SyntaxKind.ClassStaticBlockDeclaration */:
                return visitNodes(cbNode, cbNodes, node.illegalDecorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.body);
            case 178 /* SyntaxKind.TypeReference */:
                return visitNode(cbNode, node.typeName) ||
                    visitNodes(cbNode, cbNodes, node.typeArguments);
            case 177 /* SyntaxKind.TypePredicate */:
                return visitNode(cbNode, node.assertsModifier) ||
                    visitNode(cbNode, node.parameterName) ||
                    visitNode(cbNode, node.type);
            case 181 /* SyntaxKind.TypeQuery */:
                return visitNode(cbNode, node.exprName) ||
                    visitNodes(cbNode, cbNodes, node.typeArguments);
            case 182 /* SyntaxKind.TypeLiteral */:
                return visitNodes(cbNode, cbNodes, node.members);
            case 183 /* SyntaxKind.ArrayType */:
                return visitNode(cbNode, node.elementType);
            case 184 /* SyntaxKind.TupleType */:
                return visitNodes(cbNode, cbNodes, node.elements);
            case 187 /* SyntaxKind.UnionType */:
            case 188 /* SyntaxKind.IntersectionType */:
                return visitNodes(cbNode, cbNodes, node.types);
            case 189 /* SyntaxKind.ConditionalType */:
                return visitNode(cbNode, node.checkType) ||
                    visitNode(cbNode, node.extendsType) ||
                    visitNode(cbNode, node.trueType) ||
                    visitNode(cbNode, node.falseType);
            case 190 /* SyntaxKind.InferType */:
                return visitNode(cbNode, node.typeParameter);
            case 200 /* SyntaxKind.ImportType */:
                return visitNode(cbNode, node.argument) ||
                    visitNode(cbNode, node.assertions) ||
                    visitNode(cbNode, node.qualifier) ||
                    visitNodes(cbNode, cbNodes, node.typeArguments);
            case 295 /* SyntaxKind.ImportTypeAssertionContainer */:
                return visitNode(cbNode, node.assertClause);
            case 191 /* SyntaxKind.ParenthesizedType */:
            case 193 /* SyntaxKind.TypeOperator */:
                return visitNode(cbNode, node.type);
            case 194 /* SyntaxKind.IndexedAccessType */:
                return visitNode(cbNode, node.objectType) ||
                    visitNode(cbNode, node.indexType);
            case 195 /* SyntaxKind.MappedType */:
                return visitNode(cbNode, node.readonlyToken) ||
                    visitNode(cbNode, node.typeParameter) ||
                    visitNode(cbNode, node.nameType) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNode(cbNode, node.type) ||
                    visitNodes(cbNode, cbNodes, node.members);
            case 196 /* SyntaxKind.LiteralType */:
                return visitNode(cbNode, node.literal);
            case 197 /* SyntaxKind.NamedTupleMember */:
                return visitNode(cbNode, node.dotDotDotToken) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNode(cbNode, node.type);
            case 201 /* SyntaxKind.ObjectBindingPattern */:
            case 202 /* SyntaxKind.ArrayBindingPattern */:
                return visitNodes(cbNode, cbNodes, node.elements);
            case 204 /* SyntaxKind.ArrayLiteralExpression */:
                return visitNodes(cbNode, cbNodes, node.elements);
            case 205 /* SyntaxKind.ObjectLiteralExpression */:
                return visitNodes(cbNode, cbNodes, node.properties);
            case 206 /* SyntaxKind.PropertyAccessExpression */:
                return visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.questionDotToken) ||
                    visitNode(cbNode, node.name);
            case 207 /* SyntaxKind.ElementAccessExpression */:
                return visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.questionDotToken) ||
                    visitNode(cbNode, node.argumentExpression);
            case 208 /* SyntaxKind.CallExpression */:
            case 209 /* SyntaxKind.NewExpression */:
                return visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.questionDotToken) ||
                    visitNodes(cbNode, cbNodes, node.typeArguments) ||
                    visitNodes(cbNode, cbNodes, node.arguments);
            case 210 /* SyntaxKind.TaggedTemplateExpression */:
                return visitNode(cbNode, node.tag) ||
                    visitNode(cbNode, node.questionDotToken) ||
                    visitNodes(cbNode, cbNodes, node.typeArguments) ||
                    visitNode(cbNode, node.template);
            case 211 /* SyntaxKind.TypeAssertionExpression */:
                return visitNode(cbNode, node.type) ||
                    visitNode(cbNode, node.expression);
            case 212 /* SyntaxKind.ParenthesizedExpression */:
                return visitNode(cbNode, node.expression);
            case 215 /* SyntaxKind.DeleteExpression */:
                return visitNode(cbNode, node.expression);
            case 216 /* SyntaxKind.TypeOfExpression */:
                return visitNode(cbNode, node.expression);
            case 217 /* SyntaxKind.VoidExpression */:
                return visitNode(cbNode, node.expression);
            case 219 /* SyntaxKind.PrefixUnaryExpression */:
                return visitNode(cbNode, node.operand);
            case 224 /* SyntaxKind.YieldExpression */:
                return visitNode(cbNode, node.asteriskToken) ||
                    visitNode(cbNode, node.expression);
            case 218 /* SyntaxKind.AwaitExpression */:
                return visitNode(cbNode, node.expression);
            case 220 /* SyntaxKind.PostfixUnaryExpression */:
                return visitNode(cbNode, node.operand);
            case 221 /* SyntaxKind.BinaryExpression */:
                return visitNode(cbNode, node.left) ||
                    visitNode(cbNode, node.operatorToken) ||
                    visitNode(cbNode, node.right);
            case 229 /* SyntaxKind.AsExpression */:
                return visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.type);
            case 230 /* SyntaxKind.NonNullExpression */:
                return visitNode(cbNode, node.expression);
            case 231 /* SyntaxKind.MetaProperty */:
                return visitNode(cbNode, node.name);
            case 222 /* SyntaxKind.ConditionalExpression */:
                return visitNode(cbNode, node.condition) ||
                    visitNode(cbNode, node.questionToken) ||
                    visitNode(cbNode, node.whenTrue) ||
                    visitNode(cbNode, node.colonToken) ||
                    visitNode(cbNode, node.whenFalse);
            case 225 /* SyntaxKind.SpreadElement */:
                return visitNode(cbNode, node.expression);
            case 235 /* SyntaxKind.Block */:
            case 262 /* SyntaxKind.ModuleBlock */:
                return visitNodes(cbNode, cbNodes, node.statements);
            case 305 /* SyntaxKind.SourceFile */:
                return visitNodes(cbNode, cbNodes, node.statements) ||
                    visitNode(cbNode, node.endOfFileToken);
            case 237 /* SyntaxKind.VariableStatement */:
                return visitNodes(cbNode, cbNodes, node.illegalDecorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.declarationList);
            case 255 /* SyntaxKind.VariableDeclarationList */:
                return visitNodes(cbNode, cbNodes, node.declarations);
            case 238 /* SyntaxKind.ExpressionStatement */:
                return visitNode(cbNode, node.expression);
            case 239 /* SyntaxKind.IfStatement */:
                return visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.thenStatement) ||
                    visitNode(cbNode, node.elseStatement);
            case 240 /* SyntaxKind.DoStatement */:
                return visitNode(cbNode, node.statement) ||
                    visitNode(cbNode, node.expression);
            case 241 /* SyntaxKind.WhileStatement */:
                return visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.statement);
            case 242 /* SyntaxKind.ForStatement */:
                return visitNode(cbNode, node.initializer) ||
                    visitNode(cbNode, node.condition) ||
                    visitNode(cbNode, node.incrementor) ||
                    visitNode(cbNode, node.statement);
            case 243 /* SyntaxKind.ForInStatement */:
                return visitNode(cbNode, node.initializer) ||
                    visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.statement);
            case 244 /* SyntaxKind.ForOfStatement */:
                return visitNode(cbNode, node.awaitModifier) ||
                    visitNode(cbNode, node.initializer) ||
                    visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.statement);
            case 245 /* SyntaxKind.ContinueStatement */:
            case 246 /* SyntaxKind.BreakStatement */:
                return visitNode(cbNode, node.label);
            case 247 /* SyntaxKind.ReturnStatement */:
                return visitNode(cbNode, node.expression);
            case 248 /* SyntaxKind.WithStatement */:
                return visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.statement);
            case 249 /* SyntaxKind.SwitchStatement */:
                return visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.caseBlock);
            case 263 /* SyntaxKind.CaseBlock */:
                return visitNodes(cbNode, cbNodes, node.clauses);
            case 289 /* SyntaxKind.CaseClause */:
                return visitNode(cbNode, node.expression) ||
                    visitNodes(cbNode, cbNodes, node.statements);
            case 290 /* SyntaxKind.DefaultClause */:
                return visitNodes(cbNode, cbNodes, node.statements);
            case 250 /* SyntaxKind.LabeledStatement */:
                return visitNode(cbNode, node.label) ||
                    visitNode(cbNode, node.statement);
            case 251 /* SyntaxKind.ThrowStatement */:
                return visitNode(cbNode, node.expression);
            case 252 /* SyntaxKind.TryStatement */:
                return visitNode(cbNode, node.tryBlock) ||
                    visitNode(cbNode, node.catchClause) ||
                    visitNode(cbNode, node.finallyBlock);
            case 292 /* SyntaxKind.CatchClause */:
                return visitNode(cbNode, node.variableDeclaration) ||
                    visitNode(cbNode, node.block);
            case 165 /* SyntaxKind.Decorator */:
                return visitNode(cbNode, node.expression);
            case 257 /* SyntaxKind.ClassDeclaration */:
            case 226 /* SyntaxKind.ClassExpression */:
                return visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    visitNodes(cbNode, cbNodes, node.heritageClauses) ||
                    visitNodes(cbNode, cbNodes, node.members);
            case 258 /* SyntaxKind.InterfaceDeclaration */:
                return visitNodes(cbNode, cbNodes, node.illegalDecorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    visitNodes(cbNode, cbNodes, node.heritageClauses) ||
                    visitNodes(cbNode, cbNodes, node.members);
            case 259 /* SyntaxKind.TypeAliasDeclaration */:
                return visitNodes(cbNode, cbNodes, node.illegalDecorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    visitNode(cbNode, node.type);
            case 260 /* SyntaxKind.EnumDeclaration */:
                return visitNodes(cbNode, cbNodes, node.illegalDecorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNodes(cbNode, cbNodes, node.members);
            case 299 /* SyntaxKind.EnumMember */:
                return visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.initializer);
            case 261 /* SyntaxKind.ModuleDeclaration */:
                return visitNodes(cbNode, cbNodes, node.illegalDecorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.body);
            case 265 /* SyntaxKind.ImportEqualsDeclaration */:
                return visitNodes(cbNode, cbNodes, node.illegalDecorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.moduleReference);
            case 266 /* SyntaxKind.ImportDeclaration */:
                return visitNodes(cbNode, cbNodes, node.illegalDecorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.importClause) ||
                    visitNode(cbNode, node.moduleSpecifier) ||
                    visitNode(cbNode, node.assertClause);
            case 267 /* SyntaxKind.ImportClause */:
                return visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.namedBindings);
            case 293 /* SyntaxKind.AssertClause */:
                return visitNodes(cbNode, cbNodes, node.elements);
            case 294 /* SyntaxKind.AssertEntry */:
                return visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.value);
            case 264 /* SyntaxKind.NamespaceExportDeclaration */:
                return visitNodes(cbNode, cbNodes, node.illegalDecorators) ||
                    visitNode(cbNode, node.name);
            case 268 /* SyntaxKind.NamespaceImport */:
                return visitNode(cbNode, node.name);
            case 274 /* SyntaxKind.NamespaceExport */:
                return visitNode(cbNode, node.name);
            case 269 /* SyntaxKind.NamedImports */:
            case 273 /* SyntaxKind.NamedExports */:
                return visitNodes(cbNode, cbNodes, node.elements);
            case 272 /* SyntaxKind.ExportDeclaration */:
                return visitNodes(cbNode, cbNodes, node.illegalDecorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.exportClause) ||
                    visitNode(cbNode, node.moduleSpecifier) ||
                    visitNode(cbNode, node.assertClause);
            case 270 /* SyntaxKind.ImportSpecifier */:
            case 275 /* SyntaxKind.ExportSpecifier */:
                return visitNode(cbNode, node.propertyName) ||
                    visitNode(cbNode, node.name);
            case 271 /* SyntaxKind.ExportAssignment */:
                return visitNodes(cbNode, cbNodes, node.illegalDecorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers) ||
                    visitNode(cbNode, node.expression);
            case 223 /* SyntaxKind.TemplateExpression */:
                return visitNode(cbNode, node.head) ||
                    visitNodes(cbNode, cbNodes, node.templateSpans);
            case 233 /* SyntaxKind.TemplateSpan */:
                return visitNode(cbNode, node.expression) ||
                    visitNode(cbNode, node.literal);
            case 198 /* SyntaxKind.TemplateLiteralType */:
                return visitNode(cbNode, node.head) ||
                    visitNodes(cbNode, cbNodes, node.templateSpans);
            case 199 /* SyntaxKind.TemplateLiteralTypeSpan */:
                return visitNode(cbNode, node.type) ||
                    visitNode(cbNode, node.literal);
            case 162 /* SyntaxKind.ComputedPropertyName */:
                return visitNode(cbNode, node.expression);
            case 291 /* SyntaxKind.HeritageClause */:
                return visitNodes(cbNode, cbNodes, node.types);
            case 228 /* SyntaxKind.ExpressionWithTypeArguments */:
                return visitNode(cbNode, node.expression) ||
                    visitNodes(cbNode, cbNodes, node.typeArguments);
            case 277 /* SyntaxKind.ExternalModuleReference */:
                return visitNode(cbNode, node.expression);
            case 276 /* SyntaxKind.MissingDeclaration */:
                return visitNodes(cbNode, cbNodes, node.illegalDecorators) ||
                    visitNodes(cbNode, cbNodes, node.modifiers);
            case 351 /* SyntaxKind.CommaListExpression */:
                return visitNodes(cbNode, cbNodes, node.elements);
            case 278 /* SyntaxKind.JsxElement */:
                return visitNode(cbNode, node.openingElement) ||
                    visitNodes(cbNode, cbNodes, node.children) ||
                    visitNode(cbNode, node.closingElement);
            case 282 /* SyntaxKind.JsxFragment */:
                return visitNode(cbNode, node.openingFragment) ||
                    visitNodes(cbNode, cbNodes, node.children) ||
                    visitNode(cbNode, node.closingFragment);
            case 279 /* SyntaxKind.JsxSelfClosingElement */:
            case 280 /* SyntaxKind.JsxOpeningElement */:
                return visitNode(cbNode, node.tagName) ||
                    visitNodes(cbNode, cbNodes, node.typeArguments) ||
                    visitNode(cbNode, node.attributes);
            case 286 /* SyntaxKind.JsxAttributes */:
                return visitNodes(cbNode, cbNodes, node.properties);
            case 285 /* SyntaxKind.JsxAttribute */:
                return visitNode(cbNode, node.name) ||
                    visitNode(cbNode, node.initializer);
            case 287 /* SyntaxKind.JsxSpreadAttribute */:
                return visitNode(cbNode, node.expression);
            case 288 /* SyntaxKind.JsxExpression */:
                return visitNode(cbNode, node.dotDotDotToken) ||
                    visitNode(cbNode, node.expression);
            case 281 /* SyntaxKind.JsxClosingElement */:
                return visitNode(cbNode, node.tagName);
            case 185 /* SyntaxKind.OptionalType */:
            case 186 /* SyntaxKind.RestType */:
            case 309 /* SyntaxKind.JSDocTypeExpression */:
            case 315 /* SyntaxKind.JSDocNonNullableType */:
            case 314 /* SyntaxKind.JSDocNullableType */:
            case 316 /* SyntaxKind.JSDocOptionalType */:
            case 318 /* SyntaxKind.JSDocVariadicType */:
                return visitNode(cbNode, node.type);
            case 317 /* SyntaxKind.JSDocFunctionType */:
                return visitNodes(cbNode, cbNodes, node.parameters) ||
                    visitNode(cbNode, node.type);
            case 320 /* SyntaxKind.JSDoc */:
                return (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment))
                    || visitNodes(cbNode, cbNodes, node.tags);
            case 346 /* SyntaxKind.JSDocSeeTag */:
                return visitNode(cbNode, node.tagName) ||
                    visitNode(cbNode, node.name) ||
                    (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment));
            case 310 /* SyntaxKind.JSDocNameReference */:
                return visitNode(cbNode, node.name);
            case 311 /* SyntaxKind.JSDocMemberName */:
                return visitNode(cbNode, node.left) ||
                    visitNode(cbNode, node.right);
            case 340 /* SyntaxKind.JSDocParameterTag */:
            case 347 /* SyntaxKind.JSDocPropertyTag */:
                return visitNode(cbNode, node.tagName) ||
                    (node.isNameFirst
                        ? visitNode(cbNode, node.name) ||
                            visitNode(cbNode, node.typeExpression) ||
                            (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment))
                        : visitNode(cbNode, node.typeExpression) ||
                            visitNode(cbNode, node.name) ||
                            (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment)));
            case 330 /* SyntaxKind.JSDocAuthorTag */:
                return visitNode(cbNode, node.tagName) ||
                    (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment));
            case 329 /* SyntaxKind.JSDocImplementsTag */:
                return visitNode(cbNode, node.tagName) ||
                    visitNode(cbNode, node.class) ||
                    (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment));
            case 328 /* SyntaxKind.JSDocAugmentsTag */:
                return visitNode(cbNode, node.tagName) ||
                    visitNode(cbNode, node.class) ||
                    (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment));
            case 344 /* SyntaxKind.JSDocTemplateTag */:
                return visitNode(cbNode, node.tagName) ||
                    visitNode(cbNode, node.constraint) ||
                    visitNodes(cbNode, cbNodes, node.typeParameters) ||
                    (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment));
            case 345 /* SyntaxKind.JSDocTypedefTag */:
                return visitNode(cbNode, node.tagName) ||
                    (node.typeExpression &&
                        node.typeExpression.kind === 309 /* SyntaxKind.JSDocTypeExpression */
                        ? visitNode(cbNode, node.typeExpression) ||
                            visitNode(cbNode, node.fullName) ||
                            (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment))
                        : visitNode(cbNode, node.fullName) ||
                            visitNode(cbNode, node.typeExpression) ||
                            (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment)));
            case 338 /* SyntaxKind.JSDocCallbackTag */:
                return visitNode(cbNode, node.tagName) ||
                    visitNode(cbNode, node.fullName) ||
                    visitNode(cbNode, node.typeExpression) ||
                    (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment));
            case 341 /* SyntaxKind.JSDocReturnTag */:
            case 343 /* SyntaxKind.JSDocTypeTag */:
            case 342 /* SyntaxKind.JSDocThisTag */:
            case 339 /* SyntaxKind.JSDocEnumTag */:
                return visitNode(cbNode, node.tagName) ||
                    visitNode(cbNode, node.typeExpression) ||
                    (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment));
            case 323 /* SyntaxKind.JSDocSignature */:
                return ts.forEach(node.typeParameters, cbNode) ||
                    ts.forEach(node.parameters, cbNode) ||
                    visitNode(cbNode, node.type);
            case 324 /* SyntaxKind.JSDocLink */:
            case 325 /* SyntaxKind.JSDocLinkCode */:
            case 326 /* SyntaxKind.JSDocLinkPlain */:
                return visitNode(cbNode, node.name);
            case 322 /* SyntaxKind.JSDocTypeLiteral */:
                return ts.forEach(node.jsDocPropertyTags, cbNode);
            case 327 /* SyntaxKind.JSDocTag */:
            case 332 /* SyntaxKind.JSDocClassTag */:
            case 333 /* SyntaxKind.JSDocPublicTag */:
            case 334 /* SyntaxKind.JSDocPrivateTag */:
            case 335 /* SyntaxKind.JSDocProtectedTag */:
            case 336 /* SyntaxKind.JSDocReadonlyTag */:
            case 331 /* SyntaxKind.JSDocDeprecatedTag */:
                return visitNode(cbNode, node.tagName)
                    || (typeof node.comment === "string" ? undefined : visitNodes(cbNode, cbNodes, node.comment));
            case 350 /* SyntaxKind.PartiallyEmittedExpression */:
                return visitNode(cbNode, node.expression);
        }
    }
    ts.forEachChild = forEachChild;
    /** @internal */
    /**
     * Invokes a callback for each child of the given node. The 'cbNode' callback is invoked for all child nodes
     * stored in properties. If a 'cbNodes' callback is specified, it is invoked for embedded arrays; additionally,
     * unlike `forEachChild`, embedded arrays are flattened and the 'cbNode' callback is invoked for each element.
     *  If a callback returns a truthy value, iteration stops and that value is returned. Otherwise, undefined is returned.
     *
     * @param node a given node to visit its children
     * @param cbNode a callback to be invoked for all child nodes
     * @param cbNodes a callback to be invoked for embedded array
     *
     * @remarks Unlike `forEachChild`, `forEachChildRecursively` handles recursively invoking the traversal on each child node found,
     * and while doing so, handles traversing the structure without relying on the callstack to encode the tree structure.
     */
    function forEachChildRecursively(rootNode, cbNode, cbNodes) {
        var queue = gatherPossibleChildren(rootNode);
        var parents = []; // tracks parent references for elements in queue
        while (parents.length < queue.length) {
            parents.push(rootNode);
        }
        while (queue.length !== 0) {
            var current = queue.pop();
            var parent = parents.pop();
            if (ts.isArray(current)) {
                if (cbNodes) {
                    var res = cbNodes(current, parent);
                    if (res) {
                        if (res === "skip")
                            continue;
                        return res;
                    }
                }
                for (var i = current.length - 1; i >= 0; --i) {
                    queue.push(current[i]);
                    parents.push(parent);
                }
            }
            else {
                var res = cbNode(current, parent);
                if (res) {
                    if (res === "skip")
                        continue;
                    return res;
                }
                if (current.kind >= 161 /* SyntaxKind.FirstNode */) {
                    // add children in reverse order to the queue, so popping gives the first child
                    for (var _i = 0, _a = gatherPossibleChildren(current); _i < _a.length; _i++) {
                        var child = _a[_i];
                        queue.push(child);
                        parents.push(current);
                    }
                }
            }
        }
    }
    ts.forEachChildRecursively = forEachChildRecursively;
    function gatherPossibleChildren(node) {
        var children = [];
        forEachChild(node, addWorkItem, addWorkItem); // By using a stack above and `unshift` here, we emulate a depth-first preorder traversal
        return children;
        function addWorkItem(n) {
            children.unshift(n);
        }
    }
    function setExternalModuleIndicator(sourceFile) {
        sourceFile.externalModuleIndicator = isFileProbablyExternalModule(sourceFile);
    }
    function createSourceFile(fileName, sourceText, languageVersionOrOptions, setParentNodes, scriptKind) {
        if (setParentNodes === void 0) { setParentNodes = false; }
        ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("parse" /* tracing.Phase.Parse */, "createSourceFile", { path: fileName }, /*separateBeginAndEnd*/ true);
        ts.performance.mark("beforeParse");
        var result;
        ts.perfLogger.logStartParseSourceFile(fileName);
        var _a = typeof languageVersionOrOptions === "object" ? languageVersionOrOptions : { languageVersion: languageVersionOrOptions }, languageVersion = _a.languageVersion, overrideSetExternalModuleIndicator = _a.setExternalModuleIndicator, format = _a.impliedNodeFormat;
        if (languageVersion === 100 /* ScriptTarget.JSON */) {
            result = Parser.parseSourceFile(fileName, sourceText, languageVersion, /*syntaxCursor*/ undefined, setParentNodes, 6 /* ScriptKind.JSON */, ts.noop);
        }
        else {
            var setIndicator = format === undefined ? overrideSetExternalModuleIndicator : function (file) {
                file.impliedNodeFormat = format;
                return (overrideSetExternalModuleIndicator || setExternalModuleIndicator)(file);
            };
            result = Parser.parseSourceFile(fileName, sourceText, languageVersion, /*syntaxCursor*/ undefined, setParentNodes, scriptKind, setIndicator);
        }
        ts.perfLogger.logStopParseSourceFile();
        ts.performance.mark("afterParse");
        ts.performance.measure("Parse", "beforeParse", "afterParse");
        ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
        return result;
    }
    ts.createSourceFile = createSourceFile;
    function parseIsolatedEntityName(text, languageVersion) {
        return Parser.parseIsolatedEntityName(text, languageVersion);
    }
    ts.parseIsolatedEntityName = parseIsolatedEntityName;
    /**
     * Parse json text into SyntaxTree and return node and parse errors if any
     * @param fileName
     * @param sourceText
     */
    function parseJsonText(fileName, sourceText) {
        return Parser.parseJsonText(fileName, sourceText);
    }
    ts.parseJsonText = parseJsonText;
    // See also `isExternalOrCommonJsModule` in utilities.ts
    function isExternalModule(file) {
        return file.externalModuleIndicator !== undefined;
    }
    ts.isExternalModule = isExternalModule;
    // Produces a new SourceFile for the 'newText' provided. The 'textChangeRange' parameter
    // indicates what changed between the 'text' that this SourceFile has and the 'newText'.
    // The SourceFile will be created with the compiler attempting to reuse as many nodes from
    // this file as possible.
    //
    // Note: this function mutates nodes from this SourceFile. That means any existing nodes
    // from this SourceFile that are being held onto may change as a result (including
    // becoming detached from any SourceFile).  It is recommended that this SourceFile not
    // be used once 'update' is called on it.
    function updateSourceFile(sourceFile, newText, textChangeRange, aggressiveChecks) {
        if (aggressiveChecks === void 0) { aggressiveChecks = false; }
        var newSourceFile = IncrementalParser.updateSourceFile(sourceFile, newText, textChangeRange, aggressiveChecks);
        // Because new source file node is created, it may not have the flag PossiblyContainDynamicImport. This is the case if there is no new edit to add dynamic import.
        // We will manually port the flag to the new source file.
        newSourceFile.flags |= (sourceFile.flags & 6291456 /* NodeFlags.PermanentlySetIncrementalFlags */);
        return newSourceFile;
    }
    ts.updateSourceFile = updateSourceFile;
    /* @internal */
    function parseIsolatedJSDocComment(content, start, length) {
        var result = Parser.JSDocParser.parseIsolatedJSDocComment(content, start, length);
        if (result && result.jsDoc) {
            // because the jsDocComment was parsed out of the source file, it might
            // not be covered by the fixupParentReferences.
            Parser.fixupParentReferences(result.jsDoc);
        }
        return result;
    }
    ts.parseIsolatedJSDocComment = parseIsolatedJSDocComment;
    /* @internal */
    // Exposed only for testing.
    function parseJSDocTypeExpressionForTests(content, start, length) {
        return Parser.JSDocParser.parseJSDocTypeExpressionForTests(content, start, length);
    }
    ts.parseJSDocTypeExpressionForTests = parseJSDocTypeExpressionForTests;
    // Implement the parser as a singleton module.  We do this for perf reasons because creating
    // parser instances can actually be expensive enough to impact us on projects with many source
    // files.
    var Parser;
    (function (Parser) {
        // Share a single scanner across all calls to parse a source file.  This helps speed things
        // up by avoiding the cost of creating/compiling scanners over and over again.
        var scanner = ts.createScanner(99 /* ScriptTarget.Latest */, /*skipTrivia*/ true);
        var disallowInAndDecoratorContext = 4096 /* NodeFlags.DisallowInContext */ | 16384 /* NodeFlags.DecoratorContext */;
        // capture constructors in 'initializeState' to avoid null checks
        // tslint:disable variable-name
        var NodeConstructor;
        var TokenConstructor;
        var IdentifierConstructor;
        var PrivateIdentifierConstructor;
        var SourceFileConstructor;
        // tslint:enable variable-name
        function countNode(node) {
            nodeCount++;
            return node;
        }
        // Rather than using `createBaseNodeFactory` here, we establish a `BaseNodeFactory` that closes over the
        // constructors above, which are reset each time `initializeState` is called.
        var baseNodeFactory = {
            createBaseSourceFileNode: function (kind) { return countNode(new SourceFileConstructor(kind, /*pos*/ 0, /*end*/ 0)); },
            createBaseIdentifierNode: function (kind) { return countNode(new IdentifierConstructor(kind, /*pos*/ 0, /*end*/ 0)); },
            createBasePrivateIdentifierNode: function (kind) { return countNode(new PrivateIdentifierConstructor(kind, /*pos*/ 0, /*end*/ 0)); },
            createBaseTokenNode: function (kind) { return countNode(new TokenConstructor(kind, /*pos*/ 0, /*end*/ 0)); },
            createBaseNode: function (kind) { return countNode(new NodeConstructor(kind, /*pos*/ 0, /*end*/ 0)); }
        };
        var factory = ts.createNodeFactory(1 /* NodeFactoryFlags.NoParenthesizerRules */ | 2 /* NodeFactoryFlags.NoNodeConverters */ | 8 /* NodeFactoryFlags.NoOriginalNode */, baseNodeFactory);
        var fileName;
        var sourceFlags;
        var sourceText;
        var languageVersion;
        var scriptKind;
        var languageVariant;
        var parseDiagnostics;
        var jsDocDiagnostics;
        var syntaxCursor;
        var currentToken;
        var nodeCount;
        var identifiers;
        var privateIdentifiers;
        var identifierCount;
        var parsingContext;
        var notParenthesizedArrow;
        // Flags that dictate what parsing context we're in.  For example:
        // Whether or not we are in strict parsing mode.  All that changes in strict parsing mode is
        // that some tokens that would be considered identifiers may be considered keywords.
        //
        // When adding more parser context flags, consider which is the more common case that the
        // flag will be in.  This should be the 'false' state for that flag.  The reason for this is
        // that we don't store data in our nodes unless the value is in the *non-default* state.  So,
        // for example, more often than code 'allows-in' (or doesn't 'disallow-in').  We opt for
        // 'disallow-in' set to 'false'.  Otherwise, if we had 'allowsIn' set to 'true', then almost
        // all nodes would need extra state on them to store this info.
        //
        // Note: 'allowIn' and 'allowYield' track 1:1 with the [in] and [yield] concepts in the ES6
        // grammar specification.
        //
        // An important thing about these context concepts.  By default they are effectively inherited
        // while parsing through every grammar production.  i.e. if you don't change them, then when
        // you parse a sub-production, it will have the same context values as the parent production.
        // This is great most of the time.  After all, consider all the 'expression' grammar productions
        // and how nearly all of them pass along the 'in' and 'yield' context values:
        //
        // EqualityExpression[In, Yield] :
        //      RelationalExpression[?In, ?Yield]
        //      EqualityExpression[?In, ?Yield] == RelationalExpression[?In, ?Yield]
        //      EqualityExpression[?In, ?Yield] != RelationalExpression[?In, ?Yield]
        //      EqualityExpression[?In, ?Yield] === RelationalExpression[?In, ?Yield]
        //      EqualityExpression[?In, ?Yield] !== RelationalExpression[?In, ?Yield]
        //
        // Where you have to be careful is then understanding what the points are in the grammar
        // where the values are *not* passed along.  For example:
        //
        // SingleNameBinding[Yield,GeneratorParameter]
        //      [+GeneratorParameter]BindingIdentifier[Yield] Initializer[In]opt
        //      [~GeneratorParameter]BindingIdentifier[?Yield]Initializer[In, ?Yield]opt
        //
        // Here this is saying that if the GeneratorParameter context flag is set, that we should
        // explicitly set the 'yield' context flag to false before calling into the BindingIdentifier
        // and we should explicitly unset the 'yield' context flag before calling into the Initializer.
        // production.  Conversely, if the GeneratorParameter context flag is not set, then we
        // should leave the 'yield' context flag alone.
        //
        // Getting this all correct is tricky and requires careful reading of the grammar to
        // understand when these values should be changed versus when they should be inherited.
        //
        // Note: it should not be necessary to save/restore these flags during speculative/lookahead
        // parsing.  These context flags are naturally stored and restored through normal recursive
        // descent parsing and unwinding.
        var contextFlags;
        // Indicates whether we are currently parsing top-level statements.
        var topLevel = true;
        // Whether or not we've had a parse error since creating the last AST node.  If we have
        // encountered an error, it will be stored on the next AST node we create.  Parse errors
        // can be broken down into three categories:
        //
        // 1) An error that occurred during scanning.  For example, an unterminated literal, or a
        //    character that was completely not understood.
        //
        // 2) A token was expected, but was not present.  This type of error is commonly produced
        //    by the 'parseExpected' function.
        //
        // 3) A token was present that no parsing function was able to consume.  This type of error
        //    only occurs in the 'abortParsingListOrMoveToNextToken' function when the parser
        //    decides to skip the token.
        //
        // In all of these cases, we want to mark the next node as having had an error before it.
        // With this mark, we can know in incremental settings if this node can be reused, or if
        // we have to reparse it.  If we don't keep this information around, we may just reuse the
        // node.  in that event we would then not produce the same errors as we did before, causing
        // significant confusion problems.
        //
        // Note: it is necessary that this value be saved/restored during speculative/lookahead
        // parsing.  During lookahead parsing, we will often create a node.  That node will have
        // this value attached, and then this value will be set back to 'false'.  If we decide to
        // rewind, we must get back to the same value we had prior to the lookahead.
        //
        // Note: any errors at the end of the file that do not precede a regular node, should get
        // attached to the EOF token.
        var parseErrorBeforeNextFinishedNode = false;
        function parseSourceFile(fileName, sourceText, languageVersion, syntaxCursor, setParentNodes, scriptKind, setExternalModuleIndicatorOverride) {
            var _a;
            if (setParentNodes === void 0) { setParentNodes = false; }
            scriptKind = ts.ensureScriptKind(fileName, scriptKind);
            if (scriptKind === 6 /* ScriptKind.JSON */) {
                var result_3 = parseJsonText(fileName, sourceText, languageVersion, syntaxCursor, setParentNodes);
                ts.convertToObjectWorker(result_3, (_a = result_3.statements[0]) === null || _a === void 0 ? void 0 : _a.expression, result_3.parseDiagnostics, /*returnValue*/ false, /*knownRootOptions*/ undefined, /*jsonConversionNotifier*/ undefined);
                result_3.referencedFiles = ts.emptyArray;
                result_3.typeReferenceDirectives = ts.emptyArray;
                result_3.libReferenceDirectives = ts.emptyArray;
                result_3.amdDependencies = ts.emptyArray;
                result_3.hasNoDefaultLib = false;
                result_3.pragmas = ts.emptyMap;
                return result_3;
            }
            initializeState(fileName, sourceText, languageVersion, syntaxCursor, scriptKind);
            var result = parseSourceFileWorker(languageVersion, setParentNodes, scriptKind, setExternalModuleIndicatorOverride || setExternalModuleIndicator);
            clearState();
            return result;
        }
        Parser.parseSourceFile = parseSourceFile;
        function parseIsolatedEntityName(content, languageVersion) {
            // Choice of `isDeclarationFile` should be arbitrary
            initializeState("", content, languageVersion, /*syntaxCursor*/ undefined, 1 /* ScriptKind.JS */);
            // Prime the scanner.
            nextToken();
            var entityName = parseEntityName(/*allowReservedWords*/ true);
            var isInvalid = token() === 1 /* SyntaxKind.EndOfFileToken */ && !parseDiagnostics.length;
            clearState();
            return isInvalid ? entityName : undefined;
        }
        Parser.parseIsolatedEntityName = parseIsolatedEntityName;
        function parseJsonText(fileName, sourceText, languageVersion, syntaxCursor, setParentNodes) {
            if (languageVersion === void 0) { languageVersion = 2 /* ScriptTarget.ES2015 */; }
            if (setParentNodes === void 0) { setParentNodes = false; }
            initializeState(fileName, sourceText, languageVersion, syntaxCursor, 6 /* ScriptKind.JSON */);
            sourceFlags = contextFlags;
            // Prime the scanner.
            nextToken();
            var pos = getNodePos();
            var statements, endOfFileToken;
            if (token() === 1 /* SyntaxKind.EndOfFileToken */) {
                statements = createNodeArray([], pos, pos);
                endOfFileToken = parseTokenNode();
            }
            else {
                // Loop and synthesize an ArrayLiteralExpression if there are more than
                // one top-level expressions to ensure all input text is consumed.
                var expressions = void 0;
                while (token() !== 1 /* SyntaxKind.EndOfFileToken */) {
                    var expression_1 = void 0;
                    switch (token()) {
                        case 22 /* SyntaxKind.OpenBracketToken */:
                            expression_1 = parseArrayLiteralExpression();
                            break;
                        case 110 /* SyntaxKind.TrueKeyword */:
                        case 95 /* SyntaxKind.FalseKeyword */:
                        case 104 /* SyntaxKind.NullKeyword */:
                            expression_1 = parseTokenNode();
                            break;
                        case 40 /* SyntaxKind.MinusToken */:
                            if (lookAhead(function () { return nextToken() === 8 /* SyntaxKind.NumericLiteral */ && nextToken() !== 58 /* SyntaxKind.ColonToken */; })) {
                                expression_1 = parsePrefixUnaryExpression();
                            }
                            else {
                                expression_1 = parseObjectLiteralExpression();
                            }
                            break;
                        case 8 /* SyntaxKind.NumericLiteral */:
                        case 10 /* SyntaxKind.StringLiteral */:
                            if (lookAhead(function () { return nextToken() !== 58 /* SyntaxKind.ColonToken */; })) {
                                expression_1 = parseLiteralNode();
                                break;
                            }
                        // falls through
                        default:
                            expression_1 = parseObjectLiteralExpression();
                            break;
                    }
                    // Error recovery: collect multiple top-level expressions
                    if (expressions && ts.isArray(expressions)) {
                        expressions.push(expression_1);
                    }
                    else if (expressions) {
                        expressions = [expressions, expression_1];
                    }
                    else {
                        expressions = expression_1;
                        if (token() !== 1 /* SyntaxKind.EndOfFileToken */) {
                            parseErrorAtCurrentToken(ts.Diagnostics.Unexpected_token);
                        }
                    }
                }
                var expression = ts.isArray(expressions) ? finishNode(factory.createArrayLiteralExpression(expressions), pos) : ts.Debug.checkDefined(expressions);
                var statement = factory.createExpressionStatement(expression);
                finishNode(statement, pos);
                statements = createNodeArray([statement], pos);
                endOfFileToken = parseExpectedToken(1 /* SyntaxKind.EndOfFileToken */, ts.Diagnostics.Unexpected_token);
            }
            // Set source file so that errors will be reported with this file name
            var sourceFile = createSourceFile(fileName, 2 /* ScriptTarget.ES2015 */, 6 /* ScriptKind.JSON */, /*isDeclaration*/ false, statements, endOfFileToken, sourceFlags, ts.noop);
            if (setParentNodes) {
                fixupParentReferences(sourceFile);
            }
            sourceFile.nodeCount = nodeCount;
            sourceFile.identifierCount = identifierCount;
            sourceFile.identifiers = identifiers;
            sourceFile.parseDiagnostics = ts.attachFileToDiagnostics(parseDiagnostics, sourceFile);
            if (jsDocDiagnostics) {
                sourceFile.jsDocDiagnostics = ts.attachFileToDiagnostics(jsDocDiagnostics, sourceFile);
            }
            var result = sourceFile;
            clearState();
            return result;
        }
        Parser.parseJsonText = parseJsonText;
        function initializeState(_fileName, _sourceText, _languageVersion, _syntaxCursor, _scriptKind) {
            NodeConstructor = ts.objectAllocator.getNodeConstructor();
            TokenConstructor = ts.objectAllocator.getTokenConstructor();
            IdentifierConstructor = ts.objectAllocator.getIdentifierConstructor();
            PrivateIdentifierConstructor = ts.objectAllocator.getPrivateIdentifierConstructor();
            SourceFileConstructor = ts.objectAllocator.getSourceFileConstructor();
            fileName = ts.normalizePath(_fileName);
            sourceText = _sourceText;
            languageVersion = _languageVersion;
            syntaxCursor = _syntaxCursor;
            scriptKind = _scriptKind;
            languageVariant = ts.getLanguageVariant(_scriptKind);
            parseDiagnostics = [];
            parsingContext = 0;
            identifiers = new ts.Map();
            privateIdentifiers = new ts.Map();
            identifierCount = 0;
            nodeCount = 0;
            sourceFlags = 0;
            topLevel = true;
            switch (scriptKind) {
                case 1 /* ScriptKind.JS */:
                case 2 /* ScriptKind.JSX */:
                    contextFlags = 262144 /* NodeFlags.JavaScriptFile */;
                    break;
                case 6 /* ScriptKind.JSON */:
                    contextFlags = 262144 /* NodeFlags.JavaScriptFile */ | 67108864 /* NodeFlags.JsonFile */;
                    break;
                default:
                    contextFlags = 0 /* NodeFlags.None */;
                    break;
            }
            parseErrorBeforeNextFinishedNode = false;
            // Initialize and prime the scanner before parsing the source elements.
            scanner.setText(sourceText);
            scanner.setOnError(scanError);
            scanner.setScriptTarget(languageVersion);
            scanner.setLanguageVariant(languageVariant);
        }
        function clearState() {
            // Clear out the text the scanner is pointing at, so it doesn't keep anything alive unnecessarily.
            scanner.clearCommentDirectives();
            scanner.setText("");
            scanner.setOnError(undefined);
            // Clear any data.  We don't want to accidentally hold onto it for too long.
            sourceText = undefined;
            languageVersion = undefined;
            syntaxCursor = undefined;
            scriptKind = undefined;
            languageVariant = undefined;
            sourceFlags = 0;
            parseDiagnostics = undefined;
            jsDocDiagnostics = undefined;
            parsingContext = 0;
            identifiers = undefined;
            notParenthesizedArrow = undefined;
            topLevel = true;
        }
        function parseSourceFileWorker(languageVersion, setParentNodes, scriptKind, setExternalModuleIndicator) {
            var isDeclarationFile = isDeclarationFileName(fileName);
            if (isDeclarationFile) {
                contextFlags |= 16777216 /* NodeFlags.Ambient */;
            }
            sourceFlags = contextFlags;
            // Prime the scanner.
            nextToken();
            var statements = parseList(0 /* ParsingContext.SourceElements */, parseStatement);
            ts.Debug.assert(token() === 1 /* SyntaxKind.EndOfFileToken */);
            var endOfFileToken = addJSDocComment(parseTokenNode());
            var sourceFile = createSourceFile(fileName, languageVersion, scriptKind, isDeclarationFile, statements, endOfFileToken, sourceFlags, setExternalModuleIndicator);
            // A member of ReadonlyArray<T> isn't assignable to a member of T[] (and prevents a direct cast) - but this is where we set up those members so they can be readonly in the future
            processCommentPragmas(sourceFile, sourceText);
            processPragmasIntoFields(sourceFile, reportPragmaDiagnostic);
            sourceFile.commentDirectives = scanner.getCommentDirectives();
            sourceFile.nodeCount = nodeCount;
            sourceFile.identifierCount = identifierCount;
            sourceFile.identifiers = identifiers;
            sourceFile.parseDiagnostics = ts.attachFileToDiagnostics(parseDiagnostics, sourceFile);
            if (jsDocDiagnostics) {
                sourceFile.jsDocDiagnostics = ts.attachFileToDiagnostics(jsDocDiagnostics, sourceFile);
            }
            if (setParentNodes) {
                fixupParentReferences(sourceFile);
            }
            return sourceFile;
            function reportPragmaDiagnostic(pos, end, diagnostic) {
                parseDiagnostics.push(ts.createDetachedDiagnostic(fileName, pos, end, diagnostic));
            }
        }
        function withJSDoc(node, hasJSDoc) {
            return hasJSDoc ? addJSDocComment(node) : node;
        }
        var hasDeprecatedTag = false;
        function addJSDocComment(node) {
            ts.Debug.assert(!node.jsDoc); // Should only be called once per node
            var jsDoc = ts.mapDefined(ts.getJSDocCommentRanges(node, sourceText), function (comment) { return JSDocParser.parseJSDocComment(node, comment.pos, comment.end - comment.pos); });
            if (jsDoc.length)
                node.jsDoc = jsDoc;
            if (hasDeprecatedTag) {
                hasDeprecatedTag = false;
                node.flags |= 268435456 /* NodeFlags.Deprecated */;
            }
            return node;
        }
        function reparseTopLevelAwait(sourceFile) {
            var savedSyntaxCursor = syntaxCursor;
            var baseSyntaxCursor = IncrementalParser.createSyntaxCursor(sourceFile);
            syntaxCursor = { currentNode: currentNode };
            var statements = [];
            var savedParseDiagnostics = parseDiagnostics;
            parseDiagnostics = [];
            var pos = 0;
            var start = findNextStatementWithAwait(sourceFile.statements, 0);
            var _loop_3 = function () {
                // append all statements between pos and start
                var prevStatement = sourceFile.statements[pos];
                var nextStatement = sourceFile.statements[start];
                ts.addRange(statements, sourceFile.statements, pos, start);
                pos = findNextStatementWithoutAwait(sourceFile.statements, start);
                // append all diagnostics associated with the copied range
                var diagnosticStart = ts.findIndex(savedParseDiagnostics, function (diagnostic) { return diagnostic.start >= prevStatement.pos; });
                var diagnosticEnd = diagnosticStart >= 0 ? ts.findIndex(savedParseDiagnostics, function (diagnostic) { return diagnostic.start >= nextStatement.pos; }, diagnosticStart) : -1;
                if (diagnosticStart >= 0) {
                    ts.addRange(parseDiagnostics, savedParseDiagnostics, diagnosticStart, diagnosticEnd >= 0 ? diagnosticEnd : undefined);
                }
                // reparse all statements between start and pos. We skip existing diagnostics for the same range and allow the parser to generate new ones.
                speculationHelper(function () {
                    var savedContextFlags = contextFlags;
                    contextFlags |= 32768 /* NodeFlags.AwaitContext */;
                    scanner.setTextPos(nextStatement.pos);
                    nextToken();
                    while (token() !== 1 /* SyntaxKind.EndOfFileToken */) {
                        var startPos = scanner.getStartPos();
                        var statement = parseListElement(0 /* ParsingContext.SourceElements */, parseStatement);
                        statements.push(statement);
                        if (startPos === scanner.getStartPos()) {
                            nextToken();
                        }
                        if (pos >= 0) {
                            var nonAwaitStatement = sourceFile.statements[pos];
                            if (statement.end === nonAwaitStatement.pos) {
                                // done reparsing this section
                                break;
                            }
                            if (statement.end > nonAwaitStatement.pos) {
                                // we ate into the next statement, so we must reparse it.
                                pos = findNextStatementWithoutAwait(sourceFile.statements, pos + 1);
                            }
                        }
                    }
                    contextFlags = savedContextFlags;
                }, 2 /* SpeculationKind.Reparse */);
                // find the next statement containing an `await`
                start = pos >= 0 ? findNextStatementWithAwait(sourceFile.statements, pos) : -1;
            };
            while (start !== -1) {
                _loop_3();
            }
            // append all statements between pos and the end of the list
            if (pos >= 0) {
                var prevStatement_1 = sourceFile.statements[pos];
                ts.addRange(statements, sourceFile.statements, pos);
                // append all diagnostics associated with the copied range
                var diagnosticStart = ts.findIndex(savedParseDiagnostics, function (diagnostic) { return diagnostic.start >= prevStatement_1.pos; });
                if (diagnosticStart >= 0) {
                    ts.addRange(parseDiagnostics, savedParseDiagnostics, diagnosticStart);
                }
            }
            syntaxCursor = savedSyntaxCursor;
            return factory.updateSourceFile(sourceFile, ts.setTextRange(factory.createNodeArray(statements), sourceFile.statements));
            function containsPossibleTopLevelAwait(node) {
                return !(node.flags & 32768 /* NodeFlags.AwaitContext */)
                    && !!(node.transformFlags & 67108864 /* TransformFlags.ContainsPossibleTopLevelAwait */);
            }
            function findNextStatementWithAwait(statements, start) {
                for (var i = start; i < statements.length; i++) {
                    if (containsPossibleTopLevelAwait(statements[i])) {
                        return i;
                    }
                }
                return -1;
            }
            function findNextStatementWithoutAwait(statements, start) {
                for (var i = start; i < statements.length; i++) {
                    if (!containsPossibleTopLevelAwait(statements[i])) {
                        return i;
                    }
                }
                return -1;
            }
            function currentNode(position) {
                var node = baseSyntaxCursor.currentNode(position);
                if (topLevel && node && containsPossibleTopLevelAwait(node)) {
                    node.intersectsChange = true;
                }
                return node;
            }
        }
        function fixupParentReferences(rootNode) {
            // normally parent references are set during binding. However, for clients that only need
            // a syntax tree, and no semantic features, then the binding process is an unnecessary
            // overhead.  This functions allows us to set all the parents, without all the expense of
            // binding.
            ts.setParentRecursive(rootNode, /*incremental*/ true);
        }
        Parser.fixupParentReferences = fixupParentReferences;
        function createSourceFile(fileName, languageVersion, scriptKind, isDeclarationFile, statements, endOfFileToken, flags, setExternalModuleIndicator) {
            // code from createNode is inlined here so createNode won't have to deal with special case of creating source files
            // this is quite rare comparing to other nodes and createNode should be as fast as possible
            var sourceFile = factory.createSourceFile(statements, endOfFileToken, flags);
            ts.setTextRangePosWidth(sourceFile, 0, sourceText.length);
            setFields(sourceFile);
            // If we parsed this as an external module, it may contain top-level await
            if (!isDeclarationFile && isExternalModule(sourceFile) && sourceFile.transformFlags & 67108864 /* TransformFlags.ContainsPossibleTopLevelAwait */) {
                sourceFile = reparseTopLevelAwait(sourceFile);
                setFields(sourceFile);
            }
            return sourceFile;
            function setFields(sourceFile) {
                sourceFile.text = sourceText;
                sourceFile.bindDiagnostics = [];
                sourceFile.bindSuggestionDiagnostics = undefined;
                sourceFile.languageVersion = languageVersion;
                sourceFile.fileName = fileName;
                sourceFile.languageVariant = ts.getLanguageVariant(scriptKind);
                sourceFile.isDeclarationFile = isDeclarationFile;
                sourceFile.scriptKind = scriptKind;
                setExternalModuleIndicator(sourceFile);
                sourceFile.setExternalModuleIndicator = setExternalModuleIndicator;
            }
        }
        function setContextFlag(val, flag) {
            if (val) {
                contextFlags |= flag;
            }
            else {
                contextFlags &= ~flag;
            }
        }
        function setDisallowInContext(val) {
            setContextFlag(val, 4096 /* NodeFlags.DisallowInContext */);
        }
        function setYieldContext(val) {
            setContextFlag(val, 8192 /* NodeFlags.YieldContext */);
        }
        function setDecoratorContext(val) {
            setContextFlag(val, 16384 /* NodeFlags.DecoratorContext */);
        }
        function setAwaitContext(val) {
            setContextFlag(val, 32768 /* NodeFlags.AwaitContext */);
        }
        function doOutsideOfContext(context, func) {
            // contextFlagsToClear will contain only the context flags that are
            // currently set that we need to temporarily clear
            // We don't just blindly reset to the previous flags to ensure
            // that we do not mutate cached flags for the incremental
            // parser (ThisNodeHasError, ThisNodeOrAnySubNodesHasError, and
            // HasAggregatedChildData).
            var contextFlagsToClear = context & contextFlags;
            if (contextFlagsToClear) {
                // clear the requested context flags
                setContextFlag(/*val*/ false, contextFlagsToClear);
                var result = func();
                // restore the context flags we just cleared
                setContextFlag(/*val*/ true, contextFlagsToClear);
                return result;
            }
            // no need to do anything special as we are not in any of the requested contexts
            return func();
        }
        function doInsideOfContext(context, func) {
            // contextFlagsToSet will contain only the context flags that
            // are not currently set that we need to temporarily enable.
            // We don't just blindly reset to the previous flags to ensure
            // that we do not mutate cached flags for the incremental
            // parser (ThisNodeHasError, ThisNodeOrAnySubNodesHasError, and
            // HasAggregatedChildData).
            var contextFlagsToSet = context & ~contextFlags;
            if (contextFlagsToSet) {
                // set the requested context flags
                setContextFlag(/*val*/ true, contextFlagsToSet);
                var result = func();
                // reset the context flags we just set
                setContextFlag(/*val*/ false, contextFlagsToSet);
                return result;
            }
            // no need to do anything special as we are already in all of the requested contexts
            return func();
        }
        function allowInAnd(func) {
            return doOutsideOfContext(4096 /* NodeFlags.DisallowInContext */, func);
        }
        function disallowInAnd(func) {
            return doInsideOfContext(4096 /* NodeFlags.DisallowInContext */, func);
        }
        function allowConditionalTypesAnd(func) {
            return doOutsideOfContext(65536 /* NodeFlags.DisallowConditionalTypesContext */, func);
        }
        function disallowConditionalTypesAnd(func) {
            return doInsideOfContext(65536 /* NodeFlags.DisallowConditionalTypesContext */, func);
        }
        function doInYieldContext(func) {
            return doInsideOfContext(8192 /* NodeFlags.YieldContext */, func);
        }
        function doInDecoratorContext(func) {
            return doInsideOfContext(16384 /* NodeFlags.DecoratorContext */, func);
        }
        function doInAwaitContext(func) {
            return doInsideOfContext(32768 /* NodeFlags.AwaitContext */, func);
        }
        function doOutsideOfAwaitContext(func) {
            return doOutsideOfContext(32768 /* NodeFlags.AwaitContext */, func);
        }
        function doInYieldAndAwaitContext(func) {
            return doInsideOfContext(8192 /* NodeFlags.YieldContext */ | 32768 /* NodeFlags.AwaitContext */, func);
        }
        function doOutsideOfYieldAndAwaitContext(func) {
            return doOutsideOfContext(8192 /* NodeFlags.YieldContext */ | 32768 /* NodeFlags.AwaitContext */, func);
        }
        function inContext(flags) {
            return (contextFlags & flags) !== 0;
        }
        function inYieldContext() {
            return inContext(8192 /* NodeFlags.YieldContext */);
        }
        function inDisallowInContext() {
            return inContext(4096 /* NodeFlags.DisallowInContext */);
        }
        function inDisallowConditionalTypesContext() {
            return inContext(65536 /* NodeFlags.DisallowConditionalTypesContext */);
        }
        function inDecoratorContext() {
            return inContext(16384 /* NodeFlags.DecoratorContext */);
        }
        function inAwaitContext() {
            return inContext(32768 /* NodeFlags.AwaitContext */);
        }
        function parseErrorAtCurrentToken(message, arg0) {
            return parseErrorAt(scanner.getTokenPos(), scanner.getTextPos(), message, arg0);
        }
        function parseErrorAtPosition(start, length, message, arg0) {
            // Don't report another error if it would just be at the same position as the last error.
            var lastError = ts.lastOrUndefined(parseDiagnostics);
            var result;
            if (!lastError || start !== lastError.start) {
                result = ts.createDetachedDiagnostic(fileName, start, length, message, arg0);
                parseDiagnostics.push(result);
            }
            // Mark that we've encountered an error.  We'll set an appropriate bit on the next
            // node we finish so that it can't be reused incrementally.
            parseErrorBeforeNextFinishedNode = true;
            return result;
        }
        function parseErrorAt(start, end, message, arg0) {
            return parseErrorAtPosition(start, end - start, message, arg0);
        }
        function parseErrorAtRange(range, message, arg0) {
            parseErrorAt(range.pos, range.end, message, arg0);
        }
        function scanError(message, length) {
            parseErrorAtPosition(scanner.getTextPos(), length, message);
        }
        function getNodePos() {
            return scanner.getStartPos();
        }
        function hasPrecedingJSDocComment() {
            return scanner.hasPrecedingJSDocComment();
        }
        // Use this function to access the current token instead of reading the currentToken
        // variable. Since function results aren't narrowed in control flow analysis, this ensures
        // that the type checker doesn't make wrong assumptions about the type of the current
        // token (e.g. a call to nextToken() changes the current token but the checker doesn't
        // reason about this side effect).  Mainstream VMs inline simple functions like this, so
        // there is no performance penalty.
        function token() {
            return currentToken;
        }
        function nextTokenWithoutCheck() {
            return currentToken = scanner.scan();
        }
        function nextTokenAnd(func) {
            nextToken();
            return func();
        }
        function nextToken() {
            // if the keyword had an escape
            if (ts.isKeyword(currentToken) && (scanner.hasUnicodeEscape() || scanner.hasExtendedUnicodeEscape())) {
                // issue a parse error for the escape
                parseErrorAt(scanner.getTokenPos(), scanner.getTextPos(), ts.Diagnostics.Keywords_cannot_contain_escape_characters);
            }
            return nextTokenWithoutCheck();
        }
        function nextTokenJSDoc() {
            return currentToken = scanner.scanJsDocToken();
        }
        function reScanGreaterToken() {
            return currentToken = scanner.reScanGreaterToken();
        }
        function reScanSlashToken() {
            return currentToken = scanner.reScanSlashToken();
        }
        function reScanTemplateToken(isTaggedTemplate) {
            return currentToken = scanner.reScanTemplateToken(isTaggedTemplate);
        }
        function reScanTemplateHeadOrNoSubstitutionTemplate() {
            return currentToken = scanner.reScanTemplateHeadOrNoSubstitutionTemplate();
        }
        function reScanLessThanToken() {
            return currentToken = scanner.reScanLessThanToken();
        }
        function reScanHashToken() {
            return currentToken = scanner.reScanHashToken();
        }
        function scanJsxIdentifier() {
            return currentToken = scanner.scanJsxIdentifier();
        }
        function scanJsxText() {
            return currentToken = scanner.scanJsxToken();
        }
        function scanJsxAttributeValue() {
            return currentToken = scanner.scanJsxAttributeValue();
        }
        function speculationHelper(callback, speculationKind) {
            // Keep track of the state we'll need to rollback to if lookahead fails (or if the
            // caller asked us to always reset our state).
            var saveToken = currentToken;
            var saveParseDiagnosticsLength = parseDiagnostics.length;
            var saveParseErrorBeforeNextFinishedNode = parseErrorBeforeNextFinishedNode;
            // Note: it is not actually necessary to save/restore the context flags here.  That's
            // because the saving/restoring of these flags happens naturally through the recursive
            // descent nature of our parser.  However, we still store this here just so we can
            // assert that invariant holds.
            var saveContextFlags = contextFlags;
            // If we're only looking ahead, then tell the scanner to only lookahead as well.
            // Otherwise, if we're actually speculatively parsing, then tell the scanner to do the
            // same.
            var result = speculationKind !== 0 /* SpeculationKind.TryParse */
                ? scanner.lookAhead(callback)
                : scanner.tryScan(callback);
            ts.Debug.assert(saveContextFlags === contextFlags);
            // If our callback returned something 'falsy' or we're just looking ahead,
            // then unconditionally restore us to where we were.
            if (!result || speculationKind !== 0 /* SpeculationKind.TryParse */) {
                currentToken = saveToken;
                if (speculationKind !== 2 /* SpeculationKind.Reparse */) {
                    parseDiagnostics.length = saveParseDiagnosticsLength;
                }
                parseErrorBeforeNextFinishedNode = saveParseErrorBeforeNextFinishedNode;
            }
            return result;
        }
        /** Invokes the provided callback then unconditionally restores the parser to the state it
         * was in immediately prior to invoking the callback.  The result of invoking the callback
         * is returned from this function.
         */
        function lookAhead(callback) {
            return speculationHelper(callback, 1 /* SpeculationKind.Lookahead */);
        }
        /** Invokes the provided callback.  If the callback returns something falsy, then it restores
         * the parser to the state it was in immediately prior to invoking the callback.  If the
         * callback returns something truthy, then the parser state is not rolled back.  The result
         * of invoking the callback is returned from this function.
         */
        function tryParse(callback) {
            return speculationHelper(callback, 0 /* SpeculationKind.TryParse */);
        }
        function isBindingIdentifier() {
            if (token() === 79 /* SyntaxKind.Identifier */) {
                return true;
            }
            // `let await`/`let yield` in [Yield] or [Await] are allowed here and disallowed in the binder.
            return token() > 116 /* SyntaxKind.LastReservedWord */;
        }
        // Ignore strict mode flag because we will report an error in type checker instead.
        function isIdentifier() {
            if (token() === 79 /* SyntaxKind.Identifier */) {
                return true;
            }
            // If we have a 'yield' keyword, and we're in the [yield] context, then 'yield' is
            // considered a keyword and is not an identifier.
            if (token() === 125 /* SyntaxKind.YieldKeyword */ && inYieldContext()) {
                return false;
            }
            // If we have a 'await' keyword, and we're in the [Await] context, then 'await' is
            // considered a keyword and is not an identifier.
            if (token() === 132 /* SyntaxKind.AwaitKeyword */ && inAwaitContext()) {
                return false;
            }
            return token() > 116 /* SyntaxKind.LastReservedWord */;
        }
        function parseExpected(kind, diagnosticMessage, shouldAdvance) {
            if (shouldAdvance === void 0) { shouldAdvance = true; }
            if (token() === kind) {
                if (shouldAdvance) {
                    nextToken();
                }
                return true;
            }
            // Report specific message if provided with one.  Otherwise, report generic fallback message.
            if (diagnosticMessage) {
                parseErrorAtCurrentToken(diagnosticMessage);
            }
            else {
                parseErrorAtCurrentToken(ts.Diagnostics._0_expected, ts.tokenToString(kind));
            }
            return false;
        }
        var viableKeywordSuggestions = Object.keys(ts.textToKeywordObj).filter(function (keyword) { return keyword.length > 2; });
        /**
         * Provides a better error message than the generic "';' expected" if possible for
         * known common variants of a missing semicolon, such as from a mispelled names.
         *
         * @param node Node preceding the expected semicolon location.
         */
        function parseErrorForMissingSemicolonAfter(node) {
            var _a;
            // Tagged template literals are sometimes used in places where only simple strings are allowed, i.e.:
            //   module `M1` {
            //   ^^^^^^^^^^^ This block is parsed as a template literal like module`M1`.
            if (ts.isTaggedTemplateExpression(node)) {
                parseErrorAt(ts.skipTrivia(sourceText, node.template.pos), node.template.end, ts.Diagnostics.Module_declaration_names_may_only_use_or_quoted_strings);
                return;
            }
            // Otherwise, if this isn't a well-known keyword-like identifier, give the generic fallback message.
            var expressionText = ts.isIdentifier(node) ? ts.idText(node) : undefined;
            if (!expressionText || !ts.isIdentifierText(expressionText, languageVersion)) {
                parseErrorAtCurrentToken(ts.Diagnostics._0_expected, ts.tokenToString(26 /* SyntaxKind.SemicolonToken */));
                return;
            }
            var pos = ts.skipTrivia(sourceText, node.pos);
            // Some known keywords are likely signs of syntax being used improperly.
            switch (expressionText) {
                case "const":
                case "let":
                case "var":
                    parseErrorAt(pos, node.end, ts.Diagnostics.Variable_declaration_not_allowed_at_this_location);
                    return;
                case "declare":
                    // If a declared node failed to parse, it would have emitted a diagnostic already.
                    return;
                case "interface":
                    parseErrorForInvalidName(ts.Diagnostics.Interface_name_cannot_be_0, ts.Diagnostics.Interface_must_be_given_a_name, 18 /* SyntaxKind.OpenBraceToken */);
                    return;
                case "is":
                    parseErrorAt(pos, scanner.getTextPos(), ts.Diagnostics.A_type_predicate_is_only_allowed_in_return_type_position_for_functions_and_methods);
                    return;
                case "module":
                case "namespace":
                    parseErrorForInvalidName(ts.Diagnostics.Namespace_name_cannot_be_0, ts.Diagnostics.Namespace_must_be_given_a_name, 18 /* SyntaxKind.OpenBraceToken */);
                    return;
                case "type":
                    parseErrorForInvalidName(ts.Diagnostics.Type_alias_name_cannot_be_0, ts.Diagnostics.Type_alias_must_be_given_a_name, 63 /* SyntaxKind.EqualsToken */);
                    return;
            }
            // The user alternatively might have misspelled or forgotten to add a space after a common keyword.
            var suggestion = (_a = ts.getSpellingSuggestion(expressionText, viableKeywordSuggestions, function (n) { return n; })) !== null && _a !== void 0 ? _a : getSpaceSuggestion(expressionText);
            if (suggestion) {
                parseErrorAt(pos, node.end, ts.Diagnostics.Unknown_keyword_or_identifier_Did_you_mean_0, suggestion);
                return;
            }
            // Unknown tokens are handled with their own errors in the scanner
            if (token() === 0 /* SyntaxKind.Unknown */) {
                return;
            }
            // Otherwise, we know this some kind of unknown word, not just a missing expected semicolon.
            parseErrorAt(pos, node.end, ts.Diagnostics.Unexpected_keyword_or_identifier);
        }
        /**
         * Reports a diagnostic error for the current token being an invalid name.
         *
         * @param blankDiagnostic Diagnostic to report for the case of the name being blank (matched tokenIfBlankName).
         * @param nameDiagnostic Diagnostic to report for all other cases.
         * @param tokenIfBlankName Current token if the name was invalid for being blank (not provided / skipped).
         */
        function parseErrorForInvalidName(nameDiagnostic, blankDiagnostic, tokenIfBlankName) {
            if (token() === tokenIfBlankName) {
                parseErrorAtCurrentToken(blankDiagnostic);
            }
            else {
                parseErrorAtCurrentToken(nameDiagnostic, scanner.getTokenValue());
            }
        }
        function getSpaceSuggestion(expressionText) {
            for (var _i = 0, viableKeywordSuggestions_1 = viableKeywordSuggestions; _i < viableKeywordSuggestions_1.length; _i++) {
                var keyword = viableKeywordSuggestions_1[_i];
                if (expressionText.length > keyword.length + 2 && ts.startsWith(expressionText, keyword)) {
                    return "".concat(keyword, " ").concat(expressionText.slice(keyword.length));
                }
            }
            return undefined;
        }
        function parseSemicolonAfterPropertyName(name, type, initializer) {
            if (token() === 59 /* SyntaxKind.AtToken */ && !scanner.hasPrecedingLineBreak()) {
                parseErrorAtCurrentToken(ts.Diagnostics.Decorators_must_precede_the_name_and_all_keywords_of_property_declarations);
                return;
            }
            if (token() === 20 /* SyntaxKind.OpenParenToken */) {
                parseErrorAtCurrentToken(ts.Diagnostics.Cannot_start_a_function_call_in_a_type_annotation);
                nextToken();
                return;
            }
            if (type && !canParseSemicolon()) {
                if (initializer) {
                    parseErrorAtCurrentToken(ts.Diagnostics._0_expected, ts.tokenToString(26 /* SyntaxKind.SemicolonToken */));
                }
                else {
                    parseErrorAtCurrentToken(ts.Diagnostics.Expected_for_property_initializer);
                }
                return;
            }
            if (tryParseSemicolon()) {
                return;
            }
            if (initializer) {
                parseErrorAtCurrentToken(ts.Diagnostics._0_expected, ts.tokenToString(26 /* SyntaxKind.SemicolonToken */));
                return;
            }
            parseErrorForMissingSemicolonAfter(name);
        }
        function parseExpectedJSDoc(kind) {
            if (token() === kind) {
                nextTokenJSDoc();
                return true;
            }
            parseErrorAtCurrentToken(ts.Diagnostics._0_expected, ts.tokenToString(kind));
            return false;
        }
        function parseExpectedMatchingBrackets(openKind, closeKind, openParsed, openPosition) {
            if (token() === closeKind) {
                nextToken();
                return;
            }
            var lastError = parseErrorAtCurrentToken(ts.Diagnostics._0_expected, ts.tokenToString(closeKind));
            if (!openParsed) {
                return;
            }
            if (lastError) {
                ts.addRelatedInfo(lastError, ts.createDetachedDiagnostic(fileName, openPosition, 1, ts.Diagnostics.The_parser_expected_to_find_a_1_to_match_the_0_token_here, ts.tokenToString(openKind), ts.tokenToString(closeKind)));
            }
        }
        function parseOptional(t) {
            if (token() === t) {
                nextToken();
                return true;
            }
            return false;
        }
        function parseOptionalToken(t) {
            if (token() === t) {
                return parseTokenNode();
            }
            return undefined;
        }
        function parseOptionalTokenJSDoc(t) {
            if (token() === t) {
                return parseTokenNodeJSDoc();
            }
            return undefined;
        }
        function parseExpectedToken(t, diagnosticMessage, arg0) {
            return parseOptionalToken(t) ||
                createMissingNode(t, /*reportAtCurrentPosition*/ false, diagnosticMessage || ts.Diagnostics._0_expected, arg0 || ts.tokenToString(t));
        }
        function parseExpectedTokenJSDoc(t) {
            return parseOptionalTokenJSDoc(t) ||
                createMissingNode(t, /*reportAtCurrentPosition*/ false, ts.Diagnostics._0_expected, ts.tokenToString(t));
        }
        function parseTokenNode() {
            var pos = getNodePos();
            var kind = token();
            nextToken();
            return finishNode(factory.createToken(kind), pos);
        }
        function parseTokenNodeJSDoc() {
            var pos = getNodePos();
            var kind = token();
            nextTokenJSDoc();
            return finishNode(factory.createToken(kind), pos);
        }
        function canParseSemicolon() {
            // If there's a real semicolon, then we can always parse it out.
            if (token() === 26 /* SyntaxKind.SemicolonToken */) {
                return true;
            }
            // We can parse out an optional semicolon in ASI cases in the following cases.
            return token() === 19 /* SyntaxKind.CloseBraceToken */ || token() === 1 /* SyntaxKind.EndOfFileToken */ || scanner.hasPrecedingLineBreak();
        }
        function tryParseSemicolon() {
            if (!canParseSemicolon()) {
                return false;
            }
            if (token() === 26 /* SyntaxKind.SemicolonToken */) {
                // consume the semicolon if it was explicitly provided.
                nextToken();
            }
            return true;
        }
        function parseSemicolon() {
            return tryParseSemicolon() || parseExpected(26 /* SyntaxKind.SemicolonToken */);
        }
        function createNodeArray(elements, pos, end, hasTrailingComma) {
            var array = factory.createNodeArray(elements, hasTrailingComma);
            ts.setTextRangePosEnd(array, pos, end !== null && end !== void 0 ? end : scanner.getStartPos());
            return array;
        }
        function finishNode(node, pos, end) {
            ts.setTextRangePosEnd(node, pos, end !== null && end !== void 0 ? end : scanner.getStartPos());
            if (contextFlags) {
                node.flags |= contextFlags;
            }
            // Keep track on the node if we encountered an error while parsing it.  If we did, then
            // we cannot reuse the node incrementally.  Once we've marked this node, clear out the
            // flag so that we don't mark any subsequent nodes.
            if (parseErrorBeforeNextFinishedNode) {
                parseErrorBeforeNextFinishedNode = false;
                node.flags |= 131072 /* NodeFlags.ThisNodeHasError */;
            }
            return node;
        }
        function createMissingNode(kind, reportAtCurrentPosition, diagnosticMessage, arg0) {
            if (reportAtCurrentPosition) {
                parseErrorAtPosition(scanner.getStartPos(), 0, diagnosticMessage, arg0);
            }
            else if (diagnosticMessage) {
                parseErrorAtCurrentToken(diagnosticMessage, arg0);
            }
            var pos = getNodePos();
            var result = kind === 79 /* SyntaxKind.Identifier */ ? factory.createIdentifier("", /*typeArguments*/ undefined, /*originalKeywordKind*/ undefined) :
                ts.isTemplateLiteralKind(kind) ? factory.createTemplateLiteralLikeNode(kind, "", "", /*templateFlags*/ undefined) :
                    kind === 8 /* SyntaxKind.NumericLiteral */ ? factory.createNumericLiteral("", /*numericLiteralFlags*/ undefined) :
                        kind === 10 /* SyntaxKind.StringLiteral */ ? factory.createStringLiteral("", /*isSingleQuote*/ undefined) :
                            kind === 276 /* SyntaxKind.MissingDeclaration */ ? factory.createMissingDeclaration() :
                                factory.createToken(kind);
            return finishNode(result, pos);
        }
        function internIdentifier(text) {
            var identifier = identifiers.get(text);
            if (identifier === undefined) {
                identifiers.set(text, identifier = text);
            }
            return identifier;
        }
        // An identifier that starts with two underscores has an extra underscore character prepended to it to avoid issues
        // with magic property names like '__proto__'. The 'identifiers' object is used to share a single string instance for
        // each identifier in order to reduce memory consumption.
        function createIdentifier(isIdentifier, diagnosticMessage, privateIdentifierDiagnosticMessage) {
            if (isIdentifier) {
                identifierCount++;
                var pos = getNodePos();
                // Store original token kind if it is not just an Identifier so we can report appropriate error later in type checker
                var originalKeywordKind = token();
                var text = internIdentifier(scanner.getTokenValue());
                nextTokenWithoutCheck();
                return finishNode(factory.createIdentifier(text, /*typeArguments*/ undefined, originalKeywordKind), pos);
            }
            if (token() === 80 /* SyntaxKind.PrivateIdentifier */) {
                parseErrorAtCurrentToken(privateIdentifierDiagnosticMessage || ts.Diagnostics.Private_identifiers_are_not_allowed_outside_class_bodies);
                return createIdentifier(/*isIdentifier*/ true);
            }
            if (token() === 0 /* SyntaxKind.Unknown */ && scanner.tryScan(function () { return scanner.reScanInvalidIdentifier() === 79 /* SyntaxKind.Identifier */; })) {
                // Scanner has already recorded an 'Invalid character' error, so no need to add another from the parser.
                return createIdentifier(/*isIdentifier*/ true);
            }
            identifierCount++;
            // Only for end of file because the error gets reported incorrectly on embedded script tags.
            var reportAtCurrentPosition = token() === 1 /* SyntaxKind.EndOfFileToken */;
            var isReservedWord = scanner.isReservedWord();
            var msgArg = scanner.getTokenText();
            var defaultMessage = isReservedWord ?
                ts.Diagnostics.Identifier_expected_0_is_a_reserved_word_that_cannot_be_used_here :
                ts.Diagnostics.Identifier_expected;
            return createMissingNode(79 /* SyntaxKind.Identifier */, reportAtCurrentPosition, diagnosticMessage || defaultMessage, msgArg);
        }
        function parseBindingIdentifier(privateIdentifierDiagnosticMessage) {
            return createIdentifier(isBindingIdentifier(), /*diagnosticMessage*/ undefined, privateIdentifierDiagnosticMessage);
        }
        function parseIdentifier(diagnosticMessage, privateIdentifierDiagnosticMessage) {
            return createIdentifier(isIdentifier(), diagnosticMessage, privateIdentifierDiagnosticMessage);
        }
        function parseIdentifierName(diagnosticMessage) {
            return createIdentifier(ts.tokenIsIdentifierOrKeyword(token()), diagnosticMessage);
        }
        function isLiteralPropertyName() {
            return ts.tokenIsIdentifierOrKeyword(token()) ||
                token() === 10 /* SyntaxKind.StringLiteral */ ||
                token() === 8 /* SyntaxKind.NumericLiteral */;
        }
        function isAssertionKey() {
            return ts.tokenIsIdentifierOrKeyword(token()) ||
                token() === 10 /* SyntaxKind.StringLiteral */;
        }
        function parsePropertyNameWorker(allowComputedPropertyNames) {
            if (token() === 10 /* SyntaxKind.StringLiteral */ || token() === 8 /* SyntaxKind.NumericLiteral */) {
                var node = parseLiteralNode();
                node.text = internIdentifier(node.text);
                return node;
            }
            if (allowComputedPropertyNames && token() === 22 /* SyntaxKind.OpenBracketToken */) {
                return parseComputedPropertyName();
            }
            if (token() === 80 /* SyntaxKind.PrivateIdentifier */) {
                return parsePrivateIdentifier();
            }
            return parseIdentifierName();
        }
        function parsePropertyName() {
            return parsePropertyNameWorker(/*allowComputedPropertyNames*/ true);
        }
        function parseComputedPropertyName() {
            // PropertyName [Yield]:
            //      LiteralPropertyName
            //      ComputedPropertyName[?Yield]
            var pos = getNodePos();
            parseExpected(22 /* SyntaxKind.OpenBracketToken */);
            // We parse any expression (including a comma expression). But the grammar
            // says that only an assignment expression is allowed, so the grammar checker
            // will error if it sees a comma expression.
            var expression = allowInAnd(parseExpression);
            parseExpected(23 /* SyntaxKind.CloseBracketToken */);
            return finishNode(factory.createComputedPropertyName(expression), pos);
        }
        function internPrivateIdentifier(text) {
            var privateIdentifier = privateIdentifiers.get(text);
            if (privateIdentifier === undefined) {
                privateIdentifiers.set(text, privateIdentifier = text);
            }
            return privateIdentifier;
        }
        function parsePrivateIdentifier() {
            var pos = getNodePos();
            var node = factory.createPrivateIdentifier(internPrivateIdentifier(scanner.getTokenText()));
            nextToken();
            return finishNode(node, pos);
        }
        function parseContextualModifier(t) {
            return token() === t && tryParse(nextTokenCanFollowModifier);
        }
        function nextTokenIsOnSameLineAndCanFollowModifier() {
            nextToken();
            if (scanner.hasPrecedingLineBreak()) {
                return false;
            }
            return canFollowModifier();
        }
        function nextTokenCanFollowModifier() {
            switch (token()) {
                case 85 /* SyntaxKind.ConstKeyword */:
                    // 'const' is only a modifier if followed by 'enum'.
                    return nextToken() === 92 /* SyntaxKind.EnumKeyword */;
                case 93 /* SyntaxKind.ExportKeyword */:
                    nextToken();
                    if (token() === 88 /* SyntaxKind.DefaultKeyword */) {
                        return lookAhead(nextTokenCanFollowDefaultKeyword);
                    }
                    if (token() === 152 /* SyntaxKind.TypeKeyword */) {
                        return lookAhead(nextTokenCanFollowExportModifier);
                    }
                    return canFollowExportModifier();
                case 88 /* SyntaxKind.DefaultKeyword */:
                    return nextTokenCanFollowDefaultKeyword();
                case 124 /* SyntaxKind.StaticKeyword */:
                case 136 /* SyntaxKind.GetKeyword */:
                case 149 /* SyntaxKind.SetKeyword */:
                    nextToken();
                    return canFollowModifier();
                default:
                    return nextTokenIsOnSameLineAndCanFollowModifier();
            }
        }
        function canFollowExportModifier() {
            return token() !== 41 /* SyntaxKind.AsteriskToken */
                && token() !== 127 /* SyntaxKind.AsKeyword */
                && token() !== 18 /* SyntaxKind.OpenBraceToken */
                && canFollowModifier();
        }
        function nextTokenCanFollowExportModifier() {
            nextToken();
            return canFollowExportModifier();
        }
        function parseAnyContextualModifier() {
            return ts.isModifierKind(token()) && tryParse(nextTokenCanFollowModifier);
        }
        function canFollowModifier() {
            return token() === 22 /* SyntaxKind.OpenBracketToken */
                || token() === 18 /* SyntaxKind.OpenBraceToken */
                || token() === 41 /* SyntaxKind.AsteriskToken */
                || token() === 25 /* SyntaxKind.DotDotDotToken */
                || isLiteralPropertyName();
        }
        function nextTokenCanFollowDefaultKeyword() {
            nextToken();
            return token() === 84 /* SyntaxKind.ClassKeyword */ || token() === 98 /* SyntaxKind.FunctionKeyword */ ||
                token() === 118 /* SyntaxKind.InterfaceKeyword */ ||
                (token() === 126 /* SyntaxKind.AbstractKeyword */ && lookAhead(nextTokenIsClassKeywordOnSameLine)) ||
                (token() === 131 /* SyntaxKind.AsyncKeyword */ && lookAhead(nextTokenIsFunctionKeywordOnSameLine));
        }
        // True if positioned at the start of a list element
        function isListElement(parsingContext, inErrorRecovery) {
            var node = currentNode(parsingContext);
            if (node) {
                return true;
            }
            switch (parsingContext) {
                case 0 /* ParsingContext.SourceElements */:
                case 1 /* ParsingContext.BlockStatements */:
                case 3 /* ParsingContext.SwitchClauseStatements */:
                    // If we're in error recovery, then we don't want to treat ';' as an empty statement.
                    // The problem is that ';' can show up in far too many contexts, and if we see one
                    // and assume it's a statement, then we may bail out inappropriately from whatever
                    // we're parsing.  For example, if we have a semicolon in the middle of a class, then
                    // we really don't want to assume the class is over and we're on a statement in the
                    // outer module.  We just want to consume and move on.
                    return !(token() === 26 /* SyntaxKind.SemicolonToken */ && inErrorRecovery) && isStartOfStatement();
                case 2 /* ParsingContext.SwitchClauses */:
                    return token() === 82 /* SyntaxKind.CaseKeyword */ || token() === 88 /* SyntaxKind.DefaultKeyword */;
                case 4 /* ParsingContext.TypeMembers */:
                    return lookAhead(isTypeMemberStart);
                case 5 /* ParsingContext.ClassMembers */:
                    // We allow semicolons as class elements (as specified by ES6) as long as we're
                    // not in error recovery.  If we're in error recovery, we don't want an errant
                    // semicolon to be treated as a class member (since they're almost always used
                    // for statements.
                    return lookAhead(isClassMemberStart) || (token() === 26 /* SyntaxKind.SemicolonToken */ && !inErrorRecovery);
                case 6 /* ParsingContext.EnumMembers */:
                    // Include open bracket computed properties. This technically also lets in indexers,
                    // which would be a candidate for improved error reporting.
                    return token() === 22 /* SyntaxKind.OpenBracketToken */ || isLiteralPropertyName();
                case 12 /* ParsingContext.ObjectLiteralMembers */:
                    switch (token()) {
                        case 22 /* SyntaxKind.OpenBracketToken */:
                        case 41 /* SyntaxKind.AsteriskToken */:
                        case 25 /* SyntaxKind.DotDotDotToken */:
                        case 24 /* SyntaxKind.DotToken */: // Not an object literal member, but don't want to close the object (see `tests/cases/fourslash/completionsDotInObjectLiteral.ts`)
                            return true;
                        default:
                            return isLiteralPropertyName();
                    }
                case 18 /* ParsingContext.RestProperties */:
                    return isLiteralPropertyName();
                case 9 /* ParsingContext.ObjectBindingElements */:
                    return token() === 22 /* SyntaxKind.OpenBracketToken */ || token() === 25 /* SyntaxKind.DotDotDotToken */ || isLiteralPropertyName();
                case 24 /* ParsingContext.AssertEntries */:
                    return isAssertionKey();
                case 7 /* ParsingContext.HeritageClauseElement */:
                    // If we see `{ ... }` then only consume it as an expression if it is followed by `,` or `{`
                    // That way we won't consume the body of a class in its heritage clause.
                    if (token() === 18 /* SyntaxKind.OpenBraceToken */) {
                        return lookAhead(isValidHeritageClauseObjectLiteral);
                    }
                    if (!inErrorRecovery) {
                        return isStartOfLeftHandSideExpression() && !isHeritageClauseExtendsOrImplementsKeyword();
                    }
                    else {
                        // If we're in error recovery we tighten up what we're willing to match.
                        // That way we don't treat something like "this" as a valid heritage clause
                        // element during recovery.
                        return isIdentifier() && !isHeritageClauseExtendsOrImplementsKeyword();
                    }
                case 8 /* ParsingContext.VariableDeclarations */:
                    return isBindingIdentifierOrPrivateIdentifierOrPattern();
                case 10 /* ParsingContext.ArrayBindingElements */:
                    return token() === 27 /* SyntaxKind.CommaToken */ || token() === 25 /* SyntaxKind.DotDotDotToken */ || isBindingIdentifierOrPrivateIdentifierOrPattern();
                case 19 /* ParsingContext.TypeParameters */:
                    return token() === 101 /* SyntaxKind.InKeyword */ || isIdentifier();
                case 15 /* ParsingContext.ArrayLiteralMembers */:
                    switch (token()) {
                        case 27 /* SyntaxKind.CommaToken */:
                        case 24 /* SyntaxKind.DotToken */: // Not an array literal member, but don't want to close the array (see `tests/cases/fourslash/completionsDotInArrayLiteralInObjectLiteral.ts`)
                            return true;
                    }
                // falls through
                case 11 /* ParsingContext.ArgumentExpressions */:
                    return token() === 25 /* SyntaxKind.DotDotDotToken */ || isStartOfExpression();
                case 16 /* ParsingContext.Parameters */:
                    return isStartOfParameter(/*isJSDocParameter*/ false);
                case 17 /* ParsingContext.JSDocParameters */:
                    return isStartOfParameter(/*isJSDocParameter*/ true);
                case 20 /* ParsingContext.TypeArguments */:
                case 21 /* ParsingContext.TupleElementTypes */:
                    return token() === 27 /* SyntaxKind.CommaToken */ || isStartOfType();
                case 22 /* ParsingContext.HeritageClauses */:
                    return isHeritageClause();
                case 23 /* ParsingContext.ImportOrExportSpecifiers */:
                    return ts.tokenIsIdentifierOrKeyword(token());
                case 13 /* ParsingContext.JsxAttributes */:
                    return ts.tokenIsIdentifierOrKeyword(token()) || token() === 18 /* SyntaxKind.OpenBraceToken */;
                case 14 /* ParsingContext.JsxChildren */:
                    return true;
            }
            return ts.Debug.fail("Non-exhaustive case in 'isListElement'.");
        }
        function isValidHeritageClauseObjectLiteral() {
            ts.Debug.assert(token() === 18 /* SyntaxKind.OpenBraceToken */);
            if (nextToken() === 19 /* SyntaxKind.CloseBraceToken */) {
                // if we see "extends {}" then only treat the {} as what we're extending (and not
                // the class body) if we have:
                //
                //      extends {} {
                //      extends {},
                //      extends {} extends
                //      extends {} implements
                var next = nextToken();
                return next === 27 /* SyntaxKind.CommaToken */ || next === 18 /* SyntaxKind.OpenBraceToken */ || next === 94 /* SyntaxKind.ExtendsKeyword */ || next === 117 /* SyntaxKind.ImplementsKeyword */;
            }
            return true;
        }
        function nextTokenIsIdentifier() {
            nextToken();
            return isIdentifier();
        }
        function nextTokenIsIdentifierOrKeyword() {
            nextToken();
            return ts.tokenIsIdentifierOrKeyword(token());
        }
        function nextTokenIsIdentifierOrKeywordOrGreaterThan() {
            nextToken();
            return ts.tokenIsIdentifierOrKeywordOrGreaterThan(token());
        }
        function isHeritageClauseExtendsOrImplementsKeyword() {
            if (token() === 117 /* SyntaxKind.ImplementsKeyword */ ||
                token() === 94 /* SyntaxKind.ExtendsKeyword */) {
                return lookAhead(nextTokenIsStartOfExpression);
            }
            return false;
        }
        function nextTokenIsStartOfExpression() {
            nextToken();
            return isStartOfExpression();
        }
        function nextTokenIsStartOfType() {
            nextToken();
            return isStartOfType();
        }
        // True if positioned at a list terminator
        function isListTerminator(kind) {
            if (token() === 1 /* SyntaxKind.EndOfFileToken */) {
                // Being at the end of the file ends all lists.
                return true;
            }
            switch (kind) {
                case 1 /* ParsingContext.BlockStatements */:
                case 2 /* ParsingContext.SwitchClauses */:
                case 4 /* ParsingContext.TypeMembers */:
                case 5 /* ParsingContext.ClassMembers */:
                case 6 /* ParsingContext.EnumMembers */:
                case 12 /* ParsingContext.ObjectLiteralMembers */:
                case 9 /* ParsingContext.ObjectBindingElements */:
                case 23 /* ParsingContext.ImportOrExportSpecifiers */:
                case 24 /* ParsingContext.AssertEntries */:
                    return token() === 19 /* SyntaxKind.CloseBraceToken */;
                case 3 /* ParsingContext.SwitchClauseStatements */:
                    return token() === 19 /* SyntaxKind.CloseBraceToken */ || token() === 82 /* SyntaxKind.CaseKeyword */ || token() === 88 /* SyntaxKind.DefaultKeyword */;
                case 7 /* ParsingContext.HeritageClauseElement */:
                    return token() === 18 /* SyntaxKind.OpenBraceToken */ || token() === 94 /* SyntaxKind.ExtendsKeyword */ || token() === 117 /* SyntaxKind.ImplementsKeyword */;
                case 8 /* ParsingContext.VariableDeclarations */:
                    return isVariableDeclaratorListTerminator();
                case 19 /* ParsingContext.TypeParameters */:
                    // Tokens other than '>' are here for better error recovery
                    return token() === 31 /* SyntaxKind.GreaterThanToken */ || token() === 20 /* SyntaxKind.OpenParenToken */ || token() === 18 /* SyntaxKind.OpenBraceToken */ || token() === 94 /* SyntaxKind.ExtendsKeyword */ || token() === 117 /* SyntaxKind.ImplementsKeyword */;
                case 11 /* ParsingContext.ArgumentExpressions */:
                    // Tokens other than ')' are here for better error recovery
                    return token() === 21 /* SyntaxKind.CloseParenToken */ || token() === 26 /* SyntaxKind.SemicolonToken */;
                case 15 /* ParsingContext.ArrayLiteralMembers */:
                case 21 /* ParsingContext.TupleElementTypes */:
                case 10 /* ParsingContext.ArrayBindingElements */:
                    return token() === 23 /* SyntaxKind.CloseBracketToken */;
                case 17 /* ParsingContext.JSDocParameters */:
                case 16 /* ParsingContext.Parameters */:
                case 18 /* ParsingContext.RestProperties */:
                    // Tokens other than ')' and ']' (the latter for index signatures) are here for better error recovery
                    return token() === 21 /* SyntaxKind.CloseParenToken */ || token() === 23 /* SyntaxKind.CloseBracketToken */ /*|| token === SyntaxKind.OpenBraceToken*/;
                case 20 /* ParsingContext.TypeArguments */:
                    // All other tokens should cause the type-argument to terminate except comma token
                    return token() !== 27 /* SyntaxKind.CommaToken */;
                case 22 /* ParsingContext.HeritageClauses */:
                    return token() === 18 /* SyntaxKind.OpenBraceToken */ || token() === 19 /* SyntaxKind.CloseBraceToken */;
                case 13 /* ParsingContext.JsxAttributes */:
                    return token() === 31 /* SyntaxKind.GreaterThanToken */ || token() === 43 /* SyntaxKind.SlashToken */;
                case 14 /* ParsingContext.JsxChildren */:
                    return token() === 29 /* SyntaxKind.LessThanToken */ && lookAhead(nextTokenIsSlash);
                default:
                    return false;
            }
        }
        function isVariableDeclaratorListTerminator() {
            // If we can consume a semicolon (either explicitly, or with ASI), then consider us done
            // with parsing the list of variable declarators.
            if (canParseSemicolon()) {
                return true;
            }
            // in the case where we're parsing the variable declarator of a 'for-in' statement, we
            // are done if we see an 'in' keyword in front of us. Same with for-of
            if (isInOrOfKeyword(token())) {
                return true;
            }
            // ERROR RECOVERY TWEAK:
            // For better error recovery, if we see an '=>' then we just stop immediately.  We've got an
            // arrow function here and it's going to be very unlikely that we'll resynchronize and get
            // another variable declaration.
            if (token() === 38 /* SyntaxKind.EqualsGreaterThanToken */) {
                return true;
            }
            // Keep trying to parse out variable declarators.
            return false;
        }
        // True if positioned at element or terminator of the current list or any enclosing list
        function isInSomeParsingContext() {
            for (var kind = 0; kind < 25 /* ParsingContext.Count */; kind++) {
                if (parsingContext & (1 << kind)) {
                    if (isListElement(kind, /*inErrorRecovery*/ true) || isListTerminator(kind)) {
                        return true;
                    }
                }
            }
            return false;
        }
        // Parses a list of elements
        function parseList(kind, parseElement) {
            var saveParsingContext = parsingContext;
            parsingContext |= 1 << kind;
            var list = [];
            var listPos = getNodePos();
            while (!isListTerminator(kind)) {
                if (isListElement(kind, /*inErrorRecovery*/ false)) {
                    list.push(parseListElement(kind, parseElement));
                    continue;
                }
                if (abortParsingListOrMoveToNextToken(kind)) {
                    break;
                }
            }
            parsingContext = saveParsingContext;
            return createNodeArray(list, listPos);
        }
        function parseListElement(parsingContext, parseElement) {
            var node = currentNode(parsingContext);
            if (node) {
                return consumeNode(node);
            }
            return parseElement();
        }
        function currentNode(parsingContext, pos) {
            // If we don't have a cursor or the parsing context isn't reusable, there's nothing to reuse.
            //
            // If there is an outstanding parse error that we've encountered, but not attached to
            // some node, then we cannot get a node from the old source tree.  This is because we
            // want to mark the next node we encounter as being unusable.
            //
            // Note: This may be too conservative.  Perhaps we could reuse the node and set the bit
            // on it (or its leftmost child) as having the error.  For now though, being conservative
            // is nice and likely won't ever affect perf.
            if (!syntaxCursor || !isReusableParsingContext(parsingContext) || parseErrorBeforeNextFinishedNode) {
                return undefined;
            }
            var node = syntaxCursor.currentNode(pos !== null && pos !== void 0 ? pos : scanner.getStartPos());
            // Can't reuse a missing node.
            // Can't reuse a node that intersected the change range.
            // Can't reuse a node that contains a parse error.  This is necessary so that we
            // produce the same set of errors again.
            if (ts.nodeIsMissing(node) || node.intersectsChange || ts.containsParseError(node)) {
                return undefined;
            }
            // We can only reuse a node if it was parsed under the same strict mode that we're
            // currently in.  i.e. if we originally parsed a node in non-strict mode, but then
            // the user added 'using strict' at the top of the file, then we can't use that node
            // again as the presence of strict mode may cause us to parse the tokens in the file
            // differently.
            //
            // Note: we *can* reuse tokens when the strict mode changes.  That's because tokens
            // are unaffected by strict mode.  It's just the parser will decide what to do with it
            // differently depending on what mode it is in.
            //
            // This also applies to all our other context flags as well.
            var nodeContextFlags = node.flags & 50720768 /* NodeFlags.ContextFlags */;
            if (nodeContextFlags !== contextFlags) {
                return undefined;
            }
            // Ok, we have a node that looks like it could be reused.  Now verify that it is valid
            // in the current list parsing context that we're currently at.
            if (!canReuseNode(node, parsingContext)) {
                return undefined;
            }
            if (node.jsDocCache) {
                // jsDocCache may include tags from parent nodes, which might have been modified.
                node.jsDocCache = undefined;
            }
            return node;
        }
        function consumeNode(node) {
            // Move the scanner so it is after the node we just consumed.
            scanner.setTextPos(node.end);
            nextToken();
            return node;
        }
        function isReusableParsingContext(parsingContext) {
            switch (parsingContext) {
                case 5 /* ParsingContext.ClassMembers */:
                case 2 /* ParsingContext.SwitchClauses */:
                case 0 /* ParsingContext.SourceElements */:
                case 1 /* ParsingContext.BlockStatements */:
                case 3 /* ParsingContext.SwitchClauseStatements */:
                case 6 /* ParsingContext.EnumMembers */:
                case 4 /* ParsingContext.TypeMembers */:
                case 8 /* ParsingContext.VariableDeclarations */:
                case 17 /* ParsingContext.JSDocParameters */:
                case 16 /* ParsingContext.Parameters */:
                    return true;
            }
            return false;
        }
        function canReuseNode(node, parsingContext) {
            switch (parsingContext) {
                case 5 /* ParsingContext.ClassMembers */:
                    return isReusableClassMember(node);
                case 2 /* ParsingContext.SwitchClauses */:
                    return isReusableSwitchClause(node);
                case 0 /* ParsingContext.SourceElements */:
                case 1 /* ParsingContext.BlockStatements */:
                case 3 /* ParsingContext.SwitchClauseStatements */:
                    return isReusableStatement(node);
                case 6 /* ParsingContext.EnumMembers */:
                    return isReusableEnumMember(node);
                case 4 /* ParsingContext.TypeMembers */:
                    return isReusableTypeMember(node);
                case 8 /* ParsingContext.VariableDeclarations */:
                    return isReusableVariableDeclaration(node);
                case 17 /* ParsingContext.JSDocParameters */:
                case 16 /* ParsingContext.Parameters */:
                    return isReusableParameter(node);
                // Any other lists we do not care about reusing nodes in.  But feel free to add if
                // you can do so safely.  Danger areas involve nodes that may involve speculative
                // parsing.  If speculative parsing is involved with the node, then the range the
                // parser reached while looking ahead might be in the edited range (see the example
                // in canReuseVariableDeclaratorNode for a good case of this).
                // case ParsingContext.HeritageClauses:
                // This would probably be safe to reuse.  There is no speculative parsing with
                // heritage clauses.
                // case ParsingContext.TypeParameters:
                // This would probably be safe to reuse.  There is no speculative parsing with
                // type parameters.  Note that that's because type *parameters* only occur in
                // unambiguous *type* contexts.  While type *arguments* occur in very ambiguous
                // *expression* contexts.
                // case ParsingContext.TupleElementTypes:
                // This would probably be safe to reuse.  There is no speculative parsing with
                // tuple types.
                // Technically, type argument list types are probably safe to reuse.  While
                // speculative parsing is involved with them (since type argument lists are only
                // produced from speculative parsing a < as a type argument list), we only have
                // the types because speculative parsing succeeded.  Thus, the lookahead never
                // went past the end of the list and rewound.
                // case ParsingContext.TypeArguments:
                // Note: these are almost certainly not safe to ever reuse.  Expressions commonly
                // need a large amount of lookahead, and we should not reuse them as they may
                // have actually intersected the edit.
                // case ParsingContext.ArgumentExpressions:
                // This is not safe to reuse for the same reason as the 'AssignmentExpression'
                // cases.  i.e. a property assignment may end with an expression, and thus might
                // have lookahead far beyond it's old node.
                // case ParsingContext.ObjectLiteralMembers:
                // This is probably not safe to reuse.  There can be speculative parsing with
                // type names in a heritage clause.  There can be generic names in the type
                // name list, and there can be left hand side expressions (which can have type
                // arguments.)
                // case ParsingContext.HeritageClauseElement:
                // Perhaps safe to reuse, but it's unlikely we'd see more than a dozen attributes
                // on any given element. Same for children.
                // case ParsingContext.JsxAttributes:
                // case ParsingContext.JsxChildren:
            }
            return false;
        }
        function isReusableClassMember(node) {
            if (node) {
                switch (node.kind) {
                    case 171 /* SyntaxKind.Constructor */:
                    case 176 /* SyntaxKind.IndexSignature */:
                    case 172 /* SyntaxKind.GetAccessor */:
                    case 173 /* SyntaxKind.SetAccessor */:
                    case 167 /* SyntaxKind.PropertyDeclaration */:
                    case 234 /* SyntaxKind.SemicolonClassElement */:
                        return true;
                    case 169 /* SyntaxKind.MethodDeclaration */:
                        // Method declarations are not necessarily reusable.  An object-literal
                        // may have a method calls "constructor(...)" and we must reparse that
                        // into an actual .ConstructorDeclaration.
                        var methodDeclaration = node;
                        var nameIsConstructor = methodDeclaration.name.kind === 79 /* SyntaxKind.Identifier */ &&
                            methodDeclaration.name.originalKeywordKind === 134 /* SyntaxKind.ConstructorKeyword */;
                        return !nameIsConstructor;
                }
            }
            return false;
        }
        function isReusableSwitchClause(node) {
            if (node) {
                switch (node.kind) {
                    case 289 /* SyntaxKind.CaseClause */:
                    case 290 /* SyntaxKind.DefaultClause */:
                        return true;
                }
            }
            return false;
        }
        function isReusableStatement(node) {
            if (node) {
                switch (node.kind) {
                    case 256 /* SyntaxKind.FunctionDeclaration */:
                    case 237 /* SyntaxKind.VariableStatement */:
                    case 235 /* SyntaxKind.Block */:
                    case 239 /* SyntaxKind.IfStatement */:
                    case 238 /* SyntaxKind.ExpressionStatement */:
                    case 251 /* SyntaxKind.ThrowStatement */:
                    case 247 /* SyntaxKind.ReturnStatement */:
                    case 249 /* SyntaxKind.SwitchStatement */:
                    case 246 /* SyntaxKind.BreakStatement */:
                    case 245 /* SyntaxKind.ContinueStatement */:
                    case 243 /* SyntaxKind.ForInStatement */:
                    case 244 /* SyntaxKind.ForOfStatement */:
                    case 242 /* SyntaxKind.ForStatement */:
                    case 241 /* SyntaxKind.WhileStatement */:
                    case 248 /* SyntaxKind.WithStatement */:
                    case 236 /* SyntaxKind.EmptyStatement */:
                    case 252 /* SyntaxKind.TryStatement */:
                    case 250 /* SyntaxKind.LabeledStatement */:
                    case 240 /* SyntaxKind.DoStatement */:
                    case 253 /* SyntaxKind.DebuggerStatement */:
                    case 266 /* SyntaxKind.ImportDeclaration */:
                    case 265 /* SyntaxKind.ImportEqualsDeclaration */:
                    case 272 /* SyntaxKind.ExportDeclaration */:
                    case 271 /* SyntaxKind.ExportAssignment */:
                    case 261 /* SyntaxKind.ModuleDeclaration */:
                    case 257 /* SyntaxKind.ClassDeclaration */:
                    case 258 /* SyntaxKind.InterfaceDeclaration */:
                    case 260 /* SyntaxKind.EnumDeclaration */:
                    case 259 /* SyntaxKind.TypeAliasDeclaration */:
                        return true;
                }
            }
            return false;
        }
        function isReusableEnumMember(node) {
            return node.kind === 299 /* SyntaxKind.EnumMember */;
        }
        function isReusableTypeMember(node) {
            if (node) {
                switch (node.kind) {
                    case 175 /* SyntaxKind.ConstructSignature */:
                    case 168 /* SyntaxKind.MethodSignature */:
                    case 176 /* SyntaxKind.IndexSignature */:
                    case 166 /* SyntaxKind.PropertySignature */:
                    case 174 /* SyntaxKind.CallSignature */:
                        return true;
                }
            }
            return false;
        }
        function isReusableVariableDeclaration(node) {
            if (node.kind !== 254 /* SyntaxKind.VariableDeclaration */) {
                return false;
            }
            // Very subtle incremental parsing bug.  Consider the following code:
            //
            //      let v = new List < A, B
            //
            // This is actually legal code.  It's a list of variable declarators "v = new List<A"
            // on one side and "B" on the other. If you then change that to:
            //
            //      let v = new List < A, B >()
            //
            // then we have a problem.  "v = new List<A" doesn't intersect the change range, so we
            // start reparsing at "B" and we completely fail to handle this properly.
            //
            // In order to prevent this, we do not allow a variable declarator to be reused if it
            // has an initializer.
            var variableDeclarator = node;
            return variableDeclarator.initializer === undefined;
        }
        function isReusableParameter(node) {
            if (node.kind !== 164 /* SyntaxKind.Parameter */) {
                return false;
            }
            // See the comment in isReusableVariableDeclaration for why we do this.
            var parameter = node;
            return parameter.initializer === undefined;
        }
        // Returns true if we should abort parsing.
        function abortParsingListOrMoveToNextToken(kind) {
            parsingContextErrors(kind);
            if (isInSomeParsingContext()) {
                return true;
            }
            nextToken();
            return false;
        }
        function parsingContextErrors(context) {
            switch (context) {
                case 0 /* ParsingContext.SourceElements */:
                    return token() === 88 /* SyntaxKind.DefaultKeyword */
                        ? parseErrorAtCurrentToken(ts.Diagnostics._0_expected, ts.tokenToString(93 /* SyntaxKind.ExportKeyword */))
                        : parseErrorAtCurrentToken(ts.Diagnostics.Declaration_or_statement_expected);
                case 1 /* ParsingContext.BlockStatements */: return parseErrorAtCurrentToken(ts.Diagnostics.Declaration_or_statement_expected);
                case 2 /* ParsingContext.SwitchClauses */: return parseErrorAtCurrentToken(ts.Diagnostics.case_or_default_expected);
                case 3 /* ParsingContext.SwitchClauseStatements */: return parseErrorAtCurrentToken(ts.Diagnostics.Statement_expected);
                case 18 /* ParsingContext.RestProperties */: // fallthrough
                case 4 /* ParsingContext.TypeMembers */: return parseErrorAtCurrentToken(ts.Diagnostics.Property_or_signature_expected);
                case 5 /* ParsingContext.ClassMembers */: return parseErrorAtCurrentToken(ts.Diagnostics.Unexpected_token_A_constructor_method_accessor_or_property_was_expected);
                case 6 /* ParsingContext.EnumMembers */: return parseErrorAtCurrentToken(ts.Diagnostics.Enum_member_expected);
                case 7 /* ParsingContext.HeritageClauseElement */: return parseErrorAtCurrentToken(ts.Diagnostics.Expression_expected);
                case 8 /* ParsingContext.VariableDeclarations */:
                    return ts.isKeyword(token())
                        ? parseErrorAtCurrentToken(ts.Diagnostics._0_is_not_allowed_as_a_variable_declaration_name, ts.tokenToString(token()))
                        : parseErrorAtCurrentToken(ts.Diagnostics.Variable_declaration_expected);
                case 9 /* ParsingContext.ObjectBindingElements */: return parseErrorAtCurrentToken(ts.Diagnostics.Property_destructuring_pattern_expected);
                case 10 /* ParsingContext.ArrayBindingElements */: return parseErrorAtCurrentToken(ts.Diagnostics.Array_element_destructuring_pattern_expected);
                case 11 /* ParsingContext.ArgumentExpressions */: return parseErrorAtCurrentToken(ts.Diagnostics.Argument_expression_expected);
                case 12 /* ParsingContext.ObjectLiteralMembers */: return parseErrorAtCurrentToken(ts.Diagnostics.Property_assignment_expected);
                case 15 /* ParsingContext.ArrayLiteralMembers */: return parseErrorAtCurrentToken(ts.Diagnostics.Expression_or_comma_expected);
                case 17 /* ParsingContext.JSDocParameters */: return parseErrorAtCurrentToken(ts.Diagnostics.Parameter_declaration_expected);
                case 16 /* ParsingContext.Parameters */:
                    return ts.isKeyword(token())
                        ? parseErrorAtCurrentToken(ts.Diagnostics._0_is_not_allowed_as_a_parameter_name, ts.tokenToString(token()))
                        : parseErrorAtCurrentToken(ts.Diagnostics.Parameter_declaration_expected);
                case 19 /* ParsingContext.TypeParameters */: return parseErrorAtCurrentToken(ts.Diagnostics.Type_parameter_declaration_expected);
                case 20 /* ParsingContext.TypeArguments */: return parseErrorAtCurrentToken(ts.Diagnostics.Type_argument_expected);
                case 21 /* ParsingContext.TupleElementTypes */: return parseErrorAtCurrentToken(ts.Diagnostics.Type_expected);
                case 22 /* ParsingContext.HeritageClauses */: return parseErrorAtCurrentToken(ts.Diagnostics.Unexpected_token_expected);
                case 23 /* ParsingContext.ImportOrExportSpecifiers */: return parseErrorAtCurrentToken(ts.Diagnostics.Identifier_expected);
                case 13 /* ParsingContext.JsxAttributes */: return parseErrorAtCurrentToken(ts.Diagnostics.Identifier_expected);
                case 14 /* ParsingContext.JsxChildren */: return parseErrorAtCurrentToken(ts.Diagnostics.Identifier_expected);
                case 24 /* ParsingContext.AssertEntries */: return parseErrorAtCurrentToken(ts.Diagnostics.Identifier_or_string_literal_expected); // AssertionKey.
                case 25 /* ParsingContext.Count */: return ts.Debug.fail("ParsingContext.Count used as a context"); // Not a real context, only a marker.
                default: ts.Debug.assertNever(context);
            }
        }
        function parseDelimitedList(kind, parseElement, considerSemicolonAsDelimiter) {
            var saveParsingContext = parsingContext;
            parsingContext |= 1 << kind;
            var list = [];
            var listPos = getNodePos();
            var commaStart = -1; // Meaning the previous token was not a comma
            while (true) {
                if (isListElement(kind, /*inErrorRecovery*/ false)) {
                    var startPos = scanner.getStartPos();
                    var result = parseListElement(kind, parseElement);
                    if (!result) {
                        parsingContext = saveParsingContext;
                        return undefined;
                    }
                    list.push(result);
                    commaStart = scanner.getTokenPos();
                    if (parseOptional(27 /* SyntaxKind.CommaToken */)) {
                        // No need to check for a zero length node since we know we parsed a comma
                        continue;
                    }
                    commaStart = -1; // Back to the state where the last token was not a comma
                    if (isListTerminator(kind)) {
                        break;
                    }
                    // We didn't get a comma, and the list wasn't terminated, explicitly parse
                    // out a comma so we give a good error message.
                    parseExpected(27 /* SyntaxKind.CommaToken */, getExpectedCommaDiagnostic(kind));
                    // If the token was a semicolon, and the caller allows that, then skip it and
                    // continue.  This ensures we get back on track and don't result in tons of
                    // parse errors.  For example, this can happen when people do things like use
                    // a semicolon to delimit object literal members.   Note: we'll have already
                    // reported an error when we called parseExpected above.
                    if (considerSemicolonAsDelimiter && token() === 26 /* SyntaxKind.SemicolonToken */ && !scanner.hasPrecedingLineBreak()) {
                        nextToken();
                    }
                    if (startPos === scanner.getStartPos()) {
                        // What we're parsing isn't actually remotely recognizable as a element and we've consumed no tokens whatsoever
                        // Consume a token to advance the parser in some way and avoid an infinite loop
                        // This can happen when we're speculatively parsing parenthesized expressions which we think may be arrow functions,
                        // or when a modifier keyword which is disallowed as a parameter name (ie, `static` in strict mode) is supplied
                        nextToken();
                    }
                    continue;
                }
                if (isListTerminator(kind)) {
                    break;
                }
                if (abortParsingListOrMoveToNextToken(kind)) {
                    break;
                }
            }
            parsingContext = saveParsingContext;
            // Recording the trailing comma is deliberately done after the previous
            // loop, and not just if we see a list terminator. This is because the list
            // may have ended incorrectly, but it is still important to know if there
            // was a trailing comma.
            // Check if the last token was a comma.
            // Always preserve a trailing comma by marking it on the NodeArray
            return createNodeArray(list, listPos, /*end*/ undefined, commaStart >= 0);
        }
        function getExpectedCommaDiagnostic(kind) {
            return kind === 6 /* ParsingContext.EnumMembers */ ? ts.Diagnostics.An_enum_member_name_must_be_followed_by_a_or : undefined;
        }
        function createMissingList() {
            var list = createNodeArray([], getNodePos());
            list.isMissingList = true;
            return list;
        }
        function isMissingList(arr) {
            return !!arr.isMissingList;
        }
        function parseBracketedList(kind, parseElement, open, close) {
            if (parseExpected(open)) {
                var result = parseDelimitedList(kind, parseElement);
                parseExpected(close);
                return result;
            }
            return createMissingList();
        }
        function parseEntityName(allowReservedWords, diagnosticMessage) {
            var pos = getNodePos();
            var entity = allowReservedWords ? parseIdentifierName(diagnosticMessage) : parseIdentifier(diagnosticMessage);
            var dotPos = getNodePos();
            while (parseOptional(24 /* SyntaxKind.DotToken */)) {
                if (token() === 29 /* SyntaxKind.LessThanToken */) {
                    // the entity is part of a JSDoc-style generic, so record the trailing dot for later error reporting
                    entity.jsdocDotPos = dotPos;
                    break;
                }
                dotPos = getNodePos();
                entity = finishNode(factory.createQualifiedName(entity, parseRightSideOfDot(allowReservedWords, /* allowPrivateIdentifiers */ false)), pos);
            }
            return entity;
        }
        function createQualifiedName(entity, name) {
            return finishNode(factory.createQualifiedName(entity, name), entity.pos);
        }
        function parseRightSideOfDot(allowIdentifierNames, allowPrivateIdentifiers) {
            // Technically a keyword is valid here as all identifiers and keywords are identifier names.
            // However, often we'll encounter this in error situations when the identifier or keyword
            // is actually starting another valid construct.
            //
            // So, we check for the following specific case:
            //
            //      name.
            //      identifierOrKeyword identifierNameOrKeyword
            //
            // Note: the newlines are important here.  For example, if that above code
            // were rewritten into:
            //
            //      name.identifierOrKeyword
            //      identifierNameOrKeyword
            //
            // Then we would consider it valid.  That's because ASI would take effect and
            // the code would be implicitly: "name.identifierOrKeyword; identifierNameOrKeyword".
            // In the first case though, ASI will not take effect because there is not a
            // line terminator after the identifier or keyword.
            if (scanner.hasPrecedingLineBreak() && ts.tokenIsIdentifierOrKeyword(token())) {
                var matchesPattern = lookAhead(nextTokenIsIdentifierOrKeywordOnSameLine);
                if (matchesPattern) {
                    // Report that we need an identifier.  However, report it right after the dot,
                    // and not on the next token.  This is because the next token might actually
                    // be an identifier and the error would be quite confusing.
                    return createMissingNode(79 /* SyntaxKind.Identifier */, /*reportAtCurrentPosition*/ true, ts.Diagnostics.Identifier_expected);
                }
            }
            if (token() === 80 /* SyntaxKind.PrivateIdentifier */) {
                var node = parsePrivateIdentifier();
                return allowPrivateIdentifiers ? node : createMissingNode(79 /* SyntaxKind.Identifier */, /*reportAtCurrentPosition*/ true, ts.Diagnostics.Identifier_expected);
            }
            return allowIdentifierNames ? parseIdentifierName() : parseIdentifier();
        }
        function parseTemplateSpans(isTaggedTemplate) {
            var pos = getNodePos();
            var list = [];
            var node;
            do {
                node = parseTemplateSpan(isTaggedTemplate);
                list.push(node);
            } while (node.literal.kind === 16 /* SyntaxKind.TemplateMiddle */);
            return createNodeArray(list, pos);
        }
        function parseTemplateExpression(isTaggedTemplate) {
            var pos = getNodePos();
            return finishNode(factory.createTemplateExpression(parseTemplateHead(isTaggedTemplate), parseTemplateSpans(isTaggedTemplate)), pos);
        }
        function parseTemplateType() {
            var pos = getNodePos();
            return finishNode(factory.createTemplateLiteralType(parseTemplateHead(/*isTaggedTemplate*/ false), parseTemplateTypeSpans()), pos);
        }
        function parseTemplateTypeSpans() {
            var pos = getNodePos();
            var list = [];
            var node;
            do {
                node = parseTemplateTypeSpan();
                list.push(node);
            } while (node.literal.kind === 16 /* SyntaxKind.TemplateMiddle */);
            return createNodeArray(list, pos);
        }
        function parseTemplateTypeSpan() {
            var pos = getNodePos();
            return finishNode(factory.createTemplateLiteralTypeSpan(parseType(), parseLiteralOfTemplateSpan(/*isTaggedTemplate*/ false)), pos);
        }
        function parseLiteralOfTemplateSpan(isTaggedTemplate) {
            if (token() === 19 /* SyntaxKind.CloseBraceToken */) {
                reScanTemplateToken(isTaggedTemplate);
                return parseTemplateMiddleOrTemplateTail();
            }
            else {
                // TODO(rbuckton): Do we need to call `parseExpectedToken` or can we just call `createMissingNode` directly?
                return parseExpectedToken(17 /* SyntaxKind.TemplateTail */, ts.Diagnostics._0_expected, ts.tokenToString(19 /* SyntaxKind.CloseBraceToken */));
            }
        }
        function parseTemplateSpan(isTaggedTemplate) {
            var pos = getNodePos();
            return finishNode(factory.createTemplateSpan(allowInAnd(parseExpression), parseLiteralOfTemplateSpan(isTaggedTemplate)), pos);
        }
        function parseLiteralNode() {
            return parseLiteralLikeNode(token());
        }
        function parseTemplateHead(isTaggedTemplate) {
            if (isTaggedTemplate) {
                reScanTemplateHeadOrNoSubstitutionTemplate();
            }
            var fragment = parseLiteralLikeNode(token());
            ts.Debug.assert(fragment.kind === 15 /* SyntaxKind.TemplateHead */, "Template head has wrong token kind");
            return fragment;
        }
        function parseTemplateMiddleOrTemplateTail() {
            var fragment = parseLiteralLikeNode(token());
            ts.Debug.assert(fragment.kind === 16 /* SyntaxKind.TemplateMiddle */ || fragment.kind === 17 /* SyntaxKind.TemplateTail */, "Template fragment has wrong token kind");
            return fragment;
        }
        function getTemplateLiteralRawText(kind) {
            var isLast = kind === 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */ || kind === 17 /* SyntaxKind.TemplateTail */;
            var tokenText = scanner.getTokenText();
            return tokenText.substring(1, tokenText.length - (scanner.isUnterminated() ? 0 : isLast ? 1 : 2));
        }
        function parseLiteralLikeNode(kind) {
            var pos = getNodePos();
            var node = ts.isTemplateLiteralKind(kind) ? factory.createTemplateLiteralLikeNode(kind, scanner.getTokenValue(), getTemplateLiteralRawText(kind), scanner.getTokenFlags() & 2048 /* TokenFlags.TemplateLiteralLikeFlags */) :
                // Octal literals are not allowed in strict mode or ES5
                // Note that theoretically the following condition would hold true literals like 009,
                // which is not octal. But because of how the scanner separates the tokens, we would
                // never get a token like this. Instead, we would get 00 and 9 as two separate tokens.
                // We also do not need to check for negatives because any prefix operator would be part of a
                // parent unary expression.
                kind === 8 /* SyntaxKind.NumericLiteral */ ? factory.createNumericLiteral(scanner.getTokenValue(), scanner.getNumericLiteralFlags()) :
                    kind === 10 /* SyntaxKind.StringLiteral */ ? factory.createStringLiteral(scanner.getTokenValue(), /*isSingleQuote*/ undefined, scanner.hasExtendedUnicodeEscape()) :
                        ts.isLiteralKind(kind) ? factory.createLiteralLikeNode(kind, scanner.getTokenValue()) :
                            ts.Debug.fail();
            if (scanner.hasExtendedUnicodeEscape()) {
                node.hasExtendedUnicodeEscape = true;
            }
            if (scanner.isUnterminated()) {
                node.isUnterminated = true;
            }
            nextToken();
            return finishNode(node, pos);
        }
        // TYPES
        function parseEntityNameOfTypeReference() {
            return parseEntityName(/*allowReservedWords*/ true, ts.Diagnostics.Type_expected);
        }
        function parseTypeArgumentsOfTypeReference() {
            if (!scanner.hasPrecedingLineBreak() && reScanLessThanToken() === 29 /* SyntaxKind.LessThanToken */) {
                return parseBracketedList(20 /* ParsingContext.TypeArguments */, parseType, 29 /* SyntaxKind.LessThanToken */, 31 /* SyntaxKind.GreaterThanToken */);
            }
        }
        function parseTypeReference() {
            var pos = getNodePos();
            return finishNode(factory.createTypeReferenceNode(parseEntityNameOfTypeReference(), parseTypeArgumentsOfTypeReference()), pos);
        }
        // If true, we should abort parsing an error function.
        function typeHasArrowFunctionBlockingParseError(node) {
            switch (node.kind) {
                case 178 /* SyntaxKind.TypeReference */:
                    return ts.nodeIsMissing(node.typeName);
                case 179 /* SyntaxKind.FunctionType */:
                case 180 /* SyntaxKind.ConstructorType */: {
                    var _a = node, parameters = _a.parameters, type = _a.type;
                    return isMissingList(parameters) || typeHasArrowFunctionBlockingParseError(type);
                }
                case 191 /* SyntaxKind.ParenthesizedType */:
                    return typeHasArrowFunctionBlockingParseError(node.type);
                default:
                    return false;
            }
        }
        function parseThisTypePredicate(lhs) {
            nextToken();
            return finishNode(factory.createTypePredicateNode(/*assertsModifier*/ undefined, lhs, parseType()), lhs.pos);
        }
        function parseThisTypeNode() {
            var pos = getNodePos();
            nextToken();
            return finishNode(factory.createThisTypeNode(), pos);
        }
        function parseJSDocAllType() {
            var pos = getNodePos();
            nextToken();
            return finishNode(factory.createJSDocAllType(), pos);
        }
        function parseJSDocNonNullableType() {
            var pos = getNodePos();
            nextToken();
            return finishNode(factory.createJSDocNonNullableType(parseNonArrayType(), /*postfix*/ false), pos);
        }
        function parseJSDocUnknownOrNullableType() {
            var pos = getNodePos();
            // skip the ?
            nextToken();
            // Need to lookahead to decide if this is a nullable or unknown type.
            // Here are cases where we'll pick the unknown type:
            //
            //      Foo(?,
            //      { a: ? }
            //      Foo(?)
            //      Foo<?>
            //      Foo(?=
            //      (?|
            if (token() === 27 /* SyntaxKind.CommaToken */ ||
                token() === 19 /* SyntaxKind.CloseBraceToken */ ||
                token() === 21 /* SyntaxKind.CloseParenToken */ ||
                token() === 31 /* SyntaxKind.GreaterThanToken */ ||
                token() === 63 /* SyntaxKind.EqualsToken */ ||
                token() === 51 /* SyntaxKind.BarToken */) {
                return finishNode(factory.createJSDocUnknownType(), pos);
            }
            else {
                return finishNode(factory.createJSDocNullableType(parseType(), /*postfix*/ false), pos);
            }
        }
        function parseJSDocFunctionType() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            if (lookAhead(nextTokenIsOpenParen)) {
                nextToken();
                var parameters = parseParameters(4 /* SignatureFlags.Type */ | 32 /* SignatureFlags.JSDoc */);
                var type = parseReturnType(58 /* SyntaxKind.ColonToken */, /*isType*/ false);
                return withJSDoc(finishNode(factory.createJSDocFunctionType(parameters, type), pos), hasJSDoc);
            }
            return finishNode(factory.createTypeReferenceNode(parseIdentifierName(), /*typeArguments*/ undefined), pos);
        }
        function parseJSDocParameter() {
            var pos = getNodePos();
            var name;
            if (token() === 108 /* SyntaxKind.ThisKeyword */ || token() === 103 /* SyntaxKind.NewKeyword */) {
                name = parseIdentifierName();
                parseExpected(58 /* SyntaxKind.ColonToken */);
            }
            return finishNode(factory.createParameterDeclaration(
            /*modifiers*/ undefined, 
            /*dotDotDotToken*/ undefined, 
            // TODO(rbuckton): JSDoc parameters don't have names (except `this`/`new`), should we manufacture an empty identifier?
            name, 
            /*questionToken*/ undefined, parseJSDocType(), 
            /*initializer*/ undefined), pos);
        }
        function parseJSDocType() {
            scanner.setInJSDocType(true);
            var pos = getNodePos();
            if (parseOptional(141 /* SyntaxKind.ModuleKeyword */)) {
                // TODO(rbuckton): We never set the type for a JSDocNamepathType. What should we put here?
                var moduleTag = factory.createJSDocNamepathType(/*type*/ undefined);
                terminate: while (true) {
                    switch (token()) {
                        case 19 /* SyntaxKind.CloseBraceToken */:
                        case 1 /* SyntaxKind.EndOfFileToken */:
                        case 27 /* SyntaxKind.CommaToken */:
                        case 5 /* SyntaxKind.WhitespaceTrivia */:
                            break terminate;
                        default:
                            nextTokenJSDoc();
                    }
                }
                scanner.setInJSDocType(false);
                return finishNode(moduleTag, pos);
            }
            var hasDotDotDot = parseOptional(25 /* SyntaxKind.DotDotDotToken */);
            var type = parseTypeOrTypePredicate();
            scanner.setInJSDocType(false);
            if (hasDotDotDot) {
                type = finishNode(factory.createJSDocVariadicType(type), pos);
            }
            if (token() === 63 /* SyntaxKind.EqualsToken */) {
                nextToken();
                return finishNode(factory.createJSDocOptionalType(type), pos);
            }
            return type;
        }
        function parseTypeQuery() {
            var pos = getNodePos();
            parseExpected(112 /* SyntaxKind.TypeOfKeyword */);
            var entityName = parseEntityName(/*allowReservedWords*/ true);
            // Make sure we perform ASI to prevent parsing the next line's type arguments as part of an instantiation expression.
            var typeArguments = !scanner.hasPrecedingLineBreak() ? tryParseTypeArguments() : undefined;
            return finishNode(factory.createTypeQueryNode(entityName, typeArguments), pos);
        }
        function parseTypeParameter() {
            var pos = getNodePos();
            var modifiers = parseModifiers();
            var name = parseIdentifier();
            var constraint;
            var expression;
            if (parseOptional(94 /* SyntaxKind.ExtendsKeyword */)) {
                // It's not uncommon for people to write improper constraints to a generic.  If the
                // user writes a constraint that is an expression and not an actual type, then parse
                // it out as an expression (so we can recover well), but report that a type is needed
                // instead.
                if (isStartOfType() || !isStartOfExpression()) {
                    constraint = parseType();
                }
                else {
                    // It was not a type, and it looked like an expression.  Parse out an expression
                    // here so we recover well.  Note: it is important that we call parseUnaryExpression
                    // and not parseExpression here.  If the user has:
                    //
                    //      <T extends "">
                    //
                    // We do *not* want to consume the `>` as we're consuming the expression for "".
                    expression = parseUnaryExpressionOrHigher();
                }
            }
            var defaultType = parseOptional(63 /* SyntaxKind.EqualsToken */) ? parseType() : undefined;
            var node = factory.createTypeParameterDeclaration(modifiers, name, constraint, defaultType);
            node.expression = expression;
            return finishNode(node, pos);
        }
        function parseTypeParameters() {
            if (token() === 29 /* SyntaxKind.LessThanToken */) {
                return parseBracketedList(19 /* ParsingContext.TypeParameters */, parseTypeParameter, 29 /* SyntaxKind.LessThanToken */, 31 /* SyntaxKind.GreaterThanToken */);
            }
        }
        function isStartOfParameter(isJSDocParameter) {
            return token() === 25 /* SyntaxKind.DotDotDotToken */ ||
                isBindingIdentifierOrPrivateIdentifierOrPattern() ||
                ts.isModifierKind(token()) ||
                token() === 59 /* SyntaxKind.AtToken */ ||
                isStartOfType(/*inStartOfParameter*/ !isJSDocParameter);
        }
        function parseNameOfParameter(modifiers) {
            // FormalParameter [Yield,Await]:
            //      BindingElement[?Yield,?Await]
            var name = parseIdentifierOrPattern(ts.Diagnostics.Private_identifiers_cannot_be_used_as_parameters);
            if (ts.getFullWidth(name) === 0 && !ts.some(modifiers) && ts.isModifierKind(token())) {
                // in cases like
                // 'use strict'
                // function foo(static)
                // isParameter('static') === true, because of isModifier('static')
                // however 'static' is not a legal identifier in a strict mode.
                // so result of this function will be ParameterDeclaration (flags = 0, name = missing, type = undefined, initializer = undefined)
                // and current token will not change => parsing of the enclosing parameter list will last till the end of time (or OOM)
                // to avoid this we'll advance cursor to the next token.
                nextToken();
            }
            return name;
        }
        function isParameterNameStart() {
            // Be permissive about await and yield by calling isBindingIdentifier instead of isIdentifier; disallowing
            // them during a speculative parse leads to many more follow-on errors than allowing the function to parse then later
            // complaining about the use of the keywords.
            return isBindingIdentifier() || token() === 22 /* SyntaxKind.OpenBracketToken */ || token() === 18 /* SyntaxKind.OpenBraceToken */;
        }
        function parseParameter(inOuterAwaitContext) {
            return parseParameterWorker(inOuterAwaitContext);
        }
        function parseParameterForSpeculation(inOuterAwaitContext) {
            return parseParameterWorker(inOuterAwaitContext, /*allowAmbiguity*/ false);
        }
        function parseParameterWorker(inOuterAwaitContext, allowAmbiguity) {
            if (allowAmbiguity === void 0) { allowAmbiguity = true; }
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            // FormalParameter [Yield,Await]:
            //      BindingElement[?Yield,?Await]
            // Decorators are parsed in the outer [Await] context, the rest of the parameter is parsed in the function's [Await] context.
            var decorators = inOuterAwaitContext ? doInAwaitContext(parseDecorators) : doOutsideOfAwaitContext(parseDecorators);
            if (token() === 108 /* SyntaxKind.ThisKeyword */) {
                var node_1 = factory.createParameterDeclaration(decorators, 
                /*dotDotDotToken*/ undefined, createIdentifier(/*isIdentifier*/ true), 
                /*questionToken*/ undefined, parseTypeAnnotation(), 
                /*initializer*/ undefined);
                if (decorators) {
                    parseErrorAtRange(decorators[0], ts.Diagnostics.Decorators_may_not_be_applied_to_this_parameters);
                }
                return withJSDoc(finishNode(node_1, pos), hasJSDoc);
            }
            var savedTopLevel = topLevel;
            topLevel = false;
            var modifiers = combineDecoratorsAndModifiers(decorators, parseModifiers());
            var dotDotDotToken = parseOptionalToken(25 /* SyntaxKind.DotDotDotToken */);
            if (!allowAmbiguity && !isParameterNameStart()) {
                return undefined;
            }
            var node = withJSDoc(finishNode(factory.createParameterDeclaration(modifiers, dotDotDotToken, parseNameOfParameter(modifiers), parseOptionalToken(57 /* SyntaxKind.QuestionToken */), parseTypeAnnotation(), parseInitializer()), pos), hasJSDoc);
            topLevel = savedTopLevel;
            return node;
        }
        function parseReturnType(returnToken, isType) {
            if (shouldParseReturnType(returnToken, isType)) {
                return allowConditionalTypesAnd(parseTypeOrTypePredicate);
            }
        }
        function shouldParseReturnType(returnToken, isType) {
            if (returnToken === 38 /* SyntaxKind.EqualsGreaterThanToken */) {
                parseExpected(returnToken);
                return true;
            }
            else if (parseOptional(58 /* SyntaxKind.ColonToken */)) {
                return true;
            }
            else if (isType && token() === 38 /* SyntaxKind.EqualsGreaterThanToken */) {
                // This is easy to get backward, especially in type contexts, so parse the type anyway
                parseErrorAtCurrentToken(ts.Diagnostics._0_expected, ts.tokenToString(58 /* SyntaxKind.ColonToken */));
                nextToken();
                return true;
            }
            return false;
        }
        function parseParametersWorker(flags, allowAmbiguity) {
            // FormalParameters [Yield,Await]: (modified)
            //      [empty]
            //      FormalParameterList[?Yield,Await]
            //
            // FormalParameter[Yield,Await]: (modified)
            //      BindingElement[?Yield,Await]
            //
            // BindingElement [Yield,Await]: (modified)
            //      SingleNameBinding[?Yield,?Await]
            //      BindingPattern[?Yield,?Await]Initializer [In, ?Yield,?Await] opt
            //
            // SingleNameBinding [Yield,Await]:
            //      BindingIdentifier[?Yield,?Await]Initializer [In, ?Yield,?Await] opt
            var savedYieldContext = inYieldContext();
            var savedAwaitContext = inAwaitContext();
            setYieldContext(!!(flags & 1 /* SignatureFlags.Yield */));
            setAwaitContext(!!(flags & 2 /* SignatureFlags.Await */));
            var parameters = flags & 32 /* SignatureFlags.JSDoc */ ?
                parseDelimitedList(17 /* ParsingContext.JSDocParameters */, parseJSDocParameter) :
                parseDelimitedList(16 /* ParsingContext.Parameters */, function () { return allowAmbiguity ? parseParameter(savedAwaitContext) : parseParameterForSpeculation(savedAwaitContext); });
            setYieldContext(savedYieldContext);
            setAwaitContext(savedAwaitContext);
            return parameters;
        }
        function parseParameters(flags) {
            // FormalParameters [Yield,Await]: (modified)
            //      [empty]
            //      FormalParameterList[?Yield,Await]
            //
            // FormalParameter[Yield,Await]: (modified)
            //      BindingElement[?Yield,Await]
            //
            // BindingElement [Yield,Await]: (modified)
            //      SingleNameBinding[?Yield,?Await]
            //      BindingPattern[?Yield,?Await]Initializer [In, ?Yield,?Await] opt
            //
            // SingleNameBinding [Yield,Await]:
            //      BindingIdentifier[?Yield,?Await]Initializer [In, ?Yield,?Await] opt
            if (!parseExpected(20 /* SyntaxKind.OpenParenToken */)) {
                return createMissingList();
            }
            var parameters = parseParametersWorker(flags, /*allowAmbiguity*/ true);
            parseExpected(21 /* SyntaxKind.CloseParenToken */);
            return parameters;
        }
        function parseTypeMemberSemicolon() {
            // We allow type members to be separated by commas or (possibly ASI) semicolons.
            // First check if it was a comma.  If so, we're done with the member.
            if (parseOptional(27 /* SyntaxKind.CommaToken */)) {
                return;
            }
            // Didn't have a comma.  We must have a (possible ASI) semicolon.
            parseSemicolon();
        }
        function parseSignatureMember(kind) {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            if (kind === 175 /* SyntaxKind.ConstructSignature */) {
                parseExpected(103 /* SyntaxKind.NewKeyword */);
            }
            var typeParameters = parseTypeParameters();
            var parameters = parseParameters(4 /* SignatureFlags.Type */);
            var type = parseReturnType(58 /* SyntaxKind.ColonToken */, /*isType*/ true);
            parseTypeMemberSemicolon();
            var node = kind === 174 /* SyntaxKind.CallSignature */
                ? factory.createCallSignature(typeParameters, parameters, type)
                : factory.createConstructSignature(typeParameters, parameters, type);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function isIndexSignature() {
            return token() === 22 /* SyntaxKind.OpenBracketToken */ && lookAhead(isUnambiguouslyIndexSignature);
        }
        function isUnambiguouslyIndexSignature() {
            // The only allowed sequence is:
            //
            //   [id:
            //
            // However, for error recovery, we also check the following cases:
            //
            //   [...
            //   [id,
            //   [id?,
            //   [id?:
            //   [id?]
            //   [public id
            //   [private id
            //   [protected id
            //   []
            //
            nextToken();
            if (token() === 25 /* SyntaxKind.DotDotDotToken */ || token() === 23 /* SyntaxKind.CloseBracketToken */) {
                return true;
            }
            if (ts.isModifierKind(token())) {
                nextToken();
                if (isIdentifier()) {
                    return true;
                }
            }
            else if (!isIdentifier()) {
                return false;
            }
            else {
                // Skip the identifier
                nextToken();
            }
            // A colon signifies a well formed indexer
            // A comma should be a badly formed indexer because comma expressions are not allowed
            // in computed properties.
            if (token() === 58 /* SyntaxKind.ColonToken */ || token() === 27 /* SyntaxKind.CommaToken */) {
                return true;
            }
            // Question mark could be an indexer with an optional property,
            // or it could be a conditional expression in a computed property.
            if (token() !== 57 /* SyntaxKind.QuestionToken */) {
                return false;
            }
            // If any of the following tokens are after the question mark, it cannot
            // be a conditional expression, so treat it as an indexer.
            nextToken();
            return token() === 58 /* SyntaxKind.ColonToken */ || token() === 27 /* SyntaxKind.CommaToken */ || token() === 23 /* SyntaxKind.CloseBracketToken */;
        }
        function parseIndexSignatureDeclaration(pos, hasJSDoc, decorators, modifiers) {
            var parameters = parseBracketedList(16 /* ParsingContext.Parameters */, function () { return parseParameter(/*inOuterAwaitContext*/ false); }, 22 /* SyntaxKind.OpenBracketToken */, 23 /* SyntaxKind.CloseBracketToken */);
            var type = parseTypeAnnotation();
            parseTypeMemberSemicolon();
            var node = factory.createIndexSignature(modifiers, parameters, type);
            node.illegalDecorators = decorators;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parsePropertyOrMethodSignature(pos, hasJSDoc, modifiers) {
            var name = parsePropertyName();
            var questionToken = parseOptionalToken(57 /* SyntaxKind.QuestionToken */);
            var node;
            if (token() === 20 /* SyntaxKind.OpenParenToken */ || token() === 29 /* SyntaxKind.LessThanToken */) {
                // Method signatures don't exist in expression contexts.  So they have neither
                // [Yield] nor [Await]
                var typeParameters = parseTypeParameters();
                var parameters = parseParameters(4 /* SignatureFlags.Type */);
                var type = parseReturnType(58 /* SyntaxKind.ColonToken */, /*isType*/ true);
                node = factory.createMethodSignature(modifiers, name, questionToken, typeParameters, parameters, type);
            }
            else {
                var type = parseTypeAnnotation();
                node = factory.createPropertySignature(modifiers, name, questionToken, type);
                // Although type literal properties cannot not have initializers, we attempt
                // to parse an initializer so we can report in the checker that an interface
                // property or type literal property cannot have an initializer.
                if (token() === 63 /* SyntaxKind.EqualsToken */)
                    node.initializer = parseInitializer();
            }
            parseTypeMemberSemicolon();
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function isTypeMemberStart() {
            // Return true if we have the start of a signature member
            if (token() === 20 /* SyntaxKind.OpenParenToken */ ||
                token() === 29 /* SyntaxKind.LessThanToken */ ||
                token() === 136 /* SyntaxKind.GetKeyword */ ||
                token() === 149 /* SyntaxKind.SetKeyword */) {
                return true;
            }
            var idToken = false;
            // Eat up all modifiers, but hold on to the last one in case it is actually an identifier
            while (ts.isModifierKind(token())) {
                idToken = true;
                nextToken();
            }
            // Index signatures and computed property names are type members
            if (token() === 22 /* SyntaxKind.OpenBracketToken */) {
                return true;
            }
            // Try to get the first property-like token following all modifiers
            if (isLiteralPropertyName()) {
                idToken = true;
                nextToken();
            }
            // If we were able to get any potential identifier, check that it is
            // the start of a member declaration
            if (idToken) {
                return token() === 20 /* SyntaxKind.OpenParenToken */ ||
                    token() === 29 /* SyntaxKind.LessThanToken */ ||
                    token() === 57 /* SyntaxKind.QuestionToken */ ||
                    token() === 58 /* SyntaxKind.ColonToken */ ||
                    token() === 27 /* SyntaxKind.CommaToken */ ||
                    canParseSemicolon();
            }
            return false;
        }
        function parseTypeMember() {
            if (token() === 20 /* SyntaxKind.OpenParenToken */ || token() === 29 /* SyntaxKind.LessThanToken */) {
                return parseSignatureMember(174 /* SyntaxKind.CallSignature */);
            }
            if (token() === 103 /* SyntaxKind.NewKeyword */ && lookAhead(nextTokenIsOpenParenOrLessThan)) {
                return parseSignatureMember(175 /* SyntaxKind.ConstructSignature */);
            }
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var modifiers = parseModifiers();
            if (parseContextualModifier(136 /* SyntaxKind.GetKeyword */)) {
                return parseAccessorDeclaration(pos, hasJSDoc, /*decorators*/ undefined, modifiers, 172 /* SyntaxKind.GetAccessor */, 4 /* SignatureFlags.Type */);
            }
            if (parseContextualModifier(149 /* SyntaxKind.SetKeyword */)) {
                return parseAccessorDeclaration(pos, hasJSDoc, /*decorators*/ undefined, modifiers, 173 /* SyntaxKind.SetAccessor */, 4 /* SignatureFlags.Type */);
            }
            if (isIndexSignature()) {
                return parseIndexSignatureDeclaration(pos, hasJSDoc, /*decorators*/ undefined, modifiers);
            }
            return parsePropertyOrMethodSignature(pos, hasJSDoc, modifiers);
        }
        function nextTokenIsOpenParenOrLessThan() {
            nextToken();
            return token() === 20 /* SyntaxKind.OpenParenToken */ || token() === 29 /* SyntaxKind.LessThanToken */;
        }
        function nextTokenIsDot() {
            return nextToken() === 24 /* SyntaxKind.DotToken */;
        }
        function nextTokenIsOpenParenOrLessThanOrDot() {
            switch (nextToken()) {
                case 20 /* SyntaxKind.OpenParenToken */:
                case 29 /* SyntaxKind.LessThanToken */:
                case 24 /* SyntaxKind.DotToken */:
                    return true;
            }
            return false;
        }
        function parseTypeLiteral() {
            var pos = getNodePos();
            return finishNode(factory.createTypeLiteralNode(parseObjectTypeMembers()), pos);
        }
        function parseObjectTypeMembers() {
            var members;
            if (parseExpected(18 /* SyntaxKind.OpenBraceToken */)) {
                members = parseList(4 /* ParsingContext.TypeMembers */, parseTypeMember);
                parseExpected(19 /* SyntaxKind.CloseBraceToken */);
            }
            else {
                members = createMissingList();
            }
            return members;
        }
        function isStartOfMappedType() {
            nextToken();
            if (token() === 39 /* SyntaxKind.PlusToken */ || token() === 40 /* SyntaxKind.MinusToken */) {
                return nextToken() === 145 /* SyntaxKind.ReadonlyKeyword */;
            }
            if (token() === 145 /* SyntaxKind.ReadonlyKeyword */) {
                nextToken();
            }
            return token() === 22 /* SyntaxKind.OpenBracketToken */ && nextTokenIsIdentifier() && nextToken() === 101 /* SyntaxKind.InKeyword */;
        }
        function parseMappedTypeParameter() {
            var pos = getNodePos();
            var name = parseIdentifierName();
            parseExpected(101 /* SyntaxKind.InKeyword */);
            var type = parseType();
            return finishNode(factory.createTypeParameterDeclaration(/*modifiers*/ undefined, name, type, /*defaultType*/ undefined), pos);
        }
        function parseMappedType() {
            var pos = getNodePos();
            parseExpected(18 /* SyntaxKind.OpenBraceToken */);
            var readonlyToken;
            if (token() === 145 /* SyntaxKind.ReadonlyKeyword */ || token() === 39 /* SyntaxKind.PlusToken */ || token() === 40 /* SyntaxKind.MinusToken */) {
                readonlyToken = parseTokenNode();
                if (readonlyToken.kind !== 145 /* SyntaxKind.ReadonlyKeyword */) {
                    parseExpected(145 /* SyntaxKind.ReadonlyKeyword */);
                }
            }
            parseExpected(22 /* SyntaxKind.OpenBracketToken */);
            var typeParameter = parseMappedTypeParameter();
            var nameType = parseOptional(127 /* SyntaxKind.AsKeyword */) ? parseType() : undefined;
            parseExpected(23 /* SyntaxKind.CloseBracketToken */);
            var questionToken;
            if (token() === 57 /* SyntaxKind.QuestionToken */ || token() === 39 /* SyntaxKind.PlusToken */ || token() === 40 /* SyntaxKind.MinusToken */) {
                questionToken = parseTokenNode();
                if (questionToken.kind !== 57 /* SyntaxKind.QuestionToken */) {
                    parseExpected(57 /* SyntaxKind.QuestionToken */);
                }
            }
            var type = parseTypeAnnotation();
            parseSemicolon();
            var members = parseList(4 /* ParsingContext.TypeMembers */, parseTypeMember);
            parseExpected(19 /* SyntaxKind.CloseBraceToken */);
            return finishNode(factory.createMappedTypeNode(readonlyToken, typeParameter, nameType, questionToken, type, members), pos);
        }
        function parseTupleElementType() {
            var pos = getNodePos();
            if (parseOptional(25 /* SyntaxKind.DotDotDotToken */)) {
                return finishNode(factory.createRestTypeNode(parseType()), pos);
            }
            var type = parseType();
            if (ts.isJSDocNullableType(type) && type.pos === type.type.pos) {
                var node = factory.createOptionalTypeNode(type.type);
                ts.setTextRange(node, type);
                node.flags = type.flags;
                return node;
            }
            return type;
        }
        function isNextTokenColonOrQuestionColon() {
            return nextToken() === 58 /* SyntaxKind.ColonToken */ || (token() === 57 /* SyntaxKind.QuestionToken */ && nextToken() === 58 /* SyntaxKind.ColonToken */);
        }
        function isTupleElementName() {
            if (token() === 25 /* SyntaxKind.DotDotDotToken */) {
                return ts.tokenIsIdentifierOrKeyword(nextToken()) && isNextTokenColonOrQuestionColon();
            }
            return ts.tokenIsIdentifierOrKeyword(token()) && isNextTokenColonOrQuestionColon();
        }
        function parseTupleElementNameOrTupleElementType() {
            if (lookAhead(isTupleElementName)) {
                var pos = getNodePos();
                var hasJSDoc = hasPrecedingJSDocComment();
                var dotDotDotToken = parseOptionalToken(25 /* SyntaxKind.DotDotDotToken */);
                var name = parseIdentifierName();
                var questionToken = parseOptionalToken(57 /* SyntaxKind.QuestionToken */);
                parseExpected(58 /* SyntaxKind.ColonToken */);
                var type = parseTupleElementType();
                var node = factory.createNamedTupleMember(dotDotDotToken, name, questionToken, type);
                return withJSDoc(finishNode(node, pos), hasJSDoc);
            }
            return parseTupleElementType();
        }
        function parseTupleType() {
            var pos = getNodePos();
            return finishNode(factory.createTupleTypeNode(parseBracketedList(21 /* ParsingContext.TupleElementTypes */, parseTupleElementNameOrTupleElementType, 22 /* SyntaxKind.OpenBracketToken */, 23 /* SyntaxKind.CloseBracketToken */)), pos);
        }
        function parseParenthesizedType() {
            var pos = getNodePos();
            parseExpected(20 /* SyntaxKind.OpenParenToken */);
            var type = parseType();
            parseExpected(21 /* SyntaxKind.CloseParenToken */);
            return finishNode(factory.createParenthesizedType(type), pos);
        }
        function parseModifiersForConstructorType() {
            var modifiers;
            if (token() === 126 /* SyntaxKind.AbstractKeyword */) {
                var pos = getNodePos();
                nextToken();
                var modifier = finishNode(factory.createToken(126 /* SyntaxKind.AbstractKeyword */), pos);
                modifiers = createNodeArray([modifier], pos);
            }
            return modifiers;
        }
        function parseFunctionOrConstructorType() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var modifiers = parseModifiersForConstructorType();
            var isConstructorType = parseOptional(103 /* SyntaxKind.NewKeyword */);
            var typeParameters = parseTypeParameters();
            var parameters = parseParameters(4 /* SignatureFlags.Type */);
            var type = parseReturnType(38 /* SyntaxKind.EqualsGreaterThanToken */, /*isType*/ false);
            var node = isConstructorType
                ? factory.createConstructorTypeNode(modifiers, typeParameters, parameters, type)
                : factory.createFunctionTypeNode(typeParameters, parameters, type);
            if (!isConstructorType)
                node.modifiers = modifiers;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseKeywordAndNoDot() {
            var node = parseTokenNode();
            return token() === 24 /* SyntaxKind.DotToken */ ? undefined : node;
        }
        function parseLiteralTypeNode(negative) {
            var pos = getNodePos();
            if (negative) {
                nextToken();
            }
            var expression = token() === 110 /* SyntaxKind.TrueKeyword */ || token() === 95 /* SyntaxKind.FalseKeyword */ || token() === 104 /* SyntaxKind.NullKeyword */ ?
                parseTokenNode() :
                parseLiteralLikeNode(token());
            if (negative) {
                expression = finishNode(factory.createPrefixUnaryExpression(40 /* SyntaxKind.MinusToken */, expression), pos);
            }
            return finishNode(factory.createLiteralTypeNode(expression), pos);
        }
        function isStartOfTypeOfImportType() {
            nextToken();
            return token() === 100 /* SyntaxKind.ImportKeyword */;
        }
        function parseImportTypeAssertions() {
            var pos = getNodePos();
            var openBracePosition = scanner.getTokenPos();
            parseExpected(18 /* SyntaxKind.OpenBraceToken */);
            var multiLine = scanner.hasPrecedingLineBreak();
            parseExpected(129 /* SyntaxKind.AssertKeyword */);
            parseExpected(58 /* SyntaxKind.ColonToken */);
            var clause = parseAssertClause(/*skipAssertKeyword*/ true);
            if (!parseExpected(19 /* SyntaxKind.CloseBraceToken */)) {
                var lastError = ts.lastOrUndefined(parseDiagnostics);
                if (lastError && lastError.code === ts.Diagnostics._0_expected.code) {
                    ts.addRelatedInfo(lastError, ts.createDetachedDiagnostic(fileName, openBracePosition, 1, ts.Diagnostics.The_parser_expected_to_find_a_1_to_match_the_0_token_here, "{", "}"));
                }
            }
            return finishNode(factory.createImportTypeAssertionContainer(clause, multiLine), pos);
        }
        function parseImportType() {
            sourceFlags |= 2097152 /* NodeFlags.PossiblyContainsDynamicImport */;
            var pos = getNodePos();
            var isTypeOf = parseOptional(112 /* SyntaxKind.TypeOfKeyword */);
            parseExpected(100 /* SyntaxKind.ImportKeyword */);
            parseExpected(20 /* SyntaxKind.OpenParenToken */);
            var type = parseType();
            var assertions;
            if (parseOptional(27 /* SyntaxKind.CommaToken */)) {
                assertions = parseImportTypeAssertions();
            }
            parseExpected(21 /* SyntaxKind.CloseParenToken */);
            var qualifier = parseOptional(24 /* SyntaxKind.DotToken */) ? parseEntityNameOfTypeReference() : undefined;
            var typeArguments = parseTypeArgumentsOfTypeReference();
            return finishNode(factory.createImportTypeNode(type, assertions, qualifier, typeArguments, isTypeOf), pos);
        }
        function nextTokenIsNumericOrBigIntLiteral() {
            nextToken();
            return token() === 8 /* SyntaxKind.NumericLiteral */ || token() === 9 /* SyntaxKind.BigIntLiteral */;
        }
        function parseNonArrayType() {
            switch (token()) {
                case 130 /* SyntaxKind.AnyKeyword */:
                case 155 /* SyntaxKind.UnknownKeyword */:
                case 150 /* SyntaxKind.StringKeyword */:
                case 147 /* SyntaxKind.NumberKeyword */:
                case 158 /* SyntaxKind.BigIntKeyword */:
                case 151 /* SyntaxKind.SymbolKeyword */:
                case 133 /* SyntaxKind.BooleanKeyword */:
                case 153 /* SyntaxKind.UndefinedKeyword */:
                case 143 /* SyntaxKind.NeverKeyword */:
                case 148 /* SyntaxKind.ObjectKeyword */:
                    // If these are followed by a dot, then parse these out as a dotted type reference instead.
                    return tryParse(parseKeywordAndNoDot) || parseTypeReference();
                case 66 /* SyntaxKind.AsteriskEqualsToken */:
                    // If there is '*=', treat it as * followed by postfix =
                    scanner.reScanAsteriskEqualsToken();
                // falls through
                case 41 /* SyntaxKind.AsteriskToken */:
                    return parseJSDocAllType();
                case 60 /* SyntaxKind.QuestionQuestionToken */:
                    // If there is '??', treat it as prefix-'?' in JSDoc type.
                    scanner.reScanQuestionToken();
                // falls through
                case 57 /* SyntaxKind.QuestionToken */:
                    return parseJSDocUnknownOrNullableType();
                case 98 /* SyntaxKind.FunctionKeyword */:
                    return parseJSDocFunctionType();
                case 53 /* SyntaxKind.ExclamationToken */:
                    return parseJSDocNonNullableType();
                case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                case 10 /* SyntaxKind.StringLiteral */:
                case 8 /* SyntaxKind.NumericLiteral */:
                case 9 /* SyntaxKind.BigIntLiteral */:
                case 110 /* SyntaxKind.TrueKeyword */:
                case 95 /* SyntaxKind.FalseKeyword */:
                case 104 /* SyntaxKind.NullKeyword */:
                    return parseLiteralTypeNode();
                case 40 /* SyntaxKind.MinusToken */:
                    return lookAhead(nextTokenIsNumericOrBigIntLiteral) ? parseLiteralTypeNode(/*negative*/ true) : parseTypeReference();
                case 114 /* SyntaxKind.VoidKeyword */:
                    return parseTokenNode();
                case 108 /* SyntaxKind.ThisKeyword */: {
                    var thisKeyword = parseThisTypeNode();
                    if (token() === 139 /* SyntaxKind.IsKeyword */ && !scanner.hasPrecedingLineBreak()) {
                        return parseThisTypePredicate(thisKeyword);
                    }
                    else {
                        return thisKeyword;
                    }
                }
                case 112 /* SyntaxKind.TypeOfKeyword */:
                    return lookAhead(isStartOfTypeOfImportType) ? parseImportType() : parseTypeQuery();
                case 18 /* SyntaxKind.OpenBraceToken */:
                    return lookAhead(isStartOfMappedType) ? parseMappedType() : parseTypeLiteral();
                case 22 /* SyntaxKind.OpenBracketToken */:
                    return parseTupleType();
                case 20 /* SyntaxKind.OpenParenToken */:
                    return parseParenthesizedType();
                case 100 /* SyntaxKind.ImportKeyword */:
                    return parseImportType();
                case 128 /* SyntaxKind.AssertsKeyword */:
                    return lookAhead(nextTokenIsIdentifierOrKeywordOnSameLine) ? parseAssertsTypePredicate() : parseTypeReference();
                case 15 /* SyntaxKind.TemplateHead */:
                    return parseTemplateType();
                default:
                    return parseTypeReference();
            }
        }
        function isStartOfType(inStartOfParameter) {
            switch (token()) {
                case 130 /* SyntaxKind.AnyKeyword */:
                case 155 /* SyntaxKind.UnknownKeyword */:
                case 150 /* SyntaxKind.StringKeyword */:
                case 147 /* SyntaxKind.NumberKeyword */:
                case 158 /* SyntaxKind.BigIntKeyword */:
                case 133 /* SyntaxKind.BooleanKeyword */:
                case 145 /* SyntaxKind.ReadonlyKeyword */:
                case 151 /* SyntaxKind.SymbolKeyword */:
                case 154 /* SyntaxKind.UniqueKeyword */:
                case 114 /* SyntaxKind.VoidKeyword */:
                case 153 /* SyntaxKind.UndefinedKeyword */:
                case 104 /* SyntaxKind.NullKeyword */:
                case 108 /* SyntaxKind.ThisKeyword */:
                case 112 /* SyntaxKind.TypeOfKeyword */:
                case 143 /* SyntaxKind.NeverKeyword */:
                case 18 /* SyntaxKind.OpenBraceToken */:
                case 22 /* SyntaxKind.OpenBracketToken */:
                case 29 /* SyntaxKind.LessThanToken */:
                case 51 /* SyntaxKind.BarToken */:
                case 50 /* SyntaxKind.AmpersandToken */:
                case 103 /* SyntaxKind.NewKeyword */:
                case 10 /* SyntaxKind.StringLiteral */:
                case 8 /* SyntaxKind.NumericLiteral */:
                case 9 /* SyntaxKind.BigIntLiteral */:
                case 110 /* SyntaxKind.TrueKeyword */:
                case 95 /* SyntaxKind.FalseKeyword */:
                case 148 /* SyntaxKind.ObjectKeyword */:
                case 41 /* SyntaxKind.AsteriskToken */:
                case 57 /* SyntaxKind.QuestionToken */:
                case 53 /* SyntaxKind.ExclamationToken */:
                case 25 /* SyntaxKind.DotDotDotToken */:
                case 137 /* SyntaxKind.InferKeyword */:
                case 100 /* SyntaxKind.ImportKeyword */:
                case 128 /* SyntaxKind.AssertsKeyword */:
                case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                case 15 /* SyntaxKind.TemplateHead */:
                    return true;
                case 98 /* SyntaxKind.FunctionKeyword */:
                    return !inStartOfParameter;
                case 40 /* SyntaxKind.MinusToken */:
                    return !inStartOfParameter && lookAhead(nextTokenIsNumericOrBigIntLiteral);
                case 20 /* SyntaxKind.OpenParenToken */:
                    // Only consider '(' the start of a type if followed by ')', '...', an identifier, a modifier,
                    // or something that starts a type. We don't want to consider things like '(1)' a type.
                    return !inStartOfParameter && lookAhead(isStartOfParenthesizedOrFunctionType);
                default:
                    return isIdentifier();
            }
        }
        function isStartOfParenthesizedOrFunctionType() {
            nextToken();
            return token() === 21 /* SyntaxKind.CloseParenToken */ || isStartOfParameter(/*isJSDocParameter*/ false) || isStartOfType();
        }
        function parsePostfixTypeOrHigher() {
            var pos = getNodePos();
            var type = parseNonArrayType();
            while (!scanner.hasPrecedingLineBreak()) {
                switch (token()) {
                    case 53 /* SyntaxKind.ExclamationToken */:
                        nextToken();
                        type = finishNode(factory.createJSDocNonNullableType(type, /*postfix*/ true), pos);
                        break;
                    case 57 /* SyntaxKind.QuestionToken */:
                        // If next token is start of a type we have a conditional type
                        if (lookAhead(nextTokenIsStartOfType)) {
                            return type;
                        }
                        nextToken();
                        type = finishNode(factory.createJSDocNullableType(type, /*postfix*/ true), pos);
                        break;
                    case 22 /* SyntaxKind.OpenBracketToken */:
                        parseExpected(22 /* SyntaxKind.OpenBracketToken */);
                        if (isStartOfType()) {
                            var indexType = parseType();
                            parseExpected(23 /* SyntaxKind.CloseBracketToken */);
                            type = finishNode(factory.createIndexedAccessTypeNode(type, indexType), pos);
                        }
                        else {
                            parseExpected(23 /* SyntaxKind.CloseBracketToken */);
                            type = finishNode(factory.createArrayTypeNode(type), pos);
                        }
                        break;
                    default:
                        return type;
                }
            }
            return type;
        }
        function parseTypeOperator(operator) {
            var pos = getNodePos();
            parseExpected(operator);
            return finishNode(factory.createTypeOperatorNode(operator, parseTypeOperatorOrHigher()), pos);
        }
        function tryParseConstraintOfInferType() {
            if (parseOptional(94 /* SyntaxKind.ExtendsKeyword */)) {
                var constraint = disallowConditionalTypesAnd(parseType);
                if (inDisallowConditionalTypesContext() || token() !== 57 /* SyntaxKind.QuestionToken */) {
                    return constraint;
                }
            }
        }
        function parseTypeParameterOfInferType() {
            var pos = getNodePos();
            var name = parseIdentifier();
            var constraint = tryParse(tryParseConstraintOfInferType);
            var node = factory.createTypeParameterDeclaration(/*modifiers*/ undefined, name, constraint);
            return finishNode(node, pos);
        }
        function parseInferType() {
            var pos = getNodePos();
            parseExpected(137 /* SyntaxKind.InferKeyword */);
            return finishNode(factory.createInferTypeNode(parseTypeParameterOfInferType()), pos);
        }
        function parseTypeOperatorOrHigher() {
            var operator = token();
            switch (operator) {
                case 140 /* SyntaxKind.KeyOfKeyword */:
                case 154 /* SyntaxKind.UniqueKeyword */:
                case 145 /* SyntaxKind.ReadonlyKeyword */:
                    return parseTypeOperator(operator);
                case 137 /* SyntaxKind.InferKeyword */:
                    return parseInferType();
            }
            return allowConditionalTypesAnd(parsePostfixTypeOrHigher);
        }
        function parseFunctionOrConstructorTypeToError(isInUnionType) {
            // the function type and constructor type shorthand notation
            // are not allowed directly in unions and intersections, but we'll
            // try to parse them gracefully and issue a helpful message.
            if (isStartOfFunctionTypeOrConstructorType()) {
                var type = parseFunctionOrConstructorType();
                var diagnostic = void 0;
                if (ts.isFunctionTypeNode(type)) {
                    diagnostic = isInUnionType
                        ? ts.Diagnostics.Function_type_notation_must_be_parenthesized_when_used_in_a_union_type
                        : ts.Diagnostics.Function_type_notation_must_be_parenthesized_when_used_in_an_intersection_type;
                }
                else {
                    diagnostic = isInUnionType
                        ? ts.Diagnostics.Constructor_type_notation_must_be_parenthesized_when_used_in_a_union_type
                        : ts.Diagnostics.Constructor_type_notation_must_be_parenthesized_when_used_in_an_intersection_type;
                }
                parseErrorAtRange(type, diagnostic);
                return type;
            }
            return undefined;
        }
        function parseUnionOrIntersectionType(operator, parseConstituentType, createTypeNode) {
            var pos = getNodePos();
            var isUnionType = operator === 51 /* SyntaxKind.BarToken */;
            var hasLeadingOperator = parseOptional(operator);
            var type = hasLeadingOperator && parseFunctionOrConstructorTypeToError(isUnionType)
                || parseConstituentType();
            if (token() === operator || hasLeadingOperator) {
                var types = [type];
                while (parseOptional(operator)) {
                    types.push(parseFunctionOrConstructorTypeToError(isUnionType) || parseConstituentType());
                }
                type = finishNode(createTypeNode(createNodeArray(types, pos)), pos);
            }
            return type;
        }
        function parseIntersectionTypeOrHigher() {
            return parseUnionOrIntersectionType(50 /* SyntaxKind.AmpersandToken */, parseTypeOperatorOrHigher, factory.createIntersectionTypeNode);
        }
        function parseUnionTypeOrHigher() {
            return parseUnionOrIntersectionType(51 /* SyntaxKind.BarToken */, parseIntersectionTypeOrHigher, factory.createUnionTypeNode);
        }
        function nextTokenIsNewKeyword() {
            nextToken();
            return token() === 103 /* SyntaxKind.NewKeyword */;
        }
        function isStartOfFunctionTypeOrConstructorType() {
            if (token() === 29 /* SyntaxKind.LessThanToken */) {
                return true;
            }
            if (token() === 20 /* SyntaxKind.OpenParenToken */ && lookAhead(isUnambiguouslyStartOfFunctionType)) {
                return true;
            }
            return token() === 103 /* SyntaxKind.NewKeyword */ ||
                token() === 126 /* SyntaxKind.AbstractKeyword */ && lookAhead(nextTokenIsNewKeyword);
        }
        function skipParameterStart() {
            if (ts.isModifierKind(token())) {
                // Skip modifiers
                parseModifiers();
            }
            if (isIdentifier() || token() === 108 /* SyntaxKind.ThisKeyword */) {
                nextToken();
                return true;
            }
            if (token() === 22 /* SyntaxKind.OpenBracketToken */ || token() === 18 /* SyntaxKind.OpenBraceToken */) {
                // Return true if we can parse an array or object binding pattern with no errors
                var previousErrorCount = parseDiagnostics.length;
                parseIdentifierOrPattern();
                return previousErrorCount === parseDiagnostics.length;
            }
            return false;
        }
        function isUnambiguouslyStartOfFunctionType() {
            nextToken();
            if (token() === 21 /* SyntaxKind.CloseParenToken */ || token() === 25 /* SyntaxKind.DotDotDotToken */) {
                // ( )
                // ( ...
                return true;
            }
            if (skipParameterStart()) {
                // We successfully skipped modifiers (if any) and an identifier or binding pattern,
                // now see if we have something that indicates a parameter declaration
                if (token() === 58 /* SyntaxKind.ColonToken */ || token() === 27 /* SyntaxKind.CommaToken */ ||
                    token() === 57 /* SyntaxKind.QuestionToken */ || token() === 63 /* SyntaxKind.EqualsToken */) {
                    // ( xxx :
                    // ( xxx ,
                    // ( xxx ?
                    // ( xxx =
                    return true;
                }
                if (token() === 21 /* SyntaxKind.CloseParenToken */) {
                    nextToken();
                    if (token() === 38 /* SyntaxKind.EqualsGreaterThanToken */) {
                        // ( xxx ) =>
                        return true;
                    }
                }
            }
            return false;
        }
        function parseTypeOrTypePredicate() {
            var pos = getNodePos();
            var typePredicateVariable = isIdentifier() && tryParse(parseTypePredicatePrefix);
            var type = parseType();
            if (typePredicateVariable) {
                return finishNode(factory.createTypePredicateNode(/*assertsModifier*/ undefined, typePredicateVariable, type), pos);
            }
            else {
                return type;
            }
        }
        function parseTypePredicatePrefix() {
            var id = parseIdentifier();
            if (token() === 139 /* SyntaxKind.IsKeyword */ && !scanner.hasPrecedingLineBreak()) {
                nextToken();
                return id;
            }
        }
        function parseAssertsTypePredicate() {
            var pos = getNodePos();
            var assertsModifier = parseExpectedToken(128 /* SyntaxKind.AssertsKeyword */);
            var parameterName = token() === 108 /* SyntaxKind.ThisKeyword */ ? parseThisTypeNode() : parseIdentifier();
            var type = parseOptional(139 /* SyntaxKind.IsKeyword */) ? parseType() : undefined;
            return finishNode(factory.createTypePredicateNode(assertsModifier, parameterName, type), pos);
        }
        function parseType() {
            if (contextFlags & 40960 /* NodeFlags.TypeExcludesFlags */) {
                return doOutsideOfContext(40960 /* NodeFlags.TypeExcludesFlags */, parseType);
            }
            if (isStartOfFunctionTypeOrConstructorType()) {
                return parseFunctionOrConstructorType();
            }
            var pos = getNodePos();
            var type = parseUnionTypeOrHigher();
            if (!inDisallowConditionalTypesContext() && !scanner.hasPrecedingLineBreak() && parseOptional(94 /* SyntaxKind.ExtendsKeyword */)) {
                // The type following 'extends' is not permitted to be another conditional type
                var extendsType = disallowConditionalTypesAnd(parseType);
                parseExpected(57 /* SyntaxKind.QuestionToken */);
                var trueType = allowConditionalTypesAnd(parseType);
                parseExpected(58 /* SyntaxKind.ColonToken */);
                var falseType = allowConditionalTypesAnd(parseType);
                return finishNode(factory.createConditionalTypeNode(type, extendsType, trueType, falseType), pos);
            }
            return type;
        }
        function parseTypeAnnotation() {
            return parseOptional(58 /* SyntaxKind.ColonToken */) ? parseType() : undefined;
        }
        // EXPRESSIONS
        function isStartOfLeftHandSideExpression() {
            switch (token()) {
                case 108 /* SyntaxKind.ThisKeyword */:
                case 106 /* SyntaxKind.SuperKeyword */:
                case 104 /* SyntaxKind.NullKeyword */:
                case 110 /* SyntaxKind.TrueKeyword */:
                case 95 /* SyntaxKind.FalseKeyword */:
                case 8 /* SyntaxKind.NumericLiteral */:
                case 9 /* SyntaxKind.BigIntLiteral */:
                case 10 /* SyntaxKind.StringLiteral */:
                case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                case 15 /* SyntaxKind.TemplateHead */:
                case 20 /* SyntaxKind.OpenParenToken */:
                case 22 /* SyntaxKind.OpenBracketToken */:
                case 18 /* SyntaxKind.OpenBraceToken */:
                case 98 /* SyntaxKind.FunctionKeyword */:
                case 84 /* SyntaxKind.ClassKeyword */:
                case 103 /* SyntaxKind.NewKeyword */:
                case 43 /* SyntaxKind.SlashToken */:
                case 68 /* SyntaxKind.SlashEqualsToken */:
                case 79 /* SyntaxKind.Identifier */:
                    return true;
                case 100 /* SyntaxKind.ImportKeyword */:
                    return lookAhead(nextTokenIsOpenParenOrLessThanOrDot);
                default:
                    return isIdentifier();
            }
        }
        function isStartOfExpression() {
            if (isStartOfLeftHandSideExpression()) {
                return true;
            }
            switch (token()) {
                case 39 /* SyntaxKind.PlusToken */:
                case 40 /* SyntaxKind.MinusToken */:
                case 54 /* SyntaxKind.TildeToken */:
                case 53 /* SyntaxKind.ExclamationToken */:
                case 89 /* SyntaxKind.DeleteKeyword */:
                case 112 /* SyntaxKind.TypeOfKeyword */:
                case 114 /* SyntaxKind.VoidKeyword */:
                case 45 /* SyntaxKind.PlusPlusToken */:
                case 46 /* SyntaxKind.MinusMinusToken */:
                case 29 /* SyntaxKind.LessThanToken */:
                case 132 /* SyntaxKind.AwaitKeyword */:
                case 125 /* SyntaxKind.YieldKeyword */:
                case 80 /* SyntaxKind.PrivateIdentifier */:
                    // Yield/await always starts an expression.  Either it is an identifier (in which case
                    // it is definitely an expression).  Or it's a keyword (either because we're in
                    // a generator or async function, or in strict mode (or both)) and it started a yield or await expression.
                    return true;
                default:
                    // Error tolerance.  If we see the start of some binary operator, we consider
                    // that the start of an expression.  That way we'll parse out a missing identifier,
                    // give a good message about an identifier being missing, and then consume the
                    // rest of the binary expression.
                    if (isBinaryOperator()) {
                        return true;
                    }
                    return isIdentifier();
            }
        }
        function isStartOfExpressionStatement() {
            // As per the grammar, none of '{' or 'function' or 'class' can start an expression statement.
            return token() !== 18 /* SyntaxKind.OpenBraceToken */ &&
                token() !== 98 /* SyntaxKind.FunctionKeyword */ &&
                token() !== 84 /* SyntaxKind.ClassKeyword */ &&
                token() !== 59 /* SyntaxKind.AtToken */ &&
                isStartOfExpression();
        }
        function parseExpression() {
            // Expression[in]:
            //      AssignmentExpression[in]
            //      Expression[in] , AssignmentExpression[in]
            // clear the decorator context when parsing Expression, as it should be unambiguous when parsing a decorator
            var saveDecoratorContext = inDecoratorContext();
            if (saveDecoratorContext) {
                setDecoratorContext(/*val*/ false);
            }
            var pos = getNodePos();
            var expr = parseAssignmentExpressionOrHigher(/*allowReturnTypeInArrowFunction*/ true);
            var operatorToken;
            while ((operatorToken = parseOptionalToken(27 /* SyntaxKind.CommaToken */))) {
                expr = makeBinaryExpression(expr, operatorToken, parseAssignmentExpressionOrHigher(/*allowReturnTypeInArrowFunction*/ true), pos);
            }
            if (saveDecoratorContext) {
                setDecoratorContext(/*val*/ true);
            }
            return expr;
        }
        function parseInitializer() {
            return parseOptional(63 /* SyntaxKind.EqualsToken */) ? parseAssignmentExpressionOrHigher(/*allowReturnTypeInArrowFunction*/ true) : undefined;
        }
        function parseAssignmentExpressionOrHigher(allowReturnTypeInArrowFunction) {
            //  AssignmentExpression[in,yield]:
            //      1) ConditionalExpression[?in,?yield]
            //      2) LeftHandSideExpression = AssignmentExpression[?in,?yield]
            //      3) LeftHandSideExpression AssignmentOperator AssignmentExpression[?in,?yield]
            //      4) ArrowFunctionExpression[?in,?yield]
            //      5) AsyncArrowFunctionExpression[in,yield,await]
            //      6) [+Yield] YieldExpression[?In]
            //
            // Note: for ease of implementation we treat productions '2' and '3' as the same thing.
            // (i.e. they're both BinaryExpressions with an assignment operator in it).
            // First, do the simple check if we have a YieldExpression (production '6').
            if (isYieldExpression()) {
                return parseYieldExpression();
            }
            // Then, check if we have an arrow function (production '4' and '5') that starts with a parenthesized
            // parameter list or is an async arrow function.
            // AsyncArrowFunctionExpression:
            //      1) async[no LineTerminator here]AsyncArrowBindingIdentifier[?Yield][no LineTerminator here]=>AsyncConciseBody[?In]
            //      2) CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await][no LineTerminator here]=>AsyncConciseBody[?In]
            // Production (1) of AsyncArrowFunctionExpression is parsed in "tryParseAsyncSimpleArrowFunctionExpression".
            // And production (2) is parsed in "tryParseParenthesizedArrowFunctionExpression".
            //
            // If we do successfully parse arrow-function, we must *not* recurse for productions 1, 2 or 3. An ArrowFunction is
            // not a LeftHandSideExpression, nor does it start a ConditionalExpression.  So we are done
            // with AssignmentExpression if we see one.
            var arrowExpression = tryParseParenthesizedArrowFunctionExpression(allowReturnTypeInArrowFunction) || tryParseAsyncSimpleArrowFunctionExpression(allowReturnTypeInArrowFunction);
            if (arrowExpression) {
                return arrowExpression;
            }
            // Now try to see if we're in production '1', '2' or '3'.  A conditional expression can
            // start with a LogicalOrExpression, while the assignment productions can only start with
            // LeftHandSideExpressions.
            //
            // So, first, we try to just parse out a BinaryExpression.  If we get something that is a
            // LeftHandSide or higher, then we can try to parse out the assignment expression part.
            // Otherwise, we try to parse out the conditional expression bit.  We want to allow any
            // binary expression here, so we pass in the 'lowest' precedence here so that it matches
            // and consumes anything.
            var pos = getNodePos();
            var expr = parseBinaryExpressionOrHigher(0 /* OperatorPrecedence.Lowest */);
            // To avoid a look-ahead, we did not handle the case of an arrow function with a single un-parenthesized
            // parameter ('x => ...') above. We handle it here by checking if the parsed expression was a single
            // identifier and the current token is an arrow.
            if (expr.kind === 79 /* SyntaxKind.Identifier */ && token() === 38 /* SyntaxKind.EqualsGreaterThanToken */) {
                return parseSimpleArrowFunctionExpression(pos, expr, allowReturnTypeInArrowFunction, /*asyncModifier*/ undefined);
            }
            // Now see if we might be in cases '2' or '3'.
            // If the expression was a LHS expression, and we have an assignment operator, then
            // we're in '2' or '3'. Consume the assignment and return.
            //
            // Note: we call reScanGreaterToken so that we get an appropriately merged token
            // for cases like `> > =` becoming `>>=`
            if (ts.isLeftHandSideExpression(expr) && ts.isAssignmentOperator(reScanGreaterToken())) {
                return makeBinaryExpression(expr, parseTokenNode(), parseAssignmentExpressionOrHigher(allowReturnTypeInArrowFunction), pos);
            }
            // It wasn't an assignment or a lambda.  This is a conditional expression:
            return parseConditionalExpressionRest(expr, pos, allowReturnTypeInArrowFunction);
        }
        function isYieldExpression() {
            if (token() === 125 /* SyntaxKind.YieldKeyword */) {
                // If we have a 'yield' keyword, and this is a context where yield expressions are
                // allowed, then definitely parse out a yield expression.
                if (inYieldContext()) {
                    return true;
                }
                // We're in a context where 'yield expr' is not allowed.  However, if we can
                // definitely tell that the user was trying to parse a 'yield expr' and not
                // just a normal expr that start with a 'yield' identifier, then parse out
                // a 'yield expr'.  We can then report an error later that they are only
                // allowed in generator expressions.
                //
                // for example, if we see 'yield(foo)', then we'll have to treat that as an
                // invocation expression of something called 'yield'.  However, if we have
                // 'yield foo' then that is not legal as a normal expression, so we can
                // definitely recognize this as a yield expression.
                //
                // for now we just check if the next token is an identifier.  More heuristics
                // can be added here later as necessary.  We just need to make sure that we
                // don't accidentally consume something legal.
                return lookAhead(nextTokenIsIdentifierOrKeywordOrLiteralOnSameLine);
            }
            return false;
        }
        function nextTokenIsIdentifierOnSameLine() {
            nextToken();
            return !scanner.hasPrecedingLineBreak() && isIdentifier();
        }
        function parseYieldExpression() {
            var pos = getNodePos();
            // YieldExpression[In] :
            //      yield
            //      yield [no LineTerminator here] [Lexical goal InputElementRegExp]AssignmentExpression[?In, Yield]
            //      yield [no LineTerminator here] * [Lexical goal InputElementRegExp]AssignmentExpression[?In, Yield]
            nextToken();
            if (!scanner.hasPrecedingLineBreak() &&
                (token() === 41 /* SyntaxKind.AsteriskToken */ || isStartOfExpression())) {
                return finishNode(factory.createYieldExpression(parseOptionalToken(41 /* SyntaxKind.AsteriskToken */), parseAssignmentExpressionOrHigher(/*allowReturnTypeInArrowFunction*/ true)), pos);
            }
            else {
                // if the next token is not on the same line as yield.  or we don't have an '*' or
                // the start of an expression, then this is just a simple "yield" expression.
                return finishNode(factory.createYieldExpression(/*asteriskToken*/ undefined, /*expression*/ undefined), pos);
            }
        }
        function parseSimpleArrowFunctionExpression(pos, identifier, allowReturnTypeInArrowFunction, asyncModifier) {
            ts.Debug.assert(token() === 38 /* SyntaxKind.EqualsGreaterThanToken */, "parseSimpleArrowFunctionExpression should only have been called if we had a =>");
            var parameter = factory.createParameterDeclaration(
            /*modifiers*/ undefined, 
            /*dotDotDotToken*/ undefined, identifier, 
            /*questionToken*/ undefined, 
            /*type*/ undefined, 
            /*initializer*/ undefined);
            finishNode(parameter, identifier.pos);
            var parameters = createNodeArray([parameter], parameter.pos, parameter.end);
            var equalsGreaterThanToken = parseExpectedToken(38 /* SyntaxKind.EqualsGreaterThanToken */);
            var body = parseArrowFunctionExpressionBody(/*isAsync*/ !!asyncModifier, allowReturnTypeInArrowFunction);
            var node = factory.createArrowFunction(asyncModifier, /*typeParameters*/ undefined, parameters, /*type*/ undefined, equalsGreaterThanToken, body);
            return addJSDocComment(finishNode(node, pos));
        }
        function tryParseParenthesizedArrowFunctionExpression(allowReturnTypeInArrowFunction) {
            var triState = isParenthesizedArrowFunctionExpression();
            if (triState === 0 /* Tristate.False */) {
                // It's definitely not a parenthesized arrow function expression.
                return undefined;
            }
            // If we definitely have an arrow function, then we can just parse one, not requiring a
            // following => or { token. Otherwise, we *might* have an arrow function.  Try to parse
            // it out, but don't allow any ambiguity, and return 'undefined' if this could be an
            // expression instead.
            return triState === 1 /* Tristate.True */ ?
                parseParenthesizedArrowFunctionExpression(/*allowAmbiguity*/ true, /*allowReturnTypeInArrowFunction*/ true) :
                tryParse(function () { return parsePossibleParenthesizedArrowFunctionExpression(allowReturnTypeInArrowFunction); });
        }
        //  True        -> We definitely expect a parenthesized arrow function here.
        //  False       -> There *cannot* be a parenthesized arrow function here.
        //  Unknown     -> There *might* be a parenthesized arrow function here.
        //                 Speculatively look ahead to be sure, and rollback if not.
        function isParenthesizedArrowFunctionExpression() {
            if (token() === 20 /* SyntaxKind.OpenParenToken */ || token() === 29 /* SyntaxKind.LessThanToken */ || token() === 131 /* SyntaxKind.AsyncKeyword */) {
                return lookAhead(isParenthesizedArrowFunctionExpressionWorker);
            }
            if (token() === 38 /* SyntaxKind.EqualsGreaterThanToken */) {
                // ERROR RECOVERY TWEAK:
                // If we see a standalone => try to parse it as an arrow function expression as that's
                // likely what the user intended to write.
                return 1 /* Tristate.True */;
            }
            // Definitely not a parenthesized arrow function.
            return 0 /* Tristate.False */;
        }
        function isParenthesizedArrowFunctionExpressionWorker() {
            if (token() === 131 /* SyntaxKind.AsyncKeyword */) {
                nextToken();
                if (scanner.hasPrecedingLineBreak()) {
                    return 0 /* Tristate.False */;
                }
                if (token() !== 20 /* SyntaxKind.OpenParenToken */ && token() !== 29 /* SyntaxKind.LessThanToken */) {
                    return 0 /* Tristate.False */;
                }
            }
            var first = token();
            var second = nextToken();
            if (first === 20 /* SyntaxKind.OpenParenToken */) {
                if (second === 21 /* SyntaxKind.CloseParenToken */) {
                    // Simple cases: "() =>", "(): ", and "() {".
                    // This is an arrow function with no parameters.
                    // The last one is not actually an arrow function,
                    // but this is probably what the user intended.
                    var third = nextToken();
                    switch (third) {
                        case 38 /* SyntaxKind.EqualsGreaterThanToken */:
                        case 58 /* SyntaxKind.ColonToken */:
                        case 18 /* SyntaxKind.OpenBraceToken */:
                            return 1 /* Tristate.True */;
                        default:
                            return 0 /* Tristate.False */;
                    }
                }
                // If encounter "([" or "({", this could be the start of a binding pattern.
                // Examples:
                //      ([ x ]) => { }
                //      ({ x }) => { }
                //      ([ x ])
                //      ({ x })
                if (second === 22 /* SyntaxKind.OpenBracketToken */ || second === 18 /* SyntaxKind.OpenBraceToken */) {
                    return 2 /* Tristate.Unknown */;
                }
                // Simple case: "(..."
                // This is an arrow function with a rest parameter.
                if (second === 25 /* SyntaxKind.DotDotDotToken */) {
                    return 1 /* Tristate.True */;
                }
                // Check for "(xxx yyy", where xxx is a modifier and yyy is an identifier. This
                // isn't actually allowed, but we want to treat it as a lambda so we can provide
                // a good error message.
                if (ts.isModifierKind(second) && second !== 131 /* SyntaxKind.AsyncKeyword */ && lookAhead(nextTokenIsIdentifier)) {
                    if (nextToken() === 127 /* SyntaxKind.AsKeyword */) {
                        // https://github.com/microsoft/TypeScript/issues/44466
                        return 0 /* Tristate.False */;
                    }
                    return 1 /* Tristate.True */;
                }
                // If we had "(" followed by something that's not an identifier,
                // then this definitely doesn't look like a lambda.  "this" is not
                // valid, but we want to parse it and then give a semantic error.
                if (!isIdentifier() && second !== 108 /* SyntaxKind.ThisKeyword */) {
                    return 0 /* Tristate.False */;
                }
                switch (nextToken()) {
                    case 58 /* SyntaxKind.ColonToken */:
                        // If we have something like "(a:", then we must have a
                        // type-annotated parameter in an arrow function expression.
                        return 1 /* Tristate.True */;
                    case 57 /* SyntaxKind.QuestionToken */:
                        nextToken();
                        // If we have "(a?:" or "(a?," or "(a?=" or "(a?)" then it is definitely a lambda.
                        if (token() === 58 /* SyntaxKind.ColonToken */ || token() === 27 /* SyntaxKind.CommaToken */ || token() === 63 /* SyntaxKind.EqualsToken */ || token() === 21 /* SyntaxKind.CloseParenToken */) {
                            return 1 /* Tristate.True */;
                        }
                        // Otherwise it is definitely not a lambda.
                        return 0 /* Tristate.False */;
                    case 27 /* SyntaxKind.CommaToken */:
                    case 63 /* SyntaxKind.EqualsToken */:
                    case 21 /* SyntaxKind.CloseParenToken */:
                        // If we have "(a," or "(a=" or "(a)" this *could* be an arrow function
                        return 2 /* Tristate.Unknown */;
                }
                // It is definitely not an arrow function
                return 0 /* Tristate.False */;
            }
            else {
                ts.Debug.assert(first === 29 /* SyntaxKind.LessThanToken */);
                // If we have "<" not followed by an identifier,
                // then this definitely is not an arrow function.
                if (!isIdentifier()) {
                    return 0 /* Tristate.False */;
                }
                // JSX overrides
                if (languageVariant === 1 /* LanguageVariant.JSX */) {
                    var isArrowFunctionInJsx = lookAhead(function () {
                        var third = nextToken();
                        if (third === 94 /* SyntaxKind.ExtendsKeyword */) {
                            var fourth = nextToken();
                            switch (fourth) {
                                case 63 /* SyntaxKind.EqualsToken */:
                                case 31 /* SyntaxKind.GreaterThanToken */:
                                    return false;
                                default:
                                    return true;
                            }
                        }
                        else if (third === 27 /* SyntaxKind.CommaToken */ || third === 63 /* SyntaxKind.EqualsToken */) {
                            return true;
                        }
                        return false;
                    });
                    if (isArrowFunctionInJsx) {
                        return 1 /* Tristate.True */;
                    }
                    return 0 /* Tristate.False */;
                }
                // This *could* be a parenthesized arrow function.
                return 2 /* Tristate.Unknown */;
            }
        }
        function parsePossibleParenthesizedArrowFunctionExpression(allowReturnTypeInArrowFunction) {
            var tokenPos = scanner.getTokenPos();
            if (notParenthesizedArrow === null || notParenthesizedArrow === void 0 ? void 0 : notParenthesizedArrow.has(tokenPos)) {
                return undefined;
            }
            var result = parseParenthesizedArrowFunctionExpression(/*allowAmbiguity*/ false, allowReturnTypeInArrowFunction);
            if (!result) {
                (notParenthesizedArrow || (notParenthesizedArrow = new ts.Set())).add(tokenPos);
            }
            return result;
        }
        function tryParseAsyncSimpleArrowFunctionExpression(allowReturnTypeInArrowFunction) {
            // We do a check here so that we won't be doing unnecessarily call to "lookAhead"
            if (token() === 131 /* SyntaxKind.AsyncKeyword */) {
                if (lookAhead(isUnParenthesizedAsyncArrowFunctionWorker) === 1 /* Tristate.True */) {
                    var pos = getNodePos();
                    var asyncModifier = parseModifiersForArrowFunction();
                    var expr = parseBinaryExpressionOrHigher(0 /* OperatorPrecedence.Lowest */);
                    return parseSimpleArrowFunctionExpression(pos, expr, allowReturnTypeInArrowFunction, asyncModifier);
                }
            }
            return undefined;
        }
        function isUnParenthesizedAsyncArrowFunctionWorker() {
            // AsyncArrowFunctionExpression:
            //      1) async[no LineTerminator here]AsyncArrowBindingIdentifier[?Yield][no LineTerminator here]=>AsyncConciseBody[?In]
            //      2) CoverCallExpressionAndAsyncArrowHead[?Yield, ?Await][no LineTerminator here]=>AsyncConciseBody[?In]
            if (token() === 131 /* SyntaxKind.AsyncKeyword */) {
                nextToken();
                // If the "async" is followed by "=>" token then it is not a beginning of an async arrow-function
                // but instead a simple arrow-function which will be parsed inside "parseAssignmentExpressionOrHigher"
                if (scanner.hasPrecedingLineBreak() || token() === 38 /* SyntaxKind.EqualsGreaterThanToken */) {
                    return 0 /* Tristate.False */;
                }
                // Check for un-parenthesized AsyncArrowFunction
                var expr = parseBinaryExpressionOrHigher(0 /* OperatorPrecedence.Lowest */);
                if (!scanner.hasPrecedingLineBreak() && expr.kind === 79 /* SyntaxKind.Identifier */ && token() === 38 /* SyntaxKind.EqualsGreaterThanToken */) {
                    return 1 /* Tristate.True */;
                }
            }
            return 0 /* Tristate.False */;
        }
        function parseParenthesizedArrowFunctionExpression(allowAmbiguity, allowReturnTypeInArrowFunction) {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var modifiers = parseModifiersForArrowFunction();
            var isAsync = ts.some(modifiers, ts.isAsyncModifier) ? 2 /* SignatureFlags.Await */ : 0 /* SignatureFlags.None */;
            // Arrow functions are never generators.
            //
            // If we're speculatively parsing a signature for a parenthesized arrow function, then
            // we have to have a complete parameter list.  Otherwise we might see something like
            // a => (b => c)
            // And think that "(b =>" was actually a parenthesized arrow function with a missing
            // close paren.
            var typeParameters = parseTypeParameters();
            var parameters;
            if (!parseExpected(20 /* SyntaxKind.OpenParenToken */)) {
                if (!allowAmbiguity) {
                    return undefined;
                }
                parameters = createMissingList();
            }
            else {
                if (!allowAmbiguity) {
                    var maybeParameters = parseParametersWorker(isAsync, allowAmbiguity);
                    if (!maybeParameters) {
                        return undefined;
                    }
                    parameters = maybeParameters;
                }
                else {
                    parameters = parseParametersWorker(isAsync, allowAmbiguity);
                }
                if (!parseExpected(21 /* SyntaxKind.CloseParenToken */) && !allowAmbiguity) {
                    return undefined;
                }
            }
            var hasReturnColon = token() === 58 /* SyntaxKind.ColonToken */;
            var type = parseReturnType(58 /* SyntaxKind.ColonToken */, /*isType*/ false);
            if (type && !allowAmbiguity && typeHasArrowFunctionBlockingParseError(type)) {
                return undefined;
            }
            // Parsing a signature isn't enough.
            // Parenthesized arrow signatures often look like other valid expressions.
            // For instance:
            //  - "(x = 10)" is an assignment expression parsed as a signature with a default parameter value.
            //  - "(x,y)" is a comma expression parsed as a signature with two parameters.
            //  - "a ? (b): c" will have "(b):" parsed as a signature with a return type annotation.
            //  - "a ? (b): function() {}" will too, since function() is a valid JSDoc function type.
            //  - "a ? (b): (function() {})" as well, but inside of a parenthesized type with an arbitrary amount of nesting.
            //
            // So we need just a bit of lookahead to ensure that it can only be a signature.
            var unwrappedType = type;
            while ((unwrappedType === null || unwrappedType === void 0 ? void 0 : unwrappedType.kind) === 191 /* SyntaxKind.ParenthesizedType */) {
                unwrappedType = unwrappedType.type; // Skip parens if need be
            }
            var hasJSDocFunctionType = unwrappedType && ts.isJSDocFunctionType(unwrappedType);
            if (!allowAmbiguity && token() !== 38 /* SyntaxKind.EqualsGreaterThanToken */ && (hasJSDocFunctionType || token() !== 18 /* SyntaxKind.OpenBraceToken */)) {
                // Returning undefined here will cause our caller to rewind to where we started from.
                return undefined;
            }
            // If we have an arrow, then try to parse the body. Even if not, try to parse if we
            // have an opening brace, just in case we're in an error state.
            var lastToken = token();
            var equalsGreaterThanToken = parseExpectedToken(38 /* SyntaxKind.EqualsGreaterThanToken */);
            var body = (lastToken === 38 /* SyntaxKind.EqualsGreaterThanToken */ || lastToken === 18 /* SyntaxKind.OpenBraceToken */)
                ? parseArrowFunctionExpressionBody(ts.some(modifiers, ts.isAsyncModifier), allowReturnTypeInArrowFunction)
                : parseIdentifier();
            // Given:
            //     x ? y => ({ y }) : z => ({ z })
            // We try to parse the body of the first arrow function by looking at:
            //     ({ y }) : z => ({ z })
            // This is a valid arrow function with "z" as the return type.
            //
            // But, if we're in the true side of a conditional expression, this colon
            // terminates the expression, so we cannot allow a return type if we aren't
            // certain whether or not the preceding text was parsed as a parameter list.
            //
            // For example,
            //     a() ? (b: number, c?: string): void => d() : e
            // is determined by isParenthesizedArrowFunctionExpression to unambiguously
            // be an arrow expression, so we allow a return type.
            if (!allowReturnTypeInArrowFunction && hasReturnColon) {
                // However, if the arrow function we were able to parse is followed by another colon
                // as in:
                //     a ? (x): string => x : null
                // Then allow the arrow function, and treat the second colon as terminating
                // the conditional expression. It's okay to do this because this code would
                // be a syntax error in JavaScript (as the second colon shouldn't be there).
                if (token() !== 58 /* SyntaxKind.ColonToken */) {
                    return undefined;
                }
            }
            var node = factory.createArrowFunction(modifiers, typeParameters, parameters, type, equalsGreaterThanToken, body);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseArrowFunctionExpressionBody(isAsync, allowReturnTypeInArrowFunction) {
            if (token() === 18 /* SyntaxKind.OpenBraceToken */) {
                return parseFunctionBlock(isAsync ? 2 /* SignatureFlags.Await */ : 0 /* SignatureFlags.None */);
            }
            if (token() !== 26 /* SyntaxKind.SemicolonToken */ &&
                token() !== 98 /* SyntaxKind.FunctionKeyword */ &&
                token() !== 84 /* SyntaxKind.ClassKeyword */ &&
                isStartOfStatement() &&
                !isStartOfExpressionStatement()) {
                // Check if we got a plain statement (i.e. no expression-statements, no function/class expressions/declarations)
                //
                // Here we try to recover from a potential error situation in the case where the
                // user meant to supply a block. For example, if the user wrote:
                //
                //  a =>
                //      let v = 0;
                //  }
                //
                // they may be missing an open brace.  Check to see if that's the case so we can
                // try to recover better.  If we don't do this, then the next close curly we see may end
                // up preemptively closing the containing construct.
                //
                // Note: even when 'IgnoreMissingOpenBrace' is passed, parseBody will still error.
                return parseFunctionBlock(16 /* SignatureFlags.IgnoreMissingOpenBrace */ | (isAsync ? 2 /* SignatureFlags.Await */ : 0 /* SignatureFlags.None */));
            }
            var savedTopLevel = topLevel;
            topLevel = false;
            var node = isAsync
                ? doInAwaitContext(function () { return parseAssignmentExpressionOrHigher(allowReturnTypeInArrowFunction); })
                : doOutsideOfAwaitContext(function () { return parseAssignmentExpressionOrHigher(allowReturnTypeInArrowFunction); });
            topLevel = savedTopLevel;
            return node;
        }
        function parseConditionalExpressionRest(leftOperand, pos, allowReturnTypeInArrowFunction) {
            // Note: we are passed in an expression which was produced from parseBinaryExpressionOrHigher.
            var questionToken = parseOptionalToken(57 /* SyntaxKind.QuestionToken */);
            if (!questionToken) {
                return leftOperand;
            }
            // Note: we explicitly 'allowIn' in the whenTrue part of the condition expression, and
            // we do not that for the 'whenFalse' part.
            var colonToken;
            return finishNode(factory.createConditionalExpression(leftOperand, questionToken, doOutsideOfContext(disallowInAndDecoratorContext, function () { return parseAssignmentExpressionOrHigher(/*allowReturnTypeInArrowFunction*/ false); }), colonToken = parseExpectedToken(58 /* SyntaxKind.ColonToken */), ts.nodeIsPresent(colonToken)
                ? parseAssignmentExpressionOrHigher(allowReturnTypeInArrowFunction)
                : createMissingNode(79 /* SyntaxKind.Identifier */, /*reportAtCurrentPosition*/ false, ts.Diagnostics._0_expected, ts.tokenToString(58 /* SyntaxKind.ColonToken */))), pos);
        }
        function parseBinaryExpressionOrHigher(precedence) {
            var pos = getNodePos();
            var leftOperand = parseUnaryExpressionOrHigher();
            return parseBinaryExpressionRest(precedence, leftOperand, pos);
        }
        function isInOrOfKeyword(t) {
            return t === 101 /* SyntaxKind.InKeyword */ || t === 160 /* SyntaxKind.OfKeyword */;
        }
        function parseBinaryExpressionRest(precedence, leftOperand, pos) {
            while (true) {
                // We either have a binary operator here, or we're finished.  We call
                // reScanGreaterToken so that we merge token sequences like > and = into >=
                reScanGreaterToken();
                var newPrecedence = ts.getBinaryOperatorPrecedence(token());
                // Check the precedence to see if we should "take" this operator
                // - For left associative operator (all operator but **), consume the operator,
                //   recursively call the function below, and parse binaryExpression as a rightOperand
                //   of the caller if the new precedence of the operator is greater then or equal to the current precedence.
                //   For example:
                //      a - b - c;
                //            ^token; leftOperand = b. Return b to the caller as a rightOperand
                //      a * b - c
                //            ^token; leftOperand = b. Return b to the caller as a rightOperand
                //      a - b * c;
                //            ^token; leftOperand = b. Return b * c to the caller as a rightOperand
                // - For right associative operator (**), consume the operator, recursively call the function
                //   and parse binaryExpression as a rightOperand of the caller if the new precedence of
                //   the operator is strictly grater than the current precedence
                //   For example:
                //      a ** b ** c;
                //             ^^token; leftOperand = b. Return b ** c to the caller as a rightOperand
                //      a - b ** c;
                //            ^^token; leftOperand = b. Return b ** c to the caller as a rightOperand
                //      a ** b - c
                //             ^token; leftOperand = b. Return b to the caller as a rightOperand
                var consumeCurrentOperator = token() === 42 /* SyntaxKind.AsteriskAsteriskToken */ ?
                    newPrecedence >= precedence :
                    newPrecedence > precedence;
                if (!consumeCurrentOperator) {
                    break;
                }
                if (token() === 101 /* SyntaxKind.InKeyword */ && inDisallowInContext()) {
                    break;
                }
                if (token() === 127 /* SyntaxKind.AsKeyword */) {
                    // Make sure we *do* perform ASI for constructs like this:
                    //    var x = foo
                    //    as (Bar)
                    // This should be parsed as an initialized variable, followed
                    // by a function call to 'as' with the argument 'Bar'
                    if (scanner.hasPrecedingLineBreak()) {
                        break;
                    }
                    else {
                        nextToken();
                        leftOperand = makeAsExpression(leftOperand, parseType());
                    }
                }
                else {
                    leftOperand = makeBinaryExpression(leftOperand, parseTokenNode(), parseBinaryExpressionOrHigher(newPrecedence), pos);
                }
            }
            return leftOperand;
        }
        function isBinaryOperator() {
            if (inDisallowInContext() && token() === 101 /* SyntaxKind.InKeyword */) {
                return false;
            }
            return ts.getBinaryOperatorPrecedence(token()) > 0;
        }
        function makeBinaryExpression(left, operatorToken, right, pos) {
            return finishNode(factory.createBinaryExpression(left, operatorToken, right), pos);
        }
        function makeAsExpression(left, right) {
            return finishNode(factory.createAsExpression(left, right), left.pos);
        }
        function parsePrefixUnaryExpression() {
            var pos = getNodePos();
            return finishNode(factory.createPrefixUnaryExpression(token(), nextTokenAnd(parseSimpleUnaryExpression)), pos);
        }
        function parseDeleteExpression() {
            var pos = getNodePos();
            return finishNode(factory.createDeleteExpression(nextTokenAnd(parseSimpleUnaryExpression)), pos);
        }
        function parseTypeOfExpression() {
            var pos = getNodePos();
            return finishNode(factory.createTypeOfExpression(nextTokenAnd(parseSimpleUnaryExpression)), pos);
        }
        function parseVoidExpression() {
            var pos = getNodePos();
            return finishNode(factory.createVoidExpression(nextTokenAnd(parseSimpleUnaryExpression)), pos);
        }
        function isAwaitExpression() {
            if (token() === 132 /* SyntaxKind.AwaitKeyword */) {
                if (inAwaitContext()) {
                    return true;
                }
                // here we are using similar heuristics as 'isYieldExpression'
                return lookAhead(nextTokenIsIdentifierOrKeywordOrLiteralOnSameLine);
            }
            return false;
        }
        function parseAwaitExpression() {
            var pos = getNodePos();
            return finishNode(factory.createAwaitExpression(nextTokenAnd(parseSimpleUnaryExpression)), pos);
        }
        /**
         * Parse ES7 exponential expression and await expression
         *
         * ES7 ExponentiationExpression:
         *      1) UnaryExpression[?Yield]
         *      2) UpdateExpression[?Yield] ** ExponentiationExpression[?Yield]
         *
         */
        function parseUnaryExpressionOrHigher() {
            /**
             * ES7 UpdateExpression:
             *      1) LeftHandSideExpression[?Yield]
             *      2) LeftHandSideExpression[?Yield][no LineTerminator here]++
             *      3) LeftHandSideExpression[?Yield][no LineTerminator here]--
             *      4) ++UnaryExpression[?Yield]
             *      5) --UnaryExpression[?Yield]
             */
            if (isUpdateExpression()) {
                var pos = getNodePos();
                var updateExpression = parseUpdateExpression();
                return token() === 42 /* SyntaxKind.AsteriskAsteriskToken */ ?
                    parseBinaryExpressionRest(ts.getBinaryOperatorPrecedence(token()), updateExpression, pos) :
                    updateExpression;
            }
            /**
             * ES7 UnaryExpression:
             *      1) UpdateExpression[?yield]
             *      2) delete UpdateExpression[?yield]
             *      3) void UpdateExpression[?yield]
             *      4) typeof UpdateExpression[?yield]
             *      5) + UpdateExpression[?yield]
             *      6) - UpdateExpression[?yield]
             *      7) ~ UpdateExpression[?yield]
             *      8) ! UpdateExpression[?yield]
             */
            var unaryOperator = token();
            var simpleUnaryExpression = parseSimpleUnaryExpression();
            if (token() === 42 /* SyntaxKind.AsteriskAsteriskToken */) {
                var pos = ts.skipTrivia(sourceText, simpleUnaryExpression.pos);
                var end = simpleUnaryExpression.end;
                if (simpleUnaryExpression.kind === 211 /* SyntaxKind.TypeAssertionExpression */) {
                    parseErrorAt(pos, end, ts.Diagnostics.A_type_assertion_expression_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses);
                }
                else {
                    parseErrorAt(pos, end, ts.Diagnostics.An_unary_expression_with_the_0_operator_is_not_allowed_in_the_left_hand_side_of_an_exponentiation_expression_Consider_enclosing_the_expression_in_parentheses, ts.tokenToString(unaryOperator));
                }
            }
            return simpleUnaryExpression;
        }
        /**
         * Parse ES7 simple-unary expression or higher:
         *
         * ES7 UnaryExpression:
         *      1) UpdateExpression[?yield]
         *      2) delete UnaryExpression[?yield]
         *      3) void UnaryExpression[?yield]
         *      4) typeof UnaryExpression[?yield]
         *      5) + UnaryExpression[?yield]
         *      6) - UnaryExpression[?yield]
         *      7) ~ UnaryExpression[?yield]
         *      8) ! UnaryExpression[?yield]
         *      9) [+Await] await UnaryExpression[?yield]
         */
        function parseSimpleUnaryExpression() {
            switch (token()) {
                case 39 /* SyntaxKind.PlusToken */:
                case 40 /* SyntaxKind.MinusToken */:
                case 54 /* SyntaxKind.TildeToken */:
                case 53 /* SyntaxKind.ExclamationToken */:
                    return parsePrefixUnaryExpression();
                case 89 /* SyntaxKind.DeleteKeyword */:
                    return parseDeleteExpression();
                case 112 /* SyntaxKind.TypeOfKeyword */:
                    return parseTypeOfExpression();
                case 114 /* SyntaxKind.VoidKeyword */:
                    return parseVoidExpression();
                case 29 /* SyntaxKind.LessThanToken */:
                    // This is modified UnaryExpression grammar in TypeScript
                    //  UnaryExpression (modified):
                    //      < type > UnaryExpression
                    return parseTypeAssertion();
                case 132 /* SyntaxKind.AwaitKeyword */:
                    if (isAwaitExpression()) {
                        return parseAwaitExpression();
                    }
                // falls through
                default:
                    return parseUpdateExpression();
            }
        }
        /**
         * Check if the current token can possibly be an ES7 increment expression.
         *
         * ES7 UpdateExpression:
         *      LeftHandSideExpression[?Yield]
         *      LeftHandSideExpression[?Yield][no LineTerminator here]++
         *      LeftHandSideExpression[?Yield][no LineTerminator here]--
         *      ++LeftHandSideExpression[?Yield]
         *      --LeftHandSideExpression[?Yield]
         */
        function isUpdateExpression() {
            // This function is called inside parseUnaryExpression to decide
            // whether to call parseSimpleUnaryExpression or call parseUpdateExpression directly
            switch (token()) {
                case 39 /* SyntaxKind.PlusToken */:
                case 40 /* SyntaxKind.MinusToken */:
                case 54 /* SyntaxKind.TildeToken */:
                case 53 /* SyntaxKind.ExclamationToken */:
                case 89 /* SyntaxKind.DeleteKeyword */:
                case 112 /* SyntaxKind.TypeOfKeyword */:
                case 114 /* SyntaxKind.VoidKeyword */:
                case 132 /* SyntaxKind.AwaitKeyword */:
                    return false;
                case 29 /* SyntaxKind.LessThanToken */:
                    // If we are not in JSX context, we are parsing TypeAssertion which is an UnaryExpression
                    if (languageVariant !== 1 /* LanguageVariant.JSX */) {
                        return false;
                    }
                // We are in JSX context and the token is part of JSXElement.
                // falls through
                default:
                    return true;
            }
        }
        /**
         * Parse ES7 UpdateExpression. UpdateExpression is used instead of ES6's PostFixExpression.
         *
         * ES7 UpdateExpression[yield]:
         *      1) LeftHandSideExpression[?yield]
         *      2) LeftHandSideExpression[?yield] [[no LineTerminator here]]++
         *      3) LeftHandSideExpression[?yield] [[no LineTerminator here]]--
         *      4) ++LeftHandSideExpression[?yield]
         *      5) --LeftHandSideExpression[?yield]
         * In TypeScript (2), (3) are parsed as PostfixUnaryExpression. (4), (5) are parsed as PrefixUnaryExpression
         */
        function parseUpdateExpression() {
            if (token() === 45 /* SyntaxKind.PlusPlusToken */ || token() === 46 /* SyntaxKind.MinusMinusToken */) {
                var pos = getNodePos();
                return finishNode(factory.createPrefixUnaryExpression(token(), nextTokenAnd(parseLeftHandSideExpressionOrHigher)), pos);
            }
            else if (languageVariant === 1 /* LanguageVariant.JSX */ && token() === 29 /* SyntaxKind.LessThanToken */ && lookAhead(nextTokenIsIdentifierOrKeywordOrGreaterThan)) {
                // JSXElement is part of primaryExpression
                return parseJsxElementOrSelfClosingElementOrFragment(/*inExpressionContext*/ true);
            }
            var expression = parseLeftHandSideExpressionOrHigher();
            ts.Debug.assert(ts.isLeftHandSideExpression(expression));
            if ((token() === 45 /* SyntaxKind.PlusPlusToken */ || token() === 46 /* SyntaxKind.MinusMinusToken */) && !scanner.hasPrecedingLineBreak()) {
                var operator = token();
                nextToken();
                return finishNode(factory.createPostfixUnaryExpression(expression, operator), expression.pos);
            }
            return expression;
        }
        function parseLeftHandSideExpressionOrHigher() {
            // Original Ecma:
            // LeftHandSideExpression: See 11.2
            //      NewExpression
            //      CallExpression
            //
            // Our simplification:
            //
            // LeftHandSideExpression: See 11.2
            //      MemberExpression
            //      CallExpression
            //
            // See comment in parseMemberExpressionOrHigher on how we replaced NewExpression with
            // MemberExpression to make our lives easier.
            //
            // to best understand the below code, it's important to see how CallExpression expands
            // out into its own productions:
            //
            // CallExpression:
            //      MemberExpression Arguments
            //      CallExpression Arguments
            //      CallExpression[Expression]
            //      CallExpression.IdentifierName
            //      import (AssignmentExpression)
            //      super Arguments
            //      super.IdentifierName
            //
            // Because of the recursion in these calls, we need to bottom out first. There are three
            // bottom out states we can run into: 1) We see 'super' which must start either of
            // the last two CallExpression productions. 2) We see 'import' which must start import call.
            // 3)we have a MemberExpression which either completes the LeftHandSideExpression,
            // or starts the beginning of the first four CallExpression productions.
            var pos = getNodePos();
            var expression;
            if (token() === 100 /* SyntaxKind.ImportKeyword */) {
                if (lookAhead(nextTokenIsOpenParenOrLessThan)) {
                    // We don't want to eagerly consume all import keyword as import call expression so we look ahead to find "("
                    // For example:
                    //      var foo3 = require("subfolder
                    //      import * as foo1 from "module-from-node
                    // We want this import to be a statement rather than import call expression
                    sourceFlags |= 2097152 /* NodeFlags.PossiblyContainsDynamicImport */;
                    expression = parseTokenNode();
                }
                else if (lookAhead(nextTokenIsDot)) {
                    // This is an 'import.*' metaproperty (i.e. 'import.meta')
                    nextToken(); // advance past the 'import'
                    nextToken(); // advance past the dot
                    expression = finishNode(factory.createMetaProperty(100 /* SyntaxKind.ImportKeyword */, parseIdentifierName()), pos);
                    sourceFlags |= 4194304 /* NodeFlags.PossiblyContainsImportMeta */;
                }
                else {
                    expression = parseMemberExpressionOrHigher();
                }
            }
            else {
                expression = token() === 106 /* SyntaxKind.SuperKeyword */ ? parseSuperExpression() : parseMemberExpressionOrHigher();
            }
            // Now, we *may* be complete.  However, we might have consumed the start of a
            // CallExpression or OptionalExpression.  As such, we need to consume the rest
            // of it here to be complete.
            return parseCallExpressionRest(pos, expression);
        }
        function parseMemberExpressionOrHigher() {
            // Note: to make our lives simpler, we decompose the NewExpression productions and
            // place ObjectCreationExpression and FunctionExpression into PrimaryExpression.
            // like so:
            //
            //   PrimaryExpression : See 11.1
            //      this
            //      Identifier
            //      Literal
            //      ArrayLiteral
            //      ObjectLiteral
            //      (Expression)
            //      FunctionExpression
            //      new MemberExpression Arguments?
            //
            //   MemberExpression : See 11.2
            //      PrimaryExpression
            //      MemberExpression[Expression]
            //      MemberExpression.IdentifierName
            //
            //   CallExpression : See 11.2
            //      MemberExpression
            //      CallExpression Arguments
            //      CallExpression[Expression]
            //      CallExpression.IdentifierName
            //
            // Technically this is ambiguous.  i.e. CallExpression defines:
            //
            //   CallExpression:
            //      CallExpression Arguments
            //
            // If you see: "new Foo()"
            //
            // Then that could be treated as a single ObjectCreationExpression, or it could be
            // treated as the invocation of "new Foo".  We disambiguate that in code (to match
            // the original grammar) by making sure that if we see an ObjectCreationExpression
            // we always consume arguments if they are there. So we treat "new Foo()" as an
            // object creation only, and not at all as an invocation.  Another way to think
            // about this is that for every "new" that we see, we will consume an argument list if
            // it is there as part of the *associated* object creation node.  Any additional
            // argument lists we see, will become invocation expressions.
            //
            // Because there are no other places in the grammar now that refer to FunctionExpression
            // or ObjectCreationExpression, it is safe to push down into the PrimaryExpression
            // production.
            //
            // Because CallExpression and MemberExpression are left recursive, we need to bottom out
            // of the recursion immediately.  So we parse out a primary expression to start with.
            var pos = getNodePos();
            var expression = parsePrimaryExpression();
            return parseMemberExpressionRest(pos, expression, /*allowOptionalChain*/ true);
        }
        function parseSuperExpression() {
            var pos = getNodePos();
            var expression = parseTokenNode();
            if (token() === 29 /* SyntaxKind.LessThanToken */) {
                var startPos = getNodePos();
                var typeArguments = tryParse(parseTypeArgumentsInExpression);
                if (typeArguments !== undefined) {
                    parseErrorAt(startPos, getNodePos(), ts.Diagnostics.super_may_not_use_type_arguments);
                    if (!isTemplateStartOfTaggedTemplate()) {
                        expression = factory.createExpressionWithTypeArguments(expression, typeArguments);
                    }
                }
            }
            if (token() === 20 /* SyntaxKind.OpenParenToken */ || token() === 24 /* SyntaxKind.DotToken */ || token() === 22 /* SyntaxKind.OpenBracketToken */) {
                return expression;
            }
            // If we have seen "super" it must be followed by '(' or '.'.
            // If it wasn't then just try to parse out a '.' and report an error.
            parseExpectedToken(24 /* SyntaxKind.DotToken */, ts.Diagnostics.super_must_be_followed_by_an_argument_list_or_member_access);
            // private names will never work with `super` (`super.#foo`), but that's a semantic error, not syntactic
            return finishNode(factory.createPropertyAccessExpression(expression, parseRightSideOfDot(/*allowIdentifierNames*/ true, /*allowPrivateIdentifiers*/ true)), pos);
        }
        function parseJsxElementOrSelfClosingElementOrFragment(inExpressionContext, topInvalidNodePosition, openingTag) {
            var pos = getNodePos();
            var opening = parseJsxOpeningOrSelfClosingElementOrOpeningFragment(inExpressionContext);
            var result;
            if (opening.kind === 280 /* SyntaxKind.JsxOpeningElement */) {
                var children = parseJsxChildren(opening);
                var closingElement = void 0;
                var lastChild = children[children.length - 1];
                if ((lastChild === null || lastChild === void 0 ? void 0 : lastChild.kind) === 278 /* SyntaxKind.JsxElement */
                    && !tagNamesAreEquivalent(lastChild.openingElement.tagName, lastChild.closingElement.tagName)
                    && tagNamesAreEquivalent(opening.tagName, lastChild.closingElement.tagName)) {
                    // when an unclosed JsxOpeningElement incorrectly parses its parent's JsxClosingElement,
                    // restructure (<div>(...<span>...</div>)) --> (<div>(...<span>...</>)</div>)
                    // (no need to error; the parent will error)
                    var end = lastChild.children.end;
                    var newLast = finishNode(factory.createJsxElement(lastChild.openingElement, lastChild.children, finishNode(factory.createJsxClosingElement(finishNode(factory.createIdentifier(""), end, end)), end, end)), lastChild.openingElement.pos, end);
                    children = createNodeArray(__spreadArray(__spreadArray([], children.slice(0, children.length - 1), true), [newLast], false), children.pos, end);
                    closingElement = lastChild.closingElement;
                }
                else {
                    closingElement = parseJsxClosingElement(opening, inExpressionContext);
                    if (!tagNamesAreEquivalent(opening.tagName, closingElement.tagName)) {
                        if (openingTag && ts.isJsxOpeningElement(openingTag) && tagNamesAreEquivalent(closingElement.tagName, openingTag.tagName)) {
                            // opening incorrectly matched with its parent's closing -- put error on opening
                            parseErrorAtRange(opening.tagName, ts.Diagnostics.JSX_element_0_has_no_corresponding_closing_tag, ts.getTextOfNodeFromSourceText(sourceText, opening.tagName));
                        }
                        else {
                            // other opening/closing mismatches -- put error on closing
                            parseErrorAtRange(closingElement.tagName, ts.Diagnostics.Expected_corresponding_JSX_closing_tag_for_0, ts.getTextOfNodeFromSourceText(sourceText, opening.tagName));
                        }
                    }
                }
                result = finishNode(factory.createJsxElement(opening, children, closingElement), pos);
            }
            else if (opening.kind === 283 /* SyntaxKind.JsxOpeningFragment */) {
                result = finishNode(factory.createJsxFragment(opening, parseJsxChildren(opening), parseJsxClosingFragment(inExpressionContext)), pos);
            }
            else {
                ts.Debug.assert(opening.kind === 279 /* SyntaxKind.JsxSelfClosingElement */);
                // Nothing else to do for self-closing elements
                result = opening;
            }
            // If the user writes the invalid code '<div></div><div></div>' in an expression context (i.e. not wrapped in
            // an enclosing tag), we'll naively try to parse   ^ this as a 'less than' operator and the remainder of the tag
            // as garbage, which will cause the formatter to badly mangle the JSX. Perform a speculative parse of a JSX
            // element if we see a < token so that we can wrap it in a synthetic binary expression so the formatter
            // does less damage and we can report a better error.
            // Since JSX elements are invalid < operands anyway, this lookahead parse will only occur in error scenarios
            // of one sort or another.
            if (inExpressionContext && token() === 29 /* SyntaxKind.LessThanToken */) {
                var topBadPos_1 = typeof topInvalidNodePosition === "undefined" ? result.pos : topInvalidNodePosition;
                var invalidElement = tryParse(function () { return parseJsxElementOrSelfClosingElementOrFragment(/*inExpressionContext*/ true, topBadPos_1); });
                if (invalidElement) {
                    var operatorToken = createMissingNode(27 /* SyntaxKind.CommaToken */, /*reportAtCurrentPosition*/ false);
                    ts.setTextRangePosWidth(operatorToken, invalidElement.pos, 0);
                    parseErrorAt(ts.skipTrivia(sourceText, topBadPos_1), invalidElement.end, ts.Diagnostics.JSX_expressions_must_have_one_parent_element);
                    return finishNode(factory.createBinaryExpression(result, operatorToken, invalidElement), pos);
                }
            }
            return result;
        }
        function parseJsxText() {
            var pos = getNodePos();
            var node = factory.createJsxText(scanner.getTokenValue(), currentToken === 12 /* SyntaxKind.JsxTextAllWhiteSpaces */);
            currentToken = scanner.scanJsxToken();
            return finishNode(node, pos);
        }
        function parseJsxChild(openingTag, token) {
            switch (token) {
                case 1 /* SyntaxKind.EndOfFileToken */:
                    // If we hit EOF, issue the error at the tag that lacks the closing element
                    // rather than at the end of the file (which is useless)
                    if (ts.isJsxOpeningFragment(openingTag)) {
                        parseErrorAtRange(openingTag, ts.Diagnostics.JSX_fragment_has_no_corresponding_closing_tag);
                    }
                    else {
                        // We want the error span to cover only 'Foo.Bar' in < Foo.Bar >
                        // or to cover only 'Foo' in < Foo >
                        var tag = openingTag.tagName;
                        var start = ts.skipTrivia(sourceText, tag.pos);
                        parseErrorAt(start, tag.end, ts.Diagnostics.JSX_element_0_has_no_corresponding_closing_tag, ts.getTextOfNodeFromSourceText(sourceText, openingTag.tagName));
                    }
                    return undefined;
                case 30 /* SyntaxKind.LessThanSlashToken */:
                case 7 /* SyntaxKind.ConflictMarkerTrivia */:
                    return undefined;
                case 11 /* SyntaxKind.JsxText */:
                case 12 /* SyntaxKind.JsxTextAllWhiteSpaces */:
                    return parseJsxText();
                case 18 /* SyntaxKind.OpenBraceToken */:
                    return parseJsxExpression(/*inExpressionContext*/ false);
                case 29 /* SyntaxKind.LessThanToken */:
                    return parseJsxElementOrSelfClosingElementOrFragment(/*inExpressionContext*/ false, /*topInvalidNodePosition*/ undefined, openingTag);
                default:
                    return ts.Debug.assertNever(token);
            }
        }
        function parseJsxChildren(openingTag) {
            var list = [];
            var listPos = getNodePos();
            var saveParsingContext = parsingContext;
            parsingContext |= 1 << 14 /* ParsingContext.JsxChildren */;
            while (true) {
                var child = parseJsxChild(openingTag, currentToken = scanner.reScanJsxToken());
                if (!child)
                    break;
                list.push(child);
                if (ts.isJsxOpeningElement(openingTag)
                    && (child === null || child === void 0 ? void 0 : child.kind) === 278 /* SyntaxKind.JsxElement */
                    && !tagNamesAreEquivalent(child.openingElement.tagName, child.closingElement.tagName)
                    && tagNamesAreEquivalent(openingTag.tagName, child.closingElement.tagName)) {
                    // stop after parsing a mismatched child like <div>...(<span></div>) in order to reattach the </div> higher
                    break;
                }
            }
            parsingContext = saveParsingContext;
            return createNodeArray(list, listPos);
        }
        function parseJsxAttributes() {
            var pos = getNodePos();
            return finishNode(factory.createJsxAttributes(parseList(13 /* ParsingContext.JsxAttributes */, parseJsxAttribute)), pos);
        }
        function parseJsxOpeningOrSelfClosingElementOrOpeningFragment(inExpressionContext) {
            var pos = getNodePos();
            parseExpected(29 /* SyntaxKind.LessThanToken */);
            if (token() === 31 /* SyntaxKind.GreaterThanToken */) {
                // See below for explanation of scanJsxText
                scanJsxText();
                return finishNode(factory.createJsxOpeningFragment(), pos);
            }
            var tagName = parseJsxElementName();
            var typeArguments = (contextFlags & 262144 /* NodeFlags.JavaScriptFile */) === 0 ? tryParseTypeArguments() : undefined;
            var attributes = parseJsxAttributes();
            var node;
            if (token() === 31 /* SyntaxKind.GreaterThanToken */) {
                // Closing tag, so scan the immediately-following text with the JSX scanning instead
                // of regular scanning to avoid treating illegal characters (e.g. '#') as immediate
                // scanning errors
                scanJsxText();
                node = factory.createJsxOpeningElement(tagName, typeArguments, attributes);
            }
            else {
                parseExpected(43 /* SyntaxKind.SlashToken */);
                if (parseExpected(31 /* SyntaxKind.GreaterThanToken */, /*diagnostic*/ undefined, /*shouldAdvance*/ false)) {
                    // manually advance the scanner in order to look for jsx text inside jsx
                    if (inExpressionContext) {
                        nextToken();
                    }
                    else {
                        scanJsxText();
                    }
                }
                node = factory.createJsxSelfClosingElement(tagName, typeArguments, attributes);
            }
            return finishNode(node, pos);
        }
        function parseJsxElementName() {
            var pos = getNodePos();
            scanJsxIdentifier();
            // JsxElement can have name in the form of
            //      propertyAccessExpression
            //      primaryExpression in the form of an identifier and "this" keyword
            // We can't just simply use parseLeftHandSideExpressionOrHigher because then we will start consider class,function etc as a keyword
            // We only want to consider "this" as a primaryExpression
            var expression = token() === 108 /* SyntaxKind.ThisKeyword */ ?
                parseTokenNode() : parseIdentifierName();
            while (parseOptional(24 /* SyntaxKind.DotToken */)) {
                expression = finishNode(factory.createPropertyAccessExpression(expression, parseRightSideOfDot(/*allowIdentifierNames*/ true, /*allowPrivateIdentifiers*/ false)), pos);
            }
            return expression;
        }
        function parseJsxExpression(inExpressionContext) {
            var pos = getNodePos();
            if (!parseExpected(18 /* SyntaxKind.OpenBraceToken */)) {
                return undefined;
            }
            var dotDotDotToken;
            var expression;
            if (token() !== 19 /* SyntaxKind.CloseBraceToken */) {
                dotDotDotToken = parseOptionalToken(25 /* SyntaxKind.DotDotDotToken */);
                // Only an AssignmentExpression is valid here per the JSX spec,
                // but we can unambiguously parse a comma sequence and provide
                // a better error message in grammar checking.
                expression = parseExpression();
            }
            if (inExpressionContext) {
                parseExpected(19 /* SyntaxKind.CloseBraceToken */);
            }
            else {
                if (parseExpected(19 /* SyntaxKind.CloseBraceToken */, /*message*/ undefined, /*shouldAdvance*/ false)) {
                    scanJsxText();
                }
            }
            return finishNode(factory.createJsxExpression(dotDotDotToken, expression), pos);
        }
        function parseJsxAttribute() {
            if (token() === 18 /* SyntaxKind.OpenBraceToken */) {
                return parseJsxSpreadAttribute();
            }
            scanJsxIdentifier();
            var pos = getNodePos();
            return finishNode(factory.createJsxAttribute(parseIdentifierName(), parseJsxAttributeValue()), pos);
        }
        function parseJsxAttributeValue() {
            if (token() === 63 /* SyntaxKind.EqualsToken */) {
                if (scanJsxAttributeValue() === 10 /* SyntaxKind.StringLiteral */) {
                    return parseLiteralNode();
                }
                if (token() === 18 /* SyntaxKind.OpenBraceToken */) {
                    return parseJsxExpression(/*inExpressionContext*/ true);
                }
                if (token() === 29 /* SyntaxKind.LessThanToken */) {
                    return parseJsxElementOrSelfClosingElementOrFragment(/*inExpressionContext*/ true);
                }
                parseErrorAtCurrentToken(ts.Diagnostics.or_JSX_element_expected);
            }
            return undefined;
        }
        function parseJsxSpreadAttribute() {
            var pos = getNodePos();
            parseExpected(18 /* SyntaxKind.OpenBraceToken */);
            parseExpected(25 /* SyntaxKind.DotDotDotToken */);
            var expression = parseExpression();
            parseExpected(19 /* SyntaxKind.CloseBraceToken */);
            return finishNode(factory.createJsxSpreadAttribute(expression), pos);
        }
        function parseJsxClosingElement(open, inExpressionContext) {
            var pos = getNodePos();
            parseExpected(30 /* SyntaxKind.LessThanSlashToken */);
            var tagName = parseJsxElementName();
            if (parseExpected(31 /* SyntaxKind.GreaterThanToken */, /*diagnostic*/ undefined, /*shouldAdvance*/ false)) {
                // manually advance the scanner in order to look for jsx text inside jsx
                if (inExpressionContext || !tagNamesAreEquivalent(open.tagName, tagName)) {
                    nextToken();
                }
                else {
                    scanJsxText();
                }
            }
            return finishNode(factory.createJsxClosingElement(tagName), pos);
        }
        function parseJsxClosingFragment(inExpressionContext) {
            var pos = getNodePos();
            parseExpected(30 /* SyntaxKind.LessThanSlashToken */);
            if (ts.tokenIsIdentifierOrKeyword(token())) {
                parseErrorAtRange(parseJsxElementName(), ts.Diagnostics.Expected_corresponding_closing_tag_for_JSX_fragment);
            }
            if (parseExpected(31 /* SyntaxKind.GreaterThanToken */, /*diagnostic*/ undefined, /*shouldAdvance*/ false)) {
                // manually advance the scanner in order to look for jsx text inside jsx
                if (inExpressionContext) {
                    nextToken();
                }
                else {
                    scanJsxText();
                }
            }
            return finishNode(factory.createJsxJsxClosingFragment(), pos);
        }
        function parseTypeAssertion() {
            var pos = getNodePos();
            parseExpected(29 /* SyntaxKind.LessThanToken */);
            var type = parseType();
            parseExpected(31 /* SyntaxKind.GreaterThanToken */);
            var expression = parseSimpleUnaryExpression();
            return finishNode(factory.createTypeAssertion(type, expression), pos);
        }
        function nextTokenIsIdentifierOrKeywordOrOpenBracketOrTemplate() {
            nextToken();
            return ts.tokenIsIdentifierOrKeyword(token())
                || token() === 22 /* SyntaxKind.OpenBracketToken */
                || isTemplateStartOfTaggedTemplate();
        }
        function isStartOfOptionalPropertyOrElementAccessChain() {
            return token() === 28 /* SyntaxKind.QuestionDotToken */
                && lookAhead(nextTokenIsIdentifierOrKeywordOrOpenBracketOrTemplate);
        }
        function tryReparseOptionalChain(node) {
            if (node.flags & 32 /* NodeFlags.OptionalChain */) {
                return true;
            }
            // check for an optional chain in a non-null expression
            if (ts.isNonNullExpression(node)) {
                var expr = node.expression;
                while (ts.isNonNullExpression(expr) && !(expr.flags & 32 /* NodeFlags.OptionalChain */)) {
                    expr = expr.expression;
                }
                if (expr.flags & 32 /* NodeFlags.OptionalChain */) {
                    // this is part of an optional chain. Walk down from `node` to `expression` and set the flag.
                    while (ts.isNonNullExpression(node)) {
                        node.flags |= 32 /* NodeFlags.OptionalChain */;
                        node = node.expression;
                    }
                    return true;
                }
            }
            return false;
        }
        function parsePropertyAccessExpressionRest(pos, expression, questionDotToken) {
            var name = parseRightSideOfDot(/*allowIdentifierNames*/ true, /*allowPrivateIdentifiers*/ true);
            var isOptionalChain = questionDotToken || tryReparseOptionalChain(expression);
            var propertyAccess = isOptionalChain ?
                factory.createPropertyAccessChain(expression, questionDotToken, name) :
                factory.createPropertyAccessExpression(expression, name);
            if (isOptionalChain && ts.isPrivateIdentifier(propertyAccess.name)) {
                parseErrorAtRange(propertyAccess.name, ts.Diagnostics.An_optional_chain_cannot_contain_private_identifiers);
            }
            if (ts.isExpressionWithTypeArguments(expression) && expression.typeArguments) {
                var pos_2 = expression.typeArguments.pos - 1;
                var end = ts.skipTrivia(sourceText, expression.typeArguments.end) + 1;
                parseErrorAt(pos_2, end, ts.Diagnostics.An_instantiation_expression_cannot_be_followed_by_a_property_access);
            }
            return finishNode(propertyAccess, pos);
        }
        function parseElementAccessExpressionRest(pos, expression, questionDotToken) {
            var argumentExpression;
            if (token() === 23 /* SyntaxKind.CloseBracketToken */) {
                argumentExpression = createMissingNode(79 /* SyntaxKind.Identifier */, /*reportAtCurrentPosition*/ true, ts.Diagnostics.An_element_access_expression_should_take_an_argument);
            }
            else {
                var argument = allowInAnd(parseExpression);
                if (ts.isStringOrNumericLiteralLike(argument)) {
                    argument.text = internIdentifier(argument.text);
                }
                argumentExpression = argument;
            }
            parseExpected(23 /* SyntaxKind.CloseBracketToken */);
            var indexedAccess = questionDotToken || tryReparseOptionalChain(expression) ?
                factory.createElementAccessChain(expression, questionDotToken, argumentExpression) :
                factory.createElementAccessExpression(expression, argumentExpression);
            return finishNode(indexedAccess, pos);
        }
        function parseMemberExpressionRest(pos, expression, allowOptionalChain) {
            while (true) {
                var questionDotToken = void 0;
                var isPropertyAccess = false;
                if (allowOptionalChain && isStartOfOptionalPropertyOrElementAccessChain()) {
                    questionDotToken = parseExpectedToken(28 /* SyntaxKind.QuestionDotToken */);
                    isPropertyAccess = ts.tokenIsIdentifierOrKeyword(token());
                }
                else {
                    isPropertyAccess = parseOptional(24 /* SyntaxKind.DotToken */);
                }
                if (isPropertyAccess) {
                    expression = parsePropertyAccessExpressionRest(pos, expression, questionDotToken);
                    continue;
                }
                // when in the [Decorator] context, we do not parse ElementAccess as it could be part of a ComputedPropertyName
                if ((questionDotToken || !inDecoratorContext()) && parseOptional(22 /* SyntaxKind.OpenBracketToken */)) {
                    expression = parseElementAccessExpressionRest(pos, expression, questionDotToken);
                    continue;
                }
                if (isTemplateStartOfTaggedTemplate()) {
                    // Absorb type arguments into TemplateExpression when preceding expression is ExpressionWithTypeArguments
                    expression = !questionDotToken && expression.kind === 228 /* SyntaxKind.ExpressionWithTypeArguments */ ?
                        parseTaggedTemplateRest(pos, expression.expression, questionDotToken, expression.typeArguments) :
                        parseTaggedTemplateRest(pos, expression, questionDotToken, /*typeArguments*/ undefined);
                    continue;
                }
                if (!questionDotToken) {
                    if (token() === 53 /* SyntaxKind.ExclamationToken */ && !scanner.hasPrecedingLineBreak()) {
                        nextToken();
                        expression = finishNode(factory.createNonNullExpression(expression), pos);
                        continue;
                    }
                    var typeArguments = tryParse(parseTypeArgumentsInExpression);
                    if (typeArguments) {
                        expression = finishNode(factory.createExpressionWithTypeArguments(expression, typeArguments), pos);
                        continue;
                    }
                }
                return expression;
            }
        }
        function isTemplateStartOfTaggedTemplate() {
            return token() === 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */ || token() === 15 /* SyntaxKind.TemplateHead */;
        }
        function parseTaggedTemplateRest(pos, tag, questionDotToken, typeArguments) {
            var tagExpression = factory.createTaggedTemplateExpression(tag, typeArguments, token() === 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */ ?
                (reScanTemplateHeadOrNoSubstitutionTemplate(), parseLiteralNode()) :
                parseTemplateExpression(/*isTaggedTemplate*/ true));
            if (questionDotToken || tag.flags & 32 /* NodeFlags.OptionalChain */) {
                tagExpression.flags |= 32 /* NodeFlags.OptionalChain */;
            }
            tagExpression.questionDotToken = questionDotToken;
            return finishNode(tagExpression, pos);
        }
        function parseCallExpressionRest(pos, expression) {
            while (true) {
                expression = parseMemberExpressionRest(pos, expression, /*allowOptionalChain*/ true);
                var typeArguments = void 0;
                var questionDotToken = parseOptionalToken(28 /* SyntaxKind.QuestionDotToken */);
                if (questionDotToken) {
                    typeArguments = tryParse(parseTypeArgumentsInExpression);
                    if (isTemplateStartOfTaggedTemplate()) {
                        expression = parseTaggedTemplateRest(pos, expression, questionDotToken, typeArguments);
                        continue;
                    }
                }
                if (typeArguments || token() === 20 /* SyntaxKind.OpenParenToken */) {
                    // Absorb type arguments into CallExpression when preceding expression is ExpressionWithTypeArguments
                    if (!questionDotToken && expression.kind === 228 /* SyntaxKind.ExpressionWithTypeArguments */) {
                        typeArguments = expression.typeArguments;
                        expression = expression.expression;
                    }
                    var argumentList = parseArgumentList();
                    var callExpr = questionDotToken || tryReparseOptionalChain(expression) ?
                        factory.createCallChain(expression, questionDotToken, typeArguments, argumentList) :
                        factory.createCallExpression(expression, typeArguments, argumentList);
                    expression = finishNode(callExpr, pos);
                    continue;
                }
                if (questionDotToken) {
                    // We parsed `?.` but then failed to parse anything, so report a missing identifier here.
                    var name = createMissingNode(79 /* SyntaxKind.Identifier */, /*reportAtCurrentPosition*/ false, ts.Diagnostics.Identifier_expected);
                    expression = finishNode(factory.createPropertyAccessChain(expression, questionDotToken, name), pos);
                }
                break;
            }
            return expression;
        }
        function parseArgumentList() {
            parseExpected(20 /* SyntaxKind.OpenParenToken */);
            var result = parseDelimitedList(11 /* ParsingContext.ArgumentExpressions */, parseArgumentExpression);
            parseExpected(21 /* SyntaxKind.CloseParenToken */);
            return result;
        }
        function parseTypeArgumentsInExpression() {
            if ((contextFlags & 262144 /* NodeFlags.JavaScriptFile */) !== 0) {
                // TypeArguments must not be parsed in JavaScript files to avoid ambiguity with binary operators.
                return undefined;
            }
            if (reScanLessThanToken() !== 29 /* SyntaxKind.LessThanToken */) {
                return undefined;
            }
            nextToken();
            var typeArguments = parseDelimitedList(20 /* ParsingContext.TypeArguments */, parseType);
            if (reScanGreaterToken() !== 31 /* SyntaxKind.GreaterThanToken */) {
                // If it doesn't have the closing `>` then it's definitely not an type argument list.
                return undefined;
            }
            nextToken();
            // We successfully parsed a type argument list. The next token determines whether we want to
            // treat it as such. If the type argument list is followed by `(` or a template literal, as in
            // `f<number>(42)`, we favor the type argument interpretation even though JavaScript would view
            // it as a relational expression.
            return typeArguments && canFollowTypeArgumentsInExpression() ? typeArguments : undefined;
        }
        function canFollowTypeArgumentsInExpression() {
            switch (token()) {
                // These tokens can follow a type argument list in a call expression.
                case 20 /* SyntaxKind.OpenParenToken */: // foo<x>(
                case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */: // foo<T> `...`
                case 15 /* SyntaxKind.TemplateHead */: // foo<T> `...${100}...`
                    return true;
                // A type argument list followed by `<` never makes sense, and a type argument list followed
                // by `>` is ambiguous with a (re-scanned) `>>` operator, so we disqualify both. Also, in
                // this context, `+` and `-` are unary operators, not binary operators.
                case 29 /* SyntaxKind.LessThanToken */:
                case 31 /* SyntaxKind.GreaterThanToken */:
                case 39 /* SyntaxKind.PlusToken */:
                case 40 /* SyntaxKind.MinusToken */:
                    return false;
            }
            // We favor the type argument list interpretation when it is immediately followed by
            // a line break, a binary operator, or something that can't start an expression.
            return scanner.hasPrecedingLineBreak() || isBinaryOperator() || !isStartOfExpression();
        }
        function parsePrimaryExpression() {
            switch (token()) {
                case 8 /* SyntaxKind.NumericLiteral */:
                case 9 /* SyntaxKind.BigIntLiteral */:
                case 10 /* SyntaxKind.StringLiteral */:
                case 14 /* SyntaxKind.NoSubstitutionTemplateLiteral */:
                    return parseLiteralNode();
                case 108 /* SyntaxKind.ThisKeyword */:
                case 106 /* SyntaxKind.SuperKeyword */:
                case 104 /* SyntaxKind.NullKeyword */:
                case 110 /* SyntaxKind.TrueKeyword */:
                case 95 /* SyntaxKind.FalseKeyword */:
                    return parseTokenNode();
                case 20 /* SyntaxKind.OpenParenToken */:
                    return parseParenthesizedExpression();
                case 22 /* SyntaxKind.OpenBracketToken */:
                    return parseArrayLiteralExpression();
                case 18 /* SyntaxKind.OpenBraceToken */:
                    return parseObjectLiteralExpression();
                case 131 /* SyntaxKind.AsyncKeyword */:
                    // Async arrow functions are parsed earlier in parseAssignmentExpressionOrHigher.
                    // If we encounter `async [no LineTerminator here] function` then this is an async
                    // function; otherwise, its an identifier.
                    if (!lookAhead(nextTokenIsFunctionKeywordOnSameLine)) {
                        break;
                    }
                    return parseFunctionExpression();
                case 84 /* SyntaxKind.ClassKeyword */:
                    return parseClassExpression();
                case 98 /* SyntaxKind.FunctionKeyword */:
                    return parseFunctionExpression();
                case 103 /* SyntaxKind.NewKeyword */:
                    return parseNewExpressionOrNewDotTarget();
                case 43 /* SyntaxKind.SlashToken */:
                case 68 /* SyntaxKind.SlashEqualsToken */:
                    if (reScanSlashToken() === 13 /* SyntaxKind.RegularExpressionLiteral */) {
                        return parseLiteralNode();
                    }
                    break;
                case 15 /* SyntaxKind.TemplateHead */:
                    return parseTemplateExpression(/* isTaggedTemplate */ false);
                case 80 /* SyntaxKind.PrivateIdentifier */:
                    return parsePrivateIdentifier();
            }
            return parseIdentifier(ts.Diagnostics.Expression_expected);
        }
        function parseParenthesizedExpression() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(20 /* SyntaxKind.OpenParenToken */);
            var expression = allowInAnd(parseExpression);
            parseExpected(21 /* SyntaxKind.CloseParenToken */);
            return withJSDoc(finishNode(factory.createParenthesizedExpression(expression), pos), hasJSDoc);
        }
        function parseSpreadElement() {
            var pos = getNodePos();
            parseExpected(25 /* SyntaxKind.DotDotDotToken */);
            var expression = parseAssignmentExpressionOrHigher(/*allowReturnTypeInArrowFunction*/ true);
            return finishNode(factory.createSpreadElement(expression), pos);
        }
        function parseArgumentOrArrayLiteralElement() {
            return token() === 25 /* SyntaxKind.DotDotDotToken */ ? parseSpreadElement() :
                token() === 27 /* SyntaxKind.CommaToken */ ? finishNode(factory.createOmittedExpression(), getNodePos()) :
                    parseAssignmentExpressionOrHigher(/*allowReturnTypeInArrowFunction*/ true);
        }
        function parseArgumentExpression() {
            return doOutsideOfContext(disallowInAndDecoratorContext, parseArgumentOrArrayLiteralElement);
        }
        function parseArrayLiteralExpression() {
            var pos = getNodePos();
            var openBracketPosition = scanner.getTokenPos();
            var openBracketParsed = parseExpected(22 /* SyntaxKind.OpenBracketToken */);
            var multiLine = scanner.hasPrecedingLineBreak();
            var elements = parseDelimitedList(15 /* ParsingContext.ArrayLiteralMembers */, parseArgumentOrArrayLiteralElement);
            parseExpectedMatchingBrackets(22 /* SyntaxKind.OpenBracketToken */, 23 /* SyntaxKind.CloseBracketToken */, openBracketParsed, openBracketPosition);
            return finishNode(factory.createArrayLiteralExpression(elements, multiLine), pos);
        }
        function parseObjectLiteralElement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            if (parseOptionalToken(25 /* SyntaxKind.DotDotDotToken */)) {
                var expression = parseAssignmentExpressionOrHigher(/*allowReturnTypeInArrowFunction*/ true);
                return withJSDoc(finishNode(factory.createSpreadAssignment(expression), pos), hasJSDoc);
            }
            var decorators = parseDecorators();
            var modifiers = parseModifiers();
            if (parseContextualModifier(136 /* SyntaxKind.GetKeyword */)) {
                return parseAccessorDeclaration(pos, hasJSDoc, decorators, modifiers, 172 /* SyntaxKind.GetAccessor */, 0 /* SignatureFlags.None */);
            }
            if (parseContextualModifier(149 /* SyntaxKind.SetKeyword */)) {
                return parseAccessorDeclaration(pos, hasJSDoc, decorators, modifiers, 173 /* SyntaxKind.SetAccessor */, 0 /* SignatureFlags.None */);
            }
            var asteriskToken = parseOptionalToken(41 /* SyntaxKind.AsteriskToken */);
            var tokenIsIdentifier = isIdentifier();
            var name = parsePropertyName();
            // Disallowing of optional property assignments and definite assignment assertion happens in the grammar checker.
            var questionToken = parseOptionalToken(57 /* SyntaxKind.QuestionToken */);
            var exclamationToken = parseOptionalToken(53 /* SyntaxKind.ExclamationToken */);
            if (asteriskToken || token() === 20 /* SyntaxKind.OpenParenToken */ || token() === 29 /* SyntaxKind.LessThanToken */) {
                return parseMethodDeclaration(pos, hasJSDoc, decorators, modifiers, asteriskToken, name, questionToken, exclamationToken);
            }
            // check if it is short-hand property assignment or normal property assignment
            // NOTE: if token is EqualsToken it is interpreted as CoverInitializedName production
            // CoverInitializedName[Yield] :
            //     IdentifierReference[?Yield] Initializer[In, ?Yield]
            // this is necessary because ObjectLiteral productions are also used to cover grammar for ObjectAssignmentPattern
            var node;
            var isShorthandPropertyAssignment = tokenIsIdentifier && (token() !== 58 /* SyntaxKind.ColonToken */);
            if (isShorthandPropertyAssignment) {
                var equalsToken = parseOptionalToken(63 /* SyntaxKind.EqualsToken */);
                var objectAssignmentInitializer = equalsToken ? allowInAnd(function () { return parseAssignmentExpressionOrHigher(/*allowReturnTypeInArrowFunction*/ true); }) : undefined;
                node = factory.createShorthandPropertyAssignment(name, objectAssignmentInitializer);
                // Save equals token for error reporting.
                // TODO(rbuckton): Consider manufacturing this when we need to report an error as it is otherwise not useful.
                node.equalsToken = equalsToken;
            }
            else {
                parseExpected(58 /* SyntaxKind.ColonToken */);
                var initializer = allowInAnd(function () { return parseAssignmentExpressionOrHigher(/*allowReturnTypeInArrowFunction*/ true); });
                node = factory.createPropertyAssignment(name, initializer);
            }
            // Decorators, Modifiers, questionToken, and exclamationToken are not supported by property assignments and are reported in the grammar checker
            node.illegalDecorators = decorators;
            node.modifiers = modifiers;
            node.questionToken = questionToken;
            node.exclamationToken = exclamationToken;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseObjectLiteralExpression() {
            var pos = getNodePos();
            var openBracePosition = scanner.getTokenPos();
            var openBraceParsed = parseExpected(18 /* SyntaxKind.OpenBraceToken */);
            var multiLine = scanner.hasPrecedingLineBreak();
            var properties = parseDelimitedList(12 /* ParsingContext.ObjectLiteralMembers */, parseObjectLiteralElement, /*considerSemicolonAsDelimiter*/ true);
            parseExpectedMatchingBrackets(18 /* SyntaxKind.OpenBraceToken */, 19 /* SyntaxKind.CloseBraceToken */, openBraceParsed, openBracePosition);
            return finishNode(factory.createObjectLiteralExpression(properties, multiLine), pos);
        }
        function parseFunctionExpression() {
            // GeneratorExpression:
            //      function* BindingIdentifier [Yield][opt](FormalParameters[Yield]){ GeneratorBody }
            //
            // FunctionExpression:
            //      function BindingIdentifier[opt](FormalParameters){ FunctionBody }
            var savedDecoratorContext = inDecoratorContext();
            setDecoratorContext(/*val*/ false);
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var modifiers = parseModifiers();
            parseExpected(98 /* SyntaxKind.FunctionKeyword */);
            var asteriskToken = parseOptionalToken(41 /* SyntaxKind.AsteriskToken */);
            var isGenerator = asteriskToken ? 1 /* SignatureFlags.Yield */ : 0 /* SignatureFlags.None */;
            var isAsync = ts.some(modifiers, ts.isAsyncModifier) ? 2 /* SignatureFlags.Await */ : 0 /* SignatureFlags.None */;
            var name = isGenerator && isAsync ? doInYieldAndAwaitContext(parseOptionalBindingIdentifier) :
                isGenerator ? doInYieldContext(parseOptionalBindingIdentifier) :
                    isAsync ? doInAwaitContext(parseOptionalBindingIdentifier) :
                        parseOptionalBindingIdentifier();
            var typeParameters = parseTypeParameters();
            var parameters = parseParameters(isGenerator | isAsync);
            var type = parseReturnType(58 /* SyntaxKind.ColonToken */, /*isType*/ false);
            var body = parseFunctionBlock(isGenerator | isAsync);
            setDecoratorContext(savedDecoratorContext);
            var node = factory.createFunctionExpression(modifiers, asteriskToken, name, typeParameters, parameters, type, body);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseOptionalBindingIdentifier() {
            return isBindingIdentifier() ? parseBindingIdentifier() : undefined;
        }
        function parseNewExpressionOrNewDotTarget() {
            var pos = getNodePos();
            parseExpected(103 /* SyntaxKind.NewKeyword */);
            if (parseOptional(24 /* SyntaxKind.DotToken */)) {
                var name = parseIdentifierName();
                return finishNode(factory.createMetaProperty(103 /* SyntaxKind.NewKeyword */, name), pos);
            }
            var expressionPos = getNodePos();
            var expression = parseMemberExpressionRest(expressionPos, parsePrimaryExpression(), /*allowOptionalChain*/ false);
            var typeArguments;
            // Absorb type arguments into NewExpression when preceding expression is ExpressionWithTypeArguments
            if (expression.kind === 228 /* SyntaxKind.ExpressionWithTypeArguments */) {
                typeArguments = expression.typeArguments;
                expression = expression.expression;
            }
            if (token() === 28 /* SyntaxKind.QuestionDotToken */) {
                parseErrorAtCurrentToken(ts.Diagnostics.Invalid_optional_chain_from_new_expression_Did_you_mean_to_call_0, ts.getTextOfNodeFromSourceText(sourceText, expression));
            }
            var argumentList = token() === 20 /* SyntaxKind.OpenParenToken */ ? parseArgumentList() : undefined;
            return finishNode(factory.createNewExpression(expression, typeArguments, argumentList), pos);
        }
        // STATEMENTS
        function parseBlock(ignoreMissingOpenBrace, diagnosticMessage) {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var openBracePosition = scanner.getTokenPos();
            var openBraceParsed = parseExpected(18 /* SyntaxKind.OpenBraceToken */, diagnosticMessage);
            if (openBraceParsed || ignoreMissingOpenBrace) {
                var multiLine = scanner.hasPrecedingLineBreak();
                var statements = parseList(1 /* ParsingContext.BlockStatements */, parseStatement);
                parseExpectedMatchingBrackets(18 /* SyntaxKind.OpenBraceToken */, 19 /* SyntaxKind.CloseBraceToken */, openBraceParsed, openBracePosition);
                var result = withJSDoc(finishNode(factory.createBlock(statements, multiLine), pos), hasJSDoc);
                if (token() === 63 /* SyntaxKind.EqualsToken */) {
                    parseErrorAtCurrentToken(ts.Diagnostics.Declaration_or_statement_expected_This_follows_a_block_of_statements_so_if_you_intended_to_write_a_destructuring_assignment_you_might_need_to_wrap_the_the_whole_assignment_in_parentheses);
                    nextToken();
                }
                return result;
            }
            else {
                var statements = createMissingList();
                return withJSDoc(finishNode(factory.createBlock(statements, /*multiLine*/ undefined), pos), hasJSDoc);
            }
        }
        function parseFunctionBlock(flags, diagnosticMessage) {
            var savedYieldContext = inYieldContext();
            setYieldContext(!!(flags & 1 /* SignatureFlags.Yield */));
            var savedAwaitContext = inAwaitContext();
            setAwaitContext(!!(flags & 2 /* SignatureFlags.Await */));
            var savedTopLevel = topLevel;
            topLevel = false;
            // We may be in a [Decorator] context when parsing a function expression or
            // arrow function. The body of the function is not in [Decorator] context.
            var saveDecoratorContext = inDecoratorContext();
            if (saveDecoratorContext) {
                setDecoratorContext(/*val*/ false);
            }
            var block = parseBlock(!!(flags & 16 /* SignatureFlags.IgnoreMissingOpenBrace */), diagnosticMessage);
            if (saveDecoratorContext) {
                setDecoratorContext(/*val*/ true);
            }
            topLevel = savedTopLevel;
            setYieldContext(savedYieldContext);
            setAwaitContext(savedAwaitContext);
            return block;
        }
        function parseEmptyStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(26 /* SyntaxKind.SemicolonToken */);
            return withJSDoc(finishNode(factory.createEmptyStatement(), pos), hasJSDoc);
        }
        function parseIfStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(99 /* SyntaxKind.IfKeyword */);
            var openParenPosition = scanner.getTokenPos();
            var openParenParsed = parseExpected(20 /* SyntaxKind.OpenParenToken */);
            var expression = allowInAnd(parseExpression);
            parseExpectedMatchingBrackets(20 /* SyntaxKind.OpenParenToken */, 21 /* SyntaxKind.CloseParenToken */, openParenParsed, openParenPosition);
            var thenStatement = parseStatement();
            var elseStatement = parseOptional(91 /* SyntaxKind.ElseKeyword */) ? parseStatement() : undefined;
            return withJSDoc(finishNode(factory.createIfStatement(expression, thenStatement, elseStatement), pos), hasJSDoc);
        }
        function parseDoStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(90 /* SyntaxKind.DoKeyword */);
            var statement = parseStatement();
            parseExpected(115 /* SyntaxKind.WhileKeyword */);
            var openParenPosition = scanner.getTokenPos();
            var openParenParsed = parseExpected(20 /* SyntaxKind.OpenParenToken */);
            var expression = allowInAnd(parseExpression);
            parseExpectedMatchingBrackets(20 /* SyntaxKind.OpenParenToken */, 21 /* SyntaxKind.CloseParenToken */, openParenParsed, openParenPosition);
            // From: https://mail.mozilla.org/pipermail/es-discuss/2011-August/016188.html
            // 157 min --- All allen at wirfs-brock.com CONF --- "do{;}while(false)false" prohibited in
            // spec but allowed in consensus reality. Approved -- this is the de-facto standard whereby
            //  do;while(0)x will have a semicolon inserted before x.
            parseOptional(26 /* SyntaxKind.SemicolonToken */);
            return withJSDoc(finishNode(factory.createDoStatement(statement, expression), pos), hasJSDoc);
        }
        function parseWhileStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(115 /* SyntaxKind.WhileKeyword */);
            var openParenPosition = scanner.getTokenPos();
            var openParenParsed = parseExpected(20 /* SyntaxKind.OpenParenToken */);
            var expression = allowInAnd(parseExpression);
            parseExpectedMatchingBrackets(20 /* SyntaxKind.OpenParenToken */, 21 /* SyntaxKind.CloseParenToken */, openParenParsed, openParenPosition);
            var statement = parseStatement();
            return withJSDoc(finishNode(factory.createWhileStatement(expression, statement), pos), hasJSDoc);
        }
        function parseForOrForInOrForOfStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(97 /* SyntaxKind.ForKeyword */);
            var awaitToken = parseOptionalToken(132 /* SyntaxKind.AwaitKeyword */);
            parseExpected(20 /* SyntaxKind.OpenParenToken */);
            var initializer;
            if (token() !== 26 /* SyntaxKind.SemicolonToken */) {
                if (token() === 113 /* SyntaxKind.VarKeyword */ || token() === 119 /* SyntaxKind.LetKeyword */ || token() === 85 /* SyntaxKind.ConstKeyword */) {
                    initializer = parseVariableDeclarationList(/*inForStatementInitializer*/ true);
                }
                else {
                    initializer = disallowInAnd(parseExpression);
                }
            }
            var node;
            if (awaitToken ? parseExpected(160 /* SyntaxKind.OfKeyword */) : parseOptional(160 /* SyntaxKind.OfKeyword */)) {
                var expression = allowInAnd(function () { return parseAssignmentExpressionOrHigher(/*allowReturnTypeInArrowFunction*/ true); });
                parseExpected(21 /* SyntaxKind.CloseParenToken */);
                node = factory.createForOfStatement(awaitToken, initializer, expression, parseStatement());
            }
            else if (parseOptional(101 /* SyntaxKind.InKeyword */)) {
                var expression = allowInAnd(parseExpression);
                parseExpected(21 /* SyntaxKind.CloseParenToken */);
                node = factory.createForInStatement(initializer, expression, parseStatement());
            }
            else {
                parseExpected(26 /* SyntaxKind.SemicolonToken */);
                var condition = token() !== 26 /* SyntaxKind.SemicolonToken */ && token() !== 21 /* SyntaxKind.CloseParenToken */
                    ? allowInAnd(parseExpression)
                    : undefined;
                parseExpected(26 /* SyntaxKind.SemicolonToken */);
                var incrementor = token() !== 21 /* SyntaxKind.CloseParenToken */
                    ? allowInAnd(parseExpression)
                    : undefined;
                parseExpected(21 /* SyntaxKind.CloseParenToken */);
                node = factory.createForStatement(initializer, condition, incrementor, parseStatement());
            }
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseBreakOrContinueStatement(kind) {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(kind === 246 /* SyntaxKind.BreakStatement */ ? 81 /* SyntaxKind.BreakKeyword */ : 86 /* SyntaxKind.ContinueKeyword */);
            var label = canParseSemicolon() ? undefined : parseIdentifier();
            parseSemicolon();
            var node = kind === 246 /* SyntaxKind.BreakStatement */
                ? factory.createBreakStatement(label)
                : factory.createContinueStatement(label);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseReturnStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(105 /* SyntaxKind.ReturnKeyword */);
            var expression = canParseSemicolon() ? undefined : allowInAnd(parseExpression);
            parseSemicolon();
            return withJSDoc(finishNode(factory.createReturnStatement(expression), pos), hasJSDoc);
        }
        function parseWithStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(116 /* SyntaxKind.WithKeyword */);
            var openParenPosition = scanner.getTokenPos();
            var openParenParsed = parseExpected(20 /* SyntaxKind.OpenParenToken */);
            var expression = allowInAnd(parseExpression);
            parseExpectedMatchingBrackets(20 /* SyntaxKind.OpenParenToken */, 21 /* SyntaxKind.CloseParenToken */, openParenParsed, openParenPosition);
            var statement = doInsideOfContext(33554432 /* NodeFlags.InWithStatement */, parseStatement);
            return withJSDoc(finishNode(factory.createWithStatement(expression, statement), pos), hasJSDoc);
        }
        function parseCaseClause() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(82 /* SyntaxKind.CaseKeyword */);
            var expression = allowInAnd(parseExpression);
            parseExpected(58 /* SyntaxKind.ColonToken */);
            var statements = parseList(3 /* ParsingContext.SwitchClauseStatements */, parseStatement);
            return withJSDoc(finishNode(factory.createCaseClause(expression, statements), pos), hasJSDoc);
        }
        function parseDefaultClause() {
            var pos = getNodePos();
            parseExpected(88 /* SyntaxKind.DefaultKeyword */);
            parseExpected(58 /* SyntaxKind.ColonToken */);
            var statements = parseList(3 /* ParsingContext.SwitchClauseStatements */, parseStatement);
            return finishNode(factory.createDefaultClause(statements), pos);
        }
        function parseCaseOrDefaultClause() {
            return token() === 82 /* SyntaxKind.CaseKeyword */ ? parseCaseClause() : parseDefaultClause();
        }
        function parseCaseBlock() {
            var pos = getNodePos();
            parseExpected(18 /* SyntaxKind.OpenBraceToken */);
            var clauses = parseList(2 /* ParsingContext.SwitchClauses */, parseCaseOrDefaultClause);
            parseExpected(19 /* SyntaxKind.CloseBraceToken */);
            return finishNode(factory.createCaseBlock(clauses), pos);
        }
        function parseSwitchStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(107 /* SyntaxKind.SwitchKeyword */);
            parseExpected(20 /* SyntaxKind.OpenParenToken */);
            var expression = allowInAnd(parseExpression);
            parseExpected(21 /* SyntaxKind.CloseParenToken */);
            var caseBlock = parseCaseBlock();
            return withJSDoc(finishNode(factory.createSwitchStatement(expression, caseBlock), pos), hasJSDoc);
        }
        function parseThrowStatement() {
            // ThrowStatement[Yield] :
            //      throw [no LineTerminator here]Expression[In, ?Yield];
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(109 /* SyntaxKind.ThrowKeyword */);
            // Because of automatic semicolon insertion, we need to report error if this
            // throw could be terminated with a semicolon.  Note: we can't call 'parseExpression'
            // directly as that might consume an expression on the following line.
            // Instead, we create a "missing" identifier, but don't report an error. The actual error
            // will be reported in the grammar walker.
            var expression = scanner.hasPrecedingLineBreak() ? undefined : allowInAnd(parseExpression);
            if (expression === undefined) {
                identifierCount++;
                expression = finishNode(factory.createIdentifier(""), getNodePos());
            }
            if (!tryParseSemicolon()) {
                parseErrorForMissingSemicolonAfter(expression);
            }
            return withJSDoc(finishNode(factory.createThrowStatement(expression), pos), hasJSDoc);
        }
        // TODO: Review for error recovery
        function parseTryStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(111 /* SyntaxKind.TryKeyword */);
            var tryBlock = parseBlock(/*ignoreMissingOpenBrace*/ false);
            var catchClause = token() === 83 /* SyntaxKind.CatchKeyword */ ? parseCatchClause() : undefined;
            // If we don't have a catch clause, then we must have a finally clause.  Try to parse
            // one out no matter what.
            var finallyBlock;
            if (!catchClause || token() === 96 /* SyntaxKind.FinallyKeyword */) {
                parseExpected(96 /* SyntaxKind.FinallyKeyword */, ts.Diagnostics.catch_or_finally_expected);
                finallyBlock = parseBlock(/*ignoreMissingOpenBrace*/ false);
            }
            return withJSDoc(finishNode(factory.createTryStatement(tryBlock, catchClause, finallyBlock), pos), hasJSDoc);
        }
        function parseCatchClause() {
            var pos = getNodePos();
            parseExpected(83 /* SyntaxKind.CatchKeyword */);
            var variableDeclaration;
            if (parseOptional(20 /* SyntaxKind.OpenParenToken */)) {
                variableDeclaration = parseVariableDeclaration();
                parseExpected(21 /* SyntaxKind.CloseParenToken */);
            }
            else {
                // Keep shape of node to avoid degrading performance.
                variableDeclaration = undefined;
            }
            var block = parseBlock(/*ignoreMissingOpenBrace*/ false);
            return finishNode(factory.createCatchClause(variableDeclaration, block), pos);
        }
        function parseDebuggerStatement() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            parseExpected(87 /* SyntaxKind.DebuggerKeyword */);
            parseSemicolon();
            return withJSDoc(finishNode(factory.createDebuggerStatement(), pos), hasJSDoc);
        }
        function parseExpressionOrLabeledStatement() {
            // Avoiding having to do the lookahead for a labeled statement by just trying to parse
            // out an expression, seeing if it is identifier and then seeing if it is followed by
            // a colon.
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var node;
            var hasParen = token() === 20 /* SyntaxKind.OpenParenToken */;
            var expression = allowInAnd(parseExpression);
            if (ts.isIdentifier(expression) && parseOptional(58 /* SyntaxKind.ColonToken */)) {
                node = factory.createLabeledStatement(expression, parseStatement());
            }
            else {
                if (!tryParseSemicolon()) {
                    parseErrorForMissingSemicolonAfter(expression);
                }
                node = factory.createExpressionStatement(expression);
                if (hasParen) {
                    // do not parse the same jsdoc twice
                    hasJSDoc = false;
                }
            }
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function nextTokenIsIdentifierOrKeywordOnSameLine() {
            nextToken();
            return ts.tokenIsIdentifierOrKeyword(token()) && !scanner.hasPrecedingLineBreak();
        }
        function nextTokenIsClassKeywordOnSameLine() {
            nextToken();
            return token() === 84 /* SyntaxKind.ClassKeyword */ && !scanner.hasPrecedingLineBreak();
        }
        function nextTokenIsFunctionKeywordOnSameLine() {
            nextToken();
            return token() === 98 /* SyntaxKind.FunctionKeyword */ && !scanner.hasPrecedingLineBreak();
        }
        function nextTokenIsIdentifierOrKeywordOrLiteralOnSameLine() {
            nextToken();
            return (ts.tokenIsIdentifierOrKeyword(token()) || token() === 8 /* SyntaxKind.NumericLiteral */ || token() === 9 /* SyntaxKind.BigIntLiteral */ || token() === 10 /* SyntaxKind.StringLiteral */) && !scanner.hasPrecedingLineBreak();
        }
        function isDeclaration() {
            while (true) {
                switch (token()) {
                    case 113 /* SyntaxKind.VarKeyword */:
                    case 119 /* SyntaxKind.LetKeyword */:
                    case 85 /* SyntaxKind.ConstKeyword */:
                    case 98 /* SyntaxKind.FunctionKeyword */:
                    case 84 /* SyntaxKind.ClassKeyword */:
                    case 92 /* SyntaxKind.EnumKeyword */:
                        return true;
                    // 'declare', 'module', 'namespace', 'interface'* and 'type' are all legal JavaScript identifiers;
                    // however, an identifier cannot be followed by another identifier on the same line. This is what we
                    // count on to parse out the respective declarations. For instance, we exploit this to say that
                    //
                    //    namespace n
                    //
                    // can be none other than the beginning of a namespace declaration, but need to respect that JavaScript sees
                    //
                    //    namespace
                    //    n
                    //
                    // as the identifier 'namespace' on one line followed by the identifier 'n' on another.
                    // We need to look one token ahead to see if it permissible to try parsing a declaration.
                    //
                    // *Note*: 'interface' is actually a strict mode reserved word. So while
                    //
                    //   "use strict"
                    //   interface
                    //   I {}
                    //
                    // could be legal, it would add complexity for very little gain.
                    case 118 /* SyntaxKind.InterfaceKeyword */:
                    case 152 /* SyntaxKind.TypeKeyword */:
                        return nextTokenIsIdentifierOnSameLine();
                    case 141 /* SyntaxKind.ModuleKeyword */:
                    case 142 /* SyntaxKind.NamespaceKeyword */:
                        return nextTokenIsIdentifierOrStringLiteralOnSameLine();
                    case 126 /* SyntaxKind.AbstractKeyword */:
                    case 131 /* SyntaxKind.AsyncKeyword */:
                    case 135 /* SyntaxKind.DeclareKeyword */:
                    case 121 /* SyntaxKind.PrivateKeyword */:
                    case 122 /* SyntaxKind.ProtectedKeyword */:
                    case 123 /* SyntaxKind.PublicKeyword */:
                    case 145 /* SyntaxKind.ReadonlyKeyword */:
                        nextToken();
                        // ASI takes effect for this modifier.
                        if (scanner.hasPrecedingLineBreak()) {
                            return false;
                        }
                        continue;
                    case 157 /* SyntaxKind.GlobalKeyword */:
                        nextToken();
                        return token() === 18 /* SyntaxKind.OpenBraceToken */ || token() === 79 /* SyntaxKind.Identifier */ || token() === 93 /* SyntaxKind.ExportKeyword */;
                    case 100 /* SyntaxKind.ImportKeyword */:
                        nextToken();
                        return token() === 10 /* SyntaxKind.StringLiteral */ || token() === 41 /* SyntaxKind.AsteriskToken */ ||
                            token() === 18 /* SyntaxKind.OpenBraceToken */ || ts.tokenIsIdentifierOrKeyword(token());
                    case 93 /* SyntaxKind.ExportKeyword */:
                        var currentToken_1 = nextToken();
                        if (currentToken_1 === 152 /* SyntaxKind.TypeKeyword */) {
                            currentToken_1 = lookAhead(nextToken);
                        }
                        if (currentToken_1 === 63 /* SyntaxKind.EqualsToken */ || currentToken_1 === 41 /* SyntaxKind.AsteriskToken */ ||
                            currentToken_1 === 18 /* SyntaxKind.OpenBraceToken */ || currentToken_1 === 88 /* SyntaxKind.DefaultKeyword */ ||
                            currentToken_1 === 127 /* SyntaxKind.AsKeyword */) {
                            return true;
                        }
                        continue;
                    case 124 /* SyntaxKind.StaticKeyword */:
                        nextToken();
                        continue;
                    default:
                        return false;
                }
            }
        }
        function isStartOfDeclaration() {
            return lookAhead(isDeclaration);
        }
        function isStartOfStatement() {
            switch (token()) {
                case 59 /* SyntaxKind.AtToken */:
                case 26 /* SyntaxKind.SemicolonToken */:
                case 18 /* SyntaxKind.OpenBraceToken */:
                case 113 /* SyntaxKind.VarKeyword */:
                case 119 /* SyntaxKind.LetKeyword */:
                case 98 /* SyntaxKind.FunctionKeyword */:
                case 84 /* SyntaxKind.ClassKeyword */:
                case 92 /* SyntaxKind.EnumKeyword */:
                case 99 /* SyntaxKind.IfKeyword */:
                case 90 /* SyntaxKind.DoKeyword */:
                case 115 /* SyntaxKind.WhileKeyword */:
                case 97 /* SyntaxKind.ForKeyword */:
                case 86 /* SyntaxKind.ContinueKeyword */:
                case 81 /* SyntaxKind.BreakKeyword */:
                case 105 /* SyntaxKind.ReturnKeyword */:
                case 116 /* SyntaxKind.WithKeyword */:
                case 107 /* SyntaxKind.SwitchKeyword */:
                case 109 /* SyntaxKind.ThrowKeyword */:
                case 111 /* SyntaxKind.TryKeyword */:
                case 87 /* SyntaxKind.DebuggerKeyword */:
                // 'catch' and 'finally' do not actually indicate that the code is part of a statement,
                // however, we say they are here so that we may gracefully parse them and error later.
                // falls through
                case 83 /* SyntaxKind.CatchKeyword */:
                case 96 /* SyntaxKind.FinallyKeyword */:
                    return true;
                case 100 /* SyntaxKind.ImportKeyword */:
                    return isStartOfDeclaration() || lookAhead(nextTokenIsOpenParenOrLessThanOrDot);
                case 85 /* SyntaxKind.ConstKeyword */:
                case 93 /* SyntaxKind.ExportKeyword */:
                    return isStartOfDeclaration();
                case 131 /* SyntaxKind.AsyncKeyword */:
                case 135 /* SyntaxKind.DeclareKeyword */:
                case 118 /* SyntaxKind.InterfaceKeyword */:
                case 141 /* SyntaxKind.ModuleKeyword */:
                case 142 /* SyntaxKind.NamespaceKeyword */:
                case 152 /* SyntaxKind.TypeKeyword */:
                case 157 /* SyntaxKind.GlobalKeyword */:
                    // When these don't start a declaration, they're an identifier in an expression statement
                    return true;
                case 123 /* SyntaxKind.PublicKeyword */:
                case 121 /* SyntaxKind.PrivateKeyword */:
                case 122 /* SyntaxKind.ProtectedKeyword */:
                case 124 /* SyntaxKind.StaticKeyword */:
                case 145 /* SyntaxKind.ReadonlyKeyword */:
                    // When these don't start a declaration, they may be the start of a class member if an identifier
                    // immediately follows. Otherwise they're an identifier in an expression statement.
                    return isStartOfDeclaration() || !lookAhead(nextTokenIsIdentifierOrKeywordOnSameLine);
                default:
                    return isStartOfExpression();
            }
        }
        function nextTokenIsBindingIdentifierOrStartOfDestructuring() {
            nextToken();
            return isBindingIdentifier() || token() === 18 /* SyntaxKind.OpenBraceToken */ || token() === 22 /* SyntaxKind.OpenBracketToken */;
        }
        function isLetDeclaration() {
            // In ES6 'let' always starts a lexical declaration if followed by an identifier or {
            // or [.
            return lookAhead(nextTokenIsBindingIdentifierOrStartOfDestructuring);
        }
        function parseStatement() {
            switch (token()) {
                case 26 /* SyntaxKind.SemicolonToken */:
                    return parseEmptyStatement();
                case 18 /* SyntaxKind.OpenBraceToken */:
                    return parseBlock(/*ignoreMissingOpenBrace*/ false);
                case 113 /* SyntaxKind.VarKeyword */:
                    return parseVariableStatement(getNodePos(), hasPrecedingJSDocComment(), /*decorators*/ undefined, /*modifiers*/ undefined);
                case 119 /* SyntaxKind.LetKeyword */:
                    if (isLetDeclaration()) {
                        return parseVariableStatement(getNodePos(), hasPrecedingJSDocComment(), /*decorators*/ undefined, /*modifiers*/ undefined);
                    }
                    break;
                case 98 /* SyntaxKind.FunctionKeyword */:
                    return parseFunctionDeclaration(getNodePos(), hasPrecedingJSDocComment(), /*decorators*/ undefined, /*modifiers*/ undefined);
                case 84 /* SyntaxKind.ClassKeyword */:
                    return parseClassDeclaration(getNodePos(), hasPrecedingJSDocComment(), /*decorators*/ undefined, /*modifiers*/ undefined);
                case 99 /* SyntaxKind.IfKeyword */:
                    return parseIfStatement();
                case 90 /* SyntaxKind.DoKeyword */:
                    return parseDoStatement();
                case 115 /* SyntaxKind.WhileKeyword */:
                    return parseWhileStatement();
                case 97 /* SyntaxKind.ForKeyword */:
                    return parseForOrForInOrForOfStatement();
                case 86 /* SyntaxKind.ContinueKeyword */:
                    return parseBreakOrContinueStatement(245 /* SyntaxKind.ContinueStatement */);
                case 81 /* SyntaxKind.BreakKeyword */:
                    return parseBreakOrContinueStatement(246 /* SyntaxKind.BreakStatement */);
                case 105 /* SyntaxKind.ReturnKeyword */:
                    return parseReturnStatement();
                case 116 /* SyntaxKind.WithKeyword */:
                    return parseWithStatement();
                case 107 /* SyntaxKind.SwitchKeyword */:
                    return parseSwitchStatement();
                case 109 /* SyntaxKind.ThrowKeyword */:
                    return parseThrowStatement();
                case 111 /* SyntaxKind.TryKeyword */:
                // Include 'catch' and 'finally' for error recovery.
                // falls through
                case 83 /* SyntaxKind.CatchKeyword */:
                case 96 /* SyntaxKind.FinallyKeyword */:
                    return parseTryStatement();
                case 87 /* SyntaxKind.DebuggerKeyword */:
                    return parseDebuggerStatement();
                case 59 /* SyntaxKind.AtToken */:
                    return parseDeclaration();
                case 131 /* SyntaxKind.AsyncKeyword */:
                case 118 /* SyntaxKind.InterfaceKeyword */:
                case 152 /* SyntaxKind.TypeKeyword */:
                case 141 /* SyntaxKind.ModuleKeyword */:
                case 142 /* SyntaxKind.NamespaceKeyword */:
                case 135 /* SyntaxKind.DeclareKeyword */:
                case 85 /* SyntaxKind.ConstKeyword */:
                case 92 /* SyntaxKind.EnumKeyword */:
                case 93 /* SyntaxKind.ExportKeyword */:
                case 100 /* SyntaxKind.ImportKeyword */:
                case 121 /* SyntaxKind.PrivateKeyword */:
                case 122 /* SyntaxKind.ProtectedKeyword */:
                case 123 /* SyntaxKind.PublicKeyword */:
                case 126 /* SyntaxKind.AbstractKeyword */:
                case 124 /* SyntaxKind.StaticKeyword */:
                case 145 /* SyntaxKind.ReadonlyKeyword */:
                case 157 /* SyntaxKind.GlobalKeyword */:
                    if (isStartOfDeclaration()) {
                        return parseDeclaration();
                    }
                    break;
            }
            return parseExpressionOrLabeledStatement();
        }
        function isDeclareModifier(modifier) {
            return modifier.kind === 135 /* SyntaxKind.DeclareKeyword */;
        }
        function parseDeclaration() {
            // `parseListElement` attempted to get the reused node at this position,
            // but the ambient context flag was not yet set, so the node appeared
            // not reusable in that context.
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var decorators = parseDecorators();
            var modifiers = parseModifiers();
            var isAmbient = ts.some(modifiers, isDeclareModifier);
            if (isAmbient) {
                var node = tryReuseAmbientDeclaration(pos);
                if (node) {
                    return node;
                }
                for (var _i = 0, _a = modifiers; _i < _a.length; _i++) {
                    var m = _a[_i];
                    m.flags |= 16777216 /* NodeFlags.Ambient */;
                }
                return doInsideOfContext(16777216 /* NodeFlags.Ambient */, function () { return parseDeclarationWorker(pos, hasJSDoc, decorators, modifiers); });
            }
            else {
                return parseDeclarationWorker(pos, hasJSDoc, decorators, modifiers);
            }
        }
        function tryReuseAmbientDeclaration(pos) {
            return doInsideOfContext(16777216 /* NodeFlags.Ambient */, function () {
                var node = currentNode(parsingContext, pos);
                if (node) {
                    return consumeNode(node);
                }
            });
        }
        function parseDeclarationWorker(pos, hasJSDoc, decorators, modifiers) {
            switch (token()) {
                case 113 /* SyntaxKind.VarKeyword */:
                case 119 /* SyntaxKind.LetKeyword */:
                case 85 /* SyntaxKind.ConstKeyword */:
                    return parseVariableStatement(pos, hasJSDoc, decorators, modifiers);
                case 98 /* SyntaxKind.FunctionKeyword */:
                    return parseFunctionDeclaration(pos, hasJSDoc, decorators, modifiers);
                case 84 /* SyntaxKind.ClassKeyword */:
                    return parseClassDeclaration(pos, hasJSDoc, decorators, modifiers);
                case 118 /* SyntaxKind.InterfaceKeyword */:
                    return parseInterfaceDeclaration(pos, hasJSDoc, decorators, modifiers);
                case 152 /* SyntaxKind.TypeKeyword */:
                    return parseTypeAliasDeclaration(pos, hasJSDoc, decorators, modifiers);
                case 92 /* SyntaxKind.EnumKeyword */:
                    return parseEnumDeclaration(pos, hasJSDoc, decorators, modifiers);
                case 157 /* SyntaxKind.GlobalKeyword */:
                case 141 /* SyntaxKind.ModuleKeyword */:
                case 142 /* SyntaxKind.NamespaceKeyword */:
                    return parseModuleDeclaration(pos, hasJSDoc, decorators, modifiers);
                case 100 /* SyntaxKind.ImportKeyword */:
                    return parseImportDeclarationOrImportEqualsDeclaration(pos, hasJSDoc, decorators, modifiers);
                case 93 /* SyntaxKind.ExportKeyword */:
                    nextToken();
                    switch (token()) {
                        case 88 /* SyntaxKind.DefaultKeyword */:
                        case 63 /* SyntaxKind.EqualsToken */:
                            return parseExportAssignment(pos, hasJSDoc, decorators, modifiers);
                        case 127 /* SyntaxKind.AsKeyword */:
                            return parseNamespaceExportDeclaration(pos, hasJSDoc, decorators, modifiers);
                        default:
                            return parseExportDeclaration(pos, hasJSDoc, decorators, modifiers);
                    }
                default:
                    if (decorators || modifiers) {
                        // We reached this point because we encountered decorators and/or modifiers and assumed a declaration
                        // would follow. For recovery and error reporting purposes, return an incomplete declaration.
                        var missing = createMissingNode(276 /* SyntaxKind.MissingDeclaration */, /*reportAtCurrentPosition*/ true, ts.Diagnostics.Declaration_expected);
                        ts.setTextRangePos(missing, pos);
                        missing.illegalDecorators = decorators;
                        missing.modifiers = modifiers;
                        return missing;
                    }
                    return undefined; // TODO: GH#18217
            }
        }
        function nextTokenIsIdentifierOrStringLiteralOnSameLine() {
            nextToken();
            return !scanner.hasPrecedingLineBreak() && (isIdentifier() || token() === 10 /* SyntaxKind.StringLiteral */);
        }
        function parseFunctionBlockOrSemicolon(flags, diagnosticMessage) {
            if (token() !== 18 /* SyntaxKind.OpenBraceToken */) {
                if (flags & 4 /* SignatureFlags.Type */) {
                    parseTypeMemberSemicolon();
                    return;
                }
                if (canParseSemicolon()) {
                    parseSemicolon();
                    return;
                }
            }
            return parseFunctionBlock(flags, diagnosticMessage);
        }
        // DECLARATIONS
        function parseArrayBindingElement() {
            var pos = getNodePos();
            if (token() === 27 /* SyntaxKind.CommaToken */) {
                return finishNode(factory.createOmittedExpression(), pos);
            }
            var dotDotDotToken = parseOptionalToken(25 /* SyntaxKind.DotDotDotToken */);
            var name = parseIdentifierOrPattern();
            var initializer = parseInitializer();
            return finishNode(factory.createBindingElement(dotDotDotToken, /*propertyName*/ undefined, name, initializer), pos);
        }
        function parseObjectBindingElement() {
            var pos = getNodePos();
            var dotDotDotToken = parseOptionalToken(25 /* SyntaxKind.DotDotDotToken */);
            var tokenIsIdentifier = isBindingIdentifier();
            var propertyName = parsePropertyName();
            var name;
            if (tokenIsIdentifier && token() !== 58 /* SyntaxKind.ColonToken */) {
                name = propertyName;
                propertyName = undefined;
            }
            else {
                parseExpected(58 /* SyntaxKind.ColonToken */);
                name = parseIdentifierOrPattern();
            }
            var initializer = parseInitializer();
            return finishNode(factory.createBindingElement(dotDotDotToken, propertyName, name, initializer), pos);
        }
        function parseObjectBindingPattern() {
            var pos = getNodePos();
            parseExpected(18 /* SyntaxKind.OpenBraceToken */);
            var elements = parseDelimitedList(9 /* ParsingContext.ObjectBindingElements */, parseObjectBindingElement);
            parseExpected(19 /* SyntaxKind.CloseBraceToken */);
            return finishNode(factory.createObjectBindingPattern(elements), pos);
        }
        function parseArrayBindingPattern() {
            var pos = getNodePos();
            parseExpected(22 /* SyntaxKind.OpenBracketToken */);
            var elements = parseDelimitedList(10 /* ParsingContext.ArrayBindingElements */, parseArrayBindingElement);
            parseExpected(23 /* SyntaxKind.CloseBracketToken */);
            return finishNode(factory.createArrayBindingPattern(elements), pos);
        }
        function isBindingIdentifierOrPrivateIdentifierOrPattern() {
            return token() === 18 /* SyntaxKind.OpenBraceToken */
                || token() === 22 /* SyntaxKind.OpenBracketToken */
                || token() === 80 /* SyntaxKind.PrivateIdentifier */
                || isBindingIdentifier();
        }
        function parseIdentifierOrPattern(privateIdentifierDiagnosticMessage) {
            if (token() === 22 /* SyntaxKind.OpenBracketToken */) {
                return parseArrayBindingPattern();
            }
            if (token() === 18 /* SyntaxKind.OpenBraceToken */) {
                return parseObjectBindingPattern();
            }
            return parseBindingIdentifier(privateIdentifierDiagnosticMessage);
        }
        function parseVariableDeclarationAllowExclamation() {
            return parseVariableDeclaration(/*allowExclamation*/ true);
        }
        function parseVariableDeclaration(allowExclamation) {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var name = parseIdentifierOrPattern(ts.Diagnostics.Private_identifiers_are_not_allowed_in_variable_declarations);
            var exclamationToken;
            if (allowExclamation && name.kind === 79 /* SyntaxKind.Identifier */ &&
                token() === 53 /* SyntaxKind.ExclamationToken */ && !scanner.hasPrecedingLineBreak()) {
                exclamationToken = parseTokenNode();
            }
            var type = parseTypeAnnotation();
            var initializer = isInOrOfKeyword(token()) ? undefined : parseInitializer();
            var node = factory.createVariableDeclaration(name, exclamationToken, type, initializer);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseVariableDeclarationList(inForStatementInitializer) {
            var pos = getNodePos();
            var flags = 0;
            switch (token()) {
                case 113 /* SyntaxKind.VarKeyword */:
                    break;
                case 119 /* SyntaxKind.LetKeyword */:
                    flags |= 1 /* NodeFlags.Let */;
                    break;
                case 85 /* SyntaxKind.ConstKeyword */:
                    flags |= 2 /* NodeFlags.Const */;
                    break;
                default:
                    ts.Debug.fail();
            }
            nextToken();
            // The user may have written the following:
            //
            //    for (let of X) { }
            //
            // In this case, we want to parse an empty declaration list, and then parse 'of'
            // as a keyword. The reason this is not automatic is that 'of' is a valid identifier.
            // So we need to look ahead to determine if 'of' should be treated as a keyword in
            // this context.
            // The checker will then give an error that there is an empty declaration list.
            var declarations;
            if (token() === 160 /* SyntaxKind.OfKeyword */ && lookAhead(canFollowContextualOfKeyword)) {
                declarations = createMissingList();
            }
            else {
                var savedDisallowIn = inDisallowInContext();
                setDisallowInContext(inForStatementInitializer);
                declarations = parseDelimitedList(8 /* ParsingContext.VariableDeclarations */, inForStatementInitializer ? parseVariableDeclaration : parseVariableDeclarationAllowExclamation);
                setDisallowInContext(savedDisallowIn);
            }
            return finishNode(factory.createVariableDeclarationList(declarations, flags), pos);
        }
        function canFollowContextualOfKeyword() {
            return nextTokenIsIdentifier() && nextToken() === 21 /* SyntaxKind.CloseParenToken */;
        }
        function parseVariableStatement(pos, hasJSDoc, decorators, modifiers) {
            var declarationList = parseVariableDeclarationList(/*inForStatementInitializer*/ false);
            parseSemicolon();
            var node = factory.createVariableStatement(modifiers, declarationList);
            // Decorators are not allowed on a variable statement, so we keep track of them to report them in the grammar checker.
            node.illegalDecorators = decorators;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseFunctionDeclaration(pos, hasJSDoc, decorators, modifiers) {
            var savedAwaitContext = inAwaitContext();
            var modifierFlags = ts.modifiersToFlags(modifiers);
            parseExpected(98 /* SyntaxKind.FunctionKeyword */);
            var asteriskToken = parseOptionalToken(41 /* SyntaxKind.AsteriskToken */);
            // We don't parse the name here in await context, instead we will report a grammar error in the checker.
            var name = modifierFlags & 512 /* ModifierFlags.Default */ ? parseOptionalBindingIdentifier() : parseBindingIdentifier();
            var isGenerator = asteriskToken ? 1 /* SignatureFlags.Yield */ : 0 /* SignatureFlags.None */;
            var isAsync = modifierFlags & 256 /* ModifierFlags.Async */ ? 2 /* SignatureFlags.Await */ : 0 /* SignatureFlags.None */;
            var typeParameters = parseTypeParameters();
            if (modifierFlags & 1 /* ModifierFlags.Export */)
                setAwaitContext(/*value*/ true);
            var parameters = parseParameters(isGenerator | isAsync);
            var type = parseReturnType(58 /* SyntaxKind.ColonToken */, /*isType*/ false);
            var body = parseFunctionBlockOrSemicolon(isGenerator | isAsync, ts.Diagnostics.or_expected);
            setAwaitContext(savedAwaitContext);
            var node = factory.createFunctionDeclaration(modifiers, asteriskToken, name, typeParameters, parameters, type, body);
            node.illegalDecorators = decorators;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseConstructorName() {
            if (token() === 134 /* SyntaxKind.ConstructorKeyword */) {
                return parseExpected(134 /* SyntaxKind.ConstructorKeyword */);
            }
            if (token() === 10 /* SyntaxKind.StringLiteral */ && lookAhead(nextToken) === 20 /* SyntaxKind.OpenParenToken */) {
                return tryParse(function () {
                    var literalNode = parseLiteralNode();
                    return literalNode.text === "constructor" ? literalNode : undefined;
                });
            }
        }
        function tryParseConstructorDeclaration(pos, hasJSDoc, decorators, modifiers) {
            return tryParse(function () {
                if (parseConstructorName()) {
                    var typeParameters = parseTypeParameters();
                    var parameters = parseParameters(0 /* SignatureFlags.None */);
                    var type = parseReturnType(58 /* SyntaxKind.ColonToken */, /*isType*/ false);
                    var body = parseFunctionBlockOrSemicolon(0 /* SignatureFlags.None */, ts.Diagnostics.or_expected);
                    var node = factory.createConstructorDeclaration(modifiers, parameters, body);
                    // Attach invalid nodes if they exist so that we can report them in the grammar checker.
                    node.illegalDecorators = decorators;
                    node.typeParameters = typeParameters;
                    node.type = type;
                    return withJSDoc(finishNode(node, pos), hasJSDoc);
                }
            });
        }
        function parseMethodDeclaration(pos, hasJSDoc, decorators, modifiers, asteriskToken, name, questionToken, exclamationToken, diagnosticMessage) {
            var isGenerator = asteriskToken ? 1 /* SignatureFlags.Yield */ : 0 /* SignatureFlags.None */;
            var isAsync = ts.some(modifiers, ts.isAsyncModifier) ? 2 /* SignatureFlags.Await */ : 0 /* SignatureFlags.None */;
            var typeParameters = parseTypeParameters();
            var parameters = parseParameters(isGenerator | isAsync);
            var type = parseReturnType(58 /* SyntaxKind.ColonToken */, /*isType*/ false);
            var body = parseFunctionBlockOrSemicolon(isGenerator | isAsync, diagnosticMessage);
            var node = factory.createMethodDeclaration(combineDecoratorsAndModifiers(decorators, modifiers), asteriskToken, name, questionToken, typeParameters, parameters, type, body);
            // An exclamation token on a method is invalid syntax and will be handled by the grammar checker
            node.exclamationToken = exclamationToken;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parsePropertyDeclaration(pos, hasJSDoc, decorators, modifiers, name, questionToken) {
            var exclamationToken = !questionToken && !scanner.hasPrecedingLineBreak() ? parseOptionalToken(53 /* SyntaxKind.ExclamationToken */) : undefined;
            var type = parseTypeAnnotation();
            var initializer = doOutsideOfContext(8192 /* NodeFlags.YieldContext */ | 32768 /* NodeFlags.AwaitContext */ | 4096 /* NodeFlags.DisallowInContext */, parseInitializer);
            parseSemicolonAfterPropertyName(name, type, initializer);
            var node = factory.createPropertyDeclaration(combineDecoratorsAndModifiers(decorators, modifiers), name, questionToken || exclamationToken, type, initializer);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parsePropertyOrMethodDeclaration(pos, hasJSDoc, decorators, modifiers) {
            var asteriskToken = parseOptionalToken(41 /* SyntaxKind.AsteriskToken */);
            var name = parsePropertyName();
            // Note: this is not legal as per the grammar.  But we allow it in the parser and
            // report an error in the grammar checker.
            var questionToken = parseOptionalToken(57 /* SyntaxKind.QuestionToken */);
            if (asteriskToken || token() === 20 /* SyntaxKind.OpenParenToken */ || token() === 29 /* SyntaxKind.LessThanToken */) {
                return parseMethodDeclaration(pos, hasJSDoc, decorators, modifiers, asteriskToken, name, questionToken, /*exclamationToken*/ undefined, ts.Diagnostics.or_expected);
            }
            return parsePropertyDeclaration(pos, hasJSDoc, decorators, modifiers, name, questionToken);
        }
        function parseAccessorDeclaration(pos, hasJSDoc, decorators, modifiers, kind, flags) {
            var name = parsePropertyName();
            var typeParameters = parseTypeParameters();
            var parameters = parseParameters(0 /* SignatureFlags.None */);
            var type = parseReturnType(58 /* SyntaxKind.ColonToken */, /*isType*/ false);
            var body = parseFunctionBlockOrSemicolon(flags);
            var node = kind === 172 /* SyntaxKind.GetAccessor */
                ? factory.createGetAccessorDeclaration(combineDecoratorsAndModifiers(decorators, modifiers), name, parameters, type, body)
                : factory.createSetAccessorDeclaration(combineDecoratorsAndModifiers(decorators, modifiers), name, parameters, body);
            // Keep track of `typeParameters` (for both) and `type` (for setters) if they were parsed those indicate grammar errors
            node.typeParameters = typeParameters;
            if (ts.isSetAccessorDeclaration(node))
                node.type = type;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function isClassMemberStart() {
            var idToken;
            if (token() === 59 /* SyntaxKind.AtToken */) {
                return true;
            }
            // Eat up all modifiers, but hold on to the last one in case it is actually an identifier.
            while (ts.isModifierKind(token())) {
                idToken = token();
                // If the idToken is a class modifier (protected, private, public, and static), it is
                // certain that we are starting to parse class member. This allows better error recovery
                // Example:
                //      public foo() ...     // true
                //      public @dec blah ... // true; we will then report an error later
                //      export public ...    // true; we will then report an error later
                if (ts.isClassMemberModifier(idToken)) {
                    return true;
                }
                nextToken();
            }
            if (token() === 41 /* SyntaxKind.AsteriskToken */) {
                return true;
            }
            // Try to get the first property-like token following all modifiers.
            // This can either be an identifier or the 'get' or 'set' keywords.
            if (isLiteralPropertyName()) {
                idToken = token();
                nextToken();
            }
            // Index signatures and computed properties are class members; we can parse.
            if (token() === 22 /* SyntaxKind.OpenBracketToken */) {
                return true;
            }
            // If we were able to get any potential identifier...
            if (idToken !== undefined) {
                // If we have a non-keyword identifier, or if we have an accessor, then it's safe to parse.
                if (!ts.isKeyword(idToken) || idToken === 149 /* SyntaxKind.SetKeyword */ || idToken === 136 /* SyntaxKind.GetKeyword */) {
                    return true;
                }
                // If it *is* a keyword, but not an accessor, check a little farther along
                // to see if it should actually be parsed as a class member.
                switch (token()) {
                    case 20 /* SyntaxKind.OpenParenToken */: // Method declaration
                    case 29 /* SyntaxKind.LessThanToken */: // Generic Method declaration
                    case 53 /* SyntaxKind.ExclamationToken */: // Non-null assertion on property name
                    case 58 /* SyntaxKind.ColonToken */: // Type Annotation for declaration
                    case 63 /* SyntaxKind.EqualsToken */: // Initializer for declaration
                    case 57 /* SyntaxKind.QuestionToken */: // Not valid, but permitted so that it gets caught later on.
                        return true;
                    default:
                        // Covers
                        //  - Semicolons     (declaration termination)
                        //  - Closing braces (end-of-class, must be declaration)
                        //  - End-of-files   (not valid, but permitted so that it gets caught later on)
                        //  - Line-breaks    (enabling *automatic semicolon insertion*)
                        return canParseSemicolon();
                }
            }
            return false;
        }
        function parseClassStaticBlockDeclaration(pos, hasJSDoc, decorators, modifiers) {
            parseExpectedToken(124 /* SyntaxKind.StaticKeyword */);
            var body = parseClassStaticBlockBody();
            var node = withJSDoc(finishNode(factory.createClassStaticBlockDeclaration(body), pos), hasJSDoc);
            node.illegalDecorators = decorators;
            node.modifiers = modifiers;
            return node;
        }
        function parseClassStaticBlockBody() {
            var savedYieldContext = inYieldContext();
            var savedAwaitContext = inAwaitContext();
            setYieldContext(false);
            setAwaitContext(true);
            var body = parseBlock(/*ignoreMissingOpenBrace*/ false);
            setYieldContext(savedYieldContext);
            setAwaitContext(savedAwaitContext);
            return body;
        }
        function parseDecoratorExpression() {
            if (inAwaitContext() && token() === 132 /* SyntaxKind.AwaitKeyword */) {
                // `@await` is is disallowed in an [Await] context, but can cause parsing to go off the rails
                // This simply parses the missing identifier and moves on.
                var pos = getNodePos();
                var awaitExpression = parseIdentifier(ts.Diagnostics.Expression_expected);
                nextToken();
                var memberExpression = parseMemberExpressionRest(pos, awaitExpression, /*allowOptionalChain*/ true);
                return parseCallExpressionRest(pos, memberExpression);
            }
            return parseLeftHandSideExpressionOrHigher();
        }
        function tryParseDecorator() {
            var pos = getNodePos();
            if (!parseOptional(59 /* SyntaxKind.AtToken */)) {
                return undefined;
            }
            var expression = doInDecoratorContext(parseDecoratorExpression);
            return finishNode(factory.createDecorator(expression), pos);
        }
        function parseDecorators() {
            var pos = getNodePos();
            var list, decorator;
            while (decorator = tryParseDecorator()) {
                list = ts.append(list, decorator);
            }
            return list && createNodeArray(list, pos);
        }
        function tryParseModifier(permitInvalidConstAsModifier, stopOnStartOfClassStaticBlock, hasSeenStaticModifier) {
            var pos = getNodePos();
            var kind = token();
            if (token() === 85 /* SyntaxKind.ConstKeyword */ && permitInvalidConstAsModifier) {
                // We need to ensure that any subsequent modifiers appear on the same line
                // so that when 'const' is a standalone declaration, we don't issue an error.
                if (!tryParse(nextTokenIsOnSameLineAndCanFollowModifier)) {
                    return undefined;
                }
            }
            else if (stopOnStartOfClassStaticBlock && token() === 124 /* SyntaxKind.StaticKeyword */ && lookAhead(nextTokenIsOpenBrace)) {
                return undefined;
            }
            else if (hasSeenStaticModifier && token() === 124 /* SyntaxKind.StaticKeyword */) {
                return undefined;
            }
            else {
                if (!parseAnyContextualModifier()) {
                    return undefined;
                }
            }
            return finishNode(factory.createToken(kind), pos);
        }
        function combineDecoratorsAndModifiers(decorators, modifiers) {
            if (!decorators)
                return modifiers;
            if (!modifiers)
                return decorators;
            var decoratorsAndModifiers = factory.createNodeArray(ts.concatenate(decorators, modifiers));
            ts.setTextRangePosEnd(decoratorsAndModifiers, decorators.pos, modifiers.end);
            return decoratorsAndModifiers;
        }
        /*
         * There are situations in which a modifier like 'const' will appear unexpectedly, such as on a class member.
         * In those situations, if we are entirely sure that 'const' is not valid on its own (such as when ASI takes effect
         * and turns it into a standalone declaration), then it is better to parse it and report an error later.
         *
         * In such situations, 'permitInvalidConstAsModifier' should be set to true.
         */
        function parseModifiers(permitInvalidConstAsModifier, stopOnStartOfClassStaticBlock) {
            var pos = getNodePos();
            var list, modifier, hasSeenStatic = false;
            while (modifier = tryParseModifier(permitInvalidConstAsModifier, stopOnStartOfClassStaticBlock, hasSeenStatic)) {
                if (modifier.kind === 124 /* SyntaxKind.StaticKeyword */)
                    hasSeenStatic = true;
                list = ts.append(list, modifier);
            }
            return list && createNodeArray(list, pos);
        }
        function parseModifiersForArrowFunction() {
            var modifiers;
            if (token() === 131 /* SyntaxKind.AsyncKeyword */) {
                var pos = getNodePos();
                nextToken();
                var modifier = finishNode(factory.createToken(131 /* SyntaxKind.AsyncKeyword */), pos);
                modifiers = createNodeArray([modifier], pos);
            }
            return modifiers;
        }
        function parseClassElement() {
            var pos = getNodePos();
            if (token() === 26 /* SyntaxKind.SemicolonToken */) {
                nextToken();
                return finishNode(factory.createSemicolonClassElement(), pos);
            }
            var hasJSDoc = hasPrecedingJSDocComment();
            var decorators = parseDecorators();
            var modifiers = parseModifiers(/*permitInvalidConstAsModifier*/ true, /*stopOnStartOfClassStaticBlock*/ true);
            if (token() === 124 /* SyntaxKind.StaticKeyword */ && lookAhead(nextTokenIsOpenBrace)) {
                return parseClassStaticBlockDeclaration(pos, hasJSDoc, decorators, modifiers);
            }
            if (parseContextualModifier(136 /* SyntaxKind.GetKeyword */)) {
                return parseAccessorDeclaration(pos, hasJSDoc, decorators, modifiers, 172 /* SyntaxKind.GetAccessor */, 0 /* SignatureFlags.None */);
            }
            if (parseContextualModifier(149 /* SyntaxKind.SetKeyword */)) {
                return parseAccessorDeclaration(pos, hasJSDoc, decorators, modifiers, 173 /* SyntaxKind.SetAccessor */, 0 /* SignatureFlags.None */);
            }
            if (token() === 134 /* SyntaxKind.ConstructorKeyword */ || token() === 10 /* SyntaxKind.StringLiteral */) {
                var constructorDeclaration = tryParseConstructorDeclaration(pos, hasJSDoc, decorators, modifiers);
                if (constructorDeclaration) {
                    return constructorDeclaration;
                }
            }
            if (isIndexSignature()) {
                return parseIndexSignatureDeclaration(pos, hasJSDoc, decorators, modifiers);
            }
            // It is very important that we check this *after* checking indexers because
            // the [ token can start an index signature or a computed property name
            if (ts.tokenIsIdentifierOrKeyword(token()) ||
                token() === 10 /* SyntaxKind.StringLiteral */ ||
                token() === 8 /* SyntaxKind.NumericLiteral */ ||
                token() === 41 /* SyntaxKind.AsteriskToken */ ||
                token() === 22 /* SyntaxKind.OpenBracketToken */) {
                var isAmbient = ts.some(modifiers, isDeclareModifier);
                if (isAmbient) {
                    for (var _i = 0, _a = modifiers; _i < _a.length; _i++) {
                        var m = _a[_i];
                        m.flags |= 16777216 /* NodeFlags.Ambient */;
                    }
                    return doInsideOfContext(16777216 /* NodeFlags.Ambient */, function () { return parsePropertyOrMethodDeclaration(pos, hasJSDoc, decorators, modifiers); });
                }
                else {
                    return parsePropertyOrMethodDeclaration(pos, hasJSDoc, decorators, modifiers);
                }
            }
            if (decorators || modifiers) {
                // treat this as a property declaration with a missing name.
                var name = createMissingNode(79 /* SyntaxKind.Identifier */, /*reportAtCurrentPosition*/ true, ts.Diagnostics.Declaration_expected);
                return parsePropertyDeclaration(pos, hasJSDoc, decorators, modifiers, name, /*questionToken*/ undefined);
            }
            // 'isClassMemberStart' should have hinted not to attempt parsing.
            return ts.Debug.fail("Should not have attempted to parse class member declaration.");
        }
        function parseClassExpression() {
            return parseClassDeclarationOrExpression(getNodePos(), hasPrecedingJSDocComment(), /*decorators*/ undefined, /*modifiers*/ undefined, 226 /* SyntaxKind.ClassExpression */);
        }
        function parseClassDeclaration(pos, hasJSDoc, decorators, modifiers) {
            return parseClassDeclarationOrExpression(pos, hasJSDoc, decorators, modifiers, 257 /* SyntaxKind.ClassDeclaration */);
        }
        function parseClassDeclarationOrExpression(pos, hasJSDoc, decorators, modifiers, kind) {
            var savedAwaitContext = inAwaitContext();
            parseExpected(84 /* SyntaxKind.ClassKeyword */);
            // We don't parse the name here in await context, instead we will report a grammar error in the checker.
            var name = parseNameOfClassDeclarationOrExpression();
            var typeParameters = parseTypeParameters();
            if (ts.some(modifiers, ts.isExportModifier))
                setAwaitContext(/*value*/ true);
            var heritageClauses = parseHeritageClauses();
            var members;
            if (parseExpected(18 /* SyntaxKind.OpenBraceToken */)) {
                // ClassTail[Yield,Await] : (Modified) See 14.5
                //      ClassHeritage[?Yield,?Await]opt { ClassBody[?Yield,?Await]opt }
                members = parseClassMembers();
                parseExpected(19 /* SyntaxKind.CloseBraceToken */);
            }
            else {
                members = createMissingList();
            }
            setAwaitContext(savedAwaitContext);
            var node = kind === 257 /* SyntaxKind.ClassDeclaration */
                ? factory.createClassDeclaration(combineDecoratorsAndModifiers(decorators, modifiers), name, typeParameters, heritageClauses, members)
                : factory.createClassExpression(combineDecoratorsAndModifiers(decorators, modifiers), name, typeParameters, heritageClauses, members);
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseNameOfClassDeclarationOrExpression() {
            // implements is a future reserved word so
            // 'class implements' might mean either
            // - class expression with omitted name, 'implements' starts heritage clause
            // - class with name 'implements'
            // 'isImplementsClause' helps to disambiguate between these two cases
            return isBindingIdentifier() && !isImplementsClause()
                ? createIdentifier(isBindingIdentifier())
                : undefined;
        }
        function isImplementsClause() {
            return token() === 117 /* SyntaxKind.ImplementsKeyword */ && lookAhead(nextTokenIsIdentifierOrKeyword);
        }
        function parseHeritageClauses() {
            // ClassTail[Yield,Await] : (Modified) See 14.5
            //      ClassHeritage[?Yield,?Await]opt { ClassBody[?Yield,?Await]opt }
            if (isHeritageClause()) {
                return parseList(22 /* ParsingContext.HeritageClauses */, parseHeritageClause);
            }
            return undefined;
        }
        function parseHeritageClause() {
            var pos = getNodePos();
            var tok = token();
            ts.Debug.assert(tok === 94 /* SyntaxKind.ExtendsKeyword */ || tok === 117 /* SyntaxKind.ImplementsKeyword */); // isListElement() should ensure this.
            nextToken();
            var types = parseDelimitedList(7 /* ParsingContext.HeritageClauseElement */, parseExpressionWithTypeArguments);
            return finishNode(factory.createHeritageClause(tok, types), pos);
        }
        function parseExpressionWithTypeArguments() {
            var pos = getNodePos();
            var expression = parseLeftHandSideExpressionOrHigher();
            if (expression.kind === 228 /* SyntaxKind.ExpressionWithTypeArguments */) {
                return expression;
            }
            var typeArguments = tryParseTypeArguments();
            return finishNode(factory.createExpressionWithTypeArguments(expression, typeArguments), pos);
        }
        function tryParseTypeArguments() {
            return token() === 29 /* SyntaxKind.LessThanToken */ ?
                parseBracketedList(20 /* ParsingContext.TypeArguments */, parseType, 29 /* SyntaxKind.LessThanToken */, 31 /* SyntaxKind.GreaterThanToken */) : undefined;
        }
        function isHeritageClause() {
            return token() === 94 /* SyntaxKind.ExtendsKeyword */ || token() === 117 /* SyntaxKind.ImplementsKeyword */;
        }
        function parseClassMembers() {
            return parseList(5 /* ParsingContext.ClassMembers */, parseClassElement);
        }
        function parseInterfaceDeclaration(pos, hasJSDoc, decorators, modifiers) {
            parseExpected(118 /* SyntaxKind.InterfaceKeyword */);
            var name = parseIdentifier();
            var typeParameters = parseTypeParameters();
            var heritageClauses = parseHeritageClauses();
            var members = parseObjectTypeMembers();
            var node = factory.createInterfaceDeclaration(modifiers, name, typeParameters, heritageClauses, members);
            node.illegalDecorators = decorators;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseTypeAliasDeclaration(pos, hasJSDoc, decorators, modifiers) {
            parseExpected(152 /* SyntaxKind.TypeKeyword */);
            var name = parseIdentifier();
            var typeParameters = parseTypeParameters();
            parseExpected(63 /* SyntaxKind.EqualsToken */);
            var type = token() === 138 /* SyntaxKind.IntrinsicKeyword */ && tryParse(parseKeywordAndNoDot) || parseType();
            parseSemicolon();
            var node = factory.createTypeAliasDeclaration(modifiers, name, typeParameters, type);
            node.illegalDecorators = decorators;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        // In an ambient declaration, the grammar only allows integer literals as initializers.
        // In a non-ambient declaration, the grammar allows uninitialized members only in a
        // ConstantEnumMemberSection, which starts at the beginning of an enum declaration
        // or any time an integer literal initializer is encountered.
        function parseEnumMember() {
            var pos = getNodePos();
            var hasJSDoc = hasPrecedingJSDocComment();
            var name = parsePropertyName();
            var initializer = allowInAnd(parseInitializer);
            return withJSDoc(finishNode(factory.createEnumMember(name, initializer), pos), hasJSDoc);
        }
        function parseEnumDeclaration(pos, hasJSDoc, decorators, modifiers) {
            parseExpected(92 /* SyntaxKind.EnumKeyword */);
            var name = parseIdentifier();
            var members;
            if (parseExpected(18 /* SyntaxKind.OpenBraceToken */)) {
                members = doOutsideOfYieldAndAwaitContext(function () { return parseDelimitedList(6 /* ParsingContext.EnumMembers */, parseEnumMember); });
                parseExpected(19 /* SyntaxKind.CloseBraceToken */);
            }
            else {
                members = createMissingList();
            }
            var node = factory.createEnumDeclaration(modifiers, name, members);
            node.illegalDecorators = decorators;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseModuleBlock() {
            var pos = getNodePos();
            var statements;
            if (parseExpected(18 /* SyntaxKind.OpenBraceToken */)) {
                statements = parseList(1 /* ParsingContext.BlockStatements */, parseStatement);
                parseExpected(19 /* SyntaxKind.CloseBraceToken */);
            }
            else {
                statements = createMissingList();
            }
            return finishNode(factory.createModuleBlock(statements), pos);
        }
        function parseModuleOrNamespaceDeclaration(pos, hasJSDoc, decorators, modifiers, flags) {
            // If we are parsing a dotted namespace name, we want to
            // propagate the 'Namespace' flag across the names if set.
            var namespaceFlag = flags & 16 /* NodeFlags.Namespace */;
            var name = parseIdentifier();
            var body = parseOptional(24 /* SyntaxKind.DotToken */)
                ? parseModuleOrNamespaceDeclaration(getNodePos(), /*hasJSDoc*/ false, /*decorators*/ undefined, /*modifiers*/ undefined, 4 /* NodeFlags.NestedNamespace */ | namespaceFlag)
                : parseModuleBlock();
            var node = factory.createModuleDeclaration(modifiers, name, body, flags);
            node.illegalDecorators = decorators;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseAmbientExternalModuleDeclaration(pos, hasJSDoc, decorators, modifiers) {
            var flags = 0;
            var name;
            if (token() === 157 /* SyntaxKind.GlobalKeyword */) {
                // parse 'global' as name of global scope augmentation
                name = parseIdentifier();
                flags |= 1024 /* NodeFlags.GlobalAugmentation */;
            }
            else {
                name = parseLiteralNode();
                name.text = internIdentifier(name.text);
            }
            var body;
            if (token() === 18 /* SyntaxKind.OpenBraceToken */) {
                body = parseModuleBlock();
            }
            else {
                parseSemicolon();
            }
            var node = factory.createModuleDeclaration(modifiers, name, body, flags);
            node.illegalDecorators = decorators;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseModuleDeclaration(pos, hasJSDoc, decorators, modifiers) {
            var flags = 0;
            if (token() === 157 /* SyntaxKind.GlobalKeyword */) {
                // global augmentation
                return parseAmbientExternalModuleDeclaration(pos, hasJSDoc, decorators, modifiers);
            }
            else if (parseOptional(142 /* SyntaxKind.NamespaceKeyword */)) {
                flags |= 16 /* NodeFlags.Namespace */;
            }
            else {
                parseExpected(141 /* SyntaxKind.ModuleKeyword */);
                if (token() === 10 /* SyntaxKind.StringLiteral */) {
                    return parseAmbientExternalModuleDeclaration(pos, hasJSDoc, decorators, modifiers);
                }
            }
            return parseModuleOrNamespaceDeclaration(pos, hasJSDoc, decorators, modifiers, flags);
        }
        function isExternalModuleReference() {
            return token() === 146 /* SyntaxKind.RequireKeyword */ &&
                lookAhead(nextTokenIsOpenParen);
        }
        function nextTokenIsOpenParen() {
            return nextToken() === 20 /* SyntaxKind.OpenParenToken */;
        }
        function nextTokenIsOpenBrace() {
            return nextToken() === 18 /* SyntaxKind.OpenBraceToken */;
        }
        function nextTokenIsSlash() {
            return nextToken() === 43 /* SyntaxKind.SlashToken */;
        }
        function parseNamespaceExportDeclaration(pos, hasJSDoc, decorators, modifiers) {
            parseExpected(127 /* SyntaxKind.AsKeyword */);
            parseExpected(142 /* SyntaxKind.NamespaceKeyword */);
            var name = parseIdentifier();
            parseSemicolon();
            var node = factory.createNamespaceExportDeclaration(name);
            // NamespaceExportDeclaration nodes cannot have decorators or modifiers, so we attach them here so we can report them in the grammar checker
            node.illegalDecorators = decorators;
            node.modifiers = modifiers;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseImportDeclarationOrImportEqualsDeclaration(pos, hasJSDoc, decorators, modifiers) {
            parseExpected(100 /* SyntaxKind.ImportKeyword */);
            var afterImportPos = scanner.getStartPos();
            // We don't parse the identifier here in await context, instead we will report a grammar error in the checker.
            var identifier;
            if (isIdentifier()) {
                identifier = parseIdentifier();
            }
            var isTypeOnly = false;
            if (token() !== 156 /* SyntaxKind.FromKeyword */ &&
                (identifier === null || identifier === void 0 ? void 0 : identifier.escapedText) === "type" &&
                (isIdentifier() || tokenAfterImportDefinitelyProducesImportDeclaration())) {
                isTypeOnly = true;
                identifier = isIdentifier() ? parseIdentifier() : undefined;
            }
            if (identifier && !tokenAfterImportedIdentifierDefinitelyProducesImportDeclaration()) {
                return parseImportEqualsDeclaration(pos, hasJSDoc, decorators, modifiers, identifier, isTypeOnly);
            }
            // ImportDeclaration:
            //  import ImportClause from ModuleSpecifier ;
            //  import ModuleSpecifier;
            var importClause;
            if (identifier || // import id
                token() === 41 /* SyntaxKind.AsteriskToken */ || // import *
                token() === 18 /* SyntaxKind.OpenBraceToken */ // import {
            ) {
                importClause = parseImportClause(identifier, afterImportPos, isTypeOnly);
                parseExpected(156 /* SyntaxKind.FromKeyword */);
            }
            var moduleSpecifier = parseModuleSpecifier();
            var assertClause;
            if (token() === 129 /* SyntaxKind.AssertKeyword */ && !scanner.hasPrecedingLineBreak()) {
                assertClause = parseAssertClause();
            }
            parseSemicolon();
            var node = factory.createImportDeclaration(modifiers, importClause, moduleSpecifier, assertClause);
            node.illegalDecorators = decorators;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseAssertEntry() {
            var pos = getNodePos();
            var name = ts.tokenIsIdentifierOrKeyword(token()) ? parseIdentifierName() : parseLiteralLikeNode(10 /* SyntaxKind.StringLiteral */);
            parseExpected(58 /* SyntaxKind.ColonToken */);
            var value = parseAssignmentExpressionOrHigher(/*allowReturnTypeInArrowFunction*/ true);
            return finishNode(factory.createAssertEntry(name, value), pos);
        }
        function parseAssertClause(skipAssertKeyword) {
            var pos = getNodePos();
            if (!skipAssertKeyword) {
                parseExpected(129 /* SyntaxKind.AssertKeyword */);
            }
            var openBracePosition = scanner.getTokenPos();
            if (parseExpected(18 /* SyntaxKind.OpenBraceToken */)) {
                var multiLine = scanner.hasPrecedingLineBreak();
                var elements = parseDelimitedList(24 /* ParsingContext.AssertEntries */, parseAssertEntry, /*considerSemicolonAsDelimiter*/ true);
                if (!parseExpected(19 /* SyntaxKind.CloseBraceToken */)) {
                    var lastError = ts.lastOrUndefined(parseDiagnostics);
                    if (lastError && lastError.code === ts.Diagnostics._0_expected.code) {
                        ts.addRelatedInfo(lastError, ts.createDetachedDiagnostic(fileName, openBracePosition, 1, ts.Diagnostics.The_parser_expected_to_find_a_1_to_match_the_0_token_here, "{", "}"));
                    }
                }
                return finishNode(factory.createAssertClause(elements, multiLine), pos);
            }
            else {
                var elements = createNodeArray([], getNodePos(), /*end*/ undefined, /*hasTrailingComma*/ false);
                return finishNode(factory.createAssertClause(elements, /*multiLine*/ false), pos);
            }
        }
        function tokenAfterImportDefinitelyProducesImportDeclaration() {
            return token() === 41 /* SyntaxKind.AsteriskToken */ || token() === 18 /* SyntaxKind.OpenBraceToken */;
        }
        function tokenAfterImportedIdentifierDefinitelyProducesImportDeclaration() {
            // In `import id ___`, the current token decides whether to produce
            // an ImportDeclaration or ImportEqualsDeclaration.
            return token() === 27 /* SyntaxKind.CommaToken */ || token() === 156 /* SyntaxKind.FromKeyword */;
        }
        function parseImportEqualsDeclaration(pos, hasJSDoc, decorators, modifiers, identifier, isTypeOnly) {
            parseExpected(63 /* SyntaxKind.EqualsToken */);
            var moduleReference = parseModuleReference();
            parseSemicolon();
            var node = factory.createImportEqualsDeclaration(modifiers, isTypeOnly, identifier, moduleReference);
            node.illegalDecorators = decorators;
            var finished = withJSDoc(finishNode(node, pos), hasJSDoc);
            return finished;
        }
        function parseImportClause(identifier, pos, isTypeOnly) {
            // ImportClause:
            //  ImportedDefaultBinding
            //  NameSpaceImport
            //  NamedImports
            //  ImportedDefaultBinding, NameSpaceImport
            //  ImportedDefaultBinding, NamedImports
            // If there was no default import or if there is comma token after default import
            // parse namespace or named imports
            var namedBindings;
            if (!identifier ||
                parseOptional(27 /* SyntaxKind.CommaToken */)) {
                namedBindings = token() === 41 /* SyntaxKind.AsteriskToken */ ? parseNamespaceImport() : parseNamedImportsOrExports(269 /* SyntaxKind.NamedImports */);
            }
            return finishNode(factory.createImportClause(isTypeOnly, identifier, namedBindings), pos);
        }
        function parseModuleReference() {
            return isExternalModuleReference()
                ? parseExternalModuleReference()
                : parseEntityName(/*allowReservedWords*/ false);
        }
        function parseExternalModuleReference() {
            var pos = getNodePos();
            parseExpected(146 /* SyntaxKind.RequireKeyword */);
            parseExpected(20 /* SyntaxKind.OpenParenToken */);
            var expression = parseModuleSpecifier();
            parseExpected(21 /* SyntaxKind.CloseParenToken */);
            return finishNode(factory.createExternalModuleReference(expression), pos);
        }
        function parseModuleSpecifier() {
            if (token() === 10 /* SyntaxKind.StringLiteral */) {
                var result = parseLiteralNode();
                result.text = internIdentifier(result.text);
                return result;
            }
            else {
                // We allow arbitrary expressions here, even though the grammar only allows string
                // literals.  We check to ensure that it is only a string literal later in the grammar
                // check pass.
                return parseExpression();
            }
        }
        function parseNamespaceImport() {
            // NameSpaceImport:
            //  * as ImportedBinding
            var pos = getNodePos();
            parseExpected(41 /* SyntaxKind.AsteriskToken */);
            parseExpected(127 /* SyntaxKind.AsKeyword */);
            var name = parseIdentifier();
            return finishNode(factory.createNamespaceImport(name), pos);
        }
        function parseNamedImportsOrExports(kind) {
            var pos = getNodePos();
            // NamedImports:
            //  { }
            //  { ImportsList }
            //  { ImportsList, }
            // ImportsList:
            //  ImportSpecifier
            //  ImportsList, ImportSpecifier
            var node = kind === 269 /* SyntaxKind.NamedImports */
                ? factory.createNamedImports(parseBracketedList(23 /* ParsingContext.ImportOrExportSpecifiers */, parseImportSpecifier, 18 /* SyntaxKind.OpenBraceToken */, 19 /* SyntaxKind.CloseBraceToken */))
                : factory.createNamedExports(parseBracketedList(23 /* ParsingContext.ImportOrExportSpecifiers */, parseExportSpecifier, 18 /* SyntaxKind.OpenBraceToken */, 19 /* SyntaxKind.CloseBraceToken */));
            return finishNode(node, pos);
        }
        function parseExportSpecifier() {
            var hasJSDoc = hasPrecedingJSDocComment();
            return withJSDoc(parseImportOrExportSpecifier(275 /* SyntaxKind.ExportSpecifier */), hasJSDoc);
        }
        function parseImportSpecifier() {
            return parseImportOrExportSpecifier(270 /* SyntaxKind.ImportSpecifier */);
        }
        function parseImportOrExportSpecifier(kind) {
            var pos = getNodePos();
            // ImportSpecifier:
            //   BindingIdentifier
            //   IdentifierName as BindingIdentifier
            // ExportSpecifier:
            //   IdentifierName
            //   IdentifierName as IdentifierName
            var checkIdentifierIsKeyword = ts.isKeyword(token()) && !isIdentifier();
            var checkIdentifierStart = scanner.getTokenPos();
            var checkIdentifierEnd = scanner.getTextPos();
            var isTypeOnly = false;
            var propertyName;
            var canParseAsKeyword = true;
            var name = parseIdentifierName();
            if (name.escapedText === "type") {
                // If the first token of an import specifier is 'type', there are a lot of possibilities,
                // especially if we see 'as' afterwards:
                //
                // import { type } from "mod";          - isTypeOnly: false,   name: type
                // import { type as } from "mod";       - isTypeOnly: true,    name: as
                // import { type as as } from "mod";    - isTypeOnly: false,   name: as,    propertyName: type
                // import { type as as as } from "mod"; - isTypeOnly: true,    name: as,    propertyName: as
                if (token() === 127 /* SyntaxKind.AsKeyword */) {
                    // { type as ...? }
                    var firstAs = parseIdentifierName();
                    if (token() === 127 /* SyntaxKind.AsKeyword */) {
                        // { type as as ...? }
                        var secondAs = parseIdentifierName();
                        if (ts.tokenIsIdentifierOrKeyword(token())) {
                            // { type as as something }
                            isTypeOnly = true;
                            propertyName = firstAs;
                            name = parseNameWithKeywordCheck();
                            canParseAsKeyword = false;
                        }
                        else {
                            // { type as as }
                            propertyName = name;
                            name = secondAs;
                            canParseAsKeyword = false;
                        }
                    }
                    else if (ts.tokenIsIdentifierOrKeyword(token())) {
                        // { type as something }
                        propertyName = name;
                        canParseAsKeyword = false;
                        name = parseNameWithKeywordCheck();
                    }
                    else {
                        // { type as }
                        isTypeOnly = true;
                        name = firstAs;
                    }
                }
                else if (ts.tokenIsIdentifierOrKeyword(token())) {
                    // { type something ...? }
                    isTypeOnly = true;
                    name = parseNameWithKeywordCheck();
                }
            }
            if (canParseAsKeyword && token() === 127 /* SyntaxKind.AsKeyword */) {
                propertyName = name;
                parseExpected(127 /* SyntaxKind.AsKeyword */);
                name = parseNameWithKeywordCheck();
            }
            if (kind === 270 /* SyntaxKind.ImportSpecifier */ && checkIdentifierIsKeyword) {
                parseErrorAt(checkIdentifierStart, checkIdentifierEnd, ts.Diagnostics.Identifier_expected);
            }
            var node = kind === 270 /* SyntaxKind.ImportSpecifier */
                ? factory.createImportSpecifier(isTypeOnly, propertyName, name)
                : factory.createExportSpecifier(isTypeOnly, propertyName, name);
            return finishNode(node, pos);
            function parseNameWithKeywordCheck() {
                checkIdentifierIsKeyword = ts.isKeyword(token()) && !isIdentifier();
                checkIdentifierStart = scanner.getTokenPos();
                checkIdentifierEnd = scanner.getTextPos();
                return parseIdentifierName();
            }
        }
        function parseNamespaceExport(pos) {
            return finishNode(factory.createNamespaceExport(parseIdentifierName()), pos);
        }
        function parseExportDeclaration(pos, hasJSDoc, decorators, modifiers) {
            var savedAwaitContext = inAwaitContext();
            setAwaitContext(/*value*/ true);
            var exportClause;
            var moduleSpecifier;
            var assertClause;
            var isTypeOnly = parseOptional(152 /* SyntaxKind.TypeKeyword */);
            var namespaceExportPos = getNodePos();
            if (parseOptional(41 /* SyntaxKind.AsteriskToken */)) {
                if (parseOptional(127 /* SyntaxKind.AsKeyword */)) {
                    exportClause = parseNamespaceExport(namespaceExportPos);
                }
                parseExpected(156 /* SyntaxKind.FromKeyword */);
                moduleSpecifier = parseModuleSpecifier();
            }
            else {
                exportClause = parseNamedImportsOrExports(273 /* SyntaxKind.NamedExports */);
                // It is not uncommon to accidentally omit the 'from' keyword. Additionally, in editing scenarios,
                // the 'from' keyword can be parsed as a named export when the export clause is unterminated (i.e. `export { from "moduleName";`)
                // If we don't have a 'from' keyword, see if we have a string literal such that ASI won't take effect.
                if (token() === 156 /* SyntaxKind.FromKeyword */ || (token() === 10 /* SyntaxKind.StringLiteral */ && !scanner.hasPrecedingLineBreak())) {
                    parseExpected(156 /* SyntaxKind.FromKeyword */);
                    moduleSpecifier = parseModuleSpecifier();
                }
            }
            if (moduleSpecifier && token() === 129 /* SyntaxKind.AssertKeyword */ && !scanner.hasPrecedingLineBreak()) {
                assertClause = parseAssertClause();
            }
            parseSemicolon();
            setAwaitContext(savedAwaitContext);
            var node = factory.createExportDeclaration(modifiers, isTypeOnly, exportClause, moduleSpecifier, assertClause);
            node.illegalDecorators = decorators;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        function parseExportAssignment(pos, hasJSDoc, decorators, modifiers) {
            var savedAwaitContext = inAwaitContext();
            setAwaitContext(/*value*/ true);
            var isExportEquals;
            if (parseOptional(63 /* SyntaxKind.EqualsToken */)) {
                isExportEquals = true;
            }
            else {
                parseExpected(88 /* SyntaxKind.DefaultKeyword */);
            }
            var expression = parseAssignmentExpressionOrHigher(/*allowReturnTypeInArrowFunction*/ true);
            parseSemicolon();
            setAwaitContext(savedAwaitContext);
            var node = factory.createExportAssignment(modifiers, isExportEquals, expression);
            node.illegalDecorators = decorators;
            return withJSDoc(finishNode(node, pos), hasJSDoc);
        }
        var ParsingContext;
        (function (ParsingContext) {
            ParsingContext[ParsingContext["SourceElements"] = 0] = "SourceElements";
            ParsingContext[ParsingContext["BlockStatements"] = 1] = "BlockStatements";
            ParsingContext[ParsingContext["SwitchClauses"] = 2] = "SwitchClauses";
            ParsingContext[ParsingContext["SwitchClauseStatements"] = 3] = "SwitchClauseStatements";
            ParsingContext[ParsingContext["TypeMembers"] = 4] = "TypeMembers";
            ParsingContext[ParsingContext["ClassMembers"] = 5] = "ClassMembers";
            ParsingContext[ParsingContext["EnumMembers"] = 6] = "EnumMembers";
            ParsingContext[ParsingContext["HeritageClauseElement"] = 7] = "HeritageClauseElement";
            ParsingContext[ParsingContext["VariableDeclarations"] = 8] = "VariableDeclarations";
            ParsingContext[ParsingContext["ObjectBindingElements"] = 9] = "ObjectBindingElements";
            ParsingContext[ParsingContext["ArrayBindingElements"] = 10] = "ArrayBindingElements";
            ParsingContext[ParsingContext["ArgumentExpressions"] = 11] = "ArgumentExpressions";
            ParsingContext[ParsingContext["ObjectLiteralMembers"] = 12] = "ObjectLiteralMembers";
            ParsingContext[ParsingContext["JsxAttributes"] = 13] = "JsxAttributes";
            ParsingContext[ParsingContext["JsxChildren"] = 14] = "JsxChildren";
            ParsingContext[ParsingContext["ArrayLiteralMembers"] = 15] = "ArrayLiteralMembers";
            ParsingContext[ParsingContext["Parameters"] = 16] = "Parameters";
            ParsingContext[ParsingContext["JSDocParameters"] = 17] = "JSDocParameters";
            ParsingContext[ParsingContext["RestProperties"] = 18] = "RestProperties";
            ParsingContext[ParsingContext["TypeParameters"] = 19] = "TypeParameters";
            ParsingContext[ParsingContext["TypeArguments"] = 20] = "TypeArguments";
            ParsingContext[ParsingContext["TupleElementTypes"] = 21] = "TupleElementTypes";
            ParsingContext[ParsingContext["HeritageClauses"] = 22] = "HeritageClauses";
            ParsingContext[ParsingContext["ImportOrExportSpecifiers"] = 23] = "ImportOrExportSpecifiers";
            ParsingContext[ParsingContext["AssertEntries"] = 24] = "AssertEntries";
            ParsingContext[ParsingContext["Count"] = 25] = "Count"; // Number of parsing contexts
        })(ParsingContext || (ParsingContext = {}));
        var Tristate;
        (function (Tristate) {
            Tristate[Tristate["False"] = 0] = "False";
            Tristate[Tristate["True"] = 1] = "True";
            Tristate[Tristate["Unknown"] = 2] = "Unknown";
        })(Tristate || (Tristate = {}));
        var JSDocParser;
        (function (JSDocParser) {
            function parseJSDocTypeExpressionForTests(content, start, length) {
                initializeState("file.js", content, 99 /* ScriptTarget.Latest */, /*_syntaxCursor:*/ undefined, 1 /* ScriptKind.JS */);
                scanner.setText(content, start, length);
                currentToken = scanner.scan();
                var jsDocTypeExpression = parseJSDocTypeExpression();
                var sourceFile = createSourceFile("file.js", 99 /* ScriptTarget.Latest */, 1 /* ScriptKind.JS */, /*isDeclarationFile*/ false, [], factory.createToken(1 /* SyntaxKind.EndOfFileToken */), 0 /* NodeFlags.None */, ts.noop);
                var diagnostics = ts.attachFileToDiagnostics(parseDiagnostics, sourceFile);
                if (jsDocDiagnostics) {
                    sourceFile.jsDocDiagnostics = ts.attachFileToDiagnostics(jsDocDiagnostics, sourceFile);
                }
                clearState();
                return jsDocTypeExpression ? { jsDocTypeExpression: jsDocTypeExpression, diagnostics: diagnostics } : undefined;
            }
            JSDocParser.parseJSDocTypeExpressionForTests = parseJSDocTypeExpressionForTests;
            // Parses out a JSDoc type expression.
            function parseJSDocTypeExpression(mayOmitBraces) {
                var pos = getNodePos();
                var hasBrace = (mayOmitBraces ? parseOptional : parseExpected)(18 /* SyntaxKind.OpenBraceToken */);
                var type = doInsideOfContext(8388608 /* NodeFlags.JSDoc */, parseJSDocType);
                if (!mayOmitBraces || hasBrace) {
                    parseExpectedJSDoc(19 /* SyntaxKind.CloseBraceToken */);
                }
                var result = factory.createJSDocTypeExpression(type);
                fixupParentReferences(result);
                return finishNode(result, pos);
            }
            JSDocParser.parseJSDocTypeExpression = parseJSDocTypeExpression;
            function parseJSDocNameReference() {
                var pos = getNodePos();
                var hasBrace = parseOptional(18 /* SyntaxKind.OpenBraceToken */);
                var p2 = getNodePos();
                var entityName = parseEntityName(/* allowReservedWords*/ false);
                while (token() === 80 /* SyntaxKind.PrivateIdentifier */) {
                    reScanHashToken(); // rescan #id as # id
                    nextTokenJSDoc(); // then skip the #
                    entityName = finishNode(factory.createJSDocMemberName(entityName, parseIdentifier()), p2);
                }
                if (hasBrace) {
                    parseExpectedJSDoc(19 /* SyntaxKind.CloseBraceToken */);
                }
                var result = factory.createJSDocNameReference(entityName);
                fixupParentReferences(result);
                return finishNode(result, pos);
            }
            JSDocParser.parseJSDocNameReference = parseJSDocNameReference;
            function parseIsolatedJSDocComment(content, start, length) {
                initializeState("", content, 99 /* ScriptTarget.Latest */, /*_syntaxCursor:*/ undefined, 1 /* ScriptKind.JS */);
                var jsDoc = doInsideOfContext(8388608 /* NodeFlags.JSDoc */, function () { return parseJSDocCommentWorker(start, length); });
                var sourceFile = { languageVariant: 0 /* LanguageVariant.Standard */, text: content };
                var diagnostics = ts.attachFileToDiagnostics(parseDiagnostics, sourceFile);
                clearState();
                return jsDoc ? { jsDoc: jsDoc, diagnostics: diagnostics } : undefined;
            }
            JSDocParser.parseIsolatedJSDocComment = parseIsolatedJSDocComment;
            function parseJSDocComment(parent, start, length) {
                var saveToken = currentToken;
                var saveParseDiagnosticsLength = parseDiagnostics.length;
                var saveParseErrorBeforeNextFinishedNode = parseErrorBeforeNextFinishedNode;
                var comment = doInsideOfContext(8388608 /* NodeFlags.JSDoc */, function () { return parseJSDocCommentWorker(start, length); });
                ts.setParent(comment, parent);
                if (contextFlags & 262144 /* NodeFlags.JavaScriptFile */) {
                    if (!jsDocDiagnostics) {
                        jsDocDiagnostics = [];
                    }
                    jsDocDiagnostics.push.apply(jsDocDiagnostics, parseDiagnostics);
                }
                currentToken = saveToken;
                parseDiagnostics.length = saveParseDiagnosticsLength;
                parseErrorBeforeNextFinishedNode = saveParseErrorBeforeNextFinishedNode;
                return comment;
            }
            JSDocParser.parseJSDocComment = parseJSDocComment;
            var JSDocState;
            (function (JSDocState) {
                JSDocState[JSDocState["BeginningOfLine"] = 0] = "BeginningOfLine";
                JSDocState[JSDocState["SawAsterisk"] = 1] = "SawAsterisk";
                JSDocState[JSDocState["SavingComments"] = 2] = "SavingComments";
                JSDocState[JSDocState["SavingBackticks"] = 3] = "SavingBackticks";
            })(JSDocState || (JSDocState = {}));
            var PropertyLikeParse;
            (function (PropertyLikeParse) {
                PropertyLikeParse[PropertyLikeParse["Property"] = 1] = "Property";
                PropertyLikeParse[PropertyLikeParse["Parameter"] = 2] = "Parameter";
                PropertyLikeParse[PropertyLikeParse["CallbackParameter"] = 4] = "CallbackParameter";
            })(PropertyLikeParse || (PropertyLikeParse = {}));
            function parseJSDocCommentWorker(start, length) {
                if (start === void 0) { start = 0; }
                var content = sourceText;
                var end = length === undefined ? content.length : start + length;
                length = end - start;
                ts.Debug.assert(start >= 0);
                ts.Debug.assert(start <= end);
                ts.Debug.assert(end <= content.length);
                // Check for /** (JSDoc opening part)
                if (!isJSDocLikeText(content, start)) {
                    return undefined;
                }
                var tags;
                var tagsPos;
                var tagsEnd;
                var linkEnd;
                var commentsPos;
                var comments = [];
                var parts = [];
                // + 3 for leading /**, - 5 in total for /** */
                return scanner.scanRange(start + 3, length - 5, function () {
                    // Initially we can parse out a tag.  We also have seen a starting asterisk.
                    // This is so that /** * @type */ doesn't parse.
                    var state = 1 /* JSDocState.SawAsterisk */;
                    var margin;
                    // + 4 for leading '/** '
                    // + 1 because the last index of \n is always one index before the first character in the line and coincidentally, if there is no \n before start, it is -1, which is also one index before the first character
                    var indent = start - (content.lastIndexOf("\n", start) + 1) + 4;
                    function pushComment(text) {
                        if (!margin) {
                            margin = indent;
                        }
                        comments.push(text);
                        indent += text.length;
                    }
                    nextTokenJSDoc();
                    while (parseOptionalJsdoc(5 /* SyntaxKind.WhitespaceTrivia */))
                        ;
                    if (parseOptionalJsdoc(4 /* SyntaxKind.NewLineTrivia */)) {
                        state = 0 /* JSDocState.BeginningOfLine */;
                        indent = 0;
                    }
                    loop: while (true) {
                        switch (token()) {
                            case 59 /* SyntaxKind.AtToken */:
                                if (state === 0 /* JSDocState.BeginningOfLine */ || state === 1 /* JSDocState.SawAsterisk */) {
                                    removeTrailingWhitespace(comments);
                                    if (!commentsPos)
                                        commentsPos = getNodePos();
                                    addTag(parseTag(indent));
                                    // NOTE: According to usejsdoc.org, a tag goes to end of line, except the last tag.
                                    // Real-world comments may break this rule, so "BeginningOfLine" will not be a real line beginning
                                    // for malformed examples like `/** @param {string} x @returns {number} the length */`
                                    state = 0 /* JSDocState.BeginningOfLine */;
                                    margin = undefined;
                                }
                                else {
                                    pushComment(scanner.getTokenText());
                                }
                                break;
                            case 4 /* SyntaxKind.NewLineTrivia */:
                                comments.push(scanner.getTokenText());
                                state = 0 /* JSDocState.BeginningOfLine */;
                                indent = 0;
                                break;
                            case 41 /* SyntaxKind.AsteriskToken */:
                                var asterisk = scanner.getTokenText();
                                if (state === 1 /* JSDocState.SawAsterisk */ || state === 2 /* JSDocState.SavingComments */) {
                                    // If we've already seen an asterisk, then we can no longer parse a tag on this line
                                    state = 2 /* JSDocState.SavingComments */;
                                    pushComment(asterisk);
                                }
                                else {
                                    // Ignore the first asterisk on a line
                                    state = 1 /* JSDocState.SawAsterisk */;
                                    indent += asterisk.length;
                                }
                                break;
                            case 5 /* SyntaxKind.WhitespaceTrivia */:
                                // only collect whitespace if we're already saving comments or have just crossed the comment indent margin
                                var whitespace = scanner.getTokenText();
                                if (state === 2 /* JSDocState.SavingComments */) {
                                    comments.push(whitespace);
                                }
                                else if (margin !== undefined && indent + whitespace.length > margin) {
                                    comments.push(whitespace.slice(margin - indent));
                                }
                                indent += whitespace.length;
                                break;
                            case 1 /* SyntaxKind.EndOfFileToken */:
                                break loop;
                            case 18 /* SyntaxKind.OpenBraceToken */:
                                state = 2 /* JSDocState.SavingComments */;
                                var commentEnd = scanner.getStartPos();
                                var linkStart = scanner.getTextPos() - 1;
                                var link = parseJSDocLink(linkStart);
                                if (link) {
                                    if (!linkEnd) {
                                        removeLeadingNewlines(comments);
                                    }
                                    parts.push(finishNode(factory.createJSDocText(comments.join("")), linkEnd !== null && linkEnd !== void 0 ? linkEnd : start, commentEnd));
                                    parts.push(link);
                                    comments = [];
                                    linkEnd = scanner.getTextPos();
                                    break;
                                }
                            // fallthrough if it's not a {@link sequence
                            default:
                                // Anything else is doc comment text. We just save it. Because it
                                // wasn't a tag, we can no longer parse a tag on this line until we hit the next
                                // line break.
                                state = 2 /* JSDocState.SavingComments */;
                                pushComment(scanner.getTokenText());
                                break;
                        }
                        nextTokenJSDoc();
                    }
                    removeTrailingWhitespace(comments);
                    if (parts.length && comments.length) {
                        parts.push(finishNode(factory.createJSDocText(comments.join("")), linkEnd !== null && linkEnd !== void 0 ? linkEnd : start, commentsPos));
                    }
                    if (parts.length && tags)
                        ts.Debug.assertIsDefined(commentsPos, "having parsed tags implies that the end of the comment span should be set");
                    var tagsArray = tags && createNodeArray(tags, tagsPos, tagsEnd);
                    return finishNode(factory.createJSDocComment(parts.length ? createNodeArray(parts, start, commentsPos) : comments.length ? comments.join("") : undefined, tagsArray), start, end);
                });
                function removeLeadingNewlines(comments) {
                    while (comments.length && (comments[0] === "\n" || comments[0] === "\r")) {
                        comments.shift();
                    }
                }
                function removeTrailingWhitespace(comments) {
                    while (comments.length && comments[comments.length - 1].trim() === "") {
                        comments.pop();
                    }
                }
                function isNextNonwhitespaceTokenEndOfFile() {
                    // We must use infinite lookahead, as there could be any number of newlines :(
                    while (true) {
                        nextTokenJSDoc();
                        if (token() === 1 /* SyntaxKind.EndOfFileToken */) {
                            return true;
                        }
                        if (!(token() === 5 /* SyntaxKind.WhitespaceTrivia */ || token() === 4 /* SyntaxKind.NewLineTrivia */)) {
                            return false;
                        }
                    }
                }
                function skipWhitespace() {
                    if (token() === 5 /* SyntaxKind.WhitespaceTrivia */ || token() === 4 /* SyntaxKind.NewLineTrivia */) {
                        if (lookAhead(isNextNonwhitespaceTokenEndOfFile)) {
                            return; // Don't skip whitespace prior to EoF (or end of comment) - that shouldn't be included in any node's range
                        }
                    }
                    while (token() === 5 /* SyntaxKind.WhitespaceTrivia */ || token() === 4 /* SyntaxKind.NewLineTrivia */) {
                        nextTokenJSDoc();
                    }
                }
                function skipWhitespaceOrAsterisk() {
                    if (token() === 5 /* SyntaxKind.WhitespaceTrivia */ || token() === 4 /* SyntaxKind.NewLineTrivia */) {
                        if (lookAhead(isNextNonwhitespaceTokenEndOfFile)) {
                            return ""; // Don't skip whitespace prior to EoF (or end of comment) - that shouldn't be included in any node's range
                        }
                    }
                    var precedingLineBreak = scanner.hasPrecedingLineBreak();
                    var seenLineBreak = false;
                    var indentText = "";
                    while ((precedingLineBreak && token() === 41 /* SyntaxKind.AsteriskToken */) || token() === 5 /* SyntaxKind.WhitespaceTrivia */ || token() === 4 /* SyntaxKind.NewLineTrivia */) {
                        indentText += scanner.getTokenText();
                        if (token() === 4 /* SyntaxKind.NewLineTrivia */) {
                            precedingLineBreak = true;
                            seenLineBreak = true;
                            indentText = "";
                        }
                        else if (token() === 41 /* SyntaxKind.AsteriskToken */) {
                            precedingLineBreak = false;
                        }
                        nextTokenJSDoc();
                    }
                    return seenLineBreak ? indentText : "";
                }
                function parseTag(margin) {
                    ts.Debug.assert(token() === 59 /* SyntaxKind.AtToken */);
                    var start = scanner.getTokenPos();
                    nextTokenJSDoc();
                    var tagName = parseJSDocIdentifierName(/*message*/ undefined);
                    var indentText = skipWhitespaceOrAsterisk();
                    var tag;
                    switch (tagName.escapedText) {
                        case "author":
                            tag = parseAuthorTag(start, tagName, margin, indentText);
                            break;
                        case "implements":
                            tag = parseImplementsTag(start, tagName, margin, indentText);
                            break;
                        case "augments":
                        case "extends":
                            tag = parseAugmentsTag(start, tagName, margin, indentText);
                            break;
                        case "class":
                        case "constructor":
                            tag = parseSimpleTag(start, factory.createJSDocClassTag, tagName, margin, indentText);
                            break;
                        case "public":
                            tag = parseSimpleTag(start, factory.createJSDocPublicTag, tagName, margin, indentText);
                            break;
                        case "private":
                            tag = parseSimpleTag(start, factory.createJSDocPrivateTag, tagName, margin, indentText);
                            break;
                        case "protected":
                            tag = parseSimpleTag(start, factory.createJSDocProtectedTag, tagName, margin, indentText);
                            break;
                        case "readonly":
                            tag = parseSimpleTag(start, factory.createJSDocReadonlyTag, tagName, margin, indentText);
                            break;
                        case "override":
                            tag = parseSimpleTag(start, factory.createJSDocOverrideTag, tagName, margin, indentText);
                            break;
                        case "deprecated":
                            hasDeprecatedTag = true;
                            tag = parseSimpleTag(start, factory.createJSDocDeprecatedTag, tagName, margin, indentText);
                            break;
                        case "this":
                            tag = parseThisTag(start, tagName, margin, indentText);
                            break;
                        case "enum":
                            tag = parseEnumTag(start, tagName, margin, indentText);
                            break;
                        case "arg":
                        case "argument":
                        case "param":
                            return parseParameterOrPropertyTag(start, tagName, 2 /* PropertyLikeParse.Parameter */, margin);
                        case "return":
                        case "returns":
                            tag = parseReturnTag(start, tagName, margin, indentText);
                            break;
                        case "template":
                            tag = parseTemplateTag(start, tagName, margin, indentText);
                            break;
                        case "type":
                            tag = parseTypeTag(start, tagName, margin, indentText);
                            break;
                        case "typedef":
                            tag = parseTypedefTag(start, tagName, margin, indentText);
                            break;
                        case "callback":
                            tag = parseCallbackTag(start, tagName, margin, indentText);
                            break;
                        case "see":
                            tag = parseSeeTag(start, tagName, margin, indentText);
                            break;
                        default:
                            tag = parseUnknownTag(start, tagName, margin, indentText);
                            break;
                    }
                    return tag;
                }
                function parseTrailingTagComments(pos, end, margin, indentText) {
                    // some tags, like typedef and callback, have already parsed their comments earlier
                    if (!indentText) {
                        margin += end - pos;
                    }
                    return parseTagComments(margin, indentText.slice(margin));
                }
                function parseTagComments(indent, initialMargin) {
                    var commentsPos = getNodePos();
                    var comments = [];
                    var parts = [];
                    var linkEnd;
                    var state = 0 /* JSDocState.BeginningOfLine */;
                    var previousWhitespace = true;
                    var margin;
                    function pushComment(text) {
                        if (!margin) {
                            margin = indent;
                        }
                        comments.push(text);
                        indent += text.length;
                    }
                    if (initialMargin !== undefined) {
                        // jump straight to saving comments if there is some initial indentation
                        if (initialMargin !== "") {
                            pushComment(initialMargin);
                        }
                        state = 1 /* JSDocState.SawAsterisk */;
                    }
                    var tok = token();
                    loop: while (true) {
                        switch (tok) {
                            case 4 /* SyntaxKind.NewLineTrivia */:
                                state = 0 /* JSDocState.BeginningOfLine */;
                                // don't use pushComment here because we want to keep the margin unchanged
                                comments.push(scanner.getTokenText());
                                indent = 0;
                                break;
                            case 59 /* SyntaxKind.AtToken */:
                                if (state === 3 /* JSDocState.SavingBackticks */
                                    || state === 2 /* JSDocState.SavingComments */ && (!previousWhitespace || lookAhead(isNextJSDocTokenWhitespace))) {
                                    // @ doesn't start a new tag inside ``, and inside a comment, only after whitespace or not before whitespace
                                    comments.push(scanner.getTokenText());
                                    break;
                                }
                                scanner.setTextPos(scanner.getTextPos() - 1);
                            // falls through
                            case 1 /* SyntaxKind.EndOfFileToken */:
                                // Done
                                break loop;
                            case 5 /* SyntaxKind.WhitespaceTrivia */:
                                if (state === 2 /* JSDocState.SavingComments */ || state === 3 /* JSDocState.SavingBackticks */) {
                                    pushComment(scanner.getTokenText());
                                }
                                else {
                                    var whitespace = scanner.getTokenText();
                                    // if the whitespace crosses the margin, take only the whitespace that passes the margin
                                    if (margin !== undefined && indent + whitespace.length > margin) {
                                        comments.push(whitespace.slice(margin - indent));
                                    }
                                    indent += whitespace.length;
                                }
                                break;
                            case 18 /* SyntaxKind.OpenBraceToken */:
                                state = 2 /* JSDocState.SavingComments */;
                                var commentEnd = scanner.getStartPos();
                                var linkStart = scanner.getTextPos() - 1;
                                var link = parseJSDocLink(linkStart);
                                if (link) {
                                    parts.push(finishNode(factory.createJSDocText(comments.join("")), linkEnd !== null && linkEnd !== void 0 ? linkEnd : commentsPos, commentEnd));
                                    parts.push(link);
                                    comments = [];
                                    linkEnd = scanner.getTextPos();
                                }
                                else {
                                    pushComment(scanner.getTokenText());
                                }
                                break;
                            case 61 /* SyntaxKind.BacktickToken */:
                                if (state === 3 /* JSDocState.SavingBackticks */) {
                                    state = 2 /* JSDocState.SavingComments */;
                                }
                                else {
                                    state = 3 /* JSDocState.SavingBackticks */;
                                }
                                pushComment(scanner.getTokenText());
                                break;
                            case 41 /* SyntaxKind.AsteriskToken */:
                                if (state === 0 /* JSDocState.BeginningOfLine */) {
                                    // leading asterisks start recording on the *next* (non-whitespace) token
                                    state = 1 /* JSDocState.SawAsterisk */;
                                    indent += 1;
                                    break;
                                }
                            // record the * as a comment
                            // falls through
                            default:
                                if (state !== 3 /* JSDocState.SavingBackticks */) {
                                    state = 2 /* JSDocState.SavingComments */; // leading identifiers start recording as well
                                }
                                pushComment(scanner.getTokenText());
                                break;
                        }
                        previousWhitespace = token() === 5 /* SyntaxKind.WhitespaceTrivia */;
                        tok = nextTokenJSDoc();
                    }
                    removeLeadingNewlines(comments);
                    removeTrailingWhitespace(comments);
                    if (parts.length) {
                        if (comments.length) {
                            parts.push(finishNode(factory.createJSDocText(comments.join("")), linkEnd !== null && linkEnd !== void 0 ? linkEnd : commentsPos));
                        }
                        return createNodeArray(parts, commentsPos, scanner.getTextPos());
                    }
                    else if (comments.length) {
                        return comments.join("");
                    }
                }
                function isNextJSDocTokenWhitespace() {
                    var next = nextTokenJSDoc();
                    return next === 5 /* SyntaxKind.WhitespaceTrivia */ || next === 4 /* SyntaxKind.NewLineTrivia */;
                }
                function parseJSDocLink(start) {
                    var linkType = tryParse(parseJSDocLinkPrefix);
                    if (!linkType) {
                        return undefined;
                    }
                    nextTokenJSDoc(); // start at token after link, then skip any whitespace
                    skipWhitespace();
                    // parseEntityName logs an error for non-identifier, so create a MissingNode ourselves to avoid the error
                    var p2 = getNodePos();
                    var name = ts.tokenIsIdentifierOrKeyword(token())
                        ? parseEntityName(/*allowReservedWords*/ true)
                        : undefined;
                    if (name) {
                        while (token() === 80 /* SyntaxKind.PrivateIdentifier */) {
                            reScanHashToken(); // rescan #id as # id
                            nextTokenJSDoc(); // then skip the #
                            name = finishNode(factory.createJSDocMemberName(name, parseIdentifier()), p2);
                        }
                    }
                    var text = [];
                    while (token() !== 19 /* SyntaxKind.CloseBraceToken */ && token() !== 4 /* SyntaxKind.NewLineTrivia */ && token() !== 1 /* SyntaxKind.EndOfFileToken */) {
                        text.push(scanner.getTokenText());
                        nextTokenJSDoc();
                    }
                    var create = linkType === "link" ? factory.createJSDocLink
                        : linkType === "linkcode" ? factory.createJSDocLinkCode
                            : factory.createJSDocLinkPlain;
                    return finishNode(create(name, text.join("")), start, scanner.getTextPos());
                }
                function parseJSDocLinkPrefix() {
                    skipWhitespaceOrAsterisk();
                    if (token() === 18 /* SyntaxKind.OpenBraceToken */
                        && nextTokenJSDoc() === 59 /* SyntaxKind.AtToken */
                        && ts.tokenIsIdentifierOrKeyword(nextTokenJSDoc())) {
                        var kind = scanner.getTokenValue();
                        if (isJSDocLinkTag(kind))
                            return kind;
                    }
                }
                function isJSDocLinkTag(kind) {
                    return kind === "link" || kind === "linkcode" || kind === "linkplain";
                }
                function parseUnknownTag(start, tagName, indent, indentText) {
                    return finishNode(factory.createJSDocUnknownTag(tagName, parseTrailingTagComments(start, getNodePos(), indent, indentText)), start);
                }
                function addTag(tag) {
                    if (!tag) {
                        return;
                    }
                    if (!tags) {
                        tags = [tag];
                        tagsPos = tag.pos;
                    }
                    else {
                        tags.push(tag);
                    }
                    tagsEnd = tag.end;
                }
                function tryParseTypeExpression() {
                    skipWhitespaceOrAsterisk();
                    return token() === 18 /* SyntaxKind.OpenBraceToken */ ? parseJSDocTypeExpression() : undefined;
                }
                function parseBracketNameInPropertyAndParamTag() {
                    // Looking for something like '[foo]', 'foo', '[foo.bar]' or 'foo.bar'
                    var isBracketed = parseOptionalJsdoc(22 /* SyntaxKind.OpenBracketToken */);
                    if (isBracketed) {
                        skipWhitespace();
                    }
                    // a markdown-quoted name: `arg` is not legal jsdoc, but occurs in the wild
                    var isBackquoted = parseOptionalJsdoc(61 /* SyntaxKind.BacktickToken */);
                    var name = parseJSDocEntityName();
                    if (isBackquoted) {
                        parseExpectedTokenJSDoc(61 /* SyntaxKind.BacktickToken */);
                    }
                    if (isBracketed) {
                        skipWhitespace();
                        // May have an optional default, e.g. '[foo = 42]'
                        if (parseOptionalToken(63 /* SyntaxKind.EqualsToken */)) {
                            parseExpression();
                        }
                        parseExpected(23 /* SyntaxKind.CloseBracketToken */);
                    }
                    return { name: name, isBracketed: isBracketed };
                }
                function isObjectOrObjectArrayTypeReference(node) {
                    switch (node.kind) {
                        case 148 /* SyntaxKind.ObjectKeyword */:
                            return true;
                        case 183 /* SyntaxKind.ArrayType */:
                            return isObjectOrObjectArrayTypeReference(node.elementType);
                        default:
                            return ts.isTypeReferenceNode(node) && ts.isIdentifier(node.typeName) && node.typeName.escapedText === "Object" && !node.typeArguments;
                    }
                }
                function parseParameterOrPropertyTag(start, tagName, target, indent) {
                    var typeExpression = tryParseTypeExpression();
                    var isNameFirst = !typeExpression;
                    skipWhitespaceOrAsterisk();
                    var _a = parseBracketNameInPropertyAndParamTag(), name = _a.name, isBracketed = _a.isBracketed;
                    var indentText = skipWhitespaceOrAsterisk();
                    if (isNameFirst && !lookAhead(parseJSDocLinkPrefix)) {
                        typeExpression = tryParseTypeExpression();
                    }
                    var comment = parseTrailingTagComments(start, getNodePos(), indent, indentText);
                    var nestedTypeLiteral = target !== 4 /* PropertyLikeParse.CallbackParameter */ && parseNestedTypeLiteral(typeExpression, name, target, indent);
                    if (nestedTypeLiteral) {
                        typeExpression = nestedTypeLiteral;
                        isNameFirst = true;
                    }
                    var result = target === 1 /* PropertyLikeParse.Property */
                        ? factory.createJSDocPropertyTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment)
                        : factory.createJSDocParameterTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment);
                    return finishNode(result, start);
                }
                function parseNestedTypeLiteral(typeExpression, name, target, indent) {
                    if (typeExpression && isObjectOrObjectArrayTypeReference(typeExpression.type)) {
                        var pos = getNodePos();
                        var child = void 0;
                        var children = void 0;
                        while (child = tryParse(function () { return parseChildParameterOrPropertyTag(target, indent, name); })) {
                            if (child.kind === 340 /* SyntaxKind.JSDocParameterTag */ || child.kind === 347 /* SyntaxKind.JSDocPropertyTag */) {
                                children = ts.append(children, child);
                            }
                        }
                        if (children) {
                            var literal = finishNode(factory.createJSDocTypeLiteral(children, typeExpression.type.kind === 183 /* SyntaxKind.ArrayType */), pos);
                            return finishNode(factory.createJSDocTypeExpression(literal), pos);
                        }
                    }
                }
                function parseReturnTag(start, tagName, indent, indentText) {
                    if (ts.some(tags, ts.isJSDocReturnTag)) {
                        parseErrorAt(tagName.pos, scanner.getTokenPos(), ts.Diagnostics._0_tag_already_specified, tagName.escapedText);
                    }
                    var typeExpression = tryParseTypeExpression();
                    return finishNode(factory.createJSDocReturnTag(tagName, typeExpression, parseTrailingTagComments(start, getNodePos(), indent, indentText)), start);
                }
                function parseTypeTag(start, tagName, indent, indentText) {
                    if (ts.some(tags, ts.isJSDocTypeTag)) {
                        parseErrorAt(tagName.pos, scanner.getTokenPos(), ts.Diagnostics._0_tag_already_specified, tagName.escapedText);
                    }
                    var typeExpression = parseJSDocTypeExpression(/*mayOmitBraces*/ true);
                    var comments = indent !== undefined && indentText !== undefined ? parseTrailingTagComments(start, getNodePos(), indent, indentText) : undefined;
                    return finishNode(factory.createJSDocTypeTag(tagName, typeExpression, comments), start);
                }
                function parseSeeTag(start, tagName, indent, indentText) {
                    var isMarkdownOrJSDocLink = token() === 22 /* SyntaxKind.OpenBracketToken */
                        || lookAhead(function () { return nextTokenJSDoc() === 59 /* SyntaxKind.AtToken */ && ts.tokenIsIdentifierOrKeyword(nextTokenJSDoc()) && isJSDocLinkTag(scanner.getTokenValue()); });
                    var nameExpression = isMarkdownOrJSDocLink ? undefined : parseJSDocNameReference();
                    var comments = indent !== undefined && indentText !== undefined ? parseTrailingTagComments(start, getNodePos(), indent, indentText) : undefined;
                    return finishNode(factory.createJSDocSeeTag(tagName, nameExpression, comments), start);
                }
                function parseAuthorTag(start, tagName, indent, indentText) {
                    var commentStart = getNodePos();
                    var textOnly = parseAuthorNameAndEmail();
                    var commentEnd = scanner.getStartPos();
                    var comments = parseTrailingTagComments(start, commentEnd, indent, indentText);
                    if (!comments) {
                        commentEnd = scanner.getStartPos();
                    }
                    var allParts = typeof comments !== "string"
                        ? createNodeArray(ts.concatenate([finishNode(textOnly, commentStart, commentEnd)], comments), commentStart) // cast away readonly
                        : textOnly.text + comments;
                    return finishNode(factory.createJSDocAuthorTag(tagName, allParts), start);
                }
                function parseAuthorNameAndEmail() {
                    var comments = [];
                    var inEmail = false;
                    var token = scanner.getToken();
                    while (token !== 1 /* SyntaxKind.EndOfFileToken */ && token !== 4 /* SyntaxKind.NewLineTrivia */) {
                        if (token === 29 /* SyntaxKind.LessThanToken */) {
                            inEmail = true;
                        }
                        else if (token === 59 /* SyntaxKind.AtToken */ && !inEmail) {
                            break;
                        }
                        else if (token === 31 /* SyntaxKind.GreaterThanToken */ && inEmail) {
                            comments.push(scanner.getTokenText());
                            scanner.setTextPos(scanner.getTokenPos() + 1);
                            break;
                        }
                        comments.push(scanner.getTokenText());
                        token = nextTokenJSDoc();
                    }
                    return factory.createJSDocText(comments.join(""));
                }
                function parseImplementsTag(start, tagName, margin, indentText) {
                    var className = parseExpressionWithTypeArgumentsForAugments();
                    return finishNode(factory.createJSDocImplementsTag(tagName, className, parseTrailingTagComments(start, getNodePos(), margin, indentText)), start);
                }
                function parseAugmentsTag(start, tagName, margin, indentText) {
                    var className = parseExpressionWithTypeArgumentsForAugments();
                    return finishNode(factory.createJSDocAugmentsTag(tagName, className, parseTrailingTagComments(start, getNodePos(), margin, indentText)), start);
                }
                function parseExpressionWithTypeArgumentsForAugments() {
                    var usedBrace = parseOptional(18 /* SyntaxKind.OpenBraceToken */);
                    var pos = getNodePos();
                    var expression = parsePropertyAccessEntityNameExpression();
                    var typeArguments = tryParseTypeArguments();
                    var node = factory.createExpressionWithTypeArguments(expression, typeArguments);
                    var res = finishNode(node, pos);
                    if (usedBrace) {
                        parseExpected(19 /* SyntaxKind.CloseBraceToken */);
                    }
                    return res;
                }
                function parsePropertyAccessEntityNameExpression() {
                    var pos = getNodePos();
                    var node = parseJSDocIdentifierName();
                    while (parseOptional(24 /* SyntaxKind.DotToken */)) {
                        var name = parseJSDocIdentifierName();
                        node = finishNode(factory.createPropertyAccessExpression(node, name), pos);
                    }
                    return node;
                }
                function parseSimpleTag(start, createTag, tagName, margin, indentText) {
                    return finishNode(createTag(tagName, parseTrailingTagComments(start, getNodePos(), margin, indentText)), start);
                }
                function parseThisTag(start, tagName, margin, indentText) {
                    var typeExpression = parseJSDocTypeExpression(/*mayOmitBraces*/ true);
                    skipWhitespace();
                    return finishNode(factory.createJSDocThisTag(tagName, typeExpression, parseTrailingTagComments(start, getNodePos(), margin, indentText)), start);
                }
                function parseEnumTag(start, tagName, margin, indentText) {
                    var typeExpression = parseJSDocTypeExpression(/*mayOmitBraces*/ true);
                    skipWhitespace();
                    return finishNode(factory.createJSDocEnumTag(tagName, typeExpression, parseTrailingTagComments(start, getNodePos(), margin, indentText)), start);
                }
                function parseTypedefTag(start, tagName, indent, indentText) {
                    var _a;
                    var typeExpression = tryParseTypeExpression();
                    skipWhitespaceOrAsterisk();
                    var fullName = parseJSDocTypeNameWithNamespace();
                    skipWhitespace();
                    var comment = parseTagComments(indent);
                    var end;
                    if (!typeExpression || isObjectOrObjectArrayTypeReference(typeExpression.type)) {
                        var child = void 0;
                        var childTypeTag = void 0;
                        var jsDocPropertyTags = void 0;
                        var hasChildren = false;
                        while (child = tryParse(function () { return parseChildPropertyTag(indent); })) {
                            hasChildren = true;
                            if (child.kind === 343 /* SyntaxKind.JSDocTypeTag */) {
                                if (childTypeTag) {
                                    var lastError = parseErrorAtCurrentToken(ts.Diagnostics.A_JSDoc_typedef_comment_may_not_contain_multiple_type_tags);
                                    if (lastError) {
                                        ts.addRelatedInfo(lastError, ts.createDetachedDiagnostic(fileName, 0, 0, ts.Diagnostics.The_tag_was_first_specified_here));
                                    }
                                    break;
                                }
                                else {
                                    childTypeTag = child;
                                }
                            }
                            else {
                                jsDocPropertyTags = ts.append(jsDocPropertyTags, child);
                            }
                        }
                        if (hasChildren) {
                            var isArrayType = typeExpression && typeExpression.type.kind === 183 /* SyntaxKind.ArrayType */;
                            var jsdocTypeLiteral = factory.createJSDocTypeLiteral(jsDocPropertyTags, isArrayType);
                            typeExpression = childTypeTag && childTypeTag.typeExpression && !isObjectOrObjectArrayTypeReference(childTypeTag.typeExpression.type) ?
                                childTypeTag.typeExpression :
                                finishNode(jsdocTypeLiteral, start);
                            end = typeExpression.end;
                        }
                    }
                    // Only include the characters between the name end and the next token if a comment was actually parsed out - otherwise it's just whitespace
                    end = end || comment !== undefined ?
                        getNodePos() :
                        ((_a = fullName !== null && fullName !== void 0 ? fullName : typeExpression) !== null && _a !== void 0 ? _a : tagName).end;
                    if (!comment) {
                        comment = parseTrailingTagComments(start, end, indent, indentText);
                    }
                    var typedefTag = factory.createJSDocTypedefTag(tagName, typeExpression, fullName, comment);
                    return finishNode(typedefTag, start, end);
                }
                function parseJSDocTypeNameWithNamespace(nested) {
                    var pos = scanner.getTokenPos();
                    if (!ts.tokenIsIdentifierOrKeyword(token())) {
                        return undefined;
                    }
                    var typeNameOrNamespaceName = parseJSDocIdentifierName();
                    if (parseOptional(24 /* SyntaxKind.DotToken */)) {
                        var body = parseJSDocTypeNameWithNamespace(/*nested*/ true);
                        var jsDocNamespaceNode = factory.createModuleDeclaration(
                        /*modifiers*/ undefined, typeNameOrNamespaceName, body, nested ? 4 /* NodeFlags.NestedNamespace */ : undefined);
                        return finishNode(jsDocNamespaceNode, pos);
                    }
                    if (nested) {
                        typeNameOrNamespaceName.isInJSDocNamespace = true;
                    }
                    return typeNameOrNamespaceName;
                }
                function parseCallbackTagParameters(indent) {
                    var pos = getNodePos();
                    var child;
                    var parameters;
                    while (child = tryParse(function () { return parseChildParameterOrPropertyTag(4 /* PropertyLikeParse.CallbackParameter */, indent); })) {
                        parameters = ts.append(parameters, child);
                    }
                    return createNodeArray(parameters || [], pos);
                }
                function parseCallbackTag(start, tagName, indent, indentText) {
                    var fullName = parseJSDocTypeNameWithNamespace();
                    skipWhitespace();
                    var comment = parseTagComments(indent);
                    var parameters = parseCallbackTagParameters(indent);
                    var returnTag = tryParse(function () {
                        if (parseOptionalJsdoc(59 /* SyntaxKind.AtToken */)) {
                            var tag = parseTag(indent);
                            if (tag && tag.kind === 341 /* SyntaxKind.JSDocReturnTag */) {
                                return tag;
                            }
                        }
                    });
                    var typeExpression = finishNode(factory.createJSDocSignature(/*typeParameters*/ undefined, parameters, returnTag), start);
                    if (!comment) {
                        comment = parseTrailingTagComments(start, getNodePos(), indent, indentText);
                    }
                    var end = comment !== undefined ? getNodePos() : typeExpression.end;
                    return finishNode(factory.createJSDocCallbackTag(tagName, typeExpression, fullName, comment), start, end);
                }
                function escapedTextsEqual(a, b) {
                    while (!ts.isIdentifier(a) || !ts.isIdentifier(b)) {
                        if (!ts.isIdentifier(a) && !ts.isIdentifier(b) && a.right.escapedText === b.right.escapedText) {
                            a = a.left;
                            b = b.left;
                        }
                        else {
                            return false;
                        }
                    }
                    return a.escapedText === b.escapedText;
                }
                function parseChildPropertyTag(indent) {
                    return parseChildParameterOrPropertyTag(1 /* PropertyLikeParse.Property */, indent);
                }
                function parseChildParameterOrPropertyTag(target, indent, name) {
                    var canParseTag = true;
                    var seenAsterisk = false;
                    while (true) {
                        switch (nextTokenJSDoc()) {
                            case 59 /* SyntaxKind.AtToken */:
                                if (canParseTag) {
                                    var child = tryParseChildTag(target, indent);
                                    if (child && (child.kind === 340 /* SyntaxKind.JSDocParameterTag */ || child.kind === 347 /* SyntaxKind.JSDocPropertyTag */) &&
                                        target !== 4 /* PropertyLikeParse.CallbackParameter */ &&
                                        name && (ts.isIdentifier(child.name) || !escapedTextsEqual(name, child.name.left))) {
                                        return false;
                                    }
                                    return child;
                                }
                                seenAsterisk = false;
                                break;
                            case 4 /* SyntaxKind.NewLineTrivia */:
                                canParseTag = true;
                                seenAsterisk = false;
                                break;
                            case 41 /* SyntaxKind.AsteriskToken */:
                                if (seenAsterisk) {
                                    canParseTag = false;
                                }
                                seenAsterisk = true;
                                break;
                            case 79 /* SyntaxKind.Identifier */:
                                canParseTag = false;
                                break;
                            case 1 /* SyntaxKind.EndOfFileToken */:
                                return false;
                        }
                    }
                }
                function tryParseChildTag(target, indent) {
                    ts.Debug.assert(token() === 59 /* SyntaxKind.AtToken */);
                    var start = scanner.getStartPos();
                    nextTokenJSDoc();
                    var tagName = parseJSDocIdentifierName();
                    skipWhitespace();
                    var t;
                    switch (tagName.escapedText) {
                        case "type":
                            return target === 1 /* PropertyLikeParse.Property */ && parseTypeTag(start, tagName);
                        case "prop":
                        case "property":
                            t = 1 /* PropertyLikeParse.Property */;
                            break;
                        case "arg":
                        case "argument":
                        case "param":
                            t = 2 /* PropertyLikeParse.Parameter */ | 4 /* PropertyLikeParse.CallbackParameter */;
                            break;
                        default:
                            return false;
                    }
                    if (!(target & t)) {
                        return false;
                    }
                    return parseParameterOrPropertyTag(start, tagName, target, indent);
                }
                function parseTemplateTagTypeParameter() {
                    var typeParameterPos = getNodePos();
                    var isBracketed = parseOptionalJsdoc(22 /* SyntaxKind.OpenBracketToken */);
                    if (isBracketed) {
                        skipWhitespace();
                    }
                    var name = parseJSDocIdentifierName(ts.Diagnostics.Unexpected_token_A_type_parameter_name_was_expected_without_curly_braces);
                    var defaultType;
                    if (isBracketed) {
                        skipWhitespace();
                        parseExpected(63 /* SyntaxKind.EqualsToken */);
                        defaultType = doInsideOfContext(8388608 /* NodeFlags.JSDoc */, parseJSDocType);
                        parseExpected(23 /* SyntaxKind.CloseBracketToken */);
                    }
                    if (ts.nodeIsMissing(name)) {
                        return undefined;
                    }
                    return finishNode(factory.createTypeParameterDeclaration(/*modifiers*/ undefined, name, /*constraint*/ undefined, defaultType), typeParameterPos);
                }
                function parseTemplateTagTypeParameters() {
                    var pos = getNodePos();
                    var typeParameters = [];
                    do {
                        skipWhitespace();
                        var node = parseTemplateTagTypeParameter();
                        if (node !== undefined) {
                            typeParameters.push(node);
                        }
                        skipWhitespaceOrAsterisk();
                    } while (parseOptionalJsdoc(27 /* SyntaxKind.CommaToken */));
                    return createNodeArray(typeParameters, pos);
                }
                function parseTemplateTag(start, tagName, indent, indentText) {
                    // The template tag looks like one of the following:
                    //   @template T,U,V
                    //   @template {Constraint} T
                    //
                    // According to the [closure docs](https://github.com/google/closure-compiler/wiki/Generic-Types#multiple-bounded-template-types):
                    //   > Multiple bounded generics cannot be declared on the same line. For the sake of clarity, if multiple templates share the same
                    //   > type bound they must be declared on separate lines.
                    //
                    // TODO: Determine whether we should enforce this in the checker.
                    // TODO: Consider moving the `constraint` to the first type parameter as we could then remove `getEffectiveConstraintOfTypeParameter`.
                    // TODO: Consider only parsing a single type parameter if there is a constraint.
                    var constraint = token() === 18 /* SyntaxKind.OpenBraceToken */ ? parseJSDocTypeExpression() : undefined;
                    var typeParameters = parseTemplateTagTypeParameters();
                    return finishNode(factory.createJSDocTemplateTag(tagName, constraint, typeParameters, parseTrailingTagComments(start, getNodePos(), indent, indentText)), start);
                }
                function parseOptionalJsdoc(t) {
                    if (token() === t) {
                        nextTokenJSDoc();
                        return true;
                    }
                    return false;
                }
                function parseJSDocEntityName() {
                    var entity = parseJSDocIdentifierName();
                    if (parseOptional(22 /* SyntaxKind.OpenBracketToken */)) {
                        parseExpected(23 /* SyntaxKind.CloseBracketToken */);
                        // Note that y[] is accepted as an entity name, but the postfix brackets are not saved for checking.
                        // Technically usejsdoc.org requires them for specifying a property of a type equivalent to Array<{ x: ...}>
                        // but it's not worth it to enforce that restriction.
                    }
                    while (parseOptional(24 /* SyntaxKind.DotToken */)) {
                        var name = parseJSDocIdentifierName();
                        if (parseOptional(22 /* SyntaxKind.OpenBracketToken */)) {
                            parseExpected(23 /* SyntaxKind.CloseBracketToken */);
                        }
                        entity = createQualifiedName(entity, name);
                    }
                    return entity;
                }
                function parseJSDocIdentifierName(message) {
                    if (!ts.tokenIsIdentifierOrKeyword(token())) {
                        return createMissingNode(79 /* SyntaxKind.Identifier */, /*reportAtCurrentPosition*/ !message, message || ts.Diagnostics.Identifier_expected);
                    }
                    identifierCount++;
                    var pos = scanner.getTokenPos();
                    var end = scanner.getTextPos();
                    var originalKeywordKind = token();
                    var text = internIdentifier(scanner.getTokenValue());
                    var result = finishNode(factory.createIdentifier(text, /*typeArguments*/ undefined, originalKeywordKind), pos, end);
                    nextTokenJSDoc();
                    return result;
                }
            }
        })(JSDocParser = Parser.JSDocParser || (Parser.JSDocParser = {}));
    })(Parser || (Parser = {}));
    var IncrementalParser;
    (function (IncrementalParser) {
        function updateSourceFile(sourceFile, newText, textChangeRange, aggressiveChecks) {
            aggressiveChecks = aggressiveChecks || ts.Debug.shouldAssert(2 /* AssertionLevel.Aggressive */);
            checkChangeRange(sourceFile, newText, textChangeRange, aggressiveChecks);
            if (ts.textChangeRangeIsUnchanged(textChangeRange)) {
                // if the text didn't change, then we can just return our current source file as-is.
                return sourceFile;
            }
            if (sourceFile.statements.length === 0) {
                // If we don't have any statements in the current source file, then there's no real
                // way to incrementally parse.  So just do a full parse instead.
                return Parser.parseSourceFile(sourceFile.fileName, newText, sourceFile.languageVersion, /*syntaxCursor*/ undefined, /*setParentNodes*/ true, sourceFile.scriptKind, sourceFile.setExternalModuleIndicator);
            }
            // Make sure we're not trying to incrementally update a source file more than once.  Once
            // we do an update the original source file is considered unusable from that point onwards.
            //
            // This is because we do incremental parsing in-place.  i.e. we take nodes from the old
            // tree and give them new positions and parents.  From that point on, trusting the old
            // tree at all is not possible as far too much of it may violate invariants.
            var incrementalSourceFile = sourceFile;
            ts.Debug.assert(!incrementalSourceFile.hasBeenIncrementallyParsed);
            incrementalSourceFile.hasBeenIncrementallyParsed = true;
            Parser.fixupParentReferences(incrementalSourceFile);
            var oldText = sourceFile.text;
            var syntaxCursor = createSyntaxCursor(sourceFile);
            // Make the actual change larger so that we know to reparse anything whose lookahead
            // might have intersected the change.
            var changeRange = extendToAffectedRange(sourceFile, textChangeRange);
            checkChangeRange(sourceFile, newText, changeRange, aggressiveChecks);
            // Ensure that extending the affected range only moved the start of the change range
            // earlier in the file.
            ts.Debug.assert(changeRange.span.start <= textChangeRange.span.start);
            ts.Debug.assert(ts.textSpanEnd(changeRange.span) === ts.textSpanEnd(textChangeRange.span));
            ts.Debug.assert(ts.textSpanEnd(ts.textChangeRangeNewSpan(changeRange)) === ts.textSpanEnd(ts.textChangeRangeNewSpan(textChangeRange)));
            // The is the amount the nodes after the edit range need to be adjusted.  It can be
            // positive (if the edit added characters), negative (if the edit deleted characters)
            // or zero (if this was a pure overwrite with nothing added/removed).
            var delta = ts.textChangeRangeNewSpan(changeRange).length - changeRange.span.length;
            // If we added or removed characters during the edit, then we need to go and adjust all
            // the nodes after the edit.  Those nodes may move forward (if we inserted chars) or they
            // may move backward (if we deleted chars).
            //
            // Doing this helps us out in two ways.  First, it means that any nodes/tokens we want
            // to reuse are already at the appropriate position in the new text.  That way when we
            // reuse them, we don't have to figure out if they need to be adjusted.  Second, it makes
            // it very easy to determine if we can reuse a node.  If the node's position is at where
            // we are in the text, then we can reuse it.  Otherwise we can't.  If the node's position
            // is ahead of us, then we'll need to rescan tokens.  If the node's position is behind
            // us, then we'll need to skip it or crumble it as appropriate
            //
            // We will also adjust the positions of nodes that intersect the change range as well.
            // By doing this, we ensure that all the positions in the old tree are consistent, not
            // just the positions of nodes entirely before/after the change range.  By being
            // consistent, we can then easily map from positions to nodes in the old tree easily.
            //
            // Also, mark any syntax elements that intersect the changed span.  We know, up front,
            // that we cannot reuse these elements.
            updateTokenPositionsAndMarkElements(incrementalSourceFile, changeRange.span.start, ts.textSpanEnd(changeRange.span), ts.textSpanEnd(ts.textChangeRangeNewSpan(changeRange)), delta, oldText, newText, aggressiveChecks);
            // Now that we've set up our internal incremental state just proceed and parse the
            // source file in the normal fashion.  When possible the parser will retrieve and
            // reuse nodes from the old tree.
            //
            // Note: passing in 'true' for setNodeParents is very important.  When incrementally
            // parsing, we will be reusing nodes from the old tree, and placing it into new
            // parents.  If we don't set the parents now, we'll end up with an observably
            // inconsistent tree.  Setting the parents on the new tree should be very fast.  We
            // will immediately bail out of walking any subtrees when we can see that their parents
            // are already correct.
            var result = Parser.parseSourceFile(sourceFile.fileName, newText, sourceFile.languageVersion, syntaxCursor, /*setParentNodes*/ true, sourceFile.scriptKind, sourceFile.setExternalModuleIndicator);
            result.commentDirectives = getNewCommentDirectives(sourceFile.commentDirectives, result.commentDirectives, changeRange.span.start, ts.textSpanEnd(changeRange.span), delta, oldText, newText, aggressiveChecks);
            result.impliedNodeFormat = sourceFile.impliedNodeFormat;
            return result;
        }
        IncrementalParser.updateSourceFile = updateSourceFile;
        function getNewCommentDirectives(oldDirectives, newDirectives, changeStart, changeRangeOldEnd, delta, oldText, newText, aggressiveChecks) {
            if (!oldDirectives)
                return newDirectives;
            var commentDirectives;
            var addedNewlyScannedDirectives = false;
            for (var _i = 0, oldDirectives_1 = oldDirectives; _i < oldDirectives_1.length; _i++) {
                var directive = oldDirectives_1[_i];
                var range = directive.range, type = directive.type;
                // Range before the change
                if (range.end < changeStart) {
                    commentDirectives = ts.append(commentDirectives, directive);
                }
                else if (range.pos > changeRangeOldEnd) {
                    addNewlyScannedDirectives();
                    // Node is entirely past the change range.  We need to move both its pos and
                    // end, forward or backward appropriately.
                    var updatedDirective = {
                        range: { pos: range.pos + delta, end: range.end + delta },
                        type: type
                    };
                    commentDirectives = ts.append(commentDirectives, updatedDirective);
                    if (aggressiveChecks) {
                        ts.Debug.assert(oldText.substring(range.pos, range.end) === newText.substring(updatedDirective.range.pos, updatedDirective.range.end));
                    }
                }
                // Ignore ranges that fall in change range
            }
            addNewlyScannedDirectives();
            return commentDirectives;
            function addNewlyScannedDirectives() {
                if (addedNewlyScannedDirectives)
                    return;
                addedNewlyScannedDirectives = true;
                if (!commentDirectives) {
                    commentDirectives = newDirectives;
                }
                else if (newDirectives) {
                    commentDirectives.push.apply(commentDirectives, newDirectives);
                }
            }
        }
        function moveElementEntirelyPastChangeRange(element, isArray, delta, oldText, newText, aggressiveChecks) {
            if (isArray) {
                visitArray(element);
            }
            else {
                visitNode(element);
            }
            return;
            function visitNode(node) {
                var text = "";
                if (aggressiveChecks && shouldCheckNode(node)) {
                    text = oldText.substring(node.pos, node.end);
                }
                // Ditch any existing LS children we may have created.  This way we can avoid
                // moving them forward.
                if (node._children) {
                    node._children = undefined;
                }
                ts.setTextRangePosEnd(node, node.pos + delta, node.end + delta);
                if (aggressiveChecks && shouldCheckNode(node)) {
                    ts.Debug.assert(text === newText.substring(node.pos, node.end));
                }
                forEachChild(node, visitNode, visitArray);
                if (ts.hasJSDocNodes(node)) {
                    for (var _i = 0, _a = node.jsDoc; _i < _a.length; _i++) {
                        var jsDocComment = _a[_i];
                        visitNode(jsDocComment);
                    }
                }
                checkNodePositions(node, aggressiveChecks);
            }
            function visitArray(array) {
                array._children = undefined;
                ts.setTextRangePosEnd(array, array.pos + delta, array.end + delta);
                for (var _i = 0, array_9 = array; _i < array_9.length; _i++) {
                    var node = array_9[_i];
                    visitNode(node);
                }
            }
        }
        function shouldCheckNode(node) {
            switch (node.kind) {
                case 10 /* SyntaxKind.StringLiteral */:
                case 8 /* SyntaxKind.NumericLiteral */:
                case 79 /* SyntaxKind.Identifier */:
                    return true;
            }
            return false;
        }
        function adjustIntersectingElement(element, changeStart, changeRangeOldEnd, changeRangeNewEnd, delta) {
            ts.Debug.assert(element.end >= changeStart, "Adjusting an element that was entirely before the change range");
            ts.Debug.assert(element.pos <= changeRangeOldEnd, "Adjusting an element that was entirely after the change range");
            ts.Debug.assert(element.pos <= element.end);
            // We have an element that intersects the change range in some way.  It may have its
            // start, or its end (or both) in the changed range.  We want to adjust any part
            // that intersects such that the final tree is in a consistent state.  i.e. all
            // children have spans within the span of their parent, and all siblings are ordered
            // properly.
            // We may need to update both the 'pos' and the 'end' of the element.
            // If the 'pos' is before the start of the change, then we don't need to touch it.
            // If it isn't, then the 'pos' must be inside the change.  How we update it will
            // depend if delta is positive or negative. If delta is positive then we have
            // something like:
            //
            //  -------------------AAA-----------------
            //  -------------------BBBCCCCCCC-----------------
            //
            // In this case, we consider any node that started in the change range to still be
            // starting at the same position.
            //
            // however, if the delta is negative, then we instead have something like this:
            //
            //  -------------------XXXYYYYYYY-----------------
            //  -------------------ZZZ-----------------
            //
            // In this case, any element that started in the 'X' range will keep its position.
            // However any element that started after that will have their pos adjusted to be
            // at the end of the new range.  i.e. any node that started in the 'Y' range will
            // be adjusted to have their start at the end of the 'Z' range.
            //
            // The element will keep its position if possible.  Or Move backward to the new-end
            // if it's in the 'Y' range.
            var pos = Math.min(element.pos, changeRangeNewEnd);
            // If the 'end' is after the change range, then we always adjust it by the delta
            // amount.  However, if the end is in the change range, then how we adjust it
            // will depend on if delta is positive or negative.  If delta is positive then we
            // have something like:
            //
            //  -------------------AAA-----------------
            //  -------------------BBBCCCCCCC-----------------
            //
            // In this case, we consider any node that ended inside the change range to keep its
            // end position.
            //
            // however, if the delta is negative, then we instead have something like this:
            //
            //  -------------------XXXYYYYYYY-----------------
            //  -------------------ZZZ-----------------
            //
            // In this case, any element that ended in the 'X' range will keep its position.
            // However any element that ended after that will have their pos adjusted to be
            // at the end of the new range.  i.e. any node that ended in the 'Y' range will
            // be adjusted to have their end at the end of the 'Z' range.
            var end = element.end >= changeRangeOldEnd ?
                // Element ends after the change range.  Always adjust the end pos.
                element.end + delta :
                // Element ends in the change range.  The element will keep its position if
                // possible. Or Move backward to the new-end if it's in the 'Y' range.
                Math.min(element.end, changeRangeNewEnd);
            ts.Debug.assert(pos <= end);
            if (element.parent) {
                ts.Debug.assertGreaterThanOrEqual(pos, element.parent.pos);
                ts.Debug.assertLessThanOrEqual(end, element.parent.end);
            }
            ts.setTextRangePosEnd(element, pos, end);
        }
        function checkNodePositions(node, aggressiveChecks) {
            if (aggressiveChecks) {
                var pos_3 = node.pos;
                var visitNode_1 = function (child) {
                    ts.Debug.assert(child.pos >= pos_3);
                    pos_3 = child.end;
                };
                if (ts.hasJSDocNodes(node)) {
                    for (var _i = 0, _a = node.jsDoc; _i < _a.length; _i++) {
                        var jsDocComment = _a[_i];
                        visitNode_1(jsDocComment);
                    }
                }
                forEachChild(node, visitNode_1);
                ts.Debug.assert(pos_3 <= node.end);
            }
        }
        function updateTokenPositionsAndMarkElements(sourceFile, changeStart, changeRangeOldEnd, changeRangeNewEnd, delta, oldText, newText, aggressiveChecks) {
            visitNode(sourceFile);
            return;
            function visitNode(child) {
                ts.Debug.assert(child.pos <= child.end);
                if (child.pos > changeRangeOldEnd) {
                    // Node is entirely past the change range.  We need to move both its pos and
                    // end, forward or backward appropriately.
                    moveElementEntirelyPastChangeRange(child, /*isArray*/ false, delta, oldText, newText, aggressiveChecks);
                    return;
                }
                // Check if the element intersects the change range.  If it does, then it is not
                // reusable.  Also, we'll need to recurse to see what constituent portions we may
                // be able to use.
                var fullEnd = child.end;
                if (fullEnd >= changeStart) {
                    child.intersectsChange = true;
                    child._children = undefined;
                    // Adjust the pos or end (or both) of the intersecting element accordingly.
                    adjustIntersectingElement(child, changeStart, changeRangeOldEnd, changeRangeNewEnd, delta);
                    forEachChild(child, visitNode, visitArray);
                    if (ts.hasJSDocNodes(child)) {
                        for (var _i = 0, _a = child.jsDoc; _i < _a.length; _i++) {
                            var jsDocComment = _a[_i];
                            visitNode(jsDocComment);
                        }
                    }
                    checkNodePositions(child, aggressiveChecks);
                    return;
                }
                // Otherwise, the node is entirely before the change range.  No need to do anything with it.
                ts.Debug.assert(fullEnd < changeStart);
            }
            function visitArray(array) {
                ts.Debug.assert(array.pos <= array.end);
                if (array.pos > changeRangeOldEnd) {
                    // Array is entirely after the change range.  We need to move it, and move any of
                    // its children.
                    moveElementEntirelyPastChangeRange(array, /*isArray*/ true, delta, oldText, newText, aggressiveChecks);
                    return;
                }
                // Check if the element intersects the change range.  If it does, then it is not
                // reusable.  Also, we'll need to recurse to see what constituent portions we may
                // be able to use.
                var fullEnd = array.end;
                if (fullEnd >= changeStart) {
                    array.intersectsChange = true;
                    array._children = undefined;
                    // Adjust the pos or end (or both) of the intersecting array accordingly.
                    adjustIntersectingElement(array, changeStart, changeRangeOldEnd, changeRangeNewEnd, delta);
                    for (var _i = 0, array_10 = array; _i < array_10.length; _i++) {
                        var node = array_10[_i];
                        visitNode(node);
                    }
                    return;
                }
                // Otherwise, the array is entirely before the change range.  No need to do anything with it.
                ts.Debug.assert(fullEnd < changeStart);
            }
        }
        function extendToAffectedRange(sourceFile, changeRange) {
            // Consider the following code:
            //      void foo() { /; }
            //
            // If the text changes with an insertion of / just before the semicolon then we end up with:
            //      void foo() { //; }
            //
            // If we were to just use the changeRange a is, then we would not rescan the { token
            // (as it does not intersect the actual original change range).  Because an edit may
            // change the token touching it, we actually need to look back *at least* one token so
            // that the prior token sees that change.
            var maxLookahead = 1;
            var start = changeRange.span.start;
            // the first iteration aligns us with the change start. subsequent iteration move us to
            // the left by maxLookahead tokens.  We only need to do this as long as we're not at the
            // start of the tree.
            for (var i = 0; start > 0 && i <= maxLookahead; i++) {
                var nearestNode = findNearestNodeStartingBeforeOrAtPosition(sourceFile, start);
                ts.Debug.assert(nearestNode.pos <= start);
                var position = nearestNode.pos;
                start = Math.max(0, position - 1);
            }
            var finalSpan = ts.createTextSpanFromBounds(start, ts.textSpanEnd(changeRange.span));
            var finalLength = changeRange.newLength + (changeRange.span.start - start);
            return ts.createTextChangeRange(finalSpan, finalLength);
        }
        function findNearestNodeStartingBeforeOrAtPosition(sourceFile, position) {
            var bestResult = sourceFile;
            var lastNodeEntirelyBeforePosition;
            forEachChild(sourceFile, visit);
            if (lastNodeEntirelyBeforePosition) {
                var lastChildOfLastEntireNodeBeforePosition = getLastDescendant(lastNodeEntirelyBeforePosition);
                if (lastChildOfLastEntireNodeBeforePosition.pos > bestResult.pos) {
                    bestResult = lastChildOfLastEntireNodeBeforePosition;
                }
            }
            return bestResult;
            function getLastDescendant(node) {
                while (true) {
                    var lastChild = ts.getLastChild(node);
                    if (lastChild) {
                        node = lastChild;
                    }
                    else {
                        return node;
                    }
                }
            }
            function visit(child) {
                if (ts.nodeIsMissing(child)) {
                    // Missing nodes are effectively invisible to us.  We never even consider them
                    // When trying to find the nearest node before us.
                    return;
                }
                // If the child intersects this position, then this node is currently the nearest
                // node that starts before the position.
                if (child.pos <= position) {
                    if (child.pos >= bestResult.pos) {
                        // This node starts before the position, and is closer to the position than
                        // the previous best node we found.  It is now the new best node.
                        bestResult = child;
                    }
                    // Now, the node may overlap the position, or it may end entirely before the
                    // position.  If it overlaps with the position, then either it, or one of its
                    // children must be the nearest node before the position.  So we can just
                    // recurse into this child to see if we can find something better.
                    if (position < child.end) {
                        // The nearest node is either this child, or one of the children inside
                        // of it.  We've already marked this child as the best so far.  Recurse
                        // in case one of the children is better.
                        forEachChild(child, visit);
                        // Once we look at the children of this node, then there's no need to
                        // continue any further.
                        return true;
                    }
                    else {
                        ts.Debug.assert(child.end <= position);
                        // The child ends entirely before this position.  Say you have the following
                        // (where $ is the position)
                        //
                        //      <complex expr 1> ? <complex expr 2> $ : <...> <...>
                        //
                        // We would want to find the nearest preceding node in "complex expr 2".
                        // To support that, we keep track of this node, and once we're done searching
                        // for a best node, we recurse down this node to see if we can find a good
                        // result in it.
                        //
                        // This approach allows us to quickly skip over nodes that are entirely
                        // before the position, while still allowing us to find any nodes in the
                        // last one that might be what we want.
                        lastNodeEntirelyBeforePosition = child;
                    }
                }
                else {
                    ts.Debug.assert(child.pos > position);
                    // We're now at a node that is entirely past the position we're searching for.
                    // This node (and all following nodes) could never contribute to the result,
                    // so just skip them by returning 'true' here.
                    return true;
                }
            }
        }
        function checkChangeRange(sourceFile, newText, textChangeRange, aggressiveChecks) {
            var oldText = sourceFile.text;
            if (textChangeRange) {
                ts.Debug.assert((oldText.length - textChangeRange.span.length + textChangeRange.newLength) === newText.length);
                if (aggressiveChecks || ts.Debug.shouldAssert(3 /* AssertionLevel.VeryAggressive */)) {
                    var oldTextPrefix = oldText.substr(0, textChangeRange.span.start);
                    var newTextPrefix = newText.substr(0, textChangeRange.span.start);
                    ts.Debug.assert(oldTextPrefix === newTextPrefix);
                    var oldTextSuffix = oldText.substring(ts.textSpanEnd(textChangeRange.span), oldText.length);
                    var newTextSuffix = newText.substring(ts.textSpanEnd(ts.textChangeRangeNewSpan(textChangeRange)), newText.length);
                    ts.Debug.assert(oldTextSuffix === newTextSuffix);
                }
            }
        }
        function createSyntaxCursor(sourceFile) {
            var currentArray = sourceFile.statements;
            var currentArrayIndex = 0;
            ts.Debug.assert(currentArrayIndex < currentArray.length);
            var current = currentArray[currentArrayIndex];
            var lastQueriedPosition = -1 /* InvalidPosition.Value */;
            return {
                currentNode: function (position) {
                    // Only compute the current node if the position is different than the last time
                    // we were asked.  The parser commonly asks for the node at the same position
                    // twice.  Once to know if can read an appropriate list element at a certain point,
                    // and then to actually read and consume the node.
                    if (position !== lastQueriedPosition) {
                        // Much of the time the parser will need the very next node in the array that
                        // we just returned a node from.So just simply check for that case and move
                        // forward in the array instead of searching for the node again.
                        if (current && current.end === position && currentArrayIndex < (currentArray.length - 1)) {
                            currentArrayIndex++;
                            current = currentArray[currentArrayIndex];
                        }
                        // If we don't have a node, or the node we have isn't in the right position,
                        // then try to find a viable node at the position requested.
                        if (!current || current.pos !== position) {
                            findHighestListElementThatStartsAtPosition(position);
                        }
                    }
                    // Cache this query so that we don't do any extra work if the parser calls back
                    // into us.  Note: this is very common as the parser will make pairs of calls like
                    // 'isListElement -> parseListElement'.  If we were unable to find a node when
                    // called with 'isListElement', we don't want to redo the work when parseListElement
                    // is called immediately after.
                    lastQueriedPosition = position;
                    // Either we don'd have a node, or we have a node at the position being asked for.
                    ts.Debug.assert(!current || current.pos === position);
                    return current;
                }
            };
            // Finds the highest element in the tree we can find that starts at the provided position.
            // The element must be a direct child of some node list in the tree.  This way after we
            // return it, we can easily return its next sibling in the list.
            function findHighestListElementThatStartsAtPosition(position) {
                // Clear out any cached state about the last node we found.
                currentArray = undefined;
                currentArrayIndex = -1 /* InvalidPosition.Value */;
                current = undefined;
                // Recurse into the source file to find the highest node at this position.
                forEachChild(sourceFile, visitNode, visitArray);
                return;
                function visitNode(node) {
                    if (position >= node.pos && position < node.end) {
                        // Position was within this node.  Keep searching deeper to find the node.
                        forEachChild(node, visitNode, visitArray);
                        // don't proceed any further in the search.
                        return true;
                    }
                    // position wasn't in this node, have to keep searching.
                    return false;
                }
                function visitArray(array) {
                    if (position >= array.pos && position < array.end) {
                        // position was in this array.  Search through this array to see if we find a
                        // viable element.
                        for (var i = 0; i < array.length; i++) {
                            var child = array[i];
                            if (child) {
                                if (child.pos === position) {
                                    // Found the right node.  We're done.
                                    currentArray = array;
                                    currentArrayIndex = i;
                                    current = child;
                                    return true;
                                }
                                else {
                                    if (child.pos < position && position < child.end) {
                                        // Position in somewhere within this child.  Search in it and
                                        // stop searching in this array.
                                        forEachChild(child, visitNode, visitArray);
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                    // position wasn't in this array, have to keep searching.
                    return false;
                }
            }
        }
        IncrementalParser.createSyntaxCursor = createSyntaxCursor;
        var InvalidPosition;
        (function (InvalidPosition) {
            InvalidPosition[InvalidPosition["Value"] = -1] = "Value";
        })(InvalidPosition || (InvalidPosition = {}));
    })(IncrementalParser || (IncrementalParser = {}));
    /** @internal */
    function isDeclarationFileName(fileName) {
        return ts.fileExtensionIsOneOf(fileName, ts.supportedDeclarationExtensions);
    }
    ts.isDeclarationFileName = isDeclarationFileName;
    function parseResolutionMode(mode, pos, end, reportDiagnostic) {
        if (!mode) {
            return undefined;
        }
        if (mode === "import") {
            return ts.ModuleKind.ESNext;
        }
        if (mode === "require") {
            return ts.ModuleKind.CommonJS;
        }
        reportDiagnostic(pos, end - pos, ts.Diagnostics.resolution_mode_should_be_either_require_or_import);
        return undefined;
    }
    /*@internal*/
    function processCommentPragmas(context, sourceText) {
        var pragmas = [];
        for (var _i = 0, _a = ts.getLeadingCommentRanges(sourceText, 0) || ts.emptyArray; _i < _a.length; _i++) {
            var range = _a[_i];
            var comment = sourceText.substring(range.pos, range.end);
            extractPragmas(pragmas, range, comment);
        }
        context.pragmas = new ts.Map();
        for (var _b = 0, pragmas_1 = pragmas; _b < pragmas_1.length; _b++) {
            var pragma = pragmas_1[_b];
            if (context.pragmas.has(pragma.name)) {
                var currentValue = context.pragmas.get(pragma.name);
                if (currentValue instanceof Array) {
                    currentValue.push(pragma.args);
                }
                else {
                    context.pragmas.set(pragma.name, [currentValue, pragma.args]);
                }
                continue;
            }
            context.pragmas.set(pragma.name, pragma.args);
        }
    }
    ts.processCommentPragmas = processCommentPragmas;
    /*@internal*/
    function processPragmasIntoFields(context, reportDiagnostic) {
        context.checkJsDirective = undefined;
        context.referencedFiles = [];
        context.typeReferenceDirectives = [];
        context.libReferenceDirectives = [];
        context.amdDependencies = [];
        context.hasNoDefaultLib = false;
        context.pragmas.forEach(function (entryOrList, key) {
            // TODO: The below should be strongly type-guarded and not need casts/explicit annotations, since entryOrList is related to
            // key and key is constrained to a union; but it's not (see GH#21483 for at least partial fix) :(
            switch (key) {
                case "reference": {
                    var referencedFiles_1 = context.referencedFiles;
                    var typeReferenceDirectives_1 = context.typeReferenceDirectives;
                    var libReferenceDirectives_1 = context.libReferenceDirectives;
                    ts.forEach(ts.toArray(entryOrList), function (arg) {
                        var _a = arg.arguments, types = _a.types, lib = _a.lib, path = _a.path, res = _a["resolution-mode"];
                        if (arg.arguments["no-default-lib"]) {
                            context.hasNoDefaultLib = true;
                        }
                        else if (types) {
                            var parsed = parseResolutionMode(res, types.pos, types.end, reportDiagnostic);
                            typeReferenceDirectives_1.push(__assign({ pos: types.pos, end: types.end, fileName: types.value }, (parsed ? { resolutionMode: parsed } : {})));
                        }
                        else if (lib) {
                            libReferenceDirectives_1.push({ pos: lib.pos, end: lib.end, fileName: lib.value });
                        }
                        else if (path) {
                            referencedFiles_1.push({ pos: path.pos, end: path.end, fileName: path.value });
                        }
                        else {
                            reportDiagnostic(arg.range.pos, arg.range.end - arg.range.pos, ts.Diagnostics.Invalid_reference_directive_syntax);
                        }
                    });
                    break;
                }
                case "amd-dependency": {
                    context.amdDependencies = ts.map(ts.toArray(entryOrList), function (x) { return ({ name: x.arguments.name, path: x.arguments.path }); });
                    break;
                }
                case "amd-module": {
                    if (entryOrList instanceof Array) {
                        for (var _i = 0, entryOrList_1 = entryOrList; _i < entryOrList_1.length; _i++) {
                            var entry = entryOrList_1[_i];
                            if (context.moduleName) {
                                // TODO: It's probably fine to issue this diagnostic on all instances of the pragma
                                reportDiagnostic(entry.range.pos, entry.range.end - entry.range.pos, ts.Diagnostics.An_AMD_module_cannot_have_multiple_name_assignments);
                            }
                            context.moduleName = entry.arguments.name;
                        }
                    }
                    else {
                        context.moduleName = entryOrList.arguments.name;
                    }
                    break;
                }
                case "ts-nocheck":
                case "ts-check": {
                    // _last_ of either nocheck or check in a file is the "winner"
                    ts.forEach(ts.toArray(entryOrList), function (entry) {
                        if (!context.checkJsDirective || entry.range.pos > context.checkJsDirective.pos) {
                            context.checkJsDirective = {
                                enabled: key === "ts-check",
                                end: entry.range.end,
                                pos: entry.range.pos
                            };
                        }
                    });
                    break;
                }
                case "jsx":
                case "jsxfrag":
                case "jsximportsource":
                case "jsxruntime":
                    return; // Accessed directly
                default: ts.Debug.fail("Unhandled pragma kind"); // Can this be made into an assertNever in the future?
            }
        });
    }
    ts.processPragmasIntoFields = processPragmasIntoFields;
    var namedArgRegExCache = new ts.Map();
    function getNamedArgRegEx(name) {
        if (namedArgRegExCache.has(name)) {
            return namedArgRegExCache.get(name);
        }
        var result = new RegExp("(\\s".concat(name, "\\s*=\\s*)(?:(?:'([^']*)')|(?:\"([^\"]*)\"))"), "im");
        namedArgRegExCache.set(name, result);
        return result;
    }
    var tripleSlashXMLCommentStartRegEx = /^\/\/\/\s*<(\S+)\s.*?\/>/im;
    var singleLinePragmaRegEx = /^\/\/\/?\s*@(\S+)\s*(.*)\s*$/im;
    function extractPragmas(pragmas, range, text) {
        var tripleSlash = range.kind === 2 /* SyntaxKind.SingleLineCommentTrivia */ && tripleSlashXMLCommentStartRegEx.exec(text);
        if (tripleSlash) {
            var name = tripleSlash[1].toLowerCase(); // Technically unsafe cast, but we do it so the below check to make it safe typechecks
            var pragma = ts.commentPragmas[name];
            if (!pragma || !(pragma.kind & 1 /* PragmaKindFlags.TripleSlashXML */)) {
                return;
            }
            if (pragma.args) {
                var argument = {};
                for (var _i = 0, _a = pragma.args; _i < _a.length; _i++) {
                    var arg = _a[_i];
                    var matcher = getNamedArgRegEx(arg.name);
                    var matchResult = matcher.exec(text);
                    if (!matchResult && !arg.optional) {
                        return; // Missing required argument, don't parse
                    }
                    else if (matchResult) {
                        var value = matchResult[2] || matchResult[3];
                        if (arg.captureSpan) {
                            var startPos = range.pos + matchResult.index + matchResult[1].length + 1;
                            argument[arg.name] = {
                                value: value,
                                pos: startPos,
                                end: startPos + value.length
                            };
                        }
                        else {
                            argument[arg.name] = value;
                        }
                    }
                }
                pragmas.push({ name: name, args: { arguments: argument, range: range } });
            }
            else {
                pragmas.push({ name: name, args: { arguments: {}, range: range } });
            }
            return;
        }
        var singleLine = range.kind === 2 /* SyntaxKind.SingleLineCommentTrivia */ && singleLinePragmaRegEx.exec(text);
        if (singleLine) {
            return addPragmaForMatch(pragmas, range, 2 /* PragmaKindFlags.SingleLine */, singleLine);
        }
        if (range.kind === 3 /* SyntaxKind.MultiLineCommentTrivia */) {
            var multiLinePragmaRegEx = /@(\S+)(\s+.*)?$/gim; // Defined inline since it uses the "g" flag, which keeps a persistent index (for iterating)
            var multiLineMatch = void 0;
            while (multiLineMatch = multiLinePragmaRegEx.exec(text)) {
                addPragmaForMatch(pragmas, range, 4 /* PragmaKindFlags.MultiLine */, multiLineMatch);
            }
        }
    }
    function addPragmaForMatch(pragmas, range, kind, match) {
        if (!match)
            return;
        var name = match[1].toLowerCase(); // Technically unsafe cast, but we do it so they below check to make it safe typechecks
        var pragma = ts.commentPragmas[name];
        if (!pragma || !(pragma.kind & kind)) {
            return;
        }
        var args = match[2]; // Split on spaces and match up positionally with definition
        var argument = getNamedPragmaArguments(pragma, args);
        if (argument === "fail")
            return; // Missing required argument, fail to parse it
        pragmas.push({ name: name, args: { arguments: argument, range: range } });
        return;
    }
    function getNamedPragmaArguments(pragma, text) {
        if (!text)
            return {};
        if (!pragma.args)
            return {};
        var args = ts.trimString(text).split(/\s+/);
        var argMap = {};
        for (var i = 0; i < pragma.args.length; i++) {
            var argument = pragma.args[i];
            if (!args[i] && !argument.optional) {
                return "fail";
            }
            if (argument.captureSpan) {
                return ts.Debug.fail("Capture spans not yet implemented for non-xml pragmas");
            }
            argMap[argument.name] = args[i];
        }
        return argMap;
    }
    /** @internal */
    function tagNamesAreEquivalent(lhs, rhs) {
        if (lhs.kind !== rhs.kind) {
            return false;
        }
        if (lhs.kind === 79 /* SyntaxKind.Identifier */) {
            return lhs.escapedText === rhs.escapedText;
        }
        if (lhs.kind === 108 /* SyntaxKind.ThisKeyword */) {
            return true;
        }
        // If we are at this statement then we must have PropertyAccessExpression and because tag name in Jsx element can only
        // take forms of JsxTagNameExpression which includes an identifier, "this" expression, or another propertyAccessExpression
        // it is safe to case the expression property as such. See parseJsxElementName for how we parse tag name in Jsx element
        return lhs.name.escapedText === rhs.name.escapedText &&
            tagNamesAreEquivalent(lhs.expression, rhs.expression);
    }
    ts.tagNamesAreEquivalent = tagNamesAreEquivalent;
})(ts || (ts = {}));
var ts;
(function (ts) {
    /* @internal */
    ts.compileOnSaveCommandLineOption = {
        name: "compileOnSave",
        type: "boolean",
        defaultValueDescription: false,
    };
    var jsxOptionMap = new ts.Map(ts.getEntries({
        "preserve": 1 /* JsxEmit.Preserve */,
        "react-native": 3 /* JsxEmit.ReactNative */,
        "react": 2 /* JsxEmit.React */,
        "react-jsx": 4 /* JsxEmit.ReactJSX */,
        "react-jsxdev": 5 /* JsxEmit.ReactJSXDev */,
    }));
    /* @internal */
    ts.inverseJsxOptionMap = new ts.Map(ts.arrayFrom(ts.mapIterator(jsxOptionMap.entries(), function (_a) {
        var key = _a[0], value = _a[1];
        return ["" + value, key];
    })));
    // NOTE: The order here is important to default lib ordering as entries will have the same
    //       order in the generated program (see `getDefaultLibPriority` in program.ts). This
    //       order also affects overload resolution when a type declared in one lib is
    //       augmented in another lib.
    var libEntries = [
        // JavaScript only
        ["es5", "lib.es5.d.ts"],
        ["es6", "lib.es2015.d.ts"],
        ["es2015", "lib.es2015.d.ts"],
        ["es7", "lib.es2016.d.ts"],
        ["es2016", "lib.es2016.d.ts"],
        ["es2017", "lib.es2017.d.ts"],
        ["es2018", "lib.es2018.d.ts"],
        ["es2019", "lib.es2019.d.ts"],
        ["es2020", "lib.es2020.d.ts"],
        ["es2021", "lib.es2021.d.ts"],
        ["es2022", "lib.es2022.d.ts"],
        ["esnext", "lib.esnext.d.ts"],
        // Host only
        ["dom", "lib.dom.d.ts"],
        ["dom.iterable", "lib.dom.iterable.d.ts"],
        ["webworker", "lib.webworker.d.ts"],
        ["webworker.importscripts", "lib.webworker.importscripts.d.ts"],
        ["webworker.iterable", "lib.webworker.iterable.d.ts"],
        ["scripthost", "lib.scripthost.d.ts"],
        // ES2015 Or ESNext By-feature options
        ["es2015.core", "lib.es2015.core.d.ts"],
        ["es2015.collection", "lib.es2015.collection.d.ts"],
        ["es2015.generator", "lib.es2015.generator.d.ts"],
        ["es2015.iterable", "lib.es2015.iterable.d.ts"],
        ["es2015.promise", "lib.es2015.promise.d.ts"],
        ["es2015.proxy", "lib.es2015.proxy.d.ts"],
        ["es2015.reflect", "lib.es2015.reflect.d.ts"],
        ["es2015.symbol", "lib.es2015.symbol.d.ts"],
        ["es2015.symbol.wellknown", "lib.es2015.symbol.wellknown.d.ts"],
        ["es2016.array.include", "lib.es2016.array.include.d.ts"],
        ["es2017.object", "lib.es2017.object.d.ts"],
        ["es2017.sharedmemory", "lib.es2017.sharedmemory.d.ts"],
        ["es2017.string", "lib.es2017.string.d.ts"],
        ["es2017.intl", "lib.es2017.intl.d.ts"],
        ["es2017.typedarrays", "lib.es2017.typedarrays.d.ts"],
        ["es2018.asyncgenerator", "lib.es2018.asyncgenerator.d.ts"],
        ["es2018.asynciterable", "lib.es2018.asynciterable.d.ts"],
        ["es2018.intl", "lib.es2018.intl.d.ts"],
        ["es2018.promise", "lib.es2018.promise.d.ts"],
        ["es2018.regexp", "lib.es2018.regexp.d.ts"],
        ["es2019.array", "lib.es2019.array.d.ts"],
        ["es2019.object", "lib.es2019.object.d.ts"],
        ["es2019.string", "lib.es2019.string.d.ts"],
        ["es2019.symbol", "lib.es2019.symbol.d.ts"],
        ["es2020.bigint", "lib.es2020.bigint.d.ts"],
        ["es2020.date", "lib.es2020.date.d.ts"],
        ["es2020.promise", "lib.es2020.promise.d.ts"],
        ["es2020.sharedmemory", "lib.es2020.sharedmemory.d.ts"],
        ["es2020.string", "lib.es2020.string.d.ts"],
        ["es2020.symbol.wellknown", "lib.es2020.symbol.wellknown.d.ts"],
        ["es2020.intl", "lib.es2020.intl.d.ts"],
        ["es2020.number", "lib.es2020.number.d.ts"],
        ["es2021.promise", "lib.es2021.promise.d.ts"],
        ["es2021.string", "lib.es2021.string.d.ts"],
        ["es2021.weakref", "lib.es2021.weakref.d.ts"],
        ["es2021.intl", "lib.es2021.intl.d.ts"],
        ["es2022.array", "lib.es2022.array.d.ts"],
        ["es2022.error", "lib.es2022.error.d.ts"],
        ["es2022.intl", "lib.es2022.intl.d.ts"],
        ["es2022.object", "lib.es2022.object.d.ts"],
        ["es2022.sharedmemory", "lib.es2022.sharedmemory.d.ts"],
        ["es2022.string", "lib.es2022.string.d.ts"],
        ["esnext.array", "lib.es2022.array.d.ts"],
        ["esnext.symbol", "lib.es2019.symbol.d.ts"],
        ["esnext.asynciterable", "lib.es2018.asynciterable.d.ts"],
        ["esnext.intl", "lib.esnext.intl.d.ts"],
        ["esnext.bigint", "lib.es2020.bigint.d.ts"],
        ["esnext.string", "lib.es2022.string.d.ts"],
        ["esnext.promise", "lib.es2021.promise.d.ts"],
        ["esnext.weakref", "lib.es2021.weakref.d.ts"]
    ];
    /**
     * An array of supported "lib" reference file names used to determine the order for inclusion
     * when referenced, as well as for spelling suggestions. This ensures the correct ordering for
     * overload resolution when a type declared in one lib is extended by another.
     */
    /* @internal */
    ts.libs = libEntries.map(function (entry) { return entry[0]; });
    /**
     * A map of lib names to lib files. This map is used both for parsing the "lib" command line
     * option as well as for resolving lib reference directives.
     */
    /* @internal */
    ts.libMap = new ts.Map(libEntries);
    // Watch related options
    /* @internal */
    ts.optionsForWatch = [
        {
            name: "watchFile",
            type: new ts.Map(ts.getEntries({
                fixedpollinginterval: ts.WatchFileKind.FixedPollingInterval,
                prioritypollinginterval: ts.WatchFileKind.PriorityPollingInterval,
                dynamicprioritypolling: ts.WatchFileKind.DynamicPriorityPolling,
                fixedchunksizepolling: ts.WatchFileKind.FixedChunkSizePolling,
                usefsevents: ts.WatchFileKind.UseFsEvents,
                usefseventsonparentdirectory: ts.WatchFileKind.UseFsEventsOnParentDirectory,
            })),
            category: ts.Diagnostics.Watch_and_Build_Modes,
            description: ts.Diagnostics.Specify_how_the_TypeScript_watch_mode_works,
            defaultValueDescription: ts.WatchFileKind.UseFsEvents,
        },
        {
            name: "watchDirectory",
            type: new ts.Map(ts.getEntries({
                usefsevents: ts.WatchDirectoryKind.UseFsEvents,
                fixedpollinginterval: ts.WatchDirectoryKind.FixedPollingInterval,
                dynamicprioritypolling: ts.WatchDirectoryKind.DynamicPriorityPolling,
                fixedchunksizepolling: ts.WatchDirectoryKind.FixedChunkSizePolling,
            })),
            category: ts.Diagnostics.Watch_and_Build_Modes,
            description: ts.Diagnostics.Specify_how_directories_are_watched_on_systems_that_lack_recursive_file_watching_functionality,
            defaultValueDescription: ts.WatchDirectoryKind.UseFsEvents,
        },
        {
            name: "fallbackPolling",
            type: new ts.Map(ts.getEntries({
                fixedinterval: ts.PollingWatchKind.FixedInterval,
                priorityinterval: ts.PollingWatchKind.PriorityInterval,
                dynamicpriority: ts.PollingWatchKind.DynamicPriority,
                fixedchunksize: ts.PollingWatchKind.FixedChunkSize,
            })),
            category: ts.Diagnostics.Watch_and_Build_Modes,
            description: ts.Diagnostics.Specify_what_approach_the_watcher_should_use_if_the_system_runs_out_of_native_file_watchers,
            defaultValueDescription: ts.PollingWatchKind.PriorityInterval,
        },
        {
            name: "synchronousWatchDirectory",
            type: "boolean",
            category: ts.Diagnostics.Watch_and_Build_Modes,
            description: ts.Diagnostics.Synchronously_call_callbacks_and_update_the_state_of_directory_watchers_on_platforms_that_don_t_support_recursive_watching_natively,
            defaultValueDescription: false,
        },
        {
            name: "excludeDirectories",
            type: "list",
            element: {
                name: "excludeDirectory",
                type: "string",
                isFilePath: true,
                extraValidation: specToDiagnostic
            },
            category: ts.Diagnostics.Watch_and_Build_Modes,
            description: ts.Diagnostics.Remove_a_list_of_directories_from_the_watch_process,
        },
        {
            name: "excludeFiles",
            type: "list",
            element: {
                name: "excludeFile",
                type: "string",
                isFilePath: true,
                extraValidation: specToDiagnostic
            },
            category: ts.Diagnostics.Watch_and_Build_Modes,
            description: ts.Diagnostics.Remove_a_list_of_files_from_the_watch_mode_s_processing,
        },
    ];
    /* @internal */
    ts.commonOptionsWithBuild = [
        {
            name: "help",
            shortName: "h",
            type: "boolean",
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Command_line_Options,
            description: ts.Diagnostics.Print_this_message,
            defaultValueDescription: false,
        },
        {
            name: "help",
            shortName: "?",
            type: "boolean",
            defaultValueDescription: false,
        },
        {
            name: "watch",
            shortName: "w",
            type: "boolean",
            showInSimplifiedHelpView: true,
            isCommandLineOnly: true,
            category: ts.Diagnostics.Command_line_Options,
            description: ts.Diagnostics.Watch_input_files,
            defaultValueDescription: false,
        },
        {
            name: "preserveWatchOutput",
            type: "boolean",
            showInSimplifiedHelpView: false,
            category: ts.Diagnostics.Output_Formatting,
            description: ts.Diagnostics.Disable_wiping_the_console_in_watch_mode,
            defaultValueDescription: false,
        },
        {
            name: "listFiles",
            type: "boolean",
            category: ts.Diagnostics.Compiler_Diagnostics,
            description: ts.Diagnostics.Print_all_of_the_files_read_during_the_compilation,
            defaultValueDescription: false,
        },
        {
            name: "explainFiles",
            type: "boolean",
            category: ts.Diagnostics.Compiler_Diagnostics,
            description: ts.Diagnostics.Print_files_read_during_the_compilation_including_why_it_was_included,
            defaultValueDescription: false,
        },
        {
            name: "listEmittedFiles",
            type: "boolean",
            category: ts.Diagnostics.Compiler_Diagnostics,
            description: ts.Diagnostics.Print_the_names_of_emitted_files_after_a_compilation,
            defaultValueDescription: false,
        },
        {
            name: "pretty",
            type: "boolean",
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Output_Formatting,
            description: ts.Diagnostics.Enable_color_and_formatting_in_TypeScript_s_output_to_make_compiler_errors_easier_to_read,
            defaultValueDescription: true,
        },
        {
            name: "traceResolution",
            type: "boolean",
            category: ts.Diagnostics.Compiler_Diagnostics,
            description: ts.Diagnostics.Log_paths_used_during_the_moduleResolution_process,
            defaultValueDescription: false,
        },
        {
            name: "diagnostics",
            type: "boolean",
            category: ts.Diagnostics.Compiler_Diagnostics,
            description: ts.Diagnostics.Output_compiler_performance_information_after_building,
            defaultValueDescription: false,
        },
        {
            name: "extendedDiagnostics",
            type: "boolean",
            category: ts.Diagnostics.Compiler_Diagnostics,
            description: ts.Diagnostics.Output_more_detailed_compiler_performance_information_after_building,
            defaultValueDescription: false,
        },
        {
            name: "generateCpuProfile",
            type: "string",
            isFilePath: true,
            paramType: ts.Diagnostics.FILE_OR_DIRECTORY,
            category: ts.Diagnostics.Compiler_Diagnostics,
            description: ts.Diagnostics.Emit_a_v8_CPU_profile_of_the_compiler_run_for_debugging,
            defaultValueDescription: "profile.cpuprofile"
        },
        {
            name: "generateTrace",
            type: "string",
            isFilePath: true,
            isCommandLineOnly: true,
            paramType: ts.Diagnostics.DIRECTORY,
            category: ts.Diagnostics.Compiler_Diagnostics,
            description: ts.Diagnostics.Generates_an_event_trace_and_a_list_of_types
        },
        {
            name: "incremental",
            shortName: "i",
            type: "boolean",
            category: ts.Diagnostics.Projects,
            description: ts.Diagnostics.Save_tsbuildinfo_files_to_allow_for_incremental_compilation_of_projects,
            transpileOptionValue: undefined,
            defaultValueDescription: ts.Diagnostics.false_unless_composite_is_set
        },
        {
            name: "assumeChangesOnlyAffectDirectDependencies",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Watch_and_Build_Modes,
            description: ts.Diagnostics.Have_recompiles_in_projects_that_use_incremental_and_watch_mode_assume_that_changes_within_a_file_will_only_affect_files_directly_depending_on_it,
            defaultValueDescription: false,
        },
        {
            name: "locale",
            type: "string",
            category: ts.Diagnostics.Command_line_Options,
            isCommandLineOnly: true,
            description: ts.Diagnostics.Set_the_language_of_the_messaging_from_TypeScript_This_does_not_affect_emit,
            defaultValueDescription: ts.Diagnostics.Platform_specific
        },
    ];
    /* @internal */
    ts.targetOptionDeclaration = {
        name: "target",
        shortName: "t",
        type: new ts.Map(ts.getEntries({
            es3: 0 /* ScriptTarget.ES3 */,
            es5: 1 /* ScriptTarget.ES5 */,
            es6: 2 /* ScriptTarget.ES2015 */,
            es2015: 2 /* ScriptTarget.ES2015 */,
            es2016: 3 /* ScriptTarget.ES2016 */,
            es2017: 4 /* ScriptTarget.ES2017 */,
            es2018: 5 /* ScriptTarget.ES2018 */,
            es2019: 6 /* ScriptTarget.ES2019 */,
            es2020: 7 /* ScriptTarget.ES2020 */,
            es2021: 8 /* ScriptTarget.ES2021 */,
            es2022: 9 /* ScriptTarget.ES2022 */,
            esnext: 99 /* ScriptTarget.ESNext */,
        })),
        affectsSourceFile: true,
        affectsModuleResolution: true,
        affectsEmit: true,
        affectsMultiFileEmitBuildInfo: true,
        paramType: ts.Diagnostics.VERSION,
        showInSimplifiedHelpView: true,
        category: ts.Diagnostics.Language_and_Environment,
        description: ts.Diagnostics.Set_the_JavaScript_language_version_for_emitted_JavaScript_and_include_compatible_library_declarations,
        defaultValueDescription: 0 /* ScriptTarget.ES3 */,
    };
    /*@internal*/
    ts.moduleOptionDeclaration = {
        name: "module",
        shortName: "m",
        type: new ts.Map(ts.getEntries({
            none: ts.ModuleKind.None,
            commonjs: ts.ModuleKind.CommonJS,
            amd: ts.ModuleKind.AMD,
            system: ts.ModuleKind.System,
            umd: ts.ModuleKind.UMD,
            es6: ts.ModuleKind.ES2015,
            es2015: ts.ModuleKind.ES2015,
            es2020: ts.ModuleKind.ES2020,
            es2022: ts.ModuleKind.ES2022,
            esnext: ts.ModuleKind.ESNext,
            node16: ts.ModuleKind.Node16,
            nodenext: ts.ModuleKind.NodeNext,
        })),
        affectsModuleResolution: true,
        affectsEmit: true,
        affectsMultiFileEmitBuildInfo: true,
        paramType: ts.Diagnostics.KIND,
        showInSimplifiedHelpView: true,
        category: ts.Diagnostics.Modules,
        description: ts.Diagnostics.Specify_what_module_code_is_generated,
        defaultValueDescription: undefined,
    };
    var commandOptionsWithoutBuild = [
        // CommandLine only options
        {
            name: "all",
            type: "boolean",
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Command_line_Options,
            description: ts.Diagnostics.Show_all_compiler_options,
            defaultValueDescription: false,
        },
        {
            name: "version",
            shortName: "v",
            type: "boolean",
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Command_line_Options,
            description: ts.Diagnostics.Print_the_compiler_s_version,
            defaultValueDescription: false,
        },
        {
            name: "init",
            type: "boolean",
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Command_line_Options,
            description: ts.Diagnostics.Initializes_a_TypeScript_project_and_creates_a_tsconfig_json_file,
            defaultValueDescription: false,
        },
        {
            name: "project",
            shortName: "p",
            type: "string",
            isFilePath: true,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Command_line_Options,
            paramType: ts.Diagnostics.FILE_OR_DIRECTORY,
            description: ts.Diagnostics.Compile_the_project_given_the_path_to_its_configuration_file_or_to_a_folder_with_a_tsconfig_json,
        },
        {
            name: "build",
            type: "boolean",
            shortName: "b",
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Command_line_Options,
            description: ts.Diagnostics.Build_one_or_more_projects_and_their_dependencies_if_out_of_date,
            defaultValueDescription: false,
        },
        {
            name: "showConfig",
            type: "boolean",
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Command_line_Options,
            isCommandLineOnly: true,
            description: ts.Diagnostics.Print_the_final_configuration_instead_of_building,
            defaultValueDescription: false,
        },
        {
            name: "listFilesOnly",
            type: "boolean",
            category: ts.Diagnostics.Command_line_Options,
            affectsSemanticDiagnostics: true,
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            isCommandLineOnly: true,
            description: ts.Diagnostics.Print_names_of_files_that_are_part_of_the_compilation_and_then_stop_processing,
            defaultValueDescription: false,
        },
        // Basic
        ts.targetOptionDeclaration,
        ts.moduleOptionDeclaration,
        {
            name: "lib",
            type: "list",
            element: {
                name: "lib",
                type: ts.libMap,
                defaultValueDescription: undefined,
            },
            affectsProgramStructure: true,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Language_and_Environment,
            description: ts.Diagnostics.Specify_a_set_of_bundled_library_declaration_files_that_describe_the_target_runtime_environment,
            transpileOptionValue: undefined
        },
        {
            name: "allowJs",
            type: "boolean",
            affectsModuleResolution: true,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.JavaScript_Support,
            description: ts.Diagnostics.Allow_JavaScript_files_to_be_a_part_of_your_program_Use_the_checkJS_option_to_get_errors_from_these_files,
            defaultValueDescription: false,
        },
        {
            name: "checkJs",
            type: "boolean",
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.JavaScript_Support,
            description: ts.Diagnostics.Enable_error_reporting_in_type_checked_JavaScript_files,
            defaultValueDescription: false,
        },
        {
            name: "jsx",
            type: jsxOptionMap,
            affectsSourceFile: true,
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            affectsModuleResolution: true,
            paramType: ts.Diagnostics.KIND,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Language_and_Environment,
            description: ts.Diagnostics.Specify_what_JSX_code_is_generated,
            defaultValueDescription: undefined,
        },
        {
            name: "declaration",
            shortName: "d",
            type: "boolean",
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Emit,
            transpileOptionValue: undefined,
            description: ts.Diagnostics.Generate_d_ts_files_from_TypeScript_and_JavaScript_files_in_your_project,
            defaultValueDescription: ts.Diagnostics.false_unless_composite_is_set,
        },
        {
            name: "declarationMap",
            type: "boolean",
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Emit,
            transpileOptionValue: undefined,
            defaultValueDescription: false,
            description: ts.Diagnostics.Create_sourcemaps_for_d_ts_files
        },
        {
            name: "emitDeclarationOnly",
            type: "boolean",
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Only_output_d_ts_files_and_not_JavaScript_files,
            transpileOptionValue: undefined,
            defaultValueDescription: false,
        },
        {
            name: "sourceMap",
            type: "boolean",
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Emit,
            defaultValueDescription: false,
            description: ts.Diagnostics.Create_source_map_files_for_emitted_JavaScript_files,
        },
        {
            name: "outFile",
            type: "string",
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            affectsDeclarationPath: true,
            affectsBundleEmitBuildInfo: true,
            isFilePath: true,
            paramType: ts.Diagnostics.FILE,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Specify_a_file_that_bundles_all_outputs_into_one_JavaScript_file_If_declaration_is_true_also_designates_a_file_that_bundles_all_d_ts_output,
            transpileOptionValue: undefined,
        },
        {
            name: "outDir",
            type: "string",
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            affectsDeclarationPath: true,
            isFilePath: true,
            paramType: ts.Diagnostics.DIRECTORY,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Specify_an_output_folder_for_all_emitted_files,
        },
        {
            name: "rootDir",
            type: "string",
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            affectsDeclarationPath: true,
            isFilePath: true,
            paramType: ts.Diagnostics.LOCATION,
            category: ts.Diagnostics.Modules,
            description: ts.Diagnostics.Specify_the_root_folder_within_your_source_files,
            defaultValueDescription: ts.Diagnostics.Computed_from_the_list_of_input_files
        },
        {
            name: "composite",
            type: "boolean",
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            affectsBundleEmitBuildInfo: true,
            isTSConfigOnly: true,
            category: ts.Diagnostics.Projects,
            transpileOptionValue: undefined,
            defaultValueDescription: false,
            description: ts.Diagnostics.Enable_constraints_that_allow_a_TypeScript_project_to_be_used_with_project_references,
        },
        {
            name: "tsBuildInfoFile",
            type: "string",
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            affectsBundleEmitBuildInfo: true,
            isFilePath: true,
            paramType: ts.Diagnostics.FILE,
            category: ts.Diagnostics.Projects,
            transpileOptionValue: undefined,
            defaultValueDescription: ".tsbuildinfo",
            description: ts.Diagnostics.Specify_the_path_to_tsbuildinfo_incremental_compilation_file,
        },
        {
            name: "removeComments",
            type: "boolean",
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Emit,
            defaultValueDescription: false,
            description: ts.Diagnostics.Disable_emitting_comments,
        },
        {
            name: "noEmit",
            type: "boolean",
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Disable_emitting_files_from_a_compilation,
            transpileOptionValue: undefined,
            defaultValueDescription: false,
        },
        {
            name: "importHelpers",
            type: "boolean",
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Allow_importing_helper_functions_from_tslib_once_per_project_instead_of_including_them_per_file,
            defaultValueDescription: false,
        },
        {
            name: "importsNotUsedAsValues",
            type: new ts.Map(ts.getEntries({
                remove: 0 /* ImportsNotUsedAsValues.Remove */,
                preserve: 1 /* ImportsNotUsedAsValues.Preserve */,
                error: 2 /* ImportsNotUsedAsValues.Error */,
            })),
            affectsEmit: true,
            affectsSemanticDiagnostics: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Specify_emit_Slashchecking_behavior_for_imports_that_are_only_used_for_types,
            defaultValueDescription: 0 /* ImportsNotUsedAsValues.Remove */,
        },
        {
            name: "downlevelIteration",
            type: "boolean",
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Emit_more_compliant_but_verbose_and_less_performant_JavaScript_for_iteration,
            defaultValueDescription: false,
        },
        {
            name: "isolatedModules",
            type: "boolean",
            category: ts.Diagnostics.Interop_Constraints,
            description: ts.Diagnostics.Ensure_that_each_file_can_be_safely_transpiled_without_relying_on_other_imports,
            transpileOptionValue: true,
            defaultValueDescription: false,
        },
        // Strict Type Checks
        {
            name: "strict",
            type: "boolean",
            // Though this affects semantic diagnostics, affectsSemanticDiagnostics is not set here
            // The value of each strictFlag depends on own strictFlag value or this and never accessed directly.
            // But we need to store `strict` in builf info, even though it won't be examined directly, so that the
            // flags it controls (e.g. `strictNullChecks`) will be retrieved correctly
            affectsMultiFileEmitBuildInfo: true,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Enable_all_strict_type_checking_options,
            defaultValueDescription: false,
        },
        {
            name: "noImplicitAny",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsMultiFileEmitBuildInfo: true,
            strictFlag: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Enable_error_reporting_for_expressions_and_declarations_with_an_implied_any_type,
            defaultValueDescription: ts.Diagnostics.false_unless_strict_is_set
        },
        {
            name: "strictNullChecks",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsMultiFileEmitBuildInfo: true,
            strictFlag: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.When_type_checking_take_into_account_null_and_undefined,
            defaultValueDescription: ts.Diagnostics.false_unless_strict_is_set
        },
        {
            name: "strictFunctionTypes",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsMultiFileEmitBuildInfo: true,
            strictFlag: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.When_assigning_functions_check_to_ensure_parameters_and_the_return_values_are_subtype_compatible,
            defaultValueDescription: ts.Diagnostics.false_unless_strict_is_set
        },
        {
            name: "strictBindCallApply",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsMultiFileEmitBuildInfo: true,
            strictFlag: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Check_that_the_arguments_for_bind_call_and_apply_methods_match_the_original_function,
            defaultValueDescription: ts.Diagnostics.false_unless_strict_is_set
        },
        {
            name: "strictPropertyInitialization",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsMultiFileEmitBuildInfo: true,
            strictFlag: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Check_for_class_properties_that_are_declared_but_not_set_in_the_constructor,
            defaultValueDescription: ts.Diagnostics.false_unless_strict_is_set
        },
        {
            name: "noImplicitThis",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsMultiFileEmitBuildInfo: true,
            strictFlag: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Enable_error_reporting_when_this_is_given_the_type_any,
            defaultValueDescription: ts.Diagnostics.false_unless_strict_is_set
        },
        {
            name: "useUnknownInCatchVariables",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsMultiFileEmitBuildInfo: true,
            strictFlag: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Default_catch_clause_variables_as_unknown_instead_of_any,
            defaultValueDescription: false,
        },
        {
            name: "alwaysStrict",
            type: "boolean",
            affectsSourceFile: true,
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            strictFlag: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Ensure_use_strict_is_always_emitted,
            defaultValueDescription: ts.Diagnostics.false_unless_strict_is_set
        },
        // Additional Checks
        {
            name: "noUnusedLocals",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Enable_error_reporting_when_local_variables_aren_t_read,
            defaultValueDescription: false,
        },
        {
            name: "noUnusedParameters",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Raise_an_error_when_a_function_parameter_isn_t_read,
            defaultValueDescription: false,
        },
        {
            name: "exactOptionalPropertyTypes",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Interpret_optional_property_types_as_written_rather_than_adding_undefined,
            defaultValueDescription: false,
        },
        {
            name: "noImplicitReturns",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Enable_error_reporting_for_codepaths_that_do_not_explicitly_return_in_a_function,
            defaultValueDescription: false,
        },
        {
            name: "noFallthroughCasesInSwitch",
            type: "boolean",
            affectsBindDiagnostics: true,
            affectsSemanticDiagnostics: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Enable_error_reporting_for_fallthrough_cases_in_switch_statements,
            defaultValueDescription: false,
        },
        {
            name: "noUncheckedIndexedAccess",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Add_undefined_to_a_type_when_accessed_using_an_index,
            defaultValueDescription: false,
        },
        {
            name: "noImplicitOverride",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Ensure_overriding_members_in_derived_classes_are_marked_with_an_override_modifier,
            defaultValueDescription: false,
        },
        {
            name: "noPropertyAccessFromIndexSignature",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsMultiFileEmitBuildInfo: true,
            showInSimplifiedHelpView: false,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Enforces_using_indexed_accessors_for_keys_declared_using_an_indexed_type,
            defaultValueDescription: false,
        },
        // Module Resolution
        {
            name: "moduleResolution",
            type: new ts.Map(ts.getEntries({
                node: ts.ModuleResolutionKind.NodeJs,
                classic: ts.ModuleResolutionKind.Classic,
                node16: ts.ModuleResolutionKind.Node16,
                nodenext: ts.ModuleResolutionKind.NodeNext,
            })),
            affectsModuleResolution: true,
            paramType: ts.Diagnostics.STRATEGY,
            category: ts.Diagnostics.Modules,
            description: ts.Diagnostics.Specify_how_TypeScript_looks_up_a_file_from_a_given_module_specifier,
            defaultValueDescription: ts.Diagnostics.module_AMD_or_UMD_or_System_or_ES6_then_Classic_Otherwise_Node
        },
        {
            name: "baseUrl",
            type: "string",
            affectsModuleResolution: true,
            isFilePath: true,
            category: ts.Diagnostics.Modules,
            description: ts.Diagnostics.Specify_the_base_directory_to_resolve_non_relative_module_names
        },
        {
            // this option can only be specified in tsconfig.json
            // use type = object to copy the value as-is
            name: "paths",
            type: "object",
            affectsModuleResolution: true,
            isTSConfigOnly: true,
            category: ts.Diagnostics.Modules,
            description: ts.Diagnostics.Specify_a_set_of_entries_that_re_map_imports_to_additional_lookup_locations,
            transpileOptionValue: undefined
        },
        {
            // this option can only be specified in tsconfig.json
            // use type = object to copy the value as-is
            name: "rootDirs",
            type: "list",
            isTSConfigOnly: true,
            element: {
                name: "rootDirs",
                type: "string",
                isFilePath: true
            },
            affectsModuleResolution: true,
            category: ts.Diagnostics.Modules,
            description: ts.Diagnostics.Allow_multiple_folders_to_be_treated_as_one_when_resolving_modules,
            transpileOptionValue: undefined,
            defaultValueDescription: ts.Diagnostics.Computed_from_the_list_of_input_files
        },
        {
            name: "typeRoots",
            type: "list",
            element: {
                name: "typeRoots",
                type: "string",
                isFilePath: true
            },
            affectsModuleResolution: true,
            category: ts.Diagnostics.Modules,
            description: ts.Diagnostics.Specify_multiple_folders_that_act_like_Slashnode_modules_Slash_types
        },
        {
            name: "types",
            type: "list",
            element: {
                name: "types",
                type: "string"
            },
            affectsProgramStructure: true,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Modules,
            description: ts.Diagnostics.Specify_type_package_names_to_be_included_without_being_referenced_in_a_source_file,
            transpileOptionValue: undefined
        },
        {
            name: "allowSyntheticDefaultImports",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Interop_Constraints,
            description: ts.Diagnostics.Allow_import_x_from_y_when_a_module_doesn_t_have_a_default_export,
            defaultValueDescription: ts.Diagnostics.module_system_or_esModuleInterop
        },
        {
            name: "esModuleInterop",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            showInSimplifiedHelpView: true,
            category: ts.Diagnostics.Interop_Constraints,
            description: ts.Diagnostics.Emit_additional_JavaScript_to_ease_support_for_importing_CommonJS_modules_This_enables_allowSyntheticDefaultImports_for_type_compatibility,
            defaultValueDescription: false,
        },
        {
            name: "preserveSymlinks",
            type: "boolean",
            category: ts.Diagnostics.Interop_Constraints,
            description: ts.Diagnostics.Disable_resolving_symlinks_to_their_realpath_This_correlates_to_the_same_flag_in_node,
            defaultValueDescription: false,
        },
        {
            name: "allowUmdGlobalAccess",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Modules,
            description: ts.Diagnostics.Allow_accessing_UMD_globals_from_modules,
            defaultValueDescription: false,
        },
        {
            name: "moduleSuffixes",
            type: "list",
            element: {
                name: "suffix",
                type: "string",
            },
            listPreserveFalsyValues: true,
            affectsModuleResolution: true,
            category: ts.Diagnostics.Modules,
            description: ts.Diagnostics.List_of_file_name_suffixes_to_search_when_resolving_a_module,
        },
        // Source Maps
        {
            name: "sourceRoot",
            type: "string",
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            paramType: ts.Diagnostics.LOCATION,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Specify_the_root_path_for_debuggers_to_find_the_reference_source_code,
        },
        {
            name: "mapRoot",
            type: "string",
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            paramType: ts.Diagnostics.LOCATION,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Specify_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations,
        },
        {
            name: "inlineSourceMap",
            type: "boolean",
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Include_sourcemap_files_inside_the_emitted_JavaScript,
            defaultValueDescription: false,
        },
        {
            name: "inlineSources",
            type: "boolean",
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Include_source_code_in_the_sourcemaps_inside_the_emitted_JavaScript,
            defaultValueDescription: false,
        },
        // Experimental
        {
            name: "experimentalDecorators",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Language_and_Environment,
            description: ts.Diagnostics.Enable_experimental_support_for_TC39_stage_2_draft_decorators,
            defaultValueDescription: false,
        },
        {
            name: "emitDecoratorMetadata",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Language_and_Environment,
            description: ts.Diagnostics.Emit_design_type_metadata_for_decorated_declarations_in_source_files,
            defaultValueDescription: false,
        },
        // Advanced
        {
            name: "jsxFactory",
            type: "string",
            category: ts.Diagnostics.Language_and_Environment,
            description: ts.Diagnostics.Specify_the_JSX_factory_function_used_when_targeting_React_JSX_emit_e_g_React_createElement_or_h,
            defaultValueDescription: "`React.createElement`"
        },
        {
            name: "jsxFragmentFactory",
            type: "string",
            category: ts.Diagnostics.Language_and_Environment,
            description: ts.Diagnostics.Specify_the_JSX_Fragment_reference_used_for_fragments_when_targeting_React_JSX_emit_e_g_React_Fragment_or_Fragment,
            defaultValueDescription: "React.Fragment",
        },
        {
            name: "jsxImportSource",
            type: "string",
            affectsSemanticDiagnostics: true,
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            affectsModuleResolution: true,
            category: ts.Diagnostics.Language_and_Environment,
            description: ts.Diagnostics.Specify_module_specifier_used_to_import_the_JSX_factory_functions_when_using_jsx_Colon_react_jsx_Asterisk,
            defaultValueDescription: "react"
        },
        {
            name: "resolveJsonModule",
            type: "boolean",
            affectsModuleResolution: true,
            category: ts.Diagnostics.Modules,
            description: ts.Diagnostics.Enable_importing_json_files,
            defaultValueDescription: false,
        },
        {
            name: "out",
            type: "string",
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            affectsDeclarationPath: true,
            affectsBundleEmitBuildInfo: true,
            isFilePath: false,
            // for correct behaviour, please use outFile
            category: ts.Diagnostics.Backwards_Compatibility,
            paramType: ts.Diagnostics.FILE,
            transpileOptionValue: undefined,
            description: ts.Diagnostics.Deprecated_setting_Use_outFile_instead,
        },
        {
            name: "reactNamespace",
            type: "string",
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Language_and_Environment,
            description: ts.Diagnostics.Specify_the_object_invoked_for_createElement_This_only_applies_when_targeting_react_JSX_emit,
            defaultValueDescription: "`React`",
        },
        {
            name: "skipDefaultLibCheck",
            type: "boolean",
            // We need to store these to determine whether `lib` files need to be rechecked
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Completeness,
            description: ts.Diagnostics.Skip_type_checking_d_ts_files_that_are_included_with_TypeScript,
            defaultValueDescription: false,
        },
        {
            name: "charset",
            type: "string",
            category: ts.Diagnostics.Backwards_Compatibility,
            description: ts.Diagnostics.No_longer_supported_In_early_versions_manually_set_the_text_encoding_for_reading_files,
            defaultValueDescription: "utf8"
        },
        {
            name: "emitBOM",
            type: "boolean",
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Emit_a_UTF_8_Byte_Order_Mark_BOM_in_the_beginning_of_output_files,
            defaultValueDescription: false,
        },
        {
            name: "newLine",
            type: new ts.Map(ts.getEntries({
                crlf: 0 /* NewLineKind.CarriageReturnLineFeed */,
                lf: 1 /* NewLineKind.LineFeed */
            })),
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            paramType: ts.Diagnostics.NEWLINE,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Set_the_newline_character_for_emitting_files,
            defaultValueDescription: ts.Diagnostics.Platform_specific
        },
        {
            name: "noErrorTruncation",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Output_Formatting,
            description: ts.Diagnostics.Disable_truncating_types_in_error_messages,
            defaultValueDescription: false,
        },
        {
            name: "noLib",
            type: "boolean",
            category: ts.Diagnostics.Language_and_Environment,
            affectsProgramStructure: true,
            description: ts.Diagnostics.Disable_including_any_library_files_including_the_default_lib_d_ts,
            // We are not returning a sourceFile for lib file when asked by the program,
            // so pass --noLib to avoid reporting a file not found error.
            transpileOptionValue: true,
            defaultValueDescription: false,
        },
        {
            name: "noResolve",
            type: "boolean",
            affectsModuleResolution: true,
            category: ts.Diagnostics.Modules,
            description: ts.Diagnostics.Disallow_import_s_require_s_or_reference_s_from_expanding_the_number_of_files_TypeScript_should_add_to_a_project,
            // We are not doing a full typecheck, we are not resolving the whole context,
            // so pass --noResolve to avoid reporting missing file errors.
            transpileOptionValue: true,
            defaultValueDescription: false,
        },
        {
            name: "stripInternal",
            type: "boolean",
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Disable_emitting_declarations_that_have_internal_in_their_JSDoc_comments,
            defaultValueDescription: false,
        },
        {
            name: "disableSizeLimit",
            type: "boolean",
            affectsProgramStructure: true,
            category: ts.Diagnostics.Editor_Support,
            description: ts.Diagnostics.Remove_the_20mb_cap_on_total_source_code_size_for_JavaScript_files_in_the_TypeScript_language_server,
            defaultValueDescription: false,
        },
        {
            name: "disableSourceOfProjectReferenceRedirect",
            type: "boolean",
            isTSConfigOnly: true,
            category: ts.Diagnostics.Projects,
            description: ts.Diagnostics.Disable_preferring_source_files_instead_of_declaration_files_when_referencing_composite_projects,
            defaultValueDescription: false,
        },
        {
            name: "disableSolutionSearching",
            type: "boolean",
            isTSConfigOnly: true,
            category: ts.Diagnostics.Projects,
            description: ts.Diagnostics.Opt_a_project_out_of_multi_project_reference_checking_when_editing,
            defaultValueDescription: false,
        },
        {
            name: "disableReferencedProjectLoad",
            type: "boolean",
            isTSConfigOnly: true,
            category: ts.Diagnostics.Projects,
            description: ts.Diagnostics.Reduce_the_number_of_projects_loaded_automatically_by_TypeScript,
            defaultValueDescription: false,
        },
        {
            name: "noImplicitUseStrict",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Backwards_Compatibility,
            description: ts.Diagnostics.Disable_adding_use_strict_directives_in_emitted_JavaScript_files,
            defaultValueDescription: false,
        },
        {
            name: "noEmitHelpers",
            type: "boolean",
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Disable_generating_custom_helper_functions_like_extends_in_compiled_output,
            defaultValueDescription: false,
        },
        {
            name: "noEmitOnError",
            type: "boolean",
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Emit,
            transpileOptionValue: undefined,
            description: ts.Diagnostics.Disable_emitting_files_if_any_type_checking_errors_are_reported,
            defaultValueDescription: false,
        },
        {
            name: "preserveConstEnums",
            type: "boolean",
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Disable_erasing_const_enum_declarations_in_generated_code,
            defaultValueDescription: false,
        },
        {
            name: "declarationDir",
            type: "string",
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            affectsDeclarationPath: true,
            isFilePath: true,
            paramType: ts.Diagnostics.DIRECTORY,
            category: ts.Diagnostics.Emit,
            transpileOptionValue: undefined,
            description: ts.Diagnostics.Specify_the_output_directory_for_generated_declaration_files,
        },
        {
            name: "skipLibCheck",
            type: "boolean",
            // We need to store these to determine whether `lib` files need to be rechecked
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Completeness,
            description: ts.Diagnostics.Skip_type_checking_all_d_ts_files,
            defaultValueDescription: false,
        },
        {
            name: "allowUnusedLabels",
            type: "boolean",
            affectsBindDiagnostics: true,
            affectsSemanticDiagnostics: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Disable_error_reporting_for_unused_labels,
            defaultValueDescription: undefined,
        },
        {
            name: "allowUnreachableCode",
            type: "boolean",
            affectsBindDiagnostics: true,
            affectsSemanticDiagnostics: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Type_Checking,
            description: ts.Diagnostics.Disable_error_reporting_for_unreachable_code,
            defaultValueDescription: undefined,
        },
        {
            name: "suppressExcessPropertyErrors",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Backwards_Compatibility,
            description: ts.Diagnostics.Disable_reporting_of_excess_property_errors_during_the_creation_of_object_literals,
            defaultValueDescription: false,
        },
        {
            name: "suppressImplicitAnyIndexErrors",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Backwards_Compatibility,
            description: ts.Diagnostics.Suppress_noImplicitAny_errors_when_indexing_objects_that_lack_index_signatures,
            defaultValueDescription: false,
        },
        {
            name: "forceConsistentCasingInFileNames",
            type: "boolean",
            affectsModuleResolution: true,
            category: ts.Diagnostics.Interop_Constraints,
            description: ts.Diagnostics.Ensure_that_casing_is_correct_in_imports,
            defaultValueDescription: false,
        },
        {
            name: "maxNodeModuleJsDepth",
            type: "number",
            affectsModuleResolution: true,
            category: ts.Diagnostics.JavaScript_Support,
            description: ts.Diagnostics.Specify_the_maximum_folder_depth_used_for_checking_JavaScript_files_from_node_modules_Only_applicable_with_allowJs,
            defaultValueDescription: 0,
        },
        {
            name: "noStrictGenericChecks",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Backwards_Compatibility,
            description: ts.Diagnostics.Disable_strict_checking_of_generic_signatures_in_function_types,
            defaultValueDescription: false,
        },
        {
            name: "useDefineForClassFields",
            type: "boolean",
            affectsSemanticDiagnostics: true,
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Language_and_Environment,
            description: ts.Diagnostics.Emit_ECMAScript_standard_compliant_class_fields,
            defaultValueDescription: ts.Diagnostics.true_for_ES2022_and_above_including_ESNext
        },
        {
            name: "preserveValueImports",
            type: "boolean",
            affectsEmit: true,
            affectsMultiFileEmitBuildInfo: true,
            category: ts.Diagnostics.Emit,
            description: ts.Diagnostics.Preserve_unused_imported_values_in_the_JavaScript_output_that_would_otherwise_be_removed,
            defaultValueDescription: false,
        },
        {
            name: "keyofStringsOnly",
            type: "boolean",
            category: ts.Diagnostics.Backwards_Compatibility,
            description: ts.Diagnostics.Make_keyof_only_return_strings_instead_of_string_numbers_or_symbols_Legacy_option,
            defaultValueDescription: false,
        },
        {
            // A list of plugins to load in the language service
            name: "plugins",
            type: "list",
            isTSConfigOnly: true,
            element: {
                name: "plugin",
                type: "object"
            },
            description: ts.Diagnostics.Specify_a_list_of_language_service_plugins_to_include,
            category: ts.Diagnostics.Editor_Support,
        },
        {
            name: "moduleDetection",
            type: new ts.Map(ts.getEntries({
                auto: ts.ModuleDetectionKind.Auto,
                legacy: ts.ModuleDetectionKind.Legacy,
                force: ts.ModuleDetectionKind.Force,
            })),
            affectsModuleResolution: true,
            description: ts.Diagnostics.Control_what_method_is_used_to_detect_module_format_JS_files,
            category: ts.Diagnostics.Language_and_Environment,
            defaultValueDescription: ts.Diagnostics.auto_Colon_Treat_files_with_imports_exports_import_meta_jsx_with_jsx_Colon_react_jsx_or_esm_format_with_module_Colon_node16_as_modules,
        }
    ];
    /* @internal */
    ts.optionDeclarations = __spreadArray(__spreadArray([], ts.commonOptionsWithBuild, true), commandOptionsWithoutBuild, true);
    /* @internal */
    ts.semanticDiagnosticsOptionDeclarations = ts.optionDeclarations.filter(function (option) { return !!option.affectsSemanticDiagnostics; });
    /* @internal */
    ts.affectsEmitOptionDeclarations = ts.optionDeclarations.filter(function (option) { return !!option.affectsEmit; });
    /* @internal */
    ts.affectsDeclarationPathOptionDeclarations = ts.optionDeclarations.filter(function (option) { return !!option.affectsDeclarationPath; });
    /* @internal */
    ts.moduleResolutionOptionDeclarations = ts.optionDeclarations.filter(function (option) { return !!option.affectsModuleResolution; });
    /* @internal */
    ts.sourceFileAffectingCompilerOptions = ts.optionDeclarations.filter(function (option) {
        return !!option.affectsSourceFile || !!option.affectsModuleResolution || !!option.affectsBindDiagnostics;
    });
    /* @internal */
    ts.optionsAffectingProgramStructure = ts.optionDeclarations.filter(function (option) { return !!option.affectsProgramStructure; });
    /* @internal */
    ts.transpileOptionValueCompilerOptions = ts.optionDeclarations.filter(function (option) {
        return ts.hasProperty(option, "transpileOptionValue");
    });
    // Build related options
    /* @internal */
    ts.optionsForBuild = [
        {
            name: "verbose",
            shortName: "v",
            category: ts.Diagnostics.Command_line_Options,
            description: ts.Diagnostics.Enable_verbose_logging,
            type: "boolean",
            defaultValueDescription: false,
        },
        {
            name: "dry",
            shortName: "d",
            category: ts.Diagnostics.Command_line_Options,
            description: ts.Diagnostics.Show_what_would_be_built_or_deleted_if_specified_with_clean,
            type: "boolean",
            defaultValueDescription: false,
        },
        {
            name: "force",
            shortName: "f",
            category: ts.Diagnostics.Command_line_Options,
            description: ts.Diagnostics.Build_all_projects_including_those_that_appear_to_be_up_to_date,
            type: "boolean",
            defaultValueDescription: false,
        },
        {
            name: "clean",
            category: ts.Diagnostics.Command_line_Options,
            description: ts.Diagnostics.Delete_the_outputs_of_all_projects,
            type: "boolean",
            defaultValueDescription: false,
        }
    ];
    /* @internal */
    ts.buildOpts = __spreadArray(__spreadArray([], ts.commonOptionsWithBuild, true), ts.optionsForBuild, true);
    /* @internal */
    ts.typeAcquisitionDeclarations = [
        {
            /* @deprecated typingOptions.enableAutoDiscovery
             * Use typeAcquisition.enable instead.
             */
            name: "enableAutoDiscovery",
            type: "boolean",
            defaultValueDescription: false,
        },
        {
            name: "enable",
            type: "boolean",
            defaultValueDescription: false,
        },
        {
            name: "include",
            type: "list",
            element: {
                name: "include",
                type: "string"
            }
        },
        {
            name: "exclude",
            type: "list",
            element: {
                name: "exclude",
                type: "string"
            }
        },
        {
            name: "disableFilenameBasedTypeAcquisition",
            type: "boolean",
            defaultValueDescription: false,
        },
    ];
    /*@internal*/
    function createOptionNameMap(optionDeclarations) {
        var optionsNameMap = new ts.Map();
        var shortOptionNames = new ts.Map();
        ts.forEach(optionDeclarations, function (option) {
            optionsNameMap.set(option.name.toLowerCase(), option);
            if (option.shortName) {
                shortOptionNames.set(option.shortName, option.name);
            }
        });
        return { optionsNameMap: optionsNameMap, shortOptionNames: shortOptionNames };
    }
    ts.createOptionNameMap = createOptionNameMap;
    var optionsNameMapCache;
    /* @internal */
    function getOptionsNameMap() {
        return optionsNameMapCache || (optionsNameMapCache = createOptionNameMap(ts.optionDeclarations));
    }
    ts.getOptionsNameMap = getOptionsNameMap;
    var compilerOptionsAlternateMode = {
        diagnostic: ts.Diagnostics.Compiler_option_0_may_only_be_used_with_build,
        getOptionsNameMap: getBuildOptionsNameMap
    };
    /* @internal */
    ts.defaultInitCompilerOptions = {
        module: ts.ModuleKind.CommonJS,
        target: 3 /* ScriptTarget.ES2016 */,
        strict: true,
        esModuleInterop: true,
        forceConsistentCasingInFileNames: true,
        skipLibCheck: true
    };
    /* @internal */
    function convertEnableAutoDiscoveryToEnable(typeAcquisition) {
        // Convert deprecated typingOptions.enableAutoDiscovery to typeAcquisition.enable
        if (typeAcquisition && typeAcquisition.enableAutoDiscovery !== undefined && typeAcquisition.enable === undefined) {
            return {
                enable: typeAcquisition.enableAutoDiscovery,
                include: typeAcquisition.include || [],
                exclude: typeAcquisition.exclude || []
            };
        }
        return typeAcquisition;
    }
    ts.convertEnableAutoDiscoveryToEnable = convertEnableAutoDiscoveryToEnable;
    /* @internal */
    function createCompilerDiagnosticForInvalidCustomType(opt) {
        return createDiagnosticForInvalidCustomType(opt, ts.createCompilerDiagnostic);
    }
    ts.createCompilerDiagnosticForInvalidCustomType = createCompilerDiagnosticForInvalidCustomType;
    function createDiagnosticForInvalidCustomType(opt, createDiagnostic) {
        var namesOfType = ts.arrayFrom(opt.type.keys()).map(function (key) { return "'".concat(key, "'"); }).join(", ");
        return createDiagnostic(ts.Diagnostics.Argument_for_0_option_must_be_Colon_1, "--".concat(opt.name), namesOfType);
    }
    /* @internal */
    function parseCustomTypeOption(opt, value, errors) {
        return convertJsonOptionOfCustomType(opt, ts.trimString(value || ""), errors);
    }
    ts.parseCustomTypeOption = parseCustomTypeOption;
    /* @internal */
    function parseListTypeOption(opt, value, errors) {
        if (value === void 0) { value = ""; }
        value = ts.trimString(value);
        if (ts.startsWith(value, "-")) {
            return undefined;
        }
        if (value === "") {
            return [];
        }
        var values = value.split(",");
        switch (opt.element.type) {
            case "number":
                return ts.mapDefined(values, function (v) { return validateJsonOptionValue(opt.element, parseInt(v), errors); });
            case "string":
                return ts.mapDefined(values, function (v) { return validateJsonOptionValue(opt.element, v || "", errors); });
            default:
                return ts.mapDefined(values, function (v) { return parseCustomTypeOption(opt.element, v, errors); });
        }
    }
    ts.parseListTypeOption = parseListTypeOption;
    function getOptionName(option) {
        return option.name;
    }
    function createUnknownOptionError(unknownOption, diagnostics, createDiagnostics, unknownOptionErrorText) {
        var _a;
        if ((_a = diagnostics.alternateMode) === null || _a === void 0 ? void 0 : _a.getOptionsNameMap().optionsNameMap.has(unknownOption.toLowerCase())) {
            return createDiagnostics(diagnostics.alternateMode.diagnostic, unknownOption);
        }
        var possibleOption = ts.getSpellingSuggestion(unknownOption, diagnostics.optionDeclarations, getOptionName);
        return possibleOption ?
            createDiagnostics(diagnostics.unknownDidYouMeanDiagnostic, unknownOptionErrorText || unknownOption, possibleOption.name) :
            createDiagnostics(diagnostics.unknownOptionDiagnostic, unknownOptionErrorText || unknownOption);
    }
    /*@internal*/
    function parseCommandLineWorker(diagnostics, commandLine, readFile) {
        var options = {};
        var watchOptions;
        var fileNames = [];
        var errors = [];
        parseStrings(commandLine);
        return {
            options: options,
            watchOptions: watchOptions,
            fileNames: fileNames,
            errors: errors
        };
        function parseStrings(args) {
            var i = 0;
            while (i < args.length) {
                var s = args[i];
                i++;
                if (s.charCodeAt(0) === 64 /* CharacterCodes.at */) {
                    parseResponseFile(s.slice(1));
                }
                else if (s.charCodeAt(0) === 45 /* CharacterCodes.minus */) {
                    var inputOptionName = s.slice(s.charCodeAt(1) === 45 /* CharacterCodes.minus */ ? 2 : 1);
                    var opt = getOptionDeclarationFromName(diagnostics.getOptionsNameMap, inputOptionName, /*allowShort*/ true);
                    if (opt) {
                        i = parseOptionValue(args, i, diagnostics, opt, options, errors);
                    }
                    else {
                        var watchOpt = getOptionDeclarationFromName(watchOptionsDidYouMeanDiagnostics.getOptionsNameMap, inputOptionName, /*allowShort*/ true);
                        if (watchOpt) {
                            i = parseOptionValue(args, i, watchOptionsDidYouMeanDiagnostics, watchOpt, watchOptions || (watchOptions = {}), errors);
                        }
                        else {
                            errors.push(createUnknownOptionError(inputOptionName, diagnostics, ts.createCompilerDiagnostic, s));
                        }
                    }
                }
                else {
                    fileNames.push(s);
                }
            }
        }
        function parseResponseFile(fileName) {
            var text = tryReadFile(fileName, readFile || (function (fileName) { return ts.sys.readFile(fileName); }));
            if (!ts.isString(text)) {
                errors.push(text);
                return;
            }
            var args = [];
            var pos = 0;
            while (true) {
                while (pos < text.length && text.charCodeAt(pos) <= 32 /* CharacterCodes.space */)
                    pos++;
                if (pos >= text.length)
                    break;
                var start = pos;
                if (text.charCodeAt(start) === 34 /* CharacterCodes.doubleQuote */) {
                    pos++;
                    while (pos < text.length && text.charCodeAt(pos) !== 34 /* CharacterCodes.doubleQuote */)
                        pos++;
                    if (pos < text.length) {
                        args.push(text.substring(start + 1, pos));
                        pos++;
                    }
                    else {
                        errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Unterminated_quoted_string_in_response_file_0, fileName));
                    }
                }
                else {
                    while (text.charCodeAt(pos) > 32 /* CharacterCodes.space */)
                        pos++;
                    args.push(text.substring(start, pos));
                }
            }
            parseStrings(args);
        }
    }
    ts.parseCommandLineWorker = parseCommandLineWorker;
    function parseOptionValue(args, i, diagnostics, opt, options, errors) {
        if (opt.isTSConfigOnly) {
            var optValue = args[i];
            if (optValue === "null") {
                options[opt.name] = undefined;
                i++;
            }
            else if (opt.type === "boolean") {
                if (optValue === "false") {
                    options[opt.name] = validateJsonOptionValue(opt, /*value*/ false, errors);
                    i++;
                }
                else {
                    if (optValue === "true")
                        i++;
                    errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_false_or_null_on_command_line, opt.name));
                }
            }
            else {
                errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Option_0_can_only_be_specified_in_tsconfig_json_file_or_set_to_null_on_command_line, opt.name));
                if (optValue && !ts.startsWith(optValue, "-"))
                    i++;
            }
        }
        else {
            // Check to see if no argument was provided (e.g. "--locale" is the last command-line argument).
            if (!args[i] && opt.type !== "boolean") {
                errors.push(ts.createCompilerDiagnostic(diagnostics.optionTypeMismatchDiagnostic, opt.name, getCompilerOptionValueTypeString(opt)));
            }
            if (args[i] !== "null") {
                switch (opt.type) {
                    case "number":
                        options[opt.name] = validateJsonOptionValue(opt, parseInt(args[i]), errors);
                        i++;
                        break;
                    case "boolean":
                        // boolean flag has optional value true, false, others
                        var optValue = args[i];
                        options[opt.name] = validateJsonOptionValue(opt, optValue !== "false", errors);
                        // consume next argument as boolean flag value
                        if (optValue === "false" || optValue === "true") {
                            i++;
                        }
                        break;
                    case "string":
                        options[opt.name] = validateJsonOptionValue(opt, args[i] || "", errors);
                        i++;
                        break;
                    case "list":
                        var result = parseListTypeOption(opt, args[i], errors);
                        options[opt.name] = result || [];
                        if (result) {
                            i++;
                        }
                        break;
                    // If not a primitive, the possible types are specified in what is effectively a map of options.
                    default:
                        options[opt.name] = parseCustomTypeOption(opt, args[i], errors);
                        i++;
                        break;
                }
            }
            else {
                options[opt.name] = undefined;
                i++;
            }
        }
        return i;
    }
    /*@internal*/
    ts.compilerOptionsDidYouMeanDiagnostics = {
        alternateMode: compilerOptionsAlternateMode,
        getOptionsNameMap: getOptionsNameMap,
        optionDeclarations: ts.optionDeclarations,
        unknownOptionDiagnostic: ts.Diagnostics.Unknown_compiler_option_0,
        unknownDidYouMeanDiagnostic: ts.Diagnostics.Unknown_compiler_option_0_Did_you_mean_1,
        optionTypeMismatchDiagnostic: ts.Diagnostics.Compiler_option_0_expects_an_argument
    };
    function parseCommandLine(commandLine, readFile) {
        return parseCommandLineWorker(ts.compilerOptionsDidYouMeanDiagnostics, commandLine, readFile);
    }
    ts.parseCommandLine = parseCommandLine;
    /** @internal */
    function getOptionFromName(optionName, allowShort) {
        return getOptionDeclarationFromName(getOptionsNameMap, optionName, allowShort);
    }
    ts.getOptionFromName = getOptionFromName;
    function getOptionDeclarationFromName(getOptionNameMap, optionName, allowShort) {
        if (allowShort === void 0) { allowShort = false; }
        optionName = optionName.toLowerCase();
        var _a = getOptionNameMap(), optionsNameMap = _a.optionsNameMap, shortOptionNames = _a.shortOptionNames;
        // Try to translate short option names to their full equivalents.
        if (allowShort) {
            var short = shortOptionNames.get(optionName);
            if (short !== undefined) {
                optionName = short;
            }
        }
        return optionsNameMap.get(optionName);
    }
    var buildOptionsNameMapCache;
    function getBuildOptionsNameMap() {
        return buildOptionsNameMapCache || (buildOptionsNameMapCache = createOptionNameMap(ts.buildOpts));
    }
    var buildOptionsAlternateMode = {
        diagnostic: ts.Diagnostics.Compiler_option_0_may_not_be_used_with_build,
        getOptionsNameMap: getOptionsNameMap
    };
    var buildOptionsDidYouMeanDiagnostics = {
        alternateMode: buildOptionsAlternateMode,
        getOptionsNameMap: getBuildOptionsNameMap,
        optionDeclarations: ts.buildOpts,
        unknownOptionDiagnostic: ts.Diagnostics.Unknown_build_option_0,
        unknownDidYouMeanDiagnostic: ts.Diagnostics.Unknown_build_option_0_Did_you_mean_1,
        optionTypeMismatchDiagnostic: ts.Diagnostics.Build_option_0_requires_a_value_of_type_1
    };
    /*@internal*/
    function parseBuildCommand(args) {
        var _a = parseCommandLineWorker(buildOptionsDidYouMeanDiagnostics, args), options = _a.options, watchOptions = _a.watchOptions, projects = _a.fileNames, errors = _a.errors;
        var buildOptions = options;
        if (projects.length === 0) {
            // tsc -b invoked with no extra arguments; act as if invoked with "tsc -b ."
            projects.push(".");
        }
        // Nonsensical combinations
        if (buildOptions.clean && buildOptions.force) {
            errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Options_0_and_1_cannot_be_combined, "clean", "force"));
        }
        if (buildOptions.clean && buildOptions.verbose) {
            errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Options_0_and_1_cannot_be_combined, "clean", "verbose"));
        }
        if (buildOptions.clean && buildOptions.watch) {
            errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Options_0_and_1_cannot_be_combined, "clean", "watch"));
        }
        if (buildOptions.watch && buildOptions.dry) {
            errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Options_0_and_1_cannot_be_combined, "watch", "dry"));
        }
        return { buildOptions: buildOptions, watchOptions: watchOptions, projects: projects, errors: errors };
    }
    ts.parseBuildCommand = parseBuildCommand;
    /* @internal */
    function getDiagnosticText(_message) {
        var _args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            _args[_i - 1] = arguments[_i];
        }
        var diagnostic = ts.createCompilerDiagnostic.apply(undefined, arguments);
        return diagnostic.messageText;
    }
    ts.getDiagnosticText = getDiagnosticText;
    /**
     * Reads the config file, reports errors if any and exits if the config file cannot be found
     */
    function getParsedCommandLineOfConfigFile(configFileName, optionsToExtend, host, extendedConfigCache, watchOptionsToExtend, extraFileExtensions) {
        var configFileText = tryReadFile(configFileName, function (fileName) { return host.readFile(fileName); });
        if (!ts.isString(configFileText)) {
            host.onUnRecoverableConfigFileDiagnostic(configFileText);
            return undefined;
        }
        var result = ts.parseJsonText(configFileName, configFileText);
        var cwd = host.getCurrentDirectory();
        result.path = ts.toPath(configFileName, cwd, ts.createGetCanonicalFileName(host.useCaseSensitiveFileNames));
        result.resolvedPath = result.path;
        result.originalFileName = result.fileName;
        return parseJsonSourceFileConfigFileContent(result, host, ts.getNormalizedAbsolutePath(ts.getDirectoryPath(configFileName), cwd), optionsToExtend, ts.getNormalizedAbsolutePath(configFileName, cwd), 
        /*resolutionStack*/ undefined, extraFileExtensions, extendedConfigCache, watchOptionsToExtend);
    }
    ts.getParsedCommandLineOfConfigFile = getParsedCommandLineOfConfigFile;
    /**
     * Read tsconfig.json file
     * @param fileName The path to the config file
     */
    function readConfigFile(fileName, readFile) {
        var textOrDiagnostic = tryReadFile(fileName, readFile);
        return ts.isString(textOrDiagnostic) ? parseConfigFileTextToJson(fileName, textOrDiagnostic) : { config: {}, error: textOrDiagnostic };
    }
    ts.readConfigFile = readConfigFile;
    /**
     * Parse the text of the tsconfig.json file
     * @param fileName The path to the config file
     * @param jsonText The text of the config file
     */
    function parseConfigFileTextToJson(fileName, jsonText) {
        var jsonSourceFile = ts.parseJsonText(fileName, jsonText);
        return {
            config: convertConfigFileToObject(jsonSourceFile, jsonSourceFile.parseDiagnostics, /*reportOptionsErrors*/ false, /*optionsIterator*/ undefined),
            error: jsonSourceFile.parseDiagnostics.length ? jsonSourceFile.parseDiagnostics[0] : undefined
        };
    }
    ts.parseConfigFileTextToJson = parseConfigFileTextToJson;
    /**
     * Read tsconfig.json file
     * @param fileName The path to the config file
     */
    function readJsonConfigFile(fileName, readFile) {
        var textOrDiagnostic = tryReadFile(fileName, readFile);
        return ts.isString(textOrDiagnostic) ? ts.parseJsonText(fileName, textOrDiagnostic) : { fileName: fileName, parseDiagnostics: [textOrDiagnostic] };
    }
    ts.readJsonConfigFile = readJsonConfigFile;
    /*@internal*/
    function tryReadFile(fileName, readFile) {
        var text;
        try {
            text = readFile(fileName);
        }
        catch (e) {
            return ts.createCompilerDiagnostic(ts.Diagnostics.Cannot_read_file_0_Colon_1, fileName, e.message);
        }
        return text === undefined ? ts.createCompilerDiagnostic(ts.Diagnostics.Cannot_read_file_0, fileName) : text;
    }
    ts.tryReadFile = tryReadFile;
    function commandLineOptionsToMap(options) {
        return ts.arrayToMap(options, getOptionName);
    }
    var typeAcquisitionDidYouMeanDiagnostics = {
        optionDeclarations: ts.typeAcquisitionDeclarations,
        unknownOptionDiagnostic: ts.Diagnostics.Unknown_type_acquisition_option_0,
        unknownDidYouMeanDiagnostic: ts.Diagnostics.Unknown_type_acquisition_option_0_Did_you_mean_1,
    };
    var watchOptionsNameMapCache;
    function getWatchOptionsNameMap() {
        return watchOptionsNameMapCache || (watchOptionsNameMapCache = createOptionNameMap(ts.optionsForWatch));
    }
    var watchOptionsDidYouMeanDiagnostics = {
        getOptionsNameMap: getWatchOptionsNameMap,
        optionDeclarations: ts.optionsForWatch,
        unknownOptionDiagnostic: ts.Diagnostics.Unknown_watch_option_0,
        unknownDidYouMeanDiagnostic: ts.Diagnostics.Unknown_watch_option_0_Did_you_mean_1,
        optionTypeMismatchDiagnostic: ts.Diagnostics.Watch_option_0_requires_a_value_of_type_1
    };
    var commandLineCompilerOptionsMapCache;
    function getCommandLineCompilerOptionsMap() {
        return commandLineCompilerOptionsMapCache || (commandLineCompilerOptionsMapCache = commandLineOptionsToMap(ts.optionDeclarations));
    }
    var commandLineWatchOptionsMapCache;
    function getCommandLineWatchOptionsMap() {
        return commandLineWatchOptionsMapCache || (commandLineWatchOptionsMapCache = commandLineOptionsToMap(ts.optionsForWatch));
    }
    var commandLineTypeAcquisitionMapCache;
    function getCommandLineTypeAcquisitionMap() {
        return commandLineTypeAcquisitionMapCache || (commandLineTypeAcquisitionMapCache = commandLineOptionsToMap(ts.typeAcquisitionDeclarations));
    }
    var _tsconfigRootOptions;
    function getTsconfigRootOptionsMap() {
        if (_tsconfigRootOptions === undefined) {
            _tsconfigRootOptions = {
                name: undefined,
                type: "object",
                elementOptions: commandLineOptionsToMap([
                    {
                        name: "compilerOptions",
                        type: "object",
                        elementOptions: getCommandLineCompilerOptionsMap(),
                        extraKeyDiagnostics: ts.compilerOptionsDidYouMeanDiagnostics,
                    },
                    {
                        name: "watchOptions",
                        type: "object",
                        elementOptions: getCommandLineWatchOptionsMap(),
                        extraKeyDiagnostics: watchOptionsDidYouMeanDiagnostics,
                    },
                    {
                        name: "typingOptions",
                        type: "object",
                        elementOptions: getCommandLineTypeAcquisitionMap(),
                        extraKeyDiagnostics: typeAcquisitionDidYouMeanDiagnostics,
                    },
                    {
                        name: "typeAcquisition",
                        type: "object",
                        elementOptions: getCommandLineTypeAcquisitionMap(),
                        extraKeyDiagnostics: typeAcquisitionDidYouMeanDiagnostics
                    },
                    {
                        name: "extends",
                        type: "string",
                        category: ts.Diagnostics.File_Management,
                    },
                    {
                        name: "references",
                        type: "list",
                        element: {
                            name: "references",
                            type: "object"
                        },
                        category: ts.Diagnostics.Projects,
                    },
                    {
                        name: "files",
                        type: "list",
                        element: {
                            name: "files",
                            type: "string"
                        },
                        category: ts.Diagnostics.File_Management,
                    },
                    {
                        name: "include",
                        type: "list",
                        element: {
                            name: "include",
                            type: "string"
                        },
                        category: ts.Diagnostics.File_Management,
                        defaultValueDescription: ts.Diagnostics.if_files_is_specified_otherwise_Asterisk_Asterisk_Slash_Asterisk
                    },
                    {
                        name: "exclude",
                        type: "list",
                        element: {
                            name: "exclude",
                            type: "string"
                        },
                        category: ts.Diagnostics.File_Management,
                        defaultValueDescription: ts.Diagnostics.node_modules_bower_components_jspm_packages_plus_the_value_of_outDir_if_one_is_specified
                    },
                    ts.compileOnSaveCommandLineOption
                ])
            };
        }
        return _tsconfigRootOptions;
    }
    function convertConfigFileToObject(sourceFile, errors, reportOptionsErrors, optionsIterator) {
        var _a;
        var rootExpression = (_a = sourceFile.statements[0]) === null || _a === void 0 ? void 0 : _a.expression;
        var knownRootOptions = reportOptionsErrors ? getTsconfigRootOptionsMap() : undefined;
        if (rootExpression && rootExpression.kind !== 205 /* SyntaxKind.ObjectLiteralExpression */) {
            errors.push(ts.createDiagnosticForNodeInSourceFile(sourceFile, rootExpression, ts.Diagnostics.The_root_value_of_a_0_file_must_be_an_object, ts.getBaseFileName(sourceFile.fileName) === "jsconfig.json" ? "jsconfig.json" : "tsconfig.json"));
            // Last-ditch error recovery. Somewhat useful because the JSON parser will recover from some parse errors by
            // synthesizing a top-level array literal expression. There's a reasonable chance the first element of that
            // array is a well-formed configuration object, made into an array element by stray characters.
            if (ts.isArrayLiteralExpression(rootExpression)) {
                var firstObject = ts.find(rootExpression.elements, ts.isObjectLiteralExpression);
                if (firstObject) {
                    return convertToObjectWorker(sourceFile, firstObject, errors, /*returnValue*/ true, knownRootOptions, optionsIterator);
                }
            }
            return {};
        }
        return convertToObjectWorker(sourceFile, rootExpression, errors, /*returnValue*/ true, knownRootOptions, optionsIterator);
    }
    /**
     * Convert the json syntax tree into the json value
     */
    function convertToObject(sourceFile, errors) {
        var _a;
        return convertToObjectWorker(sourceFile, (_a = sourceFile.statements[0]) === null || _a === void 0 ? void 0 : _a.expression, errors, /*returnValue*/ true, /*knownRootOptions*/ undefined, /*jsonConversionNotifier*/ undefined);
    }
    ts.convertToObject = convertToObject;
    /**
     * Convert the json syntax tree into the json value and report errors
     * This returns the json value (apart from checking errors) only if returnValue provided is true.
     * Otherwise it just checks the errors and returns undefined
     */
    /*@internal*/
    function convertToObjectWorker(sourceFile, rootExpression, errors, returnValue, knownRootOptions, jsonConversionNotifier) {
        if (!rootExpression) {
            return returnValue ? {} : undefined;
        }
        return convertPropertyValueToJson(rootExpression, knownRootOptions);
        function isRootOptionMap(knownOptions) {
            return knownRootOptions && knownRootOptions.elementOptions === knownOptions;
        }
        function convertObjectLiteralExpressionToJson(node, knownOptions, extraKeyDiagnostics, parentOption) {
            var result = returnValue ? {} : undefined;
            var _loop_4 = function (element) {
                if (element.kind !== 296 /* SyntaxKind.PropertyAssignment */) {
                    errors.push(ts.createDiagnosticForNodeInSourceFile(sourceFile, element, ts.Diagnostics.Property_assignment_expected));
                    return "continue";
                }
                if (element.questionToken) {
                    errors.push(ts.createDiagnosticForNodeInSourceFile(sourceFile, element.questionToken, ts.Diagnostics.The_0_modifier_can_only_be_used_in_TypeScript_files, "?"));
                }
                if (!isDoubleQuotedString(element.name)) {
                    errors.push(ts.createDiagnosticForNodeInSourceFile(sourceFile, element.name, ts.Diagnostics.String_literal_with_double_quotes_expected));
                }
                var textOfKey = ts.isComputedNonLiteralName(element.name) ? undefined : ts.getTextOfPropertyName(element.name);
                var keyText = textOfKey && ts.unescapeLeadingUnderscores(textOfKey);
                var option = keyText && knownOptions ? knownOptions.get(keyText) : undefined;
                if (keyText && extraKeyDiagnostics && !option) {
                    if (knownOptions) {
                        errors.push(createUnknownOptionError(keyText, extraKeyDiagnostics, function (message, arg0, arg1) { return ts.createDiagnosticForNodeInSourceFile(sourceFile, element.name, message, arg0, arg1); }));
                    }
                    else {
                        errors.push(ts.createDiagnosticForNodeInSourceFile(sourceFile, element.name, extraKeyDiagnostics.unknownOptionDiagnostic, keyText));
                    }
                }
                var value = convertPropertyValueToJson(element.initializer, option);
                if (typeof keyText !== "undefined") {
                    if (returnValue) {
                        result[keyText] = value;
                    }
                    // Notify key value set, if user asked for it
                    if (jsonConversionNotifier &&
                        // Current callbacks are only on known parent option or if we are setting values in the root
                        (parentOption || isRootOptionMap(knownOptions))) {
                        var isValidOptionValue = isCompilerOptionsValue(option, value);
                        if (parentOption) {
                            if (isValidOptionValue) {
                                // Notify option set in the parent if its a valid option value
                                jsonConversionNotifier.onSetValidOptionKeyValueInParent(parentOption, option, value);
                            }
                        }
                        else if (isRootOptionMap(knownOptions)) {
                            if (isValidOptionValue) {
                                // Notify about the valid root key value being set
                                jsonConversionNotifier.onSetValidOptionKeyValueInRoot(keyText, element.name, value, element.initializer);
                            }
                            else if (!option) {
                                // Notify about the unknown root key value being set
                                jsonConversionNotifier.onSetUnknownOptionKeyValueInRoot(keyText, element.name, value, element.initializer);
                            }
                        }
                    }
                }
            };
            for (var _i = 0, _a = node.properties; _i < _a.length; _i++) {
                var element = _a[_i];
                _loop_4(element);
            }
            return result;
        }
        function convertArrayLiteralExpressionToJson(elements, elementOption) {
            if (!returnValue) {
                elements.forEach(function (element) { return convertPropertyValueToJson(element, elementOption); });
                return undefined;
            }
            // Filter out invalid values
            return ts.filter(elements.map(function (element) { return convertPropertyValueToJson(element, elementOption); }), function (v) { return v !== undefined; });
        }
        function convertPropertyValueToJson(valueExpression, option) {
            var invalidReported;
            switch (valueExpression.kind) {
                case 110 /* SyntaxKind.TrueKeyword */:
                    reportInvalidOptionValue(option && option.type !== "boolean");
                    return validateValue(/*value*/ true);
                case 95 /* SyntaxKind.FalseKeyword */:
                    reportInvalidOptionValue(option && option.type !== "boolean");
                    return validateValue(/*value*/ false);
                case 104 /* SyntaxKind.NullKeyword */:
                    reportInvalidOptionValue(option && option.name === "extends"); // "extends" is the only option we don't allow null/undefined for
                    return validateValue(/*value*/ null); // eslint-disable-line no-null/no-null
                case 10 /* SyntaxKind.StringLiteral */:
                    if (!isDoubleQuotedString(valueExpression)) {
                        errors.push(ts.createDiagnosticForNodeInSourceFile(sourceFile, valueExpression, ts.Diagnostics.String_literal_with_double_quotes_expected));
                    }
                    reportInvalidOptionValue(option && (ts.isString(option.type) && option.type !== "string"));
                    var text = valueExpression.text;
                    if (option && !ts.isString(option.type)) {
                        var customOption = option;
                        // Validate custom option type
                        if (!customOption.type.has(text.toLowerCase())) {
                            errors.push(createDiagnosticForInvalidCustomType(customOption, function (message, arg0, arg1) { return ts.createDiagnosticForNodeInSourceFile(sourceFile, valueExpression, message, arg0, arg1); }));
                            invalidReported = true;
                        }
                    }
                    return validateValue(text);
                case 8 /* SyntaxKind.NumericLiteral */:
                    reportInvalidOptionValue(option && option.type !== "number");
                    return validateValue(Number(valueExpression.text));
                case 219 /* SyntaxKind.PrefixUnaryExpression */:
                    if (valueExpression.operator !== 40 /* SyntaxKind.MinusToken */ || valueExpression.operand.kind !== 8 /* SyntaxKind.NumericLiteral */) {
                        break; // not valid JSON syntax
                    }
                    reportInvalidOptionValue(option && option.type !== "number");
                    return validateValue(-Number(valueExpression.operand.text));
                case 205 /* SyntaxKind.ObjectLiteralExpression */:
                    reportInvalidOptionValue(option && option.type !== "object");
                    var objectLiteralExpression = valueExpression;
                    // Currently having element option declaration in the tsconfig with type "object"
                    // determines if it needs onSetValidOptionKeyValueInParent callback or not
                    // At moment there are only "compilerOptions", "typeAcquisition" and "typingOptions"
                    // that satifies it and need it to modify options set in them (for normalizing file paths)
                    // vs what we set in the json
                    // If need arises, we can modify this interface and callbacks as needed
                    if (option) {
                        var _a = option, elementOptions = _a.elementOptions, extraKeyDiagnostics = _a.extraKeyDiagnostics, optionName = _a.name;
                        return validateValue(convertObjectLiteralExpressionToJson(objectLiteralExpression, elementOptions, extraKeyDiagnostics, optionName));
                    }
                    else {
                        return validateValue(convertObjectLiteralExpressionToJson(objectLiteralExpression, /* knownOptions*/ undefined, 
                        /*extraKeyDiagnosticMessage */ undefined, /*parentOption*/ undefined));
                    }
                case 204 /* SyntaxKind.ArrayLiteralExpression */:
                    reportInvalidOptionValue(option && option.type !== "list");
                    return validateValue(convertArrayLiteralExpressionToJson(valueExpression.elements, option && option.element));
            }
            // Not in expected format
            if (option) {
                reportInvalidOptionValue(/*isError*/ true);
            }
            else {
                errors.push(ts.createDiagnosticForNodeInSourceFile(sourceFile, valueExpression, ts.Diagnostics.Property_value_can_only_be_string_literal_numeric_literal_true_false_null_object_literal_or_array_literal));
            }
            return undefined;
            function validateValue(value) {
                var _a;
                if (!invalidReported) {
                    var diagnostic = (_a = option === null || option === void 0 ? void 0 : option.extraValidation) === null || _a === void 0 ? void 0 : _a.call(option, value);
                    if (diagnostic) {
                        errors.push(ts.createDiagnosticForNodeInSourceFile.apply(void 0, __spreadArray([sourceFile, valueExpression], diagnostic, false)));
                        return undefined;
                    }
                }
                return value;
            }
            function reportInvalidOptionValue(isError) {
                if (isError) {
                    errors.push(ts.createDiagnosticForNodeInSourceFile(sourceFile, valueExpression, ts.Diagnostics.Compiler_option_0_requires_a_value_of_type_1, option.name, getCompilerOptionValueTypeString(option)));
                    invalidReported = true;
                }
            }
        }
        function isDoubleQuotedString(node) {
            return ts.isStringLiteral(node) && ts.isStringDoubleQuoted(node, sourceFile);
        }
    }
    ts.convertToObjectWorker = convertToObjectWorker;
    function getCompilerOptionValueTypeString(option) {
        return option.type === "list" ?
            "Array" :
            ts.isString(option.type) ? option.type : "string";
    }
    function isCompilerOptionsValue(option, value) {
        if (option) {
            if (isNullOrUndefined(value))
                return true; // All options are undefinable/nullable
            if (option.type === "list") {
                return ts.isArray(value);
            }
            var expectedType = ts.isString(option.type) ? option.type : "string";
            return typeof value === expectedType;
        }
        return false;
    }
    /**
     * Generate an uncommented, complete tsconfig for use with "--showConfig"
     * @param configParseResult options to be generated into tsconfig.json
     * @param configFileName name of the parsed config file - output paths will be generated relative to this
     * @param host provides current directory and case sensitivity services
     */
    /** @internal */
    function convertToTSConfig(configParseResult, configFileName, host) {
        var _a, _b, _c;
        var getCanonicalFileName = ts.createGetCanonicalFileName(host.useCaseSensitiveFileNames);
        var files = ts.map(ts.filter(configParseResult.fileNames, !((_b = (_a = configParseResult.options.configFile) === null || _a === void 0 ? void 0 : _a.configFileSpecs) === null || _b === void 0 ? void 0 : _b.validatedIncludeSpecs) ? ts.returnTrue : matchesSpecs(configFileName, configParseResult.options.configFile.configFileSpecs.validatedIncludeSpecs, configParseResult.options.configFile.configFileSpecs.validatedExcludeSpecs, host)), function (f) { return ts.getRelativePathFromFile(ts.getNormalizedAbsolutePath(configFileName, host.getCurrentDirectory()), ts.getNormalizedAbsolutePath(f, host.getCurrentDirectory()), getCanonicalFileName); });
        var optionMap = serializeCompilerOptions(configParseResult.options, { configFilePath: ts.getNormalizedAbsolutePath(configFileName, host.getCurrentDirectory()), useCaseSensitiveFileNames: host.useCaseSensitiveFileNames });
        var watchOptionMap = configParseResult.watchOptions && serializeWatchOptions(configParseResult.watchOptions);
        var config = __assign(__assign({ compilerOptions: __assign(__assign({}, optionMapToObject(optionMap)), { showConfig: undefined, configFile: undefined, configFilePath: undefined, help: undefined, init: undefined, listFiles: undefined, listEmittedFiles: undefined, project: undefined, build: undefined, version: undefined }), watchOptions: watchOptionMap && optionMapToObject(watchOptionMap), references: ts.map(configParseResult.projectReferences, function (r) { return (__assign(__assign({}, r), { path: r.originalPath ? r.originalPath : "", originalPath: undefined })); }), files: ts.length(files) ? files : undefined }, (((_c = configParseResult.options.configFile) === null || _c === void 0 ? void 0 : _c.configFileSpecs) ? {
            include: filterSameAsDefaultInclude(configParseResult.options.configFile.configFileSpecs.validatedIncludeSpecs),
            exclude: configParseResult.options.configFile.configFileSpecs.validatedExcludeSpecs
        } : {})), { compileOnSave: !!configParseResult.compileOnSave ? true : undefined });
        return config;
    }
    ts.convertToTSConfig = convertToTSConfig;
    function optionMapToObject(optionMap) {
        return __assign({}, ts.arrayFrom(optionMap.entries()).reduce(function (prev, cur) {
            var _a;
            return (__assign(__assign({}, prev), (_a = {}, _a[cur[0]] = cur[1], _a)));
        }, {}));
    }
    function filterSameAsDefaultInclude(specs) {
        if (!ts.length(specs))
            return undefined;
        if (ts.length(specs) !== 1)
            return specs;
        if (specs[0] === ts.defaultIncludeSpec)
            return undefined;
        return specs;
    }
    function matchesSpecs(path, includeSpecs, excludeSpecs, host) {
        if (!includeSpecs)
            return ts.returnTrue;
        var patterns = ts.getFileMatcherPatterns(path, excludeSpecs, includeSpecs, host.useCaseSensitiveFileNames, host.getCurrentDirectory());
        var excludeRe = patterns.excludePattern && ts.getRegexFromPattern(patterns.excludePattern, host.useCaseSensitiveFileNames);
        var includeRe = patterns.includeFilePattern && ts.getRegexFromPattern(patterns.includeFilePattern, host.useCaseSensitiveFileNames);
        if (includeRe) {
            if (excludeRe) {
                return function (path) { return !(includeRe.test(path) && !excludeRe.test(path)); };
            }
            return function (path) { return !includeRe.test(path); };
        }
        if (excludeRe) {
            return function (path) { return excludeRe.test(path); };
        }
        return ts.returnTrue;
    }
    function getCustomTypeMapOfCommandLineOption(optionDefinition) {
        if (optionDefinition.type === "string" || optionDefinition.type === "number" || optionDefinition.type === "boolean" || optionDefinition.type === "object") {
            // this is of a type CommandLineOptionOfPrimitiveType
            return undefined;
        }
        else if (optionDefinition.type === "list") {
            return getCustomTypeMapOfCommandLineOption(optionDefinition.element);
        }
        else {
            return optionDefinition.type;
        }
    }
    /* @internal */
    function getNameOfCompilerOptionValue(value, customTypeMap) {
        // There is a typeMap associated with this command-line option so use it to map value back to its name
        return ts.forEachEntry(customTypeMap, function (mapValue, key) {
            if (mapValue === value) {
                return key;
            }
        });
    }
    ts.getNameOfCompilerOptionValue = getNameOfCompilerOptionValue;
    function serializeCompilerOptions(options, pathOptions) {
        return serializeOptionBaseObject(options, getOptionsNameMap(), pathOptions);
    }
    function serializeWatchOptions(options) {
        return serializeOptionBaseObject(options, getWatchOptionsNameMap());
    }
    function serializeOptionBaseObject(options, _a, pathOptions) {
        var optionsNameMap = _a.optionsNameMap;
        var result = new ts.Map();
        var getCanonicalFileName = pathOptions && ts.createGetCanonicalFileName(pathOptions.useCaseSensitiveFileNames);
        var _loop_5 = function (name) {
            if (ts.hasProperty(options, name)) {
                // tsconfig only options cannot be specified via command line,
                // so we can assume that only types that can appear here string | number | boolean
                if (optionsNameMap.has(name) && (optionsNameMap.get(name).category === ts.Diagnostics.Command_line_Options || optionsNameMap.get(name).category === ts.Diagnostics.Output_Formatting)) {
                    return "continue";
                }
                var value = options[name];
                var optionDefinition = optionsNameMap.get(name.toLowerCase());
                if (optionDefinition) {
                    var customTypeMap_1 = getCustomTypeMapOfCommandLineOption(optionDefinition);
                    if (!customTypeMap_1) {
                        // There is no map associated with this compiler option then use the value as-is
                        // This is the case if the value is expect to be string, number, boolean or list of string
                        if (pathOptions && optionDefinition.isFilePath) {
                            result.set(name, ts.getRelativePathFromFile(pathOptions.configFilePath, ts.getNormalizedAbsolutePath(value, ts.getDirectoryPath(pathOptions.configFilePath)), getCanonicalFileName));
                        }
                        else {
                            result.set(name, value);
                        }
                    }
                    else {
                        if (optionDefinition.type === "list") {
                            result.set(name, value.map(function (element) { return getNameOfCompilerOptionValue(element, customTypeMap_1); })); // TODO: GH#18217
                        }
                        else {
                            // There is a typeMap associated with this command-line option so use it to map value back to its name
                            result.set(name, getNameOfCompilerOptionValue(value, customTypeMap_1));
                        }
                    }
                }
            }
        };
        for (var name in options) {
            _loop_5(name);
        }
        return result;
    }
    /**
     * Generate a list of the compiler options whose value is not the default.
     * @param options compilerOptions to be evaluated.
    /** @internal */
    function getCompilerOptionsDiffValue(options, newLine) {
        var compilerOptionsMap = getSerializedCompilerOption(options);
        return getOverwrittenDefaultOptions();
        function makePadding(paddingLength) {
            return Array(paddingLength + 1).join(" ");
        }
        function getOverwrittenDefaultOptions() {
            var result = [];
            var tab = makePadding(2);
            commandOptionsWithoutBuild.forEach(function (cmd) {
                if (!compilerOptionsMap.has(cmd.name)) {
                    return;
                }
                var newValue = compilerOptionsMap.get(cmd.name);
                var defaultValue = getDefaultValueForOption(cmd);
                if (newValue !== defaultValue) {
                    result.push("".concat(tab).concat(cmd.name, ": ").concat(newValue));
                }
                else if (ts.hasProperty(ts.defaultInitCompilerOptions, cmd.name)) {
                    result.push("".concat(tab).concat(cmd.name, ": ").concat(defaultValue));
                }
            });
            return result.join(newLine) + newLine;
        }
    }
    ts.getCompilerOptionsDiffValue = getCompilerOptionsDiffValue;
    /**
     * Get the compiler options to be written into the tsconfig.json.
     * @param options commandlineOptions to be included in the compileOptions.
     */
    function getSerializedCompilerOption(options) {
        var compilerOptions = ts.extend(options, ts.defaultInitCompilerOptions);
        return serializeCompilerOptions(compilerOptions);
    }
    /**
     * Generate tsconfig configuration when running command line "--init"
     * @param options commandlineOptions to be generated into tsconfig.json
     * @param fileNames array of filenames to be generated into tsconfig.json
     */
    /* @internal */
    function generateTSConfig(options, fileNames, newLine) {
        var compilerOptionsMap = getSerializedCompilerOption(options);
        return writeConfigurations();
        function makePadding(paddingLength) {
            return Array(paddingLength + 1).join(" ");
        }
        function isAllowedOptionForOutput(_a) {
            var category = _a.category, name = _a.name, isCommandLineOnly = _a.isCommandLineOnly;
            // Skip options which do not have a category or have categories which are more niche
            var categoriesToSkip = [ts.Diagnostics.Command_line_Options, ts.Diagnostics.Editor_Support, ts.Diagnostics.Compiler_Diagnostics, ts.Diagnostics.Backwards_Compatibility, ts.Diagnostics.Watch_and_Build_Modes, ts.Diagnostics.Output_Formatting];
            return !isCommandLineOnly && category !== undefined && (!categoriesToSkip.includes(category) || compilerOptionsMap.has(name));
        }
        function writeConfigurations() {
            // Filter applicable options to place in the file
            var categorizedOptions = ts.createMultiMap();
            for (var _i = 0, optionDeclarations_1 = ts.optionDeclarations; _i < optionDeclarations_1.length; _i++) {
                var option = optionDeclarations_1[_i];
                var category = option.category;
                if (isAllowedOptionForOutput(option)) {
                    categorizedOptions.add(ts.getLocaleSpecificMessage(category), option);
                }
            }
            // Serialize all options and their descriptions
            var marginLength = 0;
            var seenKnownKeys = 0;
            var entries = [];
            categorizedOptions.forEach(function (options, category) {
                if (entries.length !== 0) {
                    entries.push({ value: "" });
                }
                entries.push({ value: "/* ".concat(category, " */") });
                for (var _i = 0, options_1 = options; _i < options_1.length; _i++) {
                    var option = options_1[_i];
                    var optionName = void 0;
                    if (compilerOptionsMap.has(option.name)) {
                        optionName = "\"".concat(option.name, "\": ").concat(JSON.stringify(compilerOptionsMap.get(option.name))).concat((seenKnownKeys += 1) === compilerOptionsMap.size ? "" : ",");
                    }
                    else {
                        optionName = "// \"".concat(option.name, "\": ").concat(JSON.stringify(getDefaultValueForOption(option)), ",");
                    }
                    entries.push({
                        value: optionName,
                        description: "/* ".concat(option.description && ts.getLocaleSpecificMessage(option.description) || option.name, " */")
                    });
                    marginLength = Math.max(optionName.length, marginLength);
                }
            });
            // Write the output
            var tab = makePadding(2);
            var result = [];
            result.push("{");
            result.push("".concat(tab, "\"compilerOptions\": {"));
            result.push("".concat(tab).concat(tab, "/* ").concat(ts.getLocaleSpecificMessage(ts.Diagnostics.Visit_https_Colon_Slash_Slashaka_ms_Slashtsconfig_to_read_more_about_this_file), " */"));
            result.push("");
            // Print out each row, aligning all the descriptions on the same column.
            for (var _a = 0, entries_2 = entries; _a < entries_2.length; _a++) {
                var entry = entries_2[_a];
                var value = entry.value, _b = entry.description, description = _b === void 0 ? "" : _b;
                result.push(value && "".concat(tab).concat(tab).concat(value).concat(description && (makePadding(marginLength - value.length + 2) + description)));
            }
            if (fileNames.length) {
                result.push("".concat(tab, "},"));
                result.push("".concat(tab, "\"files\": ["));
                for (var i = 0; i < fileNames.length; i++) {
                    result.push("".concat(tab).concat(tab).concat(JSON.stringify(fileNames[i])).concat(i === fileNames.length - 1 ? "" : ","));
                }
                result.push("".concat(tab, "]"));
            }
            else {
                result.push("".concat(tab, "}"));
            }
            result.push("}");
            return result.join(newLine) + newLine;
        }
    }
    ts.generateTSConfig = generateTSConfig;
    /* @internal */
    function convertToOptionsWithAbsolutePaths(options, toAbsolutePath) {
        var result = {};
        var optionsNameMap = getOptionsNameMap().optionsNameMap;
        for (var name in options) {
            if (ts.hasProperty(options, name)) {
                result[name] = convertToOptionValueWithAbsolutePaths(optionsNameMap.get(name.toLowerCase()), options[name], toAbsolutePath);
            }
        }
        if (result.configFilePath) {
            result.configFilePath = toAbsolutePath(result.configFilePath);
        }
        return result;
    }
    ts.convertToOptionsWithAbsolutePaths = convertToOptionsWithAbsolutePaths;
    function convertToOptionValueWithAbsolutePaths(option, value, toAbsolutePath) {
        if (option && !isNullOrUndefined(value)) {
            if (option.type === "list") {
                var values = value;
                if (option.element.isFilePath && values.length) {
                    return values.map(toAbsolutePath);
                }
            }
            else if (option.isFilePath) {
                return toAbsolutePath(value);
            }
        }
        return value;
    }
    /**
     * Parse the contents of a config file (tsconfig.json).
     * @param json The contents of the config file to parse
     * @param host Instance of ParseConfigHost used to enumerate files in folder.
     * @param basePath A root directory to resolve relative path entries in the config
     *    file to. e.g. outDir
     */
    function parseJsonConfigFileContent(json, host, basePath, existingOptions, configFileName, resolutionStack, extraFileExtensions, extendedConfigCache, existingWatchOptions) {
        return parseJsonConfigFileContentWorker(json, /*sourceFile*/ undefined, host, basePath, existingOptions, existingWatchOptions, configFileName, resolutionStack, extraFileExtensions, extendedConfigCache);
    }
    ts.parseJsonConfigFileContent = parseJsonConfigFileContent;
    /**
     * Parse the contents of a config file (tsconfig.json).
     * @param jsonNode The contents of the config file to parse
     * @param host Instance of ParseConfigHost used to enumerate files in folder.
     * @param basePath A root directory to resolve relative path entries in the config
     *    file to. e.g. outDir
     */
    function parseJsonSourceFileConfigFileContent(sourceFile, host, basePath, existingOptions, configFileName, resolutionStack, extraFileExtensions, extendedConfigCache, existingWatchOptions) {
        ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.push("parse" /* tracing.Phase.Parse */, "parseJsonSourceFileConfigFileContent", { path: sourceFile.fileName });
        var result = parseJsonConfigFileContentWorker(/*json*/ undefined, sourceFile, host, basePath, existingOptions, existingWatchOptions, configFileName, resolutionStack, extraFileExtensions, extendedConfigCache);
        ts.tracing === null || ts.tracing === void 0 ? void 0 : ts.tracing.pop();
        return result;
    }
    ts.parseJsonSourceFileConfigFileContent = parseJsonSourceFileConfigFileContent;
    /*@internal*/
    function setConfigFileInOptions(options, configFile) {
        if (configFile) {
            Object.defineProperty(options, "configFile", { enumerable: false, writable: false, value: configFile });
        }
    }
    ts.setConfigFileInOptions = setConfigFileInOptions;
    function isNullOrUndefined(x) {
        return x === undefined || x === null; // eslint-disable-line no-null/no-null
    }
    function directoryOfCombinedPath(fileName, basePath) {
        // Use the `getNormalizedAbsolutePath` function to avoid canonicalizing the path, as it must remain noncanonical
        // until consistent casing errors are reported
        return ts.getDirectoryPath(ts.getNormalizedAbsolutePath(fileName, basePath));
    }
    /*@internal*/
    ts.defaultIncludeSpec = "**/*";
    /**
     * Parse the contents of a config file from json or json source file (tsconfig.json).
     * @param json The contents of the config file to parse
     * @param sourceFile sourceFile corresponding to the Json
     * @param host Instance of ParseConfigHost used to enumerate files in folder.
     * @param basePath A root directory to resolve relative path entries in the config
     *    file to. e.g. outDir
     * @param resolutionStack Only present for backwards-compatibility. Should be empty.
     */
    function parseJsonConfigFileContentWorker(json, sourceFile, host, basePath, existingOptions, existingWatchOptions, configFileName, resolutionStack, extraFileExtensions, extendedConfigCache) {
        if (existingOptions === void 0) { existingOptions = {}; }
        if (resolutionStack === void 0) { resolutionStack = []; }
        if (extraFileExtensions === void 0) { extraFileExtensions = []; }
        ts.Debug.assert((json === undefined && sourceFile !== undefined) || (json !== undefined && sourceFile === undefined));
        var errors = [];
        var parsedConfig = parseConfig(json, sourceFile, host, basePath, configFileName, resolutionStack, errors, extendedConfigCache);
        var raw = parsedConfig.raw;
        var options = ts.extend(existingOptions, parsedConfig.options || {});
        var watchOptions = existingWatchOptions && parsedConfig.watchOptions ?
            ts.extend(existingWatchOptions, parsedConfig.watchOptions) :
            parsedConfig.watchOptions || existingWatchOptions;
        options.configFilePath = configFileName && ts.normalizeSlashes(configFileName);
        var configFileSpecs = getConfigFileSpecs();
        if (sourceFile)
            sourceFile.configFileSpecs = configFileSpecs;
        setConfigFileInOptions(options, sourceFile);
        var basePathForFileNames = ts.normalizePath(configFileName ? directoryOfCombinedPath(configFileName, basePath) : basePath);
        return {
            options: options,
            watchOptions: watchOptions,
            fileNames: getFileNames(basePathForFileNames),
            projectReferences: getProjectReferences(basePathForFileNames),
            typeAcquisition: parsedConfig.typeAcquisition || getDefaultTypeAcquisition(),
            raw: raw,
            errors: errors,
            // Wildcard directories (provided as part of a wildcard path) are stored in a
            // file map that marks whether it was a regular wildcard match (with a `*` or `?` token),
            // or a recursive directory. This information is used by filesystem watchers to monitor for
            // new entries in these paths.
            wildcardDirectories: getWildcardDirectories(configFileSpecs, basePathForFileNames, host.useCaseSensitiveFileNames),
            compileOnSave: !!raw.compileOnSave,
        };
        function getConfigFileSpecs() {
            var referencesOfRaw = getPropFromRaw("references", function (element) { return typeof element === "object"; }, "object");
            var filesSpecs = toPropValue(getSpecsFromRaw("files"));
            if (filesSpecs) {
                var hasZeroOrNoReferences = referencesOfRaw === "no-prop" || ts.isArray(referencesOfRaw) && referencesOfRaw.length === 0;
                var hasExtends = ts.hasProperty(raw, "extends");
                if (filesSpecs.length === 0 && hasZeroOrNoReferences && !hasExtends) {
                    if (sourceFile) {
                        var fileName = configFileName || "tsconfig.json";
                        var diagnosticMessage = ts.Diagnostics.The_files_list_in_config_file_0_is_empty;
                        var nodeValue = ts.firstDefined(ts.getTsConfigPropArray(sourceFile, "files"), function (property) { return property.initializer; });
                        var error = nodeValue
                            ? ts.createDiagnosticForNodeInSourceFile(sourceFile, nodeValue, diagnosticMessage, fileName)
                            : ts.createCompilerDiagnostic(diagnosticMessage, fileName);
                        errors.push(error);
                    }
                    else {
                        createCompilerDiagnosticOnlyIfJson(ts.Diagnostics.The_files_list_in_config_file_0_is_empty, configFileName || "tsconfig.json");
                    }
                }
            }
            var includeSpecs = toPropValue(getSpecsFromRaw("include"));
            var excludeOfRaw = getSpecsFromRaw("exclude");
            var isDefaultIncludeSpec = false;
            var excludeSpecs = toPropValue(excludeOfRaw);
            if (excludeOfRaw === "no-prop" && raw.compilerOptions) {
                var outDir = raw.compilerOptions.outDir;
                var declarationDir = raw.compilerOptions.declarationDir;
                if (outDir || declarationDir) {
                    excludeSpecs = [outDir, declarationDir].filter(function (d) { return !!d; });
                }
            }
            if (filesSpecs === undefined && includeSpecs === undefined) {
                includeSpecs = [ts.defaultIncludeSpec];
                isDefaultIncludeSpec = true;
            }
            var validatedIncludeSpecs, validatedExcludeSpecs;
            // The exclude spec list is converted into a regular expression, which allows us to quickly
            // test whether a file or directory should be excluded before recursively traversing the
            // file system.
            if (includeSpecs) {
                validatedIncludeSpecs = validateSpecs(includeSpecs, errors, /*disallowTrailingRecursion*/ true, sourceFile, "include");
            }
            if (excludeSpecs) {
                validatedExcludeSpecs = validateSpecs(excludeSpecs, errors, /*disallowTrailingRecursion*/ false, sourceFile, "exclude");
            }
            return {
                filesSpecs: filesSpecs,
                includeSpecs: includeSpecs,
                excludeSpecs: excludeSpecs,
                validatedFilesSpec: ts.filter(filesSpecs, ts.isString),
                validatedIncludeSpecs: validatedIncludeSpecs,
                validatedExcludeSpecs: validatedExcludeSpecs,
                pathPatterns: undefined,
                isDefaultIncludeSpec: isDefaultIncludeSpec,
            };
        }
        function getFileNames(basePath) {
            var fileNames = getFileNamesFromConfigSpecs(configFileSpecs, basePath, options, host, extraFileExtensions);
            if (shouldReportNoInputFiles(fileNames, canJsonReportNoInputFiles(raw), resolutionStack)) {
                errors.push(getErrorForNoInputFiles(configFileSpecs, configFileName));
            }
            return fileNames;
        }
        function getProjectReferences(basePath) {
            var projectReferences;
            var referencesOfRaw = getPropFromRaw("references", function (element) { return typeof element === "object"; }, "object");
            if (ts.isArray(referencesOfRaw)) {
                for (var _i = 0, referencesOfRaw_1 = referencesOfRaw; _i < referencesOfRaw_1.length; _i++) {
                    var ref = referencesOfRaw_1[_i];
                    if (typeof ref.path !== "string") {
                        createCompilerDiagnosticOnlyIfJson(ts.Diagnostics.Compiler_option_0_requires_a_value_of_type_1, "reference.path", "string");
                    }
                    else {
                        (projectReferences || (projectReferences = [])).push({
                            path: ts.getNormalizedAbsolutePath(ref.path, basePath),
                            originalPath: ref.path,
                            prepend: ref.prepend,
                            circular: ref.circular
                        });
                    }
                }
            }
            return projectReferences;
        }
        function toPropValue(specResult) {
            return ts.isArray(specResult) ? specResult : undefined;
        }
        function getSpecsFromRaw(prop) {
            return getPropFromRaw(prop, ts.isString, "string");
        }
        function getPropFromRaw(prop, validateElement, elementTypeName) {
            if (ts.hasProperty(raw, prop) && !isNullOrUndefined(raw[prop])) {
                if (ts.isArray(raw[prop])) {
                    var result = raw[prop];
                    if (!sourceFile && !ts.every(result, validateElement)) {
                        errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Compiler_option_0_requires_a_value_of_type_1, prop, elementTypeName));
                    }
                    return result;
                }
                else {
                    createCompilerDiagnosticOnlyIfJson(ts.Diagnostics.Compiler_option_0_requires_a_value_of_type_1, prop, "Array");
                    return "not-array";
                }
            }
            return "no-prop";
        }
        function createCompilerDiagnosticOnlyIfJson(message, arg0, arg1) {
            if (!sourceFile) {
                errors.push(ts.createCompilerDiagnostic(message, arg0, arg1));
            }
        }
    }
    function isErrorNoInputFiles(error) {
        return error.code === ts.Diagnostics.No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2.code;
    }
    function getErrorForNoInputFiles(_a, configFileName) {
        var includeSpecs = _a.includeSpecs, excludeSpecs = _a.excludeSpecs;
        return ts.createCompilerDiagnostic(ts.Diagnostics.No_inputs_were_found_in_config_file_0_Specified_include_paths_were_1_and_exclude_paths_were_2, configFileName || "tsconfig.json", JSON.stringify(includeSpecs || []), JSON.stringify(excludeSpecs || []));
    }
    function shouldReportNoInputFiles(fileNames, canJsonReportNoInutFiles, resolutionStack) {
        return fileNames.length === 0 && canJsonReportNoInutFiles && (!resolutionStack || resolutionStack.length === 0);
    }
    /*@internal*/
    function canJsonReportNoInputFiles(raw) {
        return !ts.hasProperty(raw, "files") && !ts.hasProperty(raw, "references");
    }
    ts.canJsonReportNoInputFiles = canJsonReportNoInputFiles;
    /*@internal*/
    function updateErrorForNoInputFiles(fileNames, configFileName, configFileSpecs, configParseDiagnostics, canJsonReportNoInutFiles) {
        var existingErrors = configParseDiagnostics.length;
        if (shouldReportNoInputFiles(fileNames, canJsonReportNoInutFiles)) {
            configParseDiagnostics.push(getErrorForNoInputFiles(configFileSpecs, configFileName));
        }
        else {
            ts.filterMutate(configParseDiagnostics, function (error) { return !isErrorNoInputFiles(error); });
        }
        return existingErrors !== configParseDiagnostics.length;
    }
    ts.updateErrorForNoInputFiles = updateErrorForNoInputFiles;
    function isSuccessfulParsedTsconfig(value) {
        return !!value.options;
    }
    /**
     * This *just* extracts options/include/exclude/files out of a config file.
     * It does *not* resolve the included files.
     */
    function parseConfig(json, sourceFile, host, basePath, configFileName, resolutionStack, errors, extendedConfigCache) {
        var _a;
        basePath = ts.normalizeSlashes(basePath);
        var resolvedPath = ts.getNormalizedAbsolutePath(configFileName || "", basePath);
        if (resolutionStack.indexOf(resolvedPath) >= 0) {
            errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Circularity_detected_while_resolving_configuration_Colon_0, __spreadArray(__spreadArray([], resolutionStack, true), [resolvedPath], false).join(" -> ")));
            return { raw: json || convertToObject(sourceFile, errors) };
        }
        var ownConfig = json ?
            parseOwnConfigOfJson(json, host, basePath, configFileName, errors) :
            parseOwnConfigOfJsonSourceFile(sourceFile, host, basePath, configFileName, errors);
        if ((_a = ownConfig.options) === null || _a === void 0 ? void 0 : _a.paths) {
            // If we end up needing to resolve relative paths from 'paths' relative to
            // the config file location, we'll need to know where that config file was.
            // Since 'paths' can be inherited from an extended config in another directory,
            // we wouldn't know which directory to use unless we store it here.
            ownConfig.options.pathsBasePath = basePath;
        }
        if (ownConfig.extendedConfigPath) {
            // copy the resolution stack so it is never reused between branches in potential diamond-problem scenarios.
            resolutionStack = resolutionStack.concat([resolvedPath]);
            var extendedConfig = getExtendedConfig(sourceFile, ownConfig.extendedConfigPath, host, resolutionStack, errors, extendedConfigCache);
            if (extendedConfig && isSuccessfulParsedTsconfig(extendedConfig)) {
                var baseRaw_1 = extendedConfig.raw;
                var raw_1 = ownConfig.raw;
                var relativeDifference_1;
                var setPropertyInRawIfNotUndefined = function (propertyName) {
                    if (!raw_1[propertyName] && baseRaw_1[propertyName]) {
                        raw_1[propertyName] = ts.map(baseRaw_1[propertyName], function (path) { return ts.isRootedDiskPath(path) ? path : ts.combinePaths(relativeDifference_1 || (relativeDifference_1 = ts.convertToRelativePath(ts.getDirectoryPath(ownConfig.extendedConfigPath), basePath, ts.createGetCanonicalFileName(host.useCaseSensitiveFileNames))), path); });
                    }
                };
                setPropertyInRawIfNotUndefined("include");
                setPropertyInRawIfNotUndefined("exclude");
                setPropertyInRawIfNotUndefined("files");
                if (raw_1.compileOnSave === undefined) {
                    raw_1.compileOnSave = baseRaw_1.compileOnSave;
                }
                ownConfig.options = ts.assign({}, extendedConfig.options, ownConfig.options);
                ownConfig.watchOptions = ownConfig.watchOptions && extendedConfig.watchOptions ?
                    ts.assign({}, extendedConfig.watchOptions, ownConfig.watchOptions) :
                    ownConfig.watchOptions || extendedConfig.watchOptions;
                // TODO extend type typeAcquisition
            }
        }
        return ownConfig;
    }
    function parseOwnConfigOfJson(json, host, basePath, configFileName, errors) {
        if (ts.hasProperty(json, "excludes")) {
            errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Unknown_option_excludes_Did_you_mean_exclude));
        }
        var options = convertCompilerOptionsFromJsonWorker(json.compilerOptions, basePath, errors, configFileName);
        // typingOptions has been deprecated and is only supported for backward compatibility purposes.
        // It should be removed in future releases - use typeAcquisition instead.
        var typeAcquisition = convertTypeAcquisitionFromJsonWorker(json.typeAcquisition || json.typingOptions, basePath, errors, configFileName);
        var watchOptions = convertWatchOptionsFromJsonWorker(json.watchOptions, basePath, errors);
        json.compileOnSave = convertCompileOnSaveOptionFromJson(json, basePath, errors);
        var extendedConfigPath;
        if (json.extends) {
            if (!ts.isString(json.extends)) {
                errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Compiler_option_0_requires_a_value_of_type_1, "extends", "string"));
            }
            else {
                var newBase = configFileName ? directoryOfCombinedPath(configFileName, basePath) : basePath;
                extendedConfigPath = getExtendsConfigPath(json.extends, host, newBase, errors, ts.createCompilerDiagnostic);
            }
        }
        return { raw: json, options: options, watchOptions: watchOptions, typeAcquisition: typeAcquisition, extendedConfigPath: extendedConfigPath };
    }
    function parseOwnConfigOfJsonSourceFile(sourceFile, host, basePath, configFileName, errors) {
        var options = getDefaultCompilerOptions(configFileName);
        var typeAcquisition, typingOptionstypeAcquisition;
        var watchOptions;
        var extendedConfigPath;
        var rootCompilerOptions;
        var optionsIterator = {
            onSetValidOptionKeyValueInParent: function (parentOption, option, value) {
                var currentOption;
                switch (parentOption) {
                    case "compilerOptions":
                        currentOption = options;
                        break;
                    case "watchOptions":
                        currentOption = (watchOptions || (watchOptions = {}));
                        break;
                    case "typeAcquisition":
                        currentOption = (typeAcquisition || (typeAcquisition = getDefaultTypeAcquisition(configFileName)));
                        break;
                    case "typingOptions":
                        currentOption = (typingOptionstypeAcquisition || (typingOptionstypeAcquisition = getDefaultTypeAcquisition(configFileName)));
                        break;
                    default:
                        ts.Debug.fail("Unknown option");
                }
                currentOption[option.name] = normalizeOptionValue(option, basePath, value);
            },
            onSetValidOptionKeyValueInRoot: function (key, _keyNode, value, valueNode) {
                switch (key) {
                    case "extends":
                        var newBase = configFileName ? directoryOfCombinedPath(configFileName, basePath) : basePath;
                        extendedConfigPath = getExtendsConfigPath(value, host, newBase, errors, function (message, arg0) {
                            return ts.createDiagnosticForNodeInSourceFile(sourceFile, valueNode, message, arg0);
                        });
                        return;
                }
            },
            onSetUnknownOptionKeyValueInRoot: function (key, keyNode, _value, _valueNode) {
                if (key === "excludes") {
                    errors.push(ts.createDiagnosticForNodeInSourceFile(sourceFile, keyNode, ts.Diagnostics.Unknown_option_excludes_Did_you_mean_exclude));
                }
                if (ts.find(commandOptionsWithoutBuild, function (opt) { return opt.name === key; })) {
                    rootCompilerOptions = ts.append(rootCompilerOptions, keyNode);
                }
            }
        };
        var json = convertConfigFileToObject(sourceFile, errors, /*reportOptionsErrors*/ true, optionsIterator);
        if (!typeAcquisition) {
            if (typingOptionstypeAcquisition) {
                typeAcquisition = (typingOptionstypeAcquisition.enableAutoDiscovery !== undefined) ?
                    {
                        enable: typingOptionstypeAcquisition.enableAutoDiscovery,
                        include: typingOptionstypeAcquisition.include,
                        exclude: typingOptionstypeAcquisition.exclude
                    } :
                    typingOptionstypeAcquisition;
            }
            else {
                typeAcquisition = getDefaultTypeAcquisition(configFileName);
            }
        }
        if (rootCompilerOptions && json && json.compilerOptions === undefined) {
            errors.push(ts.createDiagnosticForNodeInSourceFile(sourceFile, rootCompilerOptions[0], ts.Diagnostics._0_should_be_set_inside_the_compilerOptions_object_of_the_config_json_file, ts.getTextOfPropertyName(rootCompilerOptions[0])));
        }
        return { raw: json, options: options, watchOptions: watchOptions, typeAcquisition: typeAcquisition, extendedConfigPath: extendedConfigPath };
    }
    function getExtendsConfigPath(extendedConfig, host, basePath, errors, createDiagnostic) {
        extendedConfig = ts.normalizeSlashes(extendedConfig);
        if (ts.isRootedDiskPath(extendedConfig) || ts.startsWith(extendedConfig, "./") || ts.startsWith(extendedConfig, "../")) {
            var extendedConfigPath = ts.getNormalizedAbsolutePath(extendedConfig, basePath);
            if (!host.fileExists(extendedConfigPath) && !ts.endsWith(extendedConfigPath, ".json" /* Extension.Json */)) {
                extendedConfigPath = "".concat(extendedConfigPath, ".json");
                if (!host.fileExists(extendedConfigPath)) {
                    errors.push(createDiagnostic(ts.Diagnostics.File_0_not_found, extendedConfig));
                    return undefined;
                }
            }
            return extendedConfigPath;
        }
        // If the path isn't a rooted or relative path, resolve like a module
        var resolved = ts.nodeModuleNameResolver(extendedConfig, ts.combinePaths(basePath, "tsconfig.json"), { moduleResolution: ts.ModuleResolutionKind.NodeJs }, host, /*cache*/ undefined, /*projectRefs*/ undefined, /*lookupConfig*/ true);
        if (resolved.resolvedModule) {
            return resolved.resolvedModule.resolvedFileName;
        }
        errors.push(createDiagnostic(ts.Diagnostics.File_0_not_found, extendedConfig));
        return undefined;
    }
    function getExtendedConfig(sourceFile, extendedConfigPath, host, resolutionStack, errors, extendedConfigCache) {
        var _a;
        var path = host.useCaseSensitiveFileNames ? extendedConfigPath : ts.toFileNameLowerCase(extendedConfigPath);
        var value;
        var extendedResult;
        var extendedConfig;
        if (extendedConfigCache && (value = extendedConfigCache.get(path))) {
            (extendedResult = value.extendedResult, extendedConfig = value.extendedConfig);
        }
        else {
            extendedResult = readJsonConfigFile(extendedConfigPath, function (path) { return host.readFile(path); });
            if (!extendedResult.parseDiagnostics.length) {
                extendedConfig = parseConfig(/*json*/ undefined, extendedResult, host, ts.getDirectoryPath(extendedConfigPath), ts.getBaseFileName(extendedConfigPath), resolutionStack, errors, extendedConfigCache);
            }
            if (extendedConfigCache) {
                extendedConfigCache.set(path, { extendedResult: extendedResult, extendedConfig: extendedConfig });
            }
        }
        if (sourceFile) {
            sourceFile.extendedSourceFiles = [extendedResult.fileName];
            if (extendedResult.extendedSourceFiles) {
                (_a = sourceFile.extendedSourceFiles).push.apply(_a, extendedResult.extendedSourceFiles);
            }
        }
        if (extendedResult.parseDiagnostics.length) {
            errors.push.apply(errors, extendedResult.parseDiagnostics);
            return undefined;
        }
        return extendedConfig;
    }
    function convertCompileOnSaveOptionFromJson(jsonOption, basePath, errors) {
        if (!ts.hasProperty(jsonOption, ts.compileOnSaveCommandLineOption.name)) {
            return false;
        }
        var result = convertJsonOption(ts.compileOnSaveCommandLineOption, jsonOption.compileOnSave, basePath, errors);
        return typeof result === "boolean" && result;
    }
    function convertCompilerOptionsFromJson(jsonOptions, basePath, configFileName) {
        var errors = [];
        var options = convertCompilerOptionsFromJsonWorker(jsonOptions, basePath, errors, configFileName);
        return { options: options, errors: errors };
    }
    ts.convertCompilerOptionsFromJson = convertCompilerOptionsFromJson;
    function convertTypeAcquisitionFromJson(jsonOptions, basePath, configFileName) {
        var errors = [];
        var options = convertTypeAcquisitionFromJsonWorker(jsonOptions, basePath, errors, configFileName);
        return { options: options, errors: errors };
    }
    ts.convertTypeAcquisitionFromJson = convertTypeAcquisitionFromJson;
    function getDefaultCompilerOptions(configFileName) {
        var options = configFileName && ts.getBaseFileName(configFileName) === "jsconfig.json"
            ? { allowJs: true, maxNodeModuleJsDepth: 2, allowSyntheticDefaultImports: true, skipLibCheck: true, noEmit: true }
            : {};
        return options;
    }
    function convertCompilerOptionsFromJsonWorker(jsonOptions, basePath, errors, configFileName) {
        var options = getDefaultCompilerOptions(configFileName);
        convertOptionsFromJson(getCommandLineCompilerOptionsMap(), jsonOptions, basePath, options, ts.compilerOptionsDidYouMeanDiagnostics, errors);
        if (configFileName) {
            options.configFilePath = ts.normalizeSlashes(configFileName);
        }
        return options;
    }
    function getDefaultTypeAcquisition(configFileName) {
        return { enable: !!configFileName && ts.getBaseFileName(configFileName) === "jsconfig.json", include: [], exclude: [] };
    }
    function convertTypeAcquisitionFromJsonWorker(jsonOptions, basePath, errors, configFileName) {
        var options = getDefaultTypeAcquisition(configFileName);
        var typeAcquisition = convertEnableAutoDiscoveryToEnable(jsonOptions);
        convertOptionsFromJson(getCommandLineTypeAcquisitionMap(), typeAcquisition, basePath, options, typeAcquisitionDidYouMeanDiagnostics, errors);
        return options;
    }
    function convertWatchOptionsFromJsonWorker(jsonOptions, basePath, errors) {
        return convertOptionsFromJson(getCommandLineWatchOptionsMap(), jsonOptions, basePath, /*defaultOptions*/ undefined, watchOptionsDidYouMeanDiagnostics, errors);
    }
    function convertOptionsFromJson(optionsNameMap, jsonOptions, basePath, defaultOptions, diagnostics, errors) {
        if (!jsonOptions) {
            return;
        }
        for (var id in jsonOptions) {
            var opt = optionsNameMap.get(id);
            if (opt) {
                (defaultOptions || (defaultOptions = {}))[opt.name] = convertJsonOption(opt, jsonOptions[id], basePath, errors);
            }
            else {
                errors.push(createUnknownOptionError(id, diagnostics, ts.createCompilerDiagnostic));
            }
        }
        return defaultOptions;
    }
    /*@internal*/
    function convertJsonOption(opt, value, basePath, errors) {
        if (isCompilerOptionsValue(opt, value)) {
            var optType = opt.type;
            if (optType === "list" && ts.isArray(value)) {
                return convertJsonOptionOfListType(opt, value, basePath, errors);
            }
            else if (!ts.isString(optType)) {
                return convertJsonOptionOfCustomType(opt, value, errors);
            }
            var validatedValue = validateJsonOptionValue(opt, value, errors);
            return isNullOrUndefined(validatedValue) ? validatedValue : normalizeNonListOptionValue(opt, basePath, validatedValue);
        }
        else {
            errors.push(ts.createCompilerDiagnostic(ts.Diagnostics.Compiler_option_0_requires_a_value_of_type_1, opt.name, getCompilerOptionValueTypeString(opt)));
        }
    }
    ts.convertJsonOption = convertJsonOption;
    function normalizeOptionValue(option, basePath, value) {
        if (isNullOrUndefined(value))
            return undefined;
        if (option.type === "list") {
            var listOption_1 = option;
            if (listOption_1.element.isFilePath || !ts.isString(listOption_1.element.type)) {
                return ts.filter(ts.map(value, function (v) { return normalizeOptionValue(listOption_1.element, basePath, v); }), function (v) { return listOption_1.listPreserveFalsyValues ? true : !!v; });
            }
            return value;
        }
        else if (!ts.isString(option.type)) {
            return option.type.get(ts.isString(value) ? value.toLowerCase() : value);
        }
        return normalizeNonListOptionValue(option, basePath, value);
    }
    function normalizeNonListOptionValue(option, basePath, value) {
        if (option.isFilePath) {
            value = ts.getNormalizedAbsolutePath(value, basePath);
            if (value === "") {
                value = ".";
            }
        }
        return value;
    }
    function validateJsonOptionValue(opt, value, errors) {
        var _a;
        if (isNullOrUndefined(value))
            return undefined;
        var d = (_a = opt.extraValidation) === null || _a === void 0 ? void 0 : _a.call(opt, value);
        if (!d)
            return value;
        errors.push(ts.createCompilerDiagnostic.apply(void 0, d));
        return undefined;
    }
    function convertJsonOptionOfCustomType(opt, value, errors) {
        if (isNullOrUndefined(value))
            return undefined;
        var key = value.toLowerCase();
        var val = opt.type.get(key);
        if (val !== undefined) {
            return validateJsonOptionValue(opt, val, errors);
        }
        else {
            errors.push(createCompilerDiagnosticForInvalidCustomType(opt));
        }
    }
    function convertJsonOptionOfListType(option, values, basePath, errors) {
        return ts.filter(ts.map(values, function (v) { return convertJsonOption(option.element, v, basePath, errors); }), function (v) { return option.listPreserveFalsyValues ? true : !!v; });
    }
    /**
     * Tests for a path that ends in a recursive directory wildcard.
     * Matches **, \**, **\, and \**\, but not a**b.
     *
     * NOTE: used \ in place of / above to avoid issues with multiline comments.
     *
     * Breakdown:
     *  (^|\/)      # matches either the beginning of the string or a directory separator.
     *  \*\*        # matches the recursive directory wildcard "**".
     *  \/?$        # matches an optional trailing directory separator at the end of the string.
     */
    var invalidTrailingRecursionPattern = /(^|\/)\*\*\/?$/;
    /**
     * Matches the portion of a wildcard path that does not contain wildcards.
     * Matches \a of \a\*, or \a\b\c of \a\b\c\?\d.
     *
     * NOTE: used \ in place of / above to avoid issues with multiline comments.
     *
     * Breakdown:
     *  ^                   # matches the beginning of the string
     *  [^*?]*              # matches any number of non-wildcard characters
     *  (?=\/[^/]*[*?])     # lookahead that matches a directory separator followed by
     *                      # a path component that contains at least one wildcard character (* or ?).
     */
    var wildcardDirectoryPattern = /^[^*?]*(?=\/[^/]*[*?])/;
    /**
     * Gets the file names from the provided config file specs that contain, files, include, exclude and
     * other properties needed to resolve the file names
     * @param configFileSpecs The config file specs extracted with file names to include, wildcards to include/exclude and other details
     * @param basePath The base path for any relative file specifications.
     * @param options Compiler options.
     * @param host The host used to resolve files and directories.
     * @param extraFileExtensions optionaly file extra file extension information from host
     */
    /* @internal */
    function getFileNamesFromConfigSpecs(configFileSpecs, basePath, options, host, extraFileExtensions) {
        if (extraFileExtensions === void 0) { extraFileExtensions = ts.emptyArray; }
        basePath = ts.normalizePath(basePath);
        var keyMapper = ts.createGetCanonicalFileName(host.useCaseSensitiveFileNames);
        // Literal file names (provided via the "files" array in tsconfig.json) are stored in a
        // file map with a possibly case insensitive key. We use this map later when when including
        // wildcard paths.
        var literalFileMap = new ts.Map();
        // Wildcard paths (provided via the "includes" array in tsconfig.json) are stored in a
        // file map with a possibly case insensitive key. We use this map to store paths matched
        // via wildcard, and to handle extension priority.
        var wildcardFileMap = new ts.Map();
        // Wildcard paths of json files (provided via the "includes" array in tsconfig.json) are stored in a
        // file map with a possibly case insensitive key. We use this map to store paths matched
        // via wildcard of *.json kind
        var wildCardJsonFileMap = new ts.Map();
        var validatedFilesSpec = configFileSpecs.validatedFilesSpec, validatedIncludeSpecs = configFileSpecs.validatedIncludeSpecs, validatedExcludeSpecs = configFileSpecs.validatedExcludeSpecs;
        // Rather than re-query this for each file and filespec, we query the supported extensions
        // once and store it on the expansion context.
        var supportedExtensions = ts.getSupportedExtensions(options, extraFileExtensions);
        var supportedExtensionsWithJsonIfResolveJsonModule = ts.getSupportedExtensionsWithJsonIfResolveJsonModule(options, supportedExtensions);
        // Literal files are always included verbatim. An "include" or "exclude" specification cannot
        // remove a literal file.
        if (validatedFilesSpec) {
            for (var _i = 0, validatedFilesSpec_1 = validatedFilesSpec; _i < validatedFilesSpec_1.length; _i++) {
                var fileName = validatedFilesSpec_1[_i];
                var file = ts.getNormalizedAbsolutePath(fileName, basePath);
                literalFileMap.set(keyMapper(file), file);
            }
        }
        var jsonOnlyIncludeRegexes;
        if (validatedIncludeSpecs && validatedIncludeSpecs.length > 0) {
            var _loop_6 = function (file) {
                if (ts.fileExtensionIs(file, ".json" /* Extension.Json */)) {
                    // Valid only if *.json specified
                    if (!jsonOnlyIncludeRegexes) {
                        var includes = validatedIncludeSpecs.filter(function (s) { return ts.endsWith(s, ".json" /* Extension.Json */); });
                        var includeFilePatterns = ts.map(ts.getRegularExpressionsForWildcards(includes, basePath, "files"), function (pattern) { return "^".concat(pattern, "$"); });
                        jsonOnlyIncludeRegexes = includeFilePatterns ? includeFilePatterns.map(function (pattern) { return ts.getRegexFromPattern(pattern, host.useCaseSensitiveFileNames); }) : ts.emptyArray;
                    }
                    var includeIndex = ts.findIndex(jsonOnlyIncludeRegexes, function (re) { return re.test(file); });
                    if (includeIndex !== -1) {
                        var key_1 = keyMapper(file);
                        if (!literalFileMap.has(key_1) && !wildCardJsonFileMap.has(key_1)) {
                            wildCardJsonFileMap.set(key_1, file);
                        }
                    }
                    return "continue";
                }
                // If we have already included a literal or wildcard path with a
                // higher priority extension, we should skip this file.
                //
   